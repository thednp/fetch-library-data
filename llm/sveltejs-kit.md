@sveltejs/kit version: 2.21.1, last updated: 2025-05-25T14:47:55.354Z

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitGetting started

Introduction
============

### On this page

*   [Introduction](/docs/kit/introduction)
*   [Before we begin](#Before-we-begin)
*   [What is SvelteKit?](#What-is-SvelteKit)
*   [What is Svelte?](#What-is-Svelte)
*   [SvelteKit vs Svelte](#SvelteKit-vs-Svelte)

Before we begin[](#Before-we-begin)
-----------------------------------

> If you’re new to Svelte or SvelteKit we recommend checking out the [interactive tutorial](/tutorial/kit).
> 
> If you get stuck, reach out for help in the [Discord chatroom](/chat).

What is SvelteKit?[](#What-is-SvelteKit)
----------------------------------------

SvelteKit is a framework for rapidly developing robust, performant web applications using [Svelte](../svelte). If you’re coming from React, SvelteKit is similar to Next. If you’re coming from Vue, SvelteKit is similar to Nuxt.

To learn more about the kinds of applications you can build with SvelteKit, see the [documentation regarding project types](project-types).

What is Svelte?[](#What-is-Svelte)
----------------------------------

In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don’t need to know Svelte to understand the rest of this guide, but it will help. If you’d like to learn more, check out [the Svelte tutorial](/tutorial).

SvelteKit vs Svelte[](#SvelteKit-vs-Svelte)
-------------------------------------------

Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.

SvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a [router](glossary#Routing) that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes [build optimizations](https://vitejs.dev/guide/features.html#build-optimizations) to load only the minimal required code; [offline support](service-workers); [preloading](link-options#data-sveltekit-preload-data) pages before user navigation; [configurable rendering](page-options) to handle different parts of your app on the server via [SSR](glossary#SSR), in the browser through [client-side rendering](glossary#CSR), or at build-time with [prerendering](glossary#Prerendering); [image optimization](images); and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part.

It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging [Vite](https://vitejs.dev/) with a [Svelte plugin](https://github.com/sveltejs/vite-plugin-svelte) to do [Hot Module Replacement (HMR)](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/config.md#hot).

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/10-getting-started/10-introduction.md) [llms.txt](/docs/kit/introduction/llms.txt)

previous next

[Creating a project](/docs/kit/creating-a-project)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitGetting started

Creating a project
==================

### On this page

*   [Creating a project](/docs/kit/creating-a-project)
*   [Editor setup](#Editor-setup)

The easiest way to start building a SvelteKit app is to run `npx sv create`:

    npx sv create my-app
    cd my-app
    npm install
    npm run dev

The first command will scaffold a new project in the `my-app` directory asking you if you’d like to set up some basic tooling such as TypeScript. See [integrations](./integrations) for pointers on setting up additional tooling. The subsequent commands will then install its dependencies and start a server on [localhost:5173](http://localhost:5173).

There are two basic concepts:

*   Each page of your app is a [Svelte](../svelte) component
*   You create pages by adding files to the `src/routes` directory of your project. These will be server-rendered so that a user’s first visit to your app is as fast as possible, then a client-side app takes over

Try editing the files to get a feel for how everything works.

Editor setup[](#Editor-setup)
-----------------------------

We recommend using [Visual Studio Code (aka VS Code)](https://code.visualstudio.com/download) with [the Svelte extension](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode), but [support also exists for numerous other editors](https://sveltesociety.dev/resources#editor-support).

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/10-getting-started/20-creating-a-project.md) [llms.txt](/docs/kit/creating-a-project/llms.txt)

previous next

[Introduction](/docs/kit/introduction) [Project types](/docs/kit/project-types)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitGetting started

Project types
=============

### On this page

*   [Project types](/docs/kit/project-types)
*   [Default rendering](#Default-rendering)
*   [Static site generation](#Static-site-generation)
*   [Single-page app](#Single-page-app)
*   [Multi-page app](#Multi-page-app)
*   [Separate backend](#Separate-backend)
*   [Serverless app](#Serverless-app)
*   [Your own server](#Your-own-server)
*   [Container](#Container)
*   [Library](#Library)
*   [Offline app](#Offline-app)
*   [Mobile app](#Mobile-app)
*   [Desktop app](#Desktop-app)
*   [Browser extension](#Browser-extension)
*   [Embedded device](#Embedded-device)

SvelteKit offers configurable rendering, which allows you to build and deploy your project in several different ways. You can build all of the below types of applications and more with SvelteKit. Rendering settings are not mutually exclusive and you may choose the optimal manner with which to render different parts of your application.

If you don’t have a particular way you’d like to build your application in mind, don’t worry! The way your application is built, deployed, and rendered is controlled by which adapter you’ve chosen and a small amount of configuration and these can always be changed later. The [project structure](project-structure) and [routing](glossary#Routing) will be the same regardless of the project type that you choose.

Default rendering[](#Default-rendering)
---------------------------------------

By default, when a user visits a site, SvelteKit will render the first page with [server-side rendering (SSR)](glossary#SSR) and subsequent pages with [client-side rendering (CSR)](glossary#CSR). Using SSR for the initial render improves SEO and perceived performance of the initial page load. Client-side rendering then takes over and updates the page without having to rerender common components, which is typically faster and eliminates a flash when navigating between pages. Apps built with this hybrid rendering approach have also been called [transitional apps](https://www.youtube.com/watch?v=860d8usGC0o).

Static site generation[](#Static-site-generation)
-------------------------------------------------

You can use SvelteKit as a [static site generator (SSG)](glossary#SSG) that fully [prerenders](glossary#Prerendering) your site with static rendering using [`adapter-static`](adapter-static). You may also use [the prerender option](page-options#prerender) to prerender only some pages and then choose a different adapter with which to dynamically server-render other pages.

Tools built solely to do static site generation may scale the prerendering process more efficiently during build when rendering a very large number of pages. When working with very large statically generated sites, you can avoid long build times with [Incremental Static Regeneration (ISR) if using `adapter-vercel`](adapter-vercel#Incremental-Static-Regeneration). And in contrast to purpose-built SSGs, SvelteKit allows for nicely mixing and matching different rendering types on different pages.

Single-page app[](#Single-page-app)
-----------------------------------

[Single-page apps (SPAs)](glossary#SPA) exclusively use [client-side rendering (CSR)](glossary#CSR). You can [build single-page apps (SPAs)](single-page-apps) with SvelteKit. As with all types of SvelteKit applications, you can write your backend in SvelteKit or [another language or framework](#Separate-backend). If you are building an application with no backend or a [separate backend](#Separate-backend), you can simply skip over and ignore the parts of the docs talking about `server` files.

Multi-page app[](#Multi-page-app)
---------------------------------

SvelteKit isn’t typically used to build [traditional multi-page apps](glossary#MPA). However, in SvelteKit you can remove all JavaScript on a page with [`csr = false`](page-options#csr), which will render subsequent links on the server, or you can use [`data-sveltekit-reload`](link-options#data-sveltekit-reload) to render specific links on the server.

Separate backend[](#Separate-backend)
-------------------------------------

If your backend is written in another language such as Go, Java, PHP, Ruby, Rust, or C#, there are a couple of ways that you can deploy your application. The most recommended way would be to deploy your SvelteKit frontend separately from your backend utilizing `adapter-node` or a serverless adapter. Some users prefer not to have a separate process to manage and decide to deploy their application as a [single-page app (SPA)](single-page-apps) served by their backend server, but note that single-page apps have worse SEO and performance characteristics.

If you are using an external backend, you can simply skip over and ignore the parts of the docs talking about `server` files. You may also want to reference [the FAQ about how to make calls to a separate backend](faq#How-do-I-use-a-different-backend-API-server).

Serverless app[](#Serverless-app)
---------------------------------

SvelteKit apps are simple to run on serverless platforms. [The default zero config adapter](adapter-auto) will automatically run your app on a number of supported platforms or you can use [`adapter-vercel`](adapter-vercel), [`adapter-netlify`](adapter-netlify), or [`adapter-cloudflare`](adapter-cloudflare) to provide platform-specific configuration. And [community adapters](https://sveltesociety.dev/packages?category=sveltekit-adapters) allow you to deploy your application to almost any serverless environment. Some of these adapters such as [`adapter-vercel`](adapter-vercel) and [`adapter-netlify`](adapter-netlify) offer an `edge` option, to support [edge rendering](glossary#Edge) for improved latency.

Your own server[](#Your-own-server)
-----------------------------------

You can deploy to your own server or VPS using [`adapter-node`](adapter-node).

Container[](#Container)
-----------------------

You can use [`adapter-node`](adapter-node) to run a SvelteKit app within a container such as Docker or LXC.

Library[](#Library)
-------------------

You can create a library to be used by other Svelte apps with the [`@sveltejs/package`](packaging) add-on to SvelteKit by choosing the library option when running [`sv create`](/docs/cli/sv-create).

Offline app[](#Offline-app)
---------------------------

SvelteKit has full suppport for [service workers](service-workers) allowing you to build many types of applications such as offline apps and [progressive web apps](glossary#PWA).

Mobile app[](#Mobile-app)
-------------------------

You can turn a [SvelteKit SPA](single-page-apps) into a mobile app with [Tauri](https://v2.tauri.app/start/frontend/sveltekit/) or [Capacitor](https://capacitorjs.com/solution/svelte). Mobile features like the camera, geolocation, and push notifications are available via plugins for both platforms.

These mobile development platforms work by starting a local web server and then serving your application like a static host on your phone. You may find [`bundleStrategy: 'single'`](configuration#output) to be a helpful option to limit the number of requests made. E.g. at the time of writing, the Capacitor local server uses HTTP/1, which limits the number of concurrent connections.

Desktop app[](#Desktop-app)
---------------------------

You can turn a [SvelteKit SPA](single-page-apps) into a desktop app with [Tauri](https://v2.tauri.app/start/frontend/sveltekit/), [Wails](https://wails.io/docs/guides/sveltekit/), or [Electron](https://www.electronjs.org/).

Browser extension[](#Browser-extension)
---------------------------------------

You can build browser extensions using either [`adapter-static`](adapter-static) or [community adapters](https://sveltesociety.dev/packages?category=sveltekit-adapters) specifically tailored towards browser extensions.

Embedded device[](#Embedded-device)
-----------------------------------

Because of its efficient rendering, Svelte can be run on low power devices. Embedded devices like microcontrollers and TVs may limit the number of concurrent connections. In order to reduce the number of concurrent requests, you may find [`bundleStrategy: 'single'`](configuration#output) to be a helpful option in this deployment configuration.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/10-getting-started/25-project-types.md) [llms.txt](/docs/kit/project-types/llms.txt)

previous next

[Creating a project](/docs/kit/creating-a-project) [Project structure](/docs/kit/project-structure)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitGetting started

Project structure
=================

### On this page

*   [Project structure](/docs/kit/project-structure)
*   [Project files](#Project-files)
*   [Other files](#Other-files)

A typical SvelteKit project looks like this:

    my-project/
    ├ src/
    │ ├ lib/
    │ │ ├ server/
    │ │ │ └ [your server-only lib files]
    │ │ └ [your lib files]
    │ ├ params/
    │ │ └ [your param matchers]
    │ ├ routes/
    │ │ └ [your routes]
    │ ├ app.html
    │ ├ error.html
    │ ├ hooks.client.js
    │ ├ hooks.server.js
    │ └ service-worker.js
    ├ static/
    │ └ [your static assets]
    ├ tests/
    │ └ [your tests]
    ├ package.json
    ├ svelte.config.js
    ├ tsconfig.json
    └ vite.config.js

You’ll also find common files like `.gitignore` and `.npmrc` (and `.prettierrc` and `eslint.config.js` and so on, if you chose those options when running `npx sv create`).

Project files[](#Project-files)
-------------------------------

### src[](#Project-files-src)

The `src` directory contains the meat of your project. Everything except `src/routes` and `src/app.html` is optional.

*   `lib` contains your library code (utilities and components), which can be imported via the [`$lib`]($lib) alias, or packaged up for distribution using [`svelte-package`](packaging)
    *   `server` contains your server-only library code. It can be imported by using the [`$lib/server`](server-only-modules) alias. SvelteKit will prevent you from importing these in client code.
*   `params` contains any [param matchers](advanced-routing#Matching) your app needs
*   `routes` contains the [routes](routing) of your application. You can also colocate other components that are only used within a single route here
*   `app.html` is your page template — an HTML document containing the following placeholders:
    *   `%sveltekit.head%` — `<link>` and `<script>` elements needed by the app, plus any `<svelte:head>` content
    *   `%sveltekit.body%` — the markup for a rendered page. This should live inside a `<div>` or other element, rather than directly inside `<body>`, to prevent bugs caused by browser extensions injecting elements that are then destroyed by the hydration process. SvelteKit will warn you in development if this is not the case
    *   `%sveltekit.assets%` — either [`paths.assets`](configuration#paths), if specified, or a relative path to [`paths.base`](configuration#paths)
    *   `%sveltekit.nonce%` — a [CSP](configuration#csp) nonce for manually included links and scripts, if used
    *   `%sveltekit.env.[NAME]%` - this will be replaced at render time with the `[NAME]` environment variable, which must begin with the [`publicPrefix`](configuration#env) (usually `PUBLIC_`). It will fallback to `''` if not matched.
*   `error.html` is the page that is rendered when everything else fails. It can contain the following placeholders:
    *   `%sveltekit.status%` — the HTTP status
    *   `%sveltekit.error.message%` — the error message
*   `hooks.client.js` contains your client [hooks](hooks)
*   `hooks.server.js` contains your server [hooks](hooks)
*   `service-worker.js` contains your [service worker](service-workers)

(Whether the project contains `.js` or `.ts` files depends on whether you opt to use TypeScript when you create your project.)

If you added [Vitest](https://vitest.dev) when you set up your project, your unit tests will live in the `src` directory with a `.test.js` extension.

### static[](#Project-files-static)

Any static assets that should be served as-is, like `robots.txt` or `favicon.png`, go in here.

### tests[](#Project-files-tests)

If you added [Playwright](https://playwright.dev/) for browser testing when you set up your project, the tests will live in this directory.

### package.json[](#Project-files-package.json)

Your `package.json` file must include `@sveltejs/kit`, `svelte` and `vite` as `devDependencies`.

When you create a project with `npx sv create`, you’ll also notice that `package.json` includes `"type": "module"`. This means that `.js` files are interpreted as native JavaScript modules with `import` and `export` keywords. Legacy CommonJS files need a `.cjs` file extension.

### svelte.config.js[](#Project-files-svelte.config.js)

This file contains your Svelte and SvelteKit [configuration](configuration).

### tsconfig.json[](#Project-files-tsconfig.json)

This file (or `jsconfig.json`, if you prefer type-checked `.js` files over `.ts` files) configures TypeScript, if you added typechecking during `npx sv create`. Since SvelteKit relies on certain configuration being set a specific way, it generates its own `.svelte-kit/tsconfig.json` file which your own config `extends`.

### vite.config.js[](#Project-files-vite.config.js)

A SvelteKit project is really just a [Vite](https://vitejs.dev) project that uses the [`@sveltejs/kit/vite`](@sveltejs-kit-vite) plugin, along with any other [Vite configuration](https://vitejs.dev/config/).

Other files[](#Other-files)
---------------------------

### .svelte-kit[](#Other-files-.svelte-kit)

As you develop and build your project, SvelteKit will generate files in a `.svelte-kit` directory (configurable as [`outDir`](configuration#outDir)). You can ignore its contents, and delete them at any time (they will be regenerated when you next `dev` or `build`).

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/10-getting-started/30-project-structure.md) [llms.txt](/docs/kit/project-structure/llms.txt)

previous next

[Project types](/docs/kit/project-types) [Web standards](/docs/kit/web-standards)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitGetting started

Web standards
=============

### On this page

*   [Web standards](/docs/kit/web-standards)
*   [Fetch APIs](#Fetch-APIs)
*   [FormData](#FormData)
*   [Stream APIs](#Stream-APIs)
*   [URL APIs](#URL-APIs)
*   [Web Crypto](#Web-Crypto)

Throughout this documentation, you’ll see references to the standard [Web APIs](https://developer.mozilla.org/en-US/docs/Web/API) that SvelteKit builds on top of. Rather than reinventing the wheel, we _use the platform_, which means your existing web development skills are applicable to SvelteKit. Conversely, time spent learning SvelteKit will help you be a better web developer elsewhere.

These APIs are available in all modern browsers and in many non-browser environments like Cloudflare Workers, Deno, and Vercel Functions. During development, and in [adapters](adapters) for Node-based environments (including AWS Lambda), they’re made available via polyfills where necessary (for now, that is — Node is rapidly adding support for more web standards).

In particular, you’ll get comfortable with the following:

Fetch APIs[](#Fetch-APIs)
-------------------------

SvelteKit uses [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) for getting data from the network. It’s available in [hooks](hooks) and [server routes](routing#server) as well as in the browser.

> A special version of `fetch` is available in [`load`](load) functions, [server hooks](hooks#Server-hooks) and [API routes](routing#server) for invoking endpoints directly during server-side rendering, without making an HTTP call, while preserving credentials. (To make credentialled fetches in server-side code outside `load`, you must explicitly pass `cookie` and/or `authorization` headers.) It also allows you to make relative requests, whereas server-side `fetch` normally requires a fully qualified URL.

Besides `fetch` itself, the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) includes the following interfaces:

### Request[](#Fetch-APIs-Request)

An instance of [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) is accessible in [hooks](hooks) and [server routes](routing#server) as `event.request`. It contains useful methods like `request.json()` and `request.formData()` for getting data that was posted to an endpoint.

### Response[](#Fetch-APIs-Response)

An instance of [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) is returned from `await fetch(...)` and handlers in `+server.js` files. Fundamentally, a SvelteKit app is a machine for turning a `Request` into a `Response`.

### Headers[](#Fetch-APIs-Headers)

The [`Headers`](https://developer.mozilla.org/en-US/docs/Web/API/Headers) interface allows you to read incoming `request.headers` and set outgoing `response.headers`. For example, you can get the `request.headers` as shown below, and use the [`json` convenience function](@sveltejs-kit#json) to send modified `response.headers`:

src/routes/what-is-my-user-agent/+server

    import { function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json } from '@sveltejs/kit';
    
    /** @type {import('./$types').RequestHandler} */
    export function function GET({ request }: {
        request: any;
    }): Response@type{import('./$types').RequestHandler}GET({ request: anyrequest }) {
    	// log all headers
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(...request: anyrequest.headers);
    
    	// create a JSON Response using a header we received
    	return function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json({
    		// retrieve a specific header
    		userAgent: anyuserAgent: request: anyrequest.headers.get('user-agent')
    	}, {
    		// set a header on the response
    		ResponseInit.headers?: HeadersInit | undefinedheaders: { 'x-custom-header': 'potato' }
    	});
    }

    import { function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json } from '@sveltejs/kit';
    import type { type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler } from './$types';
    
    export const const GET: RequestHandlerGET: type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler = ({ request: RequestThe original request object.
    request }) => {
    	// log all headers
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(...request: RequestThe original request object.
    request.Request.headers: HeadersReturns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the “Host” header.
    MDN Reference
    headers);
    
    	// create a JSON Response using a header we received
    	return function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json({
    		// retrieve a specific header
    		userAgent: string | nulluserAgent: request: RequestThe original request object.
    request.Request.headers: HeadersReturns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the “Host” header.
    MDN Reference
    headers.Headers.get(name: string): string | nullMDN Reference
    get('user-agent')
    	}, {
    		// set a header on the response
    		ResponseInit.headers?: HeadersInit | undefinedheaders: { 'x-custom-header': 'potato' }
    	});
    };

FormData[](#FormData)
---------------------

When dealing with HTML native form submissions you’ll be working with [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) objects.

src/routes/hello/+server

    import { function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json } from '@sveltejs/kit';
    
    /** @type {import('./$types').RequestHandler} */
    export async function function POST(event: any): Promise<Response>@type{import('./$types').RequestHandler}POST(event: anyevent) {
    	const const body: anybody = await event: anyevent.request.formData();
    
    	// log all fields
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log([...const body: anybody]);
    
    	return function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json({
    		// get a specific field's value
    		name: anyname: const body: anybody.get('name') ?? 'world'
    	});
    }

    import { function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json } from '@sveltejs/kit';
    import type { type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler } from './$types';
    
    export const const POST: RequestHandlerPOST: type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler = async (event: Kit.RequestEvent<Record<string, any>, string | null>event) => {
    	const const body: FormDatabody = await event: Kit.RequestEvent<Record<string, any>, string | null>event.RequestEvent<Record<string, any>, string | null>.request: RequestThe original request object.
    request.Body.formData(): Promise<FormData>MDN Reference
    formData();
    
    	// log all fields
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log([...const body: FormDatabody]);
    
    	return function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json({
    		// get a specific field's value
    		name: FormDataEntryValuename: const body: FormDatabody.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('name') ?? 'world'
    	});
    };

Stream APIs[](#Stream-APIs)
---------------------------

Most of the time, your endpoints will return complete data, as in the `userAgent` example above. Sometimes, you may need to return a response that’s too large to fit in memory in one go, or is delivered in chunks, and for this the platform provides [streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) — [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream), [WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) and [TransformStream](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream).

URL APIs[](#URL-APIs)
---------------------

URLs are represented by the [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL) interface, which includes useful properties like `origin` and `pathname` (and, in the browser, `hash`). This interface shows up in various places — `event.url` in [hooks](hooks) and [server routes](routing#server), [`page.url`]($app-state) in [pages](routing#page), `from` and `to` in [`beforeNavigate` and `afterNavigate`]($app-navigation) and so on.

### URLSearchParams[](#URL-APIs-URLSearchParams)

Wherever you encounter a URL, you can access query parameters via `url.searchParams`, which is an instance of [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams):

    const const foo: string | nullfoo = const url: URLurl.URL.searchParams: URLSearchParamsMDN Reference
    searchParams.URLSearchParams.get(name: string): string | nullReturns the first value associated to the given search parameter.
    MDN Reference
    get('foo');

Web Crypto[](#Web-Crypto)
-------------------------

The [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) is made available via the `crypto` global. It’s used internally for [Content Security Policy](configuration#csp) headers, but you can also use it for things like generating UUIDs:

    const const uuid: `${string}-${string}-${string}-${string}-${string}`uuid = var crypto: CryptoMDN Reference
    crypto.Crypto.randomUUID(): `${string}-${string}-${string}-${string}-${string}`Available only in secure contexts.
    MDN Reference
    randomUUID();

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/10-getting-started/40-web-standards.md) [llms.txt](/docs/kit/web-standards/llms.txt)

previous next

[Project structure](/docs/kit/project-structure) [Routing](/docs/kit/routing)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitCore concepts

Routing
=======

### On this page

*   [Routing](/docs/kit/routing)
*   [+page](#page)
*   [+error](#error)
*   [+layout](#layout)
*   [+server](#server)
*   [$types](#$types)
*   [Other files](#Other-files)
*   [Further reading](#Further-reading)

At the heart of SvelteKit is a _filesystem-based router_. The routes of your app — i.e. the URL paths that users can access — are defined by the directories in your codebase:

*   `src/routes` is the root route
*   `src/routes/about` creates an `/about` route
*   `src/routes/blog/[slug]` creates a route with a _parameter_, `slug`, that can be used to load data dynamically when a user requests a page like `/blog/hello-world`

> You can change `src/routes` to a different directory by editing the [project config](configuration).

Each route directory contains one or more _route files_, which can be identified by their `+` prefix.

We’ll introduce these files in a moment in more detail, but here are a few simple rules to help you remember how SvelteKit’s routing works:

*   All files can run on the server
*   All files run on the client except `+server` files
*   `+layout` and `+error` files apply to subdirectories as well as the directory they live in

+page[](#page)
--------------

### +page.svelte[](#page-page.svelte)

A `+page.svelte` component defines a page of your app. By default, pages are rendered both on the server ([SSR](glossary#SSR)) for the initial request and in the browser ([CSR](glossary#CSR)) for subsequent navigation.

src/routes/+page

    <h1>Hello and welcome to my site!</h1>
    <a href="/about">About my site</a>

src/routes/about/+page

    <h1>About this site</h1>
    <p>TODO...</p>
    <a href="/">Home</a>

> SvelteKit uses `<a>` elements to navigate between routes, rather than a framework-specific `<Link>` component.

Pages can receive data from `load` functions via the `data` prop.

src/routes/blog/\[slug\]/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    </script>
    
    <h1>{data.title}</h1>
    <div>{@html data.content}</div>

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data }: PageProps = $props();
    </script>
    
    <h1>{data.title}</h1>
    <div>{@html data.content}</div>

> Legacy mode
> 
> `PageProps` was added in 2.16.0. In earlier versions, you had to type the `data` property manually with `PageData` instead, see [$types](#$types).
> 
> In Svelte 4, you’d use `export let data` instead.

### +page.js[](#page-page.js)

Often, a page will need to load some data before it can be rendered. For this, we add a `+page.js` module that exports a `load` function:

src/routes/blog/\[slug\]/+page

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    
    /** @type {import('./$types').PageLoad} */
    export function function load({ params }: {
        params: any;
    }): {
        title: string;
        content: string;
    }@type{import('./$types').PageLoad}load({ params: anyparams }) {
    	if (params: anyparams.slug === 'hello-world') {
    		return {
    			title: stringtitle: 'Hello world!',
    			content: stringcontent: 'Welcome to our blog. Lorem ipsum dolor sit amet...'
    		};
    	}
    
    	function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, 'Not found');
    }

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = ({ params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params }) => {
    	if (params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params.slug === 'hello-world') {
    		return {
    			title: stringtitle: 'Hello world!',
    			content: stringcontent: 'Welcome to our blog. Lorem ipsum dolor sit amet...'
    		};
    	}
    
    	function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, 'Not found');
    };

This function runs alongside `+page.svelte`, which means it runs on the server during server-side rendering and in the browser during client-side navigation. See [`load`](load) for full details of the API.

As well as `load`, `+page.js` can export values that configure the page’s behaviour:

*   `export const prerender = true` or `false` or `'auto'`
*   `export const ssr = true` or `false`
*   `export const csr = true` or `false`

You can find more information about these in [page options](page-options).

### +page.server.js[](#page-page.server.js)

If your `load` function can only run on the server — for example, if it needs to fetch data from a database or you need to access private [environment variables]($env-static-private) like API keys — then you can rename `+page.js` to `+page.server.js` and change the `PageLoad` type to `PageServerLoad`.

src/routes/blog/\[slug\]/+page.server

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    
    /** @type {import('./$types').PageServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageServerLoad}load({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) {
    	const const post: {
        title: string;
        content: string;
    }post = await const getPostFromDatabase: (slug: string) => {
        title: string;
        content: string;
    }getPostFromDatabase(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug);
    
    	if (const post: {
        title: string;
        content: string;
    }post) {
    		return const post: {
        title: string;
        content: string;
    }post;
    	}
    
    	function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, 'Not found');
    }

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    import type { type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = async ({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) => {
    	const const post: {
        title: string;
        content: string;
    }post = await const getPostFromDatabase: (slug: string) => {
        title: string;
        content: string;
    }getPostFromDatabase(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug);
    
    	if (const post: {
        title: string;
        content: string;
    }post) {
    		return const post: {
        title: string;
        content: string;
    }post;
    	}
    
    	function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, 'Not found');
    };

During client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using [devalue](https://github.com/rich-harris/devalue). See [`load`](load) for full details of the API.

Like `+page.js`, `+page.server.js` can export [page options](page-options) — `prerender`, `ssr` and `csr`.

A `+page.server.js` file can also export _actions_. If `load` lets you read data from the server, `actions` let you write data _to_ the server using the `<form>` element. To learn how to use them, see the [form actions](form-actions) section.

+error[](#error)
----------------

If an error occurs during `load`, SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an `+error.svelte` file:

src/routes/blog/\[slug\]/+error

    <script>
    	import { page } from '$app/state';
    </script>
    
    <h1>{page.status}: {page.error.message}</h1>

    <script lang="ts">
    	import { page } from '$app/state';
    </script>
    
    <h1>{page.status}: {page.error.message}</h1>

> Legacy mode
> 
> `$app/state` was added in SvelteKit 2.12. If you’re using an earlier version or are using Svelte 4, use `$app/stores` instead.

SvelteKit will ‘walk up the tree’ looking for the closest error boundary — if the file above didn’t exist it would try `src/routes/blog/+error.svelte` and then `src/routes/+error.svelte` before rendering the default error page. If _that_ fails (or if the error was thrown from the `load` function of the root `+layout`, which sits ‘above’ the root `+error`), SvelteKit will bail out and render a static fallback error page, which you can customise by creating a `src/error.html` file.

If the error occurs inside a `load` function in `+layout(.server).js`, the closest error boundary in the tree is an `+error.svelte` file _above_ that layout (not next to it).

If no route can be found (404), `src/routes/+error.svelte` (or the default error page, if that file does not exist) will be used.

> `+error.svelte` is _not_ used when an error occurs inside [`handle`](hooks#Server-hooks-handle) or a [+server.js](#server) request handler.

You can read more about error handling [here](errors).

+layout[](#layout)
------------------

So far, we’ve treated pages as entirely standalone components — upon navigation, the existing `+page.svelte` component will be destroyed, and a new one will take its place.

But in many apps, there are elements that should be visible on _every_ page, such as top-level navigation or a footer. Instead of repeating them in every `+page.svelte`, we can put them in _layouts_.

### +layout.svelte[](#layout-layout.svelte)

To create a layout that applies to every page, make a file called `src/routes/+layout.svelte`. The default layout (the one that SvelteKit uses if you don’t bring your own) looks like this...

    <script>
    	let { children } = $props();
    </script>
    
    {@render children()}

...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a `@render` tag for the page content. For example, let’s add a nav bar:

src/routes/+layout

    <script>
    	let { children } = $props();
    </script>
    
    <nav>
    	<a href="/">Home</a>
    	<a href="/about">About</a>
    	<a href="/settings">Settings</a>
    </nav>
    
    {@render children()}

    <script lang="ts">
    	let { children } = $props();
    </script>
    
    <nav>
    	<a href="/">Home</a>
    	<a href="/about">About</a>
    	<a href="/settings">Settings</a>
    </nav>
    
    {@render children()}

If we create pages for `/`, `/about` and `/settings`...

src/routes/+page

    <h1>Home</h1>

src/routes/about/+page

    <h1>About</h1>

src/routes/settings/+page

    <h1>Settings</h1>

...the nav will always be visible, and clicking between the three pages will only result in the `<h1>` being replaced.

Layouts can be _nested_. Suppose we don’t just have a single `/settings` page, but instead have nested pages like `/settings/profile` and `/settings/notifications` with a shared submenu (for a real-life example, see [github.com/settings](https://github.com/settings)).

We can create a layout that only applies to pages below `/settings` (while inheriting the root layout with the top-level nav):

src/routes/settings/+layout

    <script>
    	/** @type {import('./$types').LayoutProps} */
    	let { data, children } = $props();
    </script>
    
    <h1>Settings</h1>
    
    <div class="submenu">
    	{#each data.sections as section}
    		<a href="/settings/{section.slug}">{section.title}</a>
    	{/each}
    </div>
    
    {@render children()}

    <script lang="ts">
    	import type { LayoutProps } from './$types';
    
    	let { data, children }: LayoutProps = $props();
    </script>
    
    <h1>Settings</h1>
    
    <div class="submenu">
    	{#each data.sections as section}
    		<a href="/settings/{section.slug}">{section.title}</a>
    	{/each}
    </div>
    
    {@render children()}

> Legacy mode
> 
> `LayoutProps` was added in 2.16.0. In earlier versions, you had to [type the properties manually instead](#$types).

You can see how `data` is populated by looking at the `+layout.js` example in the next section just below.

By default, each layout inherits the layout above it. Sometimes that isn’t what you want - in this case, [advanced layouts](advanced-routing#Advanced-layouts) can help you.

### +layout.js[](#layout-layout.js)

Just like `+page.svelte` loading data from `+page.js`, your `+layout.svelte` component can get data from a [`load`](load) function in `+layout.js`.

src/routes/settings/+layout

    /** @type {import('./$types').LayoutLoad} */
    export function function load(): {
        sections: {
            slug: string;
            title: string;
        }[];
    }@type{import('./$types').LayoutLoad}load() {
    	return {
    		sections: {
        slug: string;
        title: string;
    }[]sections: [
    			{ slug: stringslug: 'profile', title: stringtitle: 'Profile' },
    			{ slug: stringslug: 'notifications', title: stringtitle: 'Notifications' }
    		]
    	};
    }

    import type { type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutLoad } from './$types';
    
    export const const load: LayoutLoadload: type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutLoad = () => {
    	return {
    		sections: {
        slug: string;
        title: string;
    }[]sections: [
    			{ slug: stringslug: 'profile', title: stringtitle: 'Profile' },
    			{ slug: stringslug: 'notifications', title: stringtitle: 'Notifications' }
    		]
    	};
    };

If a `+layout.js` exports [page options](page-options) — `prerender`, `ssr` and `csr` — they will be used as defaults for child pages.

Data returned from a layout’s `load` function is also available to all its child pages:

src/routes/settings/profile/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    
    	console.log(data.sections); // [{ slug: 'profile', title: 'Profile' }, ...]
    </script>

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data }: PageProps = $props();
    
    	console.log(data.sections); // [{ slug: 'profile', title: 'Profile' }, ...]
    </script>

> Often, layout data is unchanged when navigating between pages. SvelteKit will intelligently rerun [`load`](load) functions when necessary.

### +layout.server.js[](#layout-layout.server.js)

To run your layout’s `load` function on the server, move it to `+layout.server.js`, and change the `LayoutLoad` type to `LayoutServerLoad`.

Like `+layout.js`, `+layout.server.js` can export [page options](page-options) — `prerender`, `ssr` and `csr`.

+server[](#server)
------------------

As well as pages, you can define routes with a `+server.js` file (sometimes referred to as an ‘API route’ or an ‘endpoint’), which gives you full control over the response. Your `+server.js` file exports functions corresponding to HTTP verbs like `GET`, `POST`, `PATCH`, `PUT`, `DELETE`, `OPTIONS`, and `HEAD` that take a [`RequestEvent`](@sveltejs-kit#RequestEvent) argument and return a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object.

For example we could create an `/api/random-number` route with a `GET` handler:

src/routes/api/random-number/+server

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    
    /** @type {import('./$types').RequestHandler} */
    export function function GET({ url }: {
        url: any;
    }): Response@type{import('./$types').RequestHandler}GET({ url: anyurl }) {
    	const const min: numbermin = var Number: NumberConstructor
    (value?: any) => numberAn object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers.
    Number(url: anyurl.searchParams.get('min') ?? '0');
    	const const max: numbermax = var Number: NumberConstructor
    (value?: any) => numberAn object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers.
    Number(url: anyurl.searchParams.get('max') ?? '1');
    
    	const const d: numberd = const max: numbermax - const min: numbermin;
    
    	if (function isNaN(number: number): booleanReturns a Boolean value that indicates whether a value is the reserved value NaN (not a number).
    @paramnumber A numeric value.isNaN(const d: numberd) || const d: numberd < 0) {
    		function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(400, 'min and max must be numbers, and min must be less than max');
    	}
    
    	const const random: numberrandom = const min: numbermin + var Math: MathAn intrinsic object that provides basic mathematics functionality and constants.
    Math.Math.random(): numberReturns a pseudorandom number between 0 and 1.
    random() * const d: numberd;
    
    	return new var Response: new (body?: BodyInit | null, init?: ResponseInit) => ResponseThis Fetch API interface represents the response to a request.
    MDN Reference
    Response(var String: StringConstructor
    (value?: any) => stringAllows manipulation and formatting of text strings and determination and location of substrings within strings.
    String(const random: numberrandom));
    }

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    import type { type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler } from './$types';
    
    export const const GET: RequestHandlerGET: type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler = ({ url: URLThe requested URL.
    url }) => {
    	const const min: numbermin = var Number: NumberConstructor
    (value?: any) => numberAn object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers.
    Number(url: URLThe requested URL.
    url.URL.searchParams: URLSearchParamsMDN Reference
    searchParams.URLSearchParams.get(name: string): string | nullReturns the first value associated to the given search parameter.
    MDN Reference
    get('min') ?? '0');
    	const const max: numbermax = var Number: NumberConstructor
    (value?: any) => numberAn object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers.
    Number(url: URLThe requested URL.
    url.URL.searchParams: URLSearchParamsMDN Reference
    searchParams.URLSearchParams.get(name: string): string | nullReturns the first value associated to the given search parameter.
    MDN Reference
    get('max') ?? '1');
    
    	const const d: numberd = const max: numbermax - const min: numbermin;
    
    	if (function isNaN(number: number): booleanReturns a Boolean value that indicates whether a value is the reserved value NaN (not a number).
    @paramnumber A numeric value.isNaN(const d: numberd) || const d: numberd < 0) {
    		function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(400, 'min and max must be numbers, and min must be less than max');
    	}
    
    	const const random: numberrandom = const min: numbermin + var Math: MathAn intrinsic object that provides basic mathematics functionality and constants.
    Math.Math.random(): numberReturns a pseudorandom number between 0 and 1.
    random() * const d: numberd;
    
    	return new var Response: new (body?: BodyInit | null, init?: ResponseInit) => ResponseThis Fetch API interface represents the response to a request.
    MDN Reference
    Response(var String: StringConstructor
    (value?: any) => stringAllows manipulation and formatting of text strings and determination and location of substrings within strings.
    String(const random: numberrandom));
    };

The first argument to `Response` can be a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream), making it possible to stream large amounts of data or create server-sent events (unless deploying to platforms that buffer responses, like AWS Lambda).

You can use the [`error`](@sveltejs-kit#error), [`redirect`](@sveltejs-kit#redirect) and [`json`](@sveltejs-kit#json) methods from `@sveltejs/kit` for convenience (but you don’t have to).

If an error is thrown (either `error(...)` or an unexpected error), the response will be a JSON representation of the error or a fallback error page — which can be customised via `src/error.html` — depending on the `Accept` header. The [`+error.svelte`](#error) component will _not_ be rendered in this case. You can read more about error handling [here](errors).

> When creating an `OPTIONS` handler, note that Vite will inject `Access-Control-Allow-Origin` and `Access-Control-Allow-Methods` headers — these will not be present in production unless you add them.

> `+layout` files have no effect on `+server.js` files. If you want to run some logic before each request, add it to the server [`handle`](hooks#Server-hooks-handle) hook.

### Receiving data[](#server-Receiving-data)

By exporting `POST` / `PUT`/`PATCH`/`DELETE`/`OPTIONS`/`HEAD` handlers, `+server.js` files can be used to create a complete API:

src/routes/add/+page

    <script>
    	let a = 0;
    	let b = 0;
    	let total = 0;
    
    	async function add() {
    		const response = await fetch('/api/add', {
    			method: 'POST',
    			body: JSON.stringify({ a, b }),
    			headers: {
    				'content-type': 'application/json'
    			}
    		});
    
    		total = await response.json();
    	}
    </script>
    
    <input type="number" bind:value={a}> +
    <input type="number" bind:value={b}> =
    {total}
    
    <button onclick={add}>Calculate</button>

    <script lang="ts">
    	let a = 0;
    	let b = 0;
    	let total = 0;
    
    	async function add() {
    		const response = await fetch('/api/add', {
    			method: 'POST',
    			body: JSON.stringify({ a, b }),
    			headers: {
    				'content-type': 'application/json'
    			}
    		});
    
    		total = await response.json();
    	}
    </script>
    
    <input type="number" bind:value={a}> +
    <input type="number" bind:value={b}> =
    {total}
    
    <button onclick={add}>Calculate</button>

src/routes/api/add/+server

    import { function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json } from '@sveltejs/kit';
    
    /** @type {import('./$types').RequestHandler} */
    export async function function POST({ request }: {
        request: any;
    }): Promise<Response>@type{import('./$types').RequestHandler}POST({ request: anyrequest }) {
    	const { const a: anya, const b: anyb } = await request: anyrequest.json();
    	return function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json(const a: anya + const b: anyb);
    }

    import { function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json } from '@sveltejs/kit';
    import type { type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler } from './$types';
    
    export const const POST: RequestHandlerPOST: type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler = async ({ request: RequestThe original request object.
    request }) => {
    	const { const a: anya, const b: anyb } = await request: RequestThe original request object.
    request.Body.json(): Promise<any>MDN Reference
    json();
    	return function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json(const a: anya + const b: anyb);
    };

> In general, [form actions](form-actions) are a better way to submit data from the browser to the server.

> If a `GET` handler is exported, a `HEAD` request will return the `content-length` of the `GET` handler’s response body.

### Fallback method handler[](#server-Fallback-method-handler)

Exporting the `fallback` handler will match any unhandled request methods, including methods like `MOVE` which have no dedicated export from `+server.js`.

src/routes/api/add/+server

    import { function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json, function text(body: string, init?: ResponseInit | undefined): ResponseCreate a Response object from the supplied body.
    @parambody The value that will be used as-is.@paraminit Options such as status and headers that will be added to the response. A Content-Length header will be added automatically.text } from '@sveltejs/kit';
    
    /** @type {import('./$types').RequestHandler} */
    export async function function POST({ request }: {
        request: any;
    }): Promise<Response>@type{import('./$types').RequestHandler}POST({ request: anyrequest }) {
    	const { const a: anya, const b: anyb } = await request: anyrequest.json();
    	return function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json(const a: anya + const b: anyb);
    }
    
    // This handler will respond to PUT, PATCH, DELETE, etc.
    /** @type {import('./$types').RequestHandler} */
    export async function function fallback({ request }: {
        request: any;
    }): Promise<Response>@type{import('./$types').RequestHandler}fallback({ request: anyrequest }) {
    	return function text(body: string, init?: ResponseInit | undefined): ResponseCreate a Response object from the supplied body.
    @parambody The value that will be used as-is.@paraminit Options such as status and headers that will be added to the response. A Content-Length header will be added automatically.text(`I caught your ${request: anyrequest.method} request!`);
    }

    import { function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json, function text(body: string, init?: ResponseInit | undefined): ResponseCreate a Response object from the supplied body.
    @parambody The value that will be used as-is.@paraminit Options such as status and headers that will be added to the response. A Content-Length header will be added automatically.text } from '@sveltejs/kit';
    import type { type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler } from './$types';
    
    export const const POST: RequestHandlerPOST: type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler = async ({ request: RequestThe original request object.
    request }) => {
    	const { const a: anya, const b: anyb } = await request: RequestThe original request object.
    request.Body.json(): Promise<any>MDN Reference
    json();
    	return function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json(const a: anya + const b: anyb);
    };
    
    // This handler will respond to PUT, PATCH, DELETE, etc.
    
    export const const fallback: RequestHandlerfallback: type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler = async ({ request: RequestThe original request object.
    request }) => {
    	return function text(body: string, init?: ResponseInit | undefined): ResponseCreate a Response object from the supplied body.
    @parambody The value that will be used as-is.@paraminit Options such as status and headers that will be added to the response. A Content-Length header will be added automatically.text(`I caught your ${request: RequestThe original request object.
    request.Request.method: stringReturns request’s HTTP method, which is “GET” by default.
    MDN Reference
    method} request!`);
    };

> For `HEAD` requests, the `GET` handler takes precedence over the `fallback` handler.

### Content negotiation[](#server-Content-negotiation)

`+server.js` files can be placed in the same directory as `+page` files, allowing the same route to be either a page or an API endpoint. To determine which, SvelteKit applies the following rules:

*   `PUT` / `PATCH`/`DELETE`/`OPTIONS` requests are always handled by `+server.js` since they do not apply to pages
*   `GET` / `POST`/`HEAD` requests are treated as page requests if the `accept` header prioritises `text/html` (in other words, it’s a browser page request), else they are handled by `+server.js`.
*   Responses to `GET` requests will include a `Vary: Accept` header, so that proxies and browsers cache HTML and JSON responses separately.

$types[](#$types)
-----------------

Throughout the examples above, we’ve been importing types from a `$types.d.ts` file. This is a file SvelteKit creates for you in a hidden directory if you’re using TypeScript (or JavaScript with JSDoc type annotations) to give you type safety when working with your root files.

For example, annotating `let { data } = $props()` with `PageProps` (or `LayoutProps`, for a `+layout.svelte` file) tells TypeScript that the type of `data` is whatever was returned from `load`:

src/routes/blog/\[slug\]/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    </script>

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data }: PageProps = $props();
    </script>

> The `PageProps` and `LayoutProps` types, added in 2.16.0, are a shortcut for typing the `data` prop as `PageData` or `LayoutData`, as well as other props, such as `form` for pages, or `children` for layouts. In earlier versions, you had to type these properties manually. For example, for a page:
> 
> +page
> 
>     /** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */
>     let { let data: anydata, let form: anyform } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();
> 
>     import type { import PageDataPageData, import ActionDataActionData } from './$types';
>     
>     let { let data: PageDatadata, let form: ActionDataform }: { data: PageDatadata: import PageDataPageData, form: ActionDataform: import ActionDataActionData } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();
> 
> Or, for a layout:
> 
> +layout
> 
>     /** @type {{ data: import('./$types').LayoutData, children: Snippet }} */
>     let { let data: anydata, let children: anychildren } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();
> 
>     import type { import LayoutDataLayoutData } from './$types';
>     
>     let { let data: LayoutDatadata, let children: Snippetchildren }: { data: LayoutDatadata: import LayoutDataLayoutData, children: Snippetchildren: type Snippet = /*unresolved*/ anySnippet } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();

In turn, annotating the `load` function with `PageLoad`, `PageServerLoad`, `LayoutLoad` or `LayoutServerLoad` (for `+page.js`, `+page.server.js`, `+layout.js` and `+layout.server.js` respectively) ensures that `params` and the return value are correctly typed.

If you’re using VS Code or any IDE that supports the language server protocol and TypeScript plugins then you can omit these types _entirely_! Svelte’s IDE tooling will insert the correct types for you, so you’ll get type checking without writing them yourself. It also works with our command line tool `svelte-check`.

You can read more about omitting `$types` in our [blog post](/blog/zero-config-type-safety) about it.

Other files[](#Other-files)
---------------------------

Any other files inside a route directory are ignored by SvelteKit. This means you can colocate components and utility modules with the routes that need them.

If components and modules are needed by multiple routes, it’s a good idea to put them in [`$lib`]($lib).

Further reading[](#Further-reading)
-----------------------------------

*   [Tutorial: Routing](/tutorial/kit/pages)
*   [Tutorial: API routes](/tutorial/kit/get-handlers)
*   [Docs: Advanced routing](advanced-routing)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/20-core-concepts/10-routing.md) [llms.txt](/docs/kit/routing/llms.txt)

previous next

[Web standards](/docs/kit/web-standards) [Loading data](/docs/kit/load)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitCore concepts

Loading data
============

### On this page

*   [Loading data](/docs/kit/load)
*   [Page data](#Page-data)
*   [Layout data](#Layout-data)
*   [page.data](#page.data)
*   [Universal vs server](#Universal-vs-server)
*   [Using URL data](#Using-URL-data)
*   [Making fetch requests](#Making-fetch-requests)
*   [Cookies](#Cookies)
*   [Headers](#Headers)
*   [Using parent data](#Using-parent-data)
*   [Errors](#Errors)
*   [Redirects](#Redirects)
*   [Streaming with promises](#Streaming-with-promises)
*   [Parallel loading](#Parallel-loading)
*   [Rerunning load functions](#Rerunning-load-functions)
*   [Implications for authentication](#Implications-for-authentication)
*   [Using getRequestEvent](#Using-getRequestEvent)
*   [Further reading](#Further-reading)

Before a [`+page.svelte`](routing#page-page.svelte) component (and its containing [`+layout.svelte`](routing#layout-layout.svelte) components) can be rendered, we often need to get some data. This is done by defining `load` functions.

Page data[](#Page-data)
-----------------------

A `+page.svelte` file can have a sibling `+page.js` that exports a `load` function, the return value of which is available to the page via the `data` prop:

src/routes/blog/\[slug\]/+page

    /** @type {import('./$types').PageLoad} */
    export function function load({ params }: {
        params: any;
    }): {
        post: {
            title: string;
            content: string;
        };
    }@type{import('./$types').PageLoad}load({ params: anyparams }) {
    	return {
    		post: {
        title: string;
        content: string;
    }post: {
    			title: stringtitle: `Title for ${params: anyparams.slug} goes here`,
    			content: stringcontent: `Content for ${params: anyparams.slug} goes here`
    		}
    	};
    }

    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = ({ params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params }) => {
    	return {
    		post: {
        title: string;
        content: string;
    }post: {
    			title: stringtitle: `Title for ${params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params.slug} goes here`,
    			content: stringcontent: `Content for ${params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params.slug} goes here`
    		}
    	};
    };

src/routes/blog/\[slug\]/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    </script>
    
    <h1>{data.post.title}</h1>
    <div>{@html data.post.content}</div>

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data }: PageProps = $props();
    </script>
    
    <h1>{data.post.title}</h1>
    <div>{@html data.post.content}</div>

> Legacy mode
> 
> Before version 2.16.0, the props of a page and layout had to be typed individually:
> 
> +page
> 
>     /** @type {{ data: import('./$types').PageData }} */
>     let { let data: anydata } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();
> 
>     import type { import PageDataPageData } from './$types';
>     
>     let { let data: PageDatadata }: { data: PageDatadata: import PageDataPageData } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();
> 
> In Svelte 4, you’d use `export let data` instead.

Thanks to the generated `$types` module, we get full type safety.

A `load` function in a `+page.js` file runs both on the server and in the browser (unless combined with `export const ssr = false`, in which case it will [only run in the browser](page-options#ssr)). If your `load` function should _always_ run on the server (because it uses private environment variables, for example, or accesses a database) then it would go in a `+page.server.js` instead.

A more realistic version of your blog post’s `load` function, that only runs on the server and pulls data from a database, might look like this:

src/routes/blog/\[slug\]/+page.server

    import * as module "$lib/server/database"db from '$lib/server/database';
    
    /** @type {import('./$types').PageServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageServerLoad}load({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) {
    	return {
    		post: {
        title: string;
        content: string;
    }post: await module "$lib/server/database"db.function getPost(slug: string): Promise<{
        title: string;
        content: string;
    }>getPost(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug)
    	};
    }

    import * as module "$lib/server/database"db from '$lib/server/database';
    import type { type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = async ({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) => {
    	return {
    		post: {
        title: string;
        content: string;
    }post: await module "$lib/server/database"db.function getPost(slug: string): Promise<{
        title: string;
        content: string;
    }>getPost(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug)
    	};
    };

Notice that the type changed from `PageLoad` to `PageServerLoad`, because server `load` functions can access additional arguments. To understand when to use `+page.js` and when to use `+page.server.js`, see [Universal vs server](load#Universal-vs-server).

Layout data[](#Layout-data)
---------------------------

Your `+layout.svelte` files can also load data, via `+layout.js` or `+layout.server.js`.

src/routes/blog/\[slug\]/+layout.server

    import * as module "$lib/server/database"db from '$lib/server/database';
    
    /** @type {import('./$types').LayoutServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').LayoutServerLoad}load() {
    	return {
    		posts: {
        title: string;
        slug: string;
    }[]posts: await module "$lib/server/database"db.function getPostSummaries(): Promise<Array<{
        title: string;
        slug: string;
    }>>getPostSummaries()
    	};
    }

    import * as module "$lib/server/database"db from '$lib/server/database';
    import type { type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad } from './$types';
    
    export const const load: LayoutServerLoadload: type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad = async () => {
    	return {
    		posts: {
        title: string;
        slug: string;
    }[]posts: await module "$lib/server/database"db.function getPostSummaries(): Promise<Array<{
        title: string;
        slug: string;
    }>>getPostSummaries()
    	};
    };

src/routes/blog/\[slug\]/+layout

    <script>
    	/** @type {import('./$types').LayoutProps} */
    	let { data, children } = $props();
    </script>
    
    <main>
    	<!-- +page.svelte is `@render`ed here -->
    	{@render children()}
    </main>
    
    <aside>
    	<h2>More posts</h2>
    	<ul>
    		{#each data.posts as post}
    			<li>
    				<a href="/blog/{post.slug}">
    					{post.title}
    				</a>
    			</li>
    		{/each}
    	</ul>
    </aside>

    <script lang="ts">
    	import type { LayoutProps } from './$types';
    
    	let { data, children }: LayoutProps = $props();
    </script>
    
    <main>
    	<!-- +page.svelte is `@render`ed here -->
    	{@render children()}
    </main>
    
    <aside>
    	<h2>More posts</h2>
    	<ul>
    		{#each data.posts as post}
    			<li>
    				<a href="/blog/{post.slug}">
    					{post.title}
    				</a>
    			</li>
    		{/each}
    	</ul>
    </aside>

> Legacy mode
> 
> `LayoutProps` was added in 2.16.0. In earlier versions, properties had to be typed individually:
> 
> +layout
> 
>     /** @type {{ data: import('./$types').LayoutData, children: Snippet }} */
>     let { let data: anydata, let children: anychildren } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();
> 
>     import type { import LayoutDataLayoutData } from './$types';
>     
>     let { let data: LayoutDatadata, let children: Snippetchildren }: { data: LayoutDatadata: import LayoutDataLayoutData, children: Snippetchildren: type Snippet = /*unresolved*/ anySnippet } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();

Data returned from layout `load` functions is available to child `+layout.svelte` components and the `+page.svelte` component as well as the layout that it ‘belongs’ to.

src/routes/blog/\[slug\]/+page

    <script>
    	import { page } from '$app/state';
    
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    
    	// we can access `data.posts` because it's returned from
    	// the parent layout `load` function
    	let index = $derived(data.posts.findIndex(post => post.slug === page.params.slug));
    	let next = $derived(data.posts[index + 1]);
    </script>
    
    <h1>{data.post.title}</h1>
    <div>{@html data.post.content}</div>
    
    {#if next}
    	<p>Next post: <a href="/blog/{next.slug}">{next.title}</a></p>
    {/if}

    <script lang="ts">
    	import { page } from '$app/state';
    	import type { PageProps } from './$types';
    	let { data }: PageProps = $props();
    
    	// we can access `data.posts` because it's returned from
    	// the parent layout `load` function
    	let index = $derived(data.posts.findIndex(post => post.slug === page.params.slug));
    	let next = $derived(data.posts[index + 1]);
    </script>
    
    <h1>{data.post.title}</h1>
    <div>{@html data.post.content}</div>
    
    {#if next}
    	<p>Next post: <a href="/blog/{next.slug}">{next.title}</a></p>
    {/if}

> If multiple `load` functions return data with the same key, the last one ‘wins’ — the result of a layout `load` returning `{ a: 1, b: 2 }` and a page `load` returning `{ b: 3, c: 4 }` would be `{ a: 1, b: 3, c: 4 }`.

page.data[](#page.data)
-----------------------

The `+page.svelte` component, and each `+layout.svelte` component above it, has access to its own data plus all the data from its parents.

In some cases, we might need the opposite — a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a `title` property returned from a `load` function in `+page.js` or `+page.server.js`. This can be done with `page.data`:

src/routes/+layout

    <script>
    	import { page } from '$app/state';
    </script>
    
    <svelte:head>
    	<title>{page.data.title}</title>
    </svelte:head>

    <script lang="ts">
    	import { page } from '$app/state';
    </script>
    
    <svelte:head>
    	<title>{page.data.title}</title>
    </svelte:head>

Type information for `page.data` is provided by `App.PageData`.

> Legacy mode
> 
> `$app/state` was added in SvelteKit 2.12. If you’re using an earlier version or are using Svelte 4, use `$app/stores` instead. It provides a `page` store with the same interface that you can subscribe to, e.g. `$page.data.title`.

Universal vs server[](#Universal-vs-server)
-------------------------------------------

As we’ve seen, there are two types of `load` function:

*   `+page.js` and `+layout.js` files export _universal_ `load` functions that run both on the server and in the browser
*   `+page.server.js` and `+layout.server.js` files export _server_ `load` functions that only run server-side

Conceptually, they’re the same thing, but there are some important differences to be aware of.

### When does which load function run?[](#Universal-vs-server-When-does-which-load-function-run)

Server `load` functions _always_ run on the server.

By default, universal `load` functions run on the server during SSR when the user first visits your page. They will then run again during hydration, reusing any responses from [fetch requests](#Making-fetch-requests). All subsequent invocations of universal `load` functions happen in the browser. You can customize the behavior through [page options](page-options). If you disable [server side rendering](page-options#ssr), you’ll get an SPA and universal `load` functions _always_ run on the client.

If a route contains both universal and server `load` functions, the server `load` runs first.

A `load` function is invoked at runtime, unless you [prerender](page-options#prerender) the page — in that case, it’s invoked at build time.

### Input[](#Universal-vs-server-Input)

Both universal and server `load` functions have access to properties describing the request (`params`, `route` and `url`) and various functions (`fetch`, `setHeaders`, `parent`, `depends` and `untrack`). These are described in the following sections.

Server `load` functions are called with a `ServerLoadEvent`, which inherits `clientAddress`, `cookies`, `locals`, `platform` and `request` from `RequestEvent`.

Universal `load` functions are called with a `LoadEvent`, which has a `data` property. If you have `load` functions in both `+page.js` and `+page.server.js` (or `+layout.js` and `+layout.server.js`), the return value of the server `load` function is the `data` property of the universal `load` function’s argument.

### Output[](#Universal-vs-server-Output)

A universal `load` function can return an object containing any values, including things like custom classes and component constructors.

A server `load` function must return data that can be serialized with [devalue](https://github.com/rich-harris/devalue) — anything that can be represented as JSON plus things like `BigInt`, `Date`, `Map`, `Set` and `RegExp`, or repeated/cyclical references — so that it can be transported over the network. Your data can include [promises](#Streaming-with-promises), in which case it will be streamed to browsers.

### When to use which[](#Universal-vs-server-When-to-use-which)

Server `load` functions are convenient when you need to access data directly from a database or filesystem, or need to use private environment variables.

Universal `load` functions are useful when you need to `fetch` data from an external API and don’t need private credentials, since SvelteKit can get the data directly from the API rather than going via your server. They are also useful when you need to return something that can’t be serialized, such as a Svelte component constructor.

In rare cases, you might need to use both together — for example, you might need to return an instance of a custom class that was initialised with data from your server. When using both, the server `load` return value is _not_ passed directly to the page, but to the universal `load` function (as the `data` property):

src/routes/+page.server

    /** @type {import('./$types').PageServerLoad} */
    export async function function load(): Promise<{
        serverMessage: string;
    }>@type{import('./$types').PageServerLoad}load() {
    	return {
    		serverMessage: stringserverMessage: 'hello from server load function'
    	};
    }

    import type { type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = async () => {
    	return {
    		serverMessage: stringserverMessage: 'hello from server load function'
    	};
    };

src/routes/+page

    /** @type {import('./$types').PageLoad} */
    export async function function load({ data }: {
        data: any;
    }): Promise<{
        serverMessage: any;
        universalMessage: string;
    }>@type{import('./$types').PageLoad}load({ data: anydata }) {
    	return {
    		serverMessage: anyserverMessage: data: anydata.serverMessage,
    		universalMessage: stringuniversalMessage: 'hello from universal load function'
    	};
    }

    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ data: Record<string, any> | nullContains the data returned by the route’s server load function (in +layout.server.js or +page.server.js), if any.
    data }) => {
    	return {
    		serverMessage: anyserverMessage: data: Record<string, any> | nullContains the data returned by the route’s server load function (in +layout.server.js or +page.server.js), if any.
    data.serverMessage,
    		universalMessage: stringuniversalMessage: 'hello from universal load function'
    	};
    };

Using URL data[](#Using-URL-data)
---------------------------------

Often the `load` function depends on the URL in one way or another. For this, the `load` function provides you with `url`, `route` and `params`.

### url[](#Using-URL-data-url)

An instance of [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL), containing properties like the `origin`, `hostname`, `pathname` and `searchParams` (which contains the parsed query string as a [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) object). `url.hash` cannot be accessed during `load`, since it is unavailable on the server.

> In some environments this is derived from request headers during server-side rendering. If you’re using [adapter-node](adapter-node), for example, you may need to configure the adapter in order for the URL to be correct.

### route[](#Using-URL-data-route)

Contains the name of the current route directory, relative to `src/routes`:

src/routes/a/\[b\]/\[...c\]/+page

    /** @type {import('./$types').PageLoad} */
    export function function load({ route }: {
        route: any;
    }): void@type{import('./$types').PageLoad}load({ route: anyroute }) {
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(route: anyroute.id); // '/a/[b]/[...c]'
    }

    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = ({ route: {
        id: string | null;
    }Info about the current route
    route }) => {
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(route: {
        id: string | null;
    }Info about the current route
    route.id: string | nullThe ID of the current route - e.g. for src/routes/blog/[slug], it would be /blog/[slug]. It is null when no route is matched.
    id); // '/a/[b]/[...c]'
    };

### params[](#Using-URL-data-params)

`params` is derived from `url.pathname` and `route.id`.

Given a `route.id` of `/a/[b]/[...c]` and a `url.pathname` of `/a/x/y/z`, the `params` object would look like this:

    {
    	"b": "x",
    	"c": "y/z"
    }

Making fetch requests[](#Making-fetch-requests)
-----------------------------------------------

To get data from an external API or a `+server.js` handler, you can use the provided `fetch` function, which behaves identically to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch) with a few additional features:

*   It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request.
*   It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context).
*   Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
*   During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text`, `json` and `arrayBuffer` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](hooks#Server-hooks-handle).
*   During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request - if you received a warning in your browser console when using the browser `fetch` instead of the `load` `fetch`, this is why.

src/routes/items/\[id\]/+page

    /** @type {import('./$types').PageLoad} */
    export async function function load({ fetch, params }: {
        fetch: any;
        params: any;
    }): Promise<{
        item: any;
    }>@type{import('./$types').PageLoad}load({ fetch: anyfetch, params: anyparams }) {
    	const const res: anyres = await fetch: anyfetch(`/api/items/${params: anyparams.id}`);
    	const const item: anyitem = await const res: anyres.json();
    
    	return { item: anyitem };
    }

    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here
    fetch, params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params }) => {
    	const const res: Responseres = await fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch(`/api/items/${params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params.id}`);
    	const const item: anyitem = await const res: Responseres.Body.json(): Promise<any>MDN Reference
    json();
    
    	return { item: anyitem };
    };

Cookies[](#Cookies)
-------------------

A server `load` function can get and set [`cookies`](@sveltejs-kit#Cookies).

src/routes/+layout.server

    import * as module "$lib/server/database"db from '$lib/server/database';
    
    /** @type {import('./$types').LayoutServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').LayoutServerLoad}load({ cookies: CookiesGet or set cookies related to the current request
    cookies }) {
    	const const sessionid: string | undefinedsessionid = cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.get: (name: string, opts?: CookieParseOptions) => string | undefinedGets a cookie that was previously set with cookies.set, or from the request headers.
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.parse. See documentation hereget('sessionid');
    
    	return {
    		user: {
        name: string;
        avatar: string;
    }user: await module "$lib/server/database"db.function getUser(sessionid: string | undefined): Promise<{
        name: string;
        avatar: string;
    }>getUser(const sessionid: string | undefinedsessionid)
    	};
    }

    import * as module "$lib/server/database"db from '$lib/server/database';
    import type { type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad } from './$types';
    
    export const const load: LayoutServerLoadload: type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad = async ({ cookies: CookiesGet or set cookies related to the current request
    cookies }) => {
    	const const sessionid: string | undefinedsessionid = cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.get: (name: string, opts?: CookieParseOptions) => string | undefinedGets a cookie that was previously set with cookies.set, or from the request headers.
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.parse. See documentation hereget('sessionid');
    
    	return {
    		user: {
        name: string;
        avatar: string;
    }user: await module "$lib/server/database"db.function getUser(sessionid: string | undefined): Promise<{
        name: string;
        avatar: string;
    }>getUser(const sessionid: string | undefinedsessionid)
    	};
    };

Cookies will only be passed through the provided `fetch` function if the target host is the same as the SvelteKit application or a more specific subdomain of it.

For example, if SvelteKit is serving my.domain.com:

*   domain.com WILL NOT receive cookies
*   my.domain.com WILL receive cookies
*   api.domain.com WILL NOT receive cookies
*   sub.my.domain.com WILL receive cookies

Other cookies will not be passed when `credentials: 'include'` is set, because SvelteKit does not know which domain which cookie belongs to (the browser does not pass this information along), so it’s not safe to forward any of them. Use the [handleFetch hook](hooks#Server-hooks-handleFetch) to work around it.

Headers[](#Headers)
-------------------

Both server and universal `load` functions have access to a `setHeaders` function that, when running on the server, can set headers for the response. (When running in the browser, `setHeaders` has no effect.) This is useful if you want the page to be cached, for example:

src/routes/products/+page

    /** @type {import('./$types').PageLoad} */
    export async function function load({ fetch, setHeaders }: {
        fetch: any;
        setHeaders: any;
    }): Promise<any>@type{import('./$types').PageLoad}load({ fetch: anyfetch, setHeaders: anysetHeaders }) {
    	const const url: "https://cms.example.com/products.json"url = `https://cms.example.com/products.json`;
    	const const response: anyresponse = await fetch: anyfetch(const url: "https://cms.example.com/products.json"url);
    
    	// Headers are only set during SSR, caching the page's HTML
    	// for the same length of time as the underlying data.
    	setHeaders: anysetHeaders({
    		age: anyage: const response: anyresponse.headers.get('age'),
    		'cache-control': const response: anyresponse.headers.get('cache-control')
    	});
    
    	return const response: anyresponse.json();
    }

    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here
    fetch, setHeaders: (headers: Record<string, string>) => voidIf you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:
    src/routes/blog/+pageexport async function load({ fetch, setHeaders }) {
    	const url = `https://cms.example.com/articles.json`;
    	const response = await fetch(url);
    
    	setHeaders({
    		age: response.headers.get('age'),
    		'cache-control': response.headers.get('cache-control')
    	});
    
    	return response.json();
    }Setting the same header multiple times (even in separate load functions) is an error — you can only set a given header once.
    You cannot add a set-cookie header with setHeaders — use the cookies API in a server-only load function instead.
    setHeaders has no effect when a load function runs in the browser.
    setHeaders }) => {
    	const const url: "https://cms.example.com/products.json"url = `https://cms.example.com/products.json`;
    	const const response: Responseresponse = await fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch(const url: "https://cms.example.com/products.json"url);
    
    	// Headers are only set during SSR, caching the page's HTML
    	// for the same length of time as the underlying data.
    	setHeaders: (headers: Record<string, string>) => voidIf you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:
    src/routes/blog/+pageexport async function load({ fetch, setHeaders }) {
    	const url = `https://cms.example.com/articles.json`;
    	const response = await fetch(url);
    
    	setHeaders({
    		age: response.headers.get('age'),
    		'cache-control': response.headers.get('cache-control')
    	});
    
    	return response.json();
    }Setting the same header multiple times (even in separate load functions) is an error — you can only set a given header once.
    You cannot add a set-cookie header with setHeaders — use the cookies API in a server-only load function instead.
    setHeaders has no effect when a load function runs in the browser.
    setHeaders({
    		age: string | nullage: const response: Responseresponse.Response.headers: HeadersMDN Reference
    headers.Headers.get(name: string): string | nullMDN Reference
    get('age'),
    		'cache-control': const response: Responseresponse.Response.headers: HeadersMDN Reference
    headers.Headers.get(name: string): string | nullMDN Reference
    get('cache-control')
    	});
    
    	return const response: Responseresponse.Body.json(): Promise<any>MDN Reference
    json();
    };

Setting the same header multiple times (even in separate `load` functions) is an error. You can only set a given header once using the `setHeaders` function. You cannot add a `set-cookie` header with `setHeaders` — use `cookies.set(name, value, options)` instead.

Using parent data[](#Using-parent-data)
---------------------------------------

Occasionally it’s useful for a `load` function to access data from a parent `load` function, which can be done with `await parent()`:

src/routes/+layout

    /** @type {import('./$types').LayoutLoad} */
    export function function load(): {
        a: number;
    }@type{import('./$types').LayoutLoad}load() {
    	return { a: numbera: 1 };
    }

    import type { type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutLoad } from './$types';
    
    export const const load: LayoutLoadload: type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutLoad = () => {
    	return { a: numbera: 1 };
    };

src/routes/abc/+layout

    /** @type {import('./$types').LayoutLoad} */
    export async function function load({ parent }: {
        parent: any;
    }): Promise<{
        b: any;
    }>@type{import('./$types').LayoutLoad}load({ parent: anyparent }) {
    	const { const a: anya } = await parent: anyparent();
    	return { b: anyb: const a: anya + 1 };
    }

    import type { type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutLoad } from './$types';
    
    export const const load: LayoutLoadload: type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type LayoutLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutLoad = async ({ parent: () => Promise<Record<string, any>>await parent() returns data from parent +layout.js load functions.
    Implicitly, a missing +layout.js is treated as a ({ data }) => data function, meaning that it will return and forward data from parent +layout.server.js files.
    Be careful not to introduce accidental waterfalls when using await parent(). If for example you only want to merge parent data into the returned output, call it after fetching your other data.
    parent }) => {
    	const { const a: anya } = await parent: () => Promise<Record<string, any>>await parent() returns data from parent +layout.js load functions.
    Implicitly, a missing +layout.js is treated as a ({ data }) => data function, meaning that it will return and forward data from parent +layout.server.js files.
    Be careful not to introduce accidental waterfalls when using await parent(). If for example you only want to merge parent data into the returned output, call it after fetching your other data.
    parent();
    	return { b: anyb: const a: anya + 1 };
    };

src/routes/abc/+page

    /** @type {import('./$types').PageLoad} */
    export async function function load({ parent }: {
        parent: any;
    }): Promise<{
        c: any;
    }>@type{import('./$types').PageLoad}load({ parent: anyparent }) {
    	const { const a: anya, const b: anyb } = await parent: anyparent();
    	return { c: anyc: const a: anya + const b: anyb };
    }

    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ parent: () => Promise<Record<string, any>>await parent() returns data from parent +layout.js load functions.
    Implicitly, a missing +layout.js is treated as a ({ data }) => data function, meaning that it will return and forward data from parent +layout.server.js files.
    Be careful not to introduce accidental waterfalls when using await parent(). If for example you only want to merge parent data into the returned output, call it after fetching your other data.
    parent }) => {
    	const { const a: anya, const b: anyb } = await parent: () => Promise<Record<string, any>>await parent() returns data from parent +layout.js load functions.
    Implicitly, a missing +layout.js is treated as a ({ data }) => data function, meaning that it will return and forward data from parent +layout.server.js files.
    Be careful not to introduce accidental waterfalls when using await parent(). If for example you only want to merge parent data into the returned output, call it after fetching your other data.
    parent();
    	return { c: anyc: const a: anya + const b: anyb };
    };

src/routes/abc/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    </script>
    
    <!-- renders `1 + 2 = 3` -->
    <p>{data.a} + {data.b} = {data.c}</p>

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data }: PageProps = $props();
    </script>
    
    <!-- renders `1 + 2 = 3` -->
    <p>{data.a} + {data.b} = {data.c}</p>

> Notice that the `load` function in `+page.js` receives the merged data from both layout `load` functions, not just the immediate parent.

Inside `+page.server.js` and `+layout.server.js`, `parent` returns data from parent `+layout.server.js` files.

In `+page.js` or `+layout.js` it will return data from parent `+layout.js` files. However, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will also return data from parent `+layout.server.js` files that are not ‘shadowed’ by a `+layout.js` file

Take care not to introduce waterfalls when using `await parent()`. Here, for example, `getData(params)` does not depend on the result of calling `parent()`, so we should call it first to avoid a delayed render.

+page

    /** @type {import('./$types').PageLoad} */
    export async function function load(event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageLoad}load({ params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params, parent: () => Promise<Record<string, any>>await parent() returns data from parent +layout.js load functions.
    Implicitly, a missing +layout.js is treated as a ({ data }) => data function, meaning that it will return and forward data from parent +layout.server.js files.
    Be careful not to introduce accidental waterfalls when using await parent(). If for example you only want to merge parent data into the returned output, call it after fetching your other data.
    parent }) {
    	const parentData = await parent();
    	const const data: {
        meta: any;
    }data = await function getData(params: Record<string, string>): Promise<{
        meta: any;
    }>getData(params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params);
    	const const parentData: Record<string, any>parentData = await parent: () => Promise<Record<string, any>>await parent() returns data from parent +layout.js load functions.
    Implicitly, a missing +layout.js is treated as a ({ data }) => data function, meaning that it will return and forward data from parent +layout.server.js files.
    Be careful not to introduce accidental waterfalls when using await parent(). If for example you only want to merge parent data into the returned output, call it after fetching your other data.
    parent();
    
    	return {
    		...const data: {
        meta: any;
    }data,
    		meta: anymeta: { ...const parentData: Record<string, any>parentData.meta, ...const data: {
        meta: any;
    }data.meta: anymeta }
    	};
    }

    import type { type PageLoad = (event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params, parent: () => Promise<Record<string, any>>await parent() returns data from parent +layout.js load functions.
    Implicitly, a missing +layout.js is treated as a ({ data }) => data function, meaning that it will return and forward data from parent +layout.server.js files.
    Be careful not to introduce accidental waterfalls when using await parent(). If for example you only want to merge parent data into the returned output, call it after fetching your other data.
    parent }) => {
    	const parentData = await parent();
    	const const data: {
        meta: any;
    }data = await function getData(params: Record<string, string>): Promise<{
        meta: any;
    }>getData(params: Record<string, any>The parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params);
    	const const parentData: Record<string, any>parentData = await parent: () => Promise<Record<string, any>>await parent() returns data from parent +layout.js load functions.
    Implicitly, a missing +layout.js is treated as a ({ data }) => data function, meaning that it will return and forward data from parent +layout.server.js files.
    Be careful not to introduce accidental waterfalls when using await parent(). If for example you only want to merge parent data into the returned output, call it after fetching your other data.
    parent();
    
    	return {
    		...const data: {
        meta: any;
    }data,
    		meta: anymeta: { ...const parentData: Record<string, any>parentData.meta, ...const data: {
        meta: any;
    }data.meta: anymeta }
    	};
    };

Errors[](#Errors)
-----------------

If an error is thrown during `load`, the nearest [`+error.svelte`](routing#error) will be rendered. For [_expected_](errors#Expected-errors) errors, use the `error` helper from `@sveltejs/kit` to specify the HTTP status code and an optional message:

src/routes/admin/+layout.server

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    
    /** @type {import('./$types').LayoutServerLoad} */
    export function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').LayoutServerLoad}load({ locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals }) {
    	if (!locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user?: {
        name: string;
        isAdmin: boolean;
    } | undefineduser) {
    		function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(401, 'not logged in');
    	}
    
    	if (!locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user?: {
        name: string;
        isAdmin: boolean;
    }user.isAdmin: booleanisAdmin) {
    		function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(403, 'not an admin');
    	}
    }

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    import type { type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad } from './$types';
    
    export const const load: LayoutServerLoadload: type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad = ({ locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals }) => {
    	if (!locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user?: {
        name: string;
        isAdmin: boolean;
    } | undefineduser) {
    		function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(401, 'not logged in');
    	}
    
    	if (!locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user?: {
        name: string;
        isAdmin: boolean;
    }user.isAdmin: booleanisAdmin) {
    		function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(403, 'not an admin');
    	}
    };

Calling `error(...)` will throw an exception, making it easy to stop execution from inside helper functions.

If an [_unexpected_](errors#Unexpected-errors) error is thrown, SvelteKit will invoke [`handleError`](hooks#Shared-hooks-handleError) and treat it as a 500 Internal Error.

> [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the error yourself

Redirects[](#Redirects)
-----------------------

To redirect users, use the `redirect` helper from `@sveltejs/kit` to specify the location to which they should be redirected alongside a `3xx` status code. Like `error(...)`, calling `redirect(...)` will throw an exception, making it easy to stop execution from inside helper functions.

src/routes/user/+layout.server

    import { function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect } from '@sveltejs/kit';
    
    /** @type {import('./$types').LayoutServerLoad} */
    export function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').LayoutServerLoad}load({ locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals }) {
    	if (!locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user?: {
        name: string;
    } | undefineduser) {
    		function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect(307, '/login');
    	}
    }

    import { function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect } from '@sveltejs/kit';
    import type { type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad } from './$types';
    
    export const const load: LayoutServerLoadload: type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad = ({ locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals }) => {
    	if (!locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user?: {
        name: string;
    } | undefineduser) {
    		function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect(307, '/login');
    	}
    };

> Don’t use `redirect()` inside a `try {...}` block, as the redirect will immediately trigger the catch statement.

In the browser, you can also navigate programmatically outside of a `load` function using [`goto`]($app-navigation#goto) from [`$app.navigation`]($app-navigation).

> [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the `redirect` yourself

Streaming with promises[](#Streaming-with-promises)
---------------------------------------------------

When using a server `load`, promises will be streamed to the browser as they resolve. This is useful if you have slow, non-essential data, since you can start rendering the page before all the data is available:

src/routes/blog/\[slug\]/+page.server

    /** @type {import('./$types').PageServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageServerLoad}load({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) {
    	return {
    		// make sure the `await` happens at the end, otherwise we
    		// can't start loading comments until we've loaded the post
    		comments: Promise<{
        content: string;
    }>comments: const loadComments: (slug: string) => Promise<{
        content: string;
    }>loadComments(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug),
    		post: {
        title: string;
        content: string;
    }post: await const loadPost: (slug: string) => Promise<{
        title: string;
        content: string;
    }>loadPost(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug)
    	};
    }

    import type { type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = async ({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) => {
    	return {
    		// make sure the `await` happens at the end, otherwise we
    		// can't start loading comments until we've loaded the post
    		comments: Promise<{
        content: string;
    }>comments: const loadComments: (slug: string) => Promise<{
        content: string;
    }>loadComments(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug),
    		post: {
        title: string;
        content: string;
    }post: await const loadPost: (slug: string) => Promise<{
        title: string;
        content: string;
    }>loadPost(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug)
    	};
    };

This is useful for creating skeleton loading states, for example:

src/routes/blog/\[slug\]/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    </script>
    
    <h1>{data.post.title}</h1>
    <div>{@html data.post.content}</div>
    
    {#await data.comments}
    	Loading comments...
    {:then comments}
    	{#each comments as comment}
    		<p>{comment.content}</p>
    	{/each}
    {:catch error}
    	<p>error loading comments: {error.message}</p>
    {/await}

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data }: PageProps = $props();
    </script>
    
    <h1>{data.post.title}</h1>
    <div>{@html data.post.content}</div>
    
    {#await data.comments}
    	Loading comments...
    {:then comments}
    	{#each comments as comment}
    		<p>{comment.content}</p>
    	{/each}
    {:catch error}
    	<p>error loading comments: {error.message}</p>
    {/await}

When streaming data, be careful to handle promise rejections correctly. More specifically, the server could crash with an “unhandled promise rejection” error if a lazy-loaded promise fails before rendering starts (at which point it’s caught) and isn’t handling the error in some way. When using SvelteKit’s `fetch` directly in the `load` function, SvelteKit will handle this case for you. For other promises, it is enough to attach a noop-`catch` to the promise to mark it as handled.

src/routes/+page.server

    /** @type {import('./$types').PageServerLoad} */
    export function function load({ fetch }: {
        fetch: any;
    }): {
        ok_manual: Promise<never>;
        ok_fetch: any;
        dangerous_unhandled: Promise<never>;
    }@type{import('./$types').PageServerLoad}load({ fetch: anyfetch }) {
    	const const ok_manual: Promise<never>ok_manual = var Promise: PromiseConstructorRepresents the completion of an asynchronous operation
    Promise.PromiseConstructor.reject<never>(reason?: any): Promise<never>Creates a new rejected promise for the provided reason.
    @paramreason The reason the promise was rejected.@returnsA new rejected Promise.reject();
    	const ok_manual: Promise<never>ok_manual.Promise<never>.catch<void>(onrejected?: ((reason: any) => void | PromiseLike<void>) | null | undefined): Promise<void>Attaches a callback for only the rejection of the Promise.
    @paramonrejected The callback to execute when the Promise is rejected.@returnsA Promise for the completion of the callback.catch(() => {});
    
    	return {
    		ok_manual: Promise<never>ok_manual,
    		ok_fetch: anyok_fetch: fetch: anyfetch('/fetch/that/could/fail'),
    		dangerous_unhandled: Promise<never>dangerous_unhandled: var Promise: PromiseConstructorRepresents the completion of an asynchronous operation
    Promise.PromiseConstructor.reject<never>(reason?: any): Promise<never>Creates a new rejected promise for the provided reason.
    @paramreason The reason the promise was rejected.@returnsA new rejected Promise.reject()
    	};
    }

    import type { type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = ({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here.
    fetch }) => {
    	const const ok_manual: Promise<never>ok_manual = var Promise: PromiseConstructorRepresents the completion of an asynchronous operation
    Promise.PromiseConstructor.reject<never>(reason?: any): Promise<never>Creates a new rejected promise for the provided reason.
    @paramreason The reason the promise was rejected.@returnsA new rejected Promise.reject();
    	const ok_manual: Promise<never>ok_manual.Promise<never>.catch<void>(onrejected?: ((reason: any) => void | PromiseLike<void>) | null | undefined): Promise<void>Attaches a callback for only the rejection of the Promise.
    @paramonrejected The callback to execute when the Promise is rejected.@returnsA Promise for the completion of the callback.catch(() => {});
    
    	return {
    		ok_manual: Promise<never>ok_manual,
    		ok_fetch: Promise<Response>ok_fetch: fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch('/fetch/that/could/fail'),
    		dangerous_unhandled: Promise<never>dangerous_unhandled: var Promise: PromiseConstructorRepresents the completion of an asynchronous operation
    Promise.PromiseConstructor.reject<never>(reason?: any): Promise<never>Creates a new rejected promise for the provided reason.
    @paramreason The reason the promise was rejected.@returnsA new rejected Promise.reject()
    	};
    };

> On platforms that do not support streaming, such as AWS Lambda or Firebase, responses will be buffered. This means the page will only render once all promises resolve. If you are using a proxy (e.g. NGINX), make sure it does not buffer responses from the proxied server.

> Streaming data will only work when JavaScript is enabled. You should avoid returning promises from a universal `load` function if the page is server rendered, as these are _not_ streamed — instead, the promise is recreated when the function reruns in the browser.

> The headers and status code of a response cannot be changed once the response has started streaming, therefore you cannot `setHeaders` or throw redirects inside a streamed promise.

> [In SvelteKit 1.x](migrating-to-sveltekit-2#Top-level-promises-are-no-longer-awaited) top-level promises were automatically awaited, only nested promises were streamed.

Parallel loading[](#Parallel-loading)
-------------------------------------

When rendering (or navigating to) a page, SvelteKit runs all `load` functions concurrently, avoiding a waterfall of requests. During client-side navigation, the result of calling multiple server `load` functions are grouped into a single response. Once all `load` functions have returned, the page is rendered.

Rerunning load functions[](#Rerunning-load-functions)
-----------------------------------------------------

SvelteKit tracks the dependencies of each `load` function to avoid rerunning it unnecessarily during navigation.

For example, given a pair of `load` functions like these...

src/routes/blog/\[slug\]/+page.server

    import * as module "$lib/server/database"db from '$lib/server/database';
    
    /** @type {import('./$types').PageServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageServerLoad}load({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) {
    	return {
    		post: {
        title: string;
        content: string;
    }post: await module "$lib/server/database"db.function getPost(slug: string): Promise<{
        title: string;
        content: string;
    }>getPost(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug)
    	};
    }

    import * as module "$lib/server/database"db from '$lib/server/database';
    import type { type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = async ({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) => {
    	return {
    		post: {
        title: string;
        content: string;
    }post: await module "$lib/server/database"db.function getPost(slug: string): Promise<{
        title: string;
        content: string;
    }>getPost(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug)
    	};
    };

src/routes/blog/\[slug\]/+layout.server

    import * as module "$lib/server/database"db from '$lib/server/database';
    
    /** @type {import('./$types').LayoutServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').LayoutServerLoad}load() {
    	return {
    		posts: {
        title: string;
        slug: string;
    }[]posts: await module "$lib/server/database"db.function getPostSummaries(): Promise<Array<{
        title: string;
        slug: string;
    }>>getPostSummaries()
    	};
    }

    import * as module "$lib/server/database"db from '$lib/server/database';
    import type { type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad } from './$types';
    
    export const const load: LayoutServerLoadload: type LayoutServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad = async () => {
    	return {
    		posts: {
        title: string;
        slug: string;
    }[]posts: await module "$lib/server/database"db.function getPostSummaries(): Promise<Array<{
        title: string;
        slug: string;
    }>>getPostSummaries()
    	};
    };

...the one in `+page.server.js` will rerun if we navigate from `/blog/trying-the-raw-meat-diet` to `/blog/i-regret-my-choices` because `params.slug` has changed. The one in `+layout.server.js` will not, because the data is still valid. In other words, we won’t call `db.getPostSummaries()` a second time.

A `load` function that calls `await parent()` will also rerun if a parent `load` function is rerun.

Dependency tracking does not apply _after_ the `load` function has returned — for example, accessing `params.x` inside a nested [promise](#Streaming-with-promises) will not cause the function to rerun when `params.x` changes. (Don’t worry, you’ll get a warning in development if you accidentally do this.) Instead, access the parameter in the main body of your `load` function.

Search parameters are tracked independently from the rest of the url. For example, accessing `event.url.searchParams.get("x")` inside a `load` function will make that `load` function re-run when navigating from `?x=1` to `?x=2`, but not when navigating from `?x=1&y=1` to `?x=1&y=2`.

### Untracking dependencies[](#Rerunning-load-functions-Untracking-dependencies)

In rare cases, you may wish to exclude something from the dependency tracking mechanism. You can do this with the provided `untrack` function:

src/routes/+page

    /** @type {import('./$types').PageLoad} */
    export async function function load({ untrack, url }: {
        untrack: any;
        url: any;
    }): Promise<{
        message: string;
    } | undefined>@type{import('./$types').PageLoad}load({ untrack: anyuntrack, url: anyurl }) {
    	// Untrack url.pathname so that path changes don't trigger a rerun
    	if (untrack: anyuntrack(() => url: anyurl.pathname === '/')) {
    		return { message: stringmessage: 'Welcome!' };
    	}
    }

    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ untrack: <T>(fn: () => T) => TUse this function to opt out of dependency tracking for everything that is synchronously called within the callback. Example:
    src/routes/+page.serverexport async function load({ untrack, url }) {
    	// Untrack url.pathname so that path changes don't trigger a rerun
    	if (untrack(() => url.pathname === '/')) {
    		return { message: 'Welcome!' };
    	}
    }untrack, url: URLThe URL of the current page
    url }) => {
    	// Untrack url.pathname so that path changes don't trigger a rerun
    	if (untrack: <boolean>(fn: () => boolean) => booleanUse this function to opt out of dependency tracking for everything that is synchronously called within the callback. Example:
    src/routes/+page.serverexport async function load({ untrack, url }) {
    	// Untrack url.pathname so that path changes don't trigger a rerun
    	if (untrack(() => url.pathname === '/')) {
    		return { message: 'Welcome!' };
    	}
    }untrack(() => url: URLThe URL of the current page
    url.URL.pathname: stringMDN Reference
    pathname === '/')) {
    		return { message: stringmessage: 'Welcome!' };
    	}
    };

### Manual invalidation[](#Rerunning-load-functions-Manual-invalidation)

You can also rerun `load` functions that apply to the current page using [`invalidate(url)`]($app-navigation#invalidate), which reruns all `load` functions that depend on `url`, and [`invalidateAll()`]($app-navigation#invalidateAll), which reruns every `load` function. Server load functions will never automatically depend on a fetched `url` to avoid leaking secrets to the client.

A `load` function depends on `url` if it calls `fetch(url)` or `depends(url)`. Note that `url` can be a custom identifier that starts with `[a-z]:`:

src/routes/random-number/+page

    /** @type {import('./$types').PageLoad} */
    export async function function load({ fetch, depends }: {
        fetch: any;
        depends: any;
    }): Promise<{
        number: any;
    }>@type{import('./$types').PageLoad}load({ fetch: anyfetch, depends: anydepends }) {
    	// load reruns when `invalidate('https://api.example.com/random-number')` is called...
    	const const response: anyresponse = await fetch: anyfetch('https://api.example.com/random-number');
    
    	// ...or when `invalidate('app:random')` is called
    	depends: anydepends('app:random');
    
    	return {
    		number: anynumber: await const response: anyresponse.json()
    	};
    }

    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here
    fetch, depends: (...deps: Array<`${string}:${string}`>) => voidThis function declares that the load function has a dependency on one or more URLs or custom identifiers, which can subsequently be used with invalidate() to cause load to rerun.
    Most of the time you won’t need this, as fetch calls depends on your behalf — it’s only necessary if you’re using a custom API client that bypasses fetch.
    URLs can be absolute or relative to the page being loaded, and must be encoded.
    Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the URI specification.
    The following example shows how to use depends to register a dependency on a custom identifier, which is invalidated after a button click, making the load function rerun.
    src/routes/+pagelet count = 0;
    export async function load({ depends }) {
    	depends('increase:count');
    
    	return { count: count++ };
    }src/routes/+page&#x3C;script>
    	import { invalidate } from '$app/navigation';
    
    	let { data } = $props();
    
    	const increase = async () => {
    		await invalidate('increase:count');
    	}
    &#x3C;/script>
    
    &#x3C;p>{data.count}&#x3C;p>
    &#x3C;button on:click={increase}>Increase Count&#x3C;/button>depends }) => {
    	// load reruns when `invalidate('https://api.example.com/random-number')` is called...
    	const const response: Responseresponse = await fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch('https://api.example.com/random-number');
    
    	// ...or when `invalidate('app:random')` is called
    	depends: (...deps: Array<`${string}:${string}`>) => voidThis function declares that the load function has a dependency on one or more URLs or custom identifiers, which can subsequently be used with invalidate() to cause load to rerun.
    Most of the time you won’t need this, as fetch calls depends on your behalf — it’s only necessary if you’re using a custom API client that bypasses fetch.
    URLs can be absolute or relative to the page being loaded, and must be encoded.
    Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the URI specification.
    The following example shows how to use depends to register a dependency on a custom identifier, which is invalidated after a button click, making the load function rerun.
    src/routes/+pagelet count = 0;
    export async function load({ depends }) {
    	depends('increase:count');
    
    	return { count: count++ };
    }src/routes/+page&#x3C;script>
    	import { invalidate } from '$app/navigation';
    
    	let { data } = $props();
    
    	const increase = async () => {
    		await invalidate('increase:count');
    	}
    &#x3C;/script>
    
    &#x3C;p>{data.count}&#x3C;p>
    &#x3C;button on:click={increase}>Increase Count&#x3C;/button>depends('app:random');
    
    	return {
    		number: anynumber: await const response: Responseresponse.Body.json(): Promise<any>MDN Reference
    json()
    	};
    };

src/routes/random-number/+page

    <script>
    	import { invalidate, invalidateAll } from '$app/navigation';
    
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    
    	function rerunLoadFunction() {
    		// any of these will cause the `load` function to rerun
    		invalidate('app:random');
    		invalidate('https://api.example.com/random-number');
    		invalidate(url => url.href.includes('random-number'));
    		invalidateAll();
    	}
    </script>
    
    <p>random number: {data.number}</p>
    <button onclick={rerunLoadFunction}>Update random number</button>

    <script lang="ts">
    	import { invalidate, invalidateAll } from '$app/navigation';
    	import type { PageProps } from './$types';
    	let { data }: PageProps = $props();
    
    	function rerunLoadFunction() {
    		// any of these will cause the `load` function to rerun
    		invalidate('app:random');
    		invalidate('https://api.example.com/random-number');
    		invalidate(url => url.href.includes('random-number'));
    		invalidateAll();
    	}
    </script>
    
    <p>random number: {data.number}</p>
    <button onclick={rerunLoadFunction}>Update random number</button>

### When do load functions rerun?[](#Rerunning-load-functions-When-do-load-functions-rerun)

To summarize, a `load` function will rerun in the following situations:

*   It references a property of `params` whose value has changed
*   It references a property of `url` (such as `url.pathname` or `url.search`) whose value has changed. Properties in `request.url` are _not_ tracked
*   It calls `url.searchParams.get(...)`, `url.searchParams.getAll(...)` or `url.searchParams.has(...)` and the parameter in question changes. Accessing other properties of `url.searchParams` will have the same effect as accessing `url.search`.
*   It calls `await parent()` and a parent `load` function reran
*   A child `load` function calls `await parent()` and is rerunning, and the parent is a server load function
*   It declared a dependency on a specific URL via [`fetch`](#Making-fetch-requests) (universal load only) or [`depends`](@sveltejs-kit#LoadEvent), and that URL was marked invalid with [`invalidate(url)`]($app-navigation#invalidate)
*   All active `load` functions were forcibly rerun with [`invalidateAll()`]($app-navigation#invalidateAll)

`params` and `url` can change in response to a `<a href="..">` link click, a [`<form>` interaction](form-actions#GET-vs-POST), a [`goto`]($app-navigation#goto) invocation, or a [`redirect`](@sveltejs-kit#redirect).

Note that rerunning a `load` function will update the `data` prop inside the corresponding `+layout.svelte` or `+page.svelte`; it does _not_ cause the component to be recreated. As a result, internal state is preserved. If this isn’t what you want, you can reset whatever you need to reset inside an [`afterNavigate`]($app-navigation#afterNavigate) callback, and/or wrap your component in a [`{#key ...}`](../svelte/key) block.

Implications for authentication[](#Implications-for-authentication)
-------------------------------------------------------------------

A couple features of loading data have important implications for auth checks:

*   Layout `load` functions do not run on every request, such as during client side navigation between child routes. [(When do load functions rerun?)](load#Rerunning-load-functions-When-do-load-functions-rerun)
*   Layout and page `load` functions run concurrently unless `await parent()` is called. If a layout `load` throws, the page `load` function runs, but the client will not receive the returned data.

There are a few possible strategies to ensure an auth check occurs before protected code.

To prevent data waterfalls and preserve layout `load` caches:

*   Use [hooks](hooks) to protect multiple routes before any `load` functions run
*   Use auth guards directly in `+page.server.js` `load` functions for route specific protection

Putting an auth guard in `+layout.server.js` requires all child pages to call `await parent()` before protected code. Unless every child page depends on returned data from `await parent()`, the other options will be more performant.

Using getRequestEvent[](#Using-getRequestEvent)
-----------------------------------------------

When running server `load` functions, the `event` object passed to the function as an argument can also be retrieved with [`getRequestEvent`]($app-server#getRequestEvent). This allows shared logic (such as authentication guards) to access information about the current request without it needing to be passed around.

For example, you might have a function that requires users to be logged in, and redirects them to `/login` if not:

src/lib/server/auth

    import { function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect } from '@sveltejs/kit';
    import { function getRequestEvent(): RequestEvent<Partial<Record<string, string>>, string | null>Returns the current RequestEvent. Can be used inside handle, load and actions (and functions called by them).
    In environments without AsyncLocalStorage, this must be called synchronously (i.e. not after an await).
    @since2.20.0getRequestEvent } from '$app/server';
    
    export function function requireLogin(): UserrequireLogin() {
    	const { const locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals, const url: URLThe requested URL.
    url } = function getRequestEvent(): RequestEvent<Partial<Record<string, string>>, string | null>Returns the current RequestEvent. Can be used inside handle, load and actions (and functions called by them).
    In environments without AsyncLocalStorage, this must be called synchronously (i.e. not after an await).
    @since2.20.0getRequestEvent();
    
    	// assume `locals.user` is populated in `handle`
    	if (!const locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user?: User | undefineduser) {
    		const const redirectTo: stringredirectTo = const url: URLThe requested URL.
    url.URL.pathname: stringMDN Reference
    pathname + const url: URLThe requested URL.
    url.URL.search: stringMDN Reference
    search;
    		const const params: URLSearchParamsparams = new var URLSearchParams: new (init?: string[][] | Record<string, string> | string | URLSearchParams) => URLSearchParamsMDN Reference
    URLSearchParams class is a global reference for require('url').URLSearchParams
    https://nodejs.org/api/url.html#class-urlsearchparams
    @sincev10.0.0URLSearchParams({ redirectTo: stringredirectTo });
    
    		function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect(307, `/login?${const params: URLSearchParamsparams}`);
    	}
    
    	return const locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user?: Useruser;
    }

Now, you can call `requireLogin` in any `load` function (or [form action](form-actions), for example) to guarantee that the user is logged in:

+page.server

    import { function requireLogin(): UserrequireLogin } from '$lib/server/auth';
    
    export function function load(): {
        message: string;
    }load() {
    	const const user: Useruser = function requireLogin(): UserrequireLogin();
    
    	// `user` is guaranteed to be a user object here, because otherwise
    	// `requireLogin` would throw a redirect and we wouldn't get here
    	return {
    		message: stringmessage: `hello ${const user: Useruser.User.name: stringname}!`
    	};
    }

Further reading[](#Further-reading)
-----------------------------------

*   [Tutorial: Loading data](/tutorial/kit/page-data)
*   [Tutorial: Errors and redirects](/tutorial/kit/error-basics)
*   [Tutorial: Advanced loading](/tutorial/kit/await-parent)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/20-core-concepts/20-load.md) [llms.txt](/docs/kit/load/llms.txt)

previous next

[Routing](/docs/kit/routing) [Form actions](/docs/kit/form-actions)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitCore concepts

Form actions
============

### On this page

*   [Form actions](/docs/kit/form-actions)
*   [Default actions](#Default-actions)
*   [Named actions](#Named-actions)
*   [Anatomy of an action](#Anatomy-of-an-action)
*   [Loading data](#Loading-data)
*   [Progressive enhancement](#Progressive-enhancement)
*   [Alternatives](#Alternatives)
*   [GET vs POST](#GET-vs-POST)
*   [Further reading](#Further-reading)

A `+page.server.js` file can export _actions_, which allow you to `POST` data to the server using the `<form>` element.

When using `<form>`, client-side JavaScript is optional, but you can easily _progressively enhance_ your form interactions with JavaScript to provide the best user experience.

Default actions[](#Default-actions)
-----------------------------------

In the simplest case, a page declares a `default` action:

src/routes/login/+page.server

    /** @satisfies {import('./$types').Actions} */
    export const const actions: {
        default: (event: any) => Promise<void>;
    }@satisfies{import('./$types').Actions}actions = {
    	default: (event: any) => Promise<void>default: async (event: anyevent) => {
    		// TODO log the user in
    	}
    };

    import type { type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }
    type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions } from './$types';
    
    export const const actions: {
        default: (event: Kit.RequestEvent<Record<string, any>, string | null>) => Promise<void>;
    }actions = {
    	default: (event: Kit.RequestEvent<Record<string, any>, string | null>) => Promise<void>default: async (event: Kit.RequestEvent<Record<string, any>, string | null>event) => {
    		// TODO log the user in
    	}
    } satisfies type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }
    type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions;

To invoke this action from the `/login` page, just add a `<form>` — no JavaScript needed:

src/routes/login/+page

    <form method="POST">
    	<label>
    		Email
    		<input name="email" type="email">
    	</label>
    	<label>
    		Password
    		<input name="password" type="password">
    	</label>
    	<button>Log in</button>
    </form>

If someone were to click the button, the browser would send the form data via `POST` request to the server, running the default action.

> Actions always use `POST` requests, since `GET` requests should never have side-effects.

We can also invoke the action from other pages (for example if there’s a login widget in the nav in the root layout) by adding the `action` attribute, pointing to the page:

src/routes/+layout

    <form method="POST" action="/login">
    	<!-- content -->
    </form>

Named actions[](#Named-actions)
-------------------------------

Instead of one `default` action, a page can have as many named actions as it needs:

src/routes/login/+page.server

    /** @satisfies {import('./$types').Actions} */
    export const const actions: {
        login: (event: any) => Promise<void>;
        register: (event: any) => Promise<void>;
    }@satisfies{import('./$types').Actions}actions = {
    	default: async (event) => {
    	login: (event: any) => Promise<void>login: async (event: anyevent) => {
    		// TODO log the user in
    	},
    	register: (event: any) => Promise<void>register: async (event: anyevent) => {
    		// TODO register the user
    	}
    };

    import type { type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }
    type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions } from './$types';
    
    export const const actions: {
        login: (event: Kit.RequestEvent<Record<string, any>, string | null>) => Promise<void>;
        register: (event: Kit.RequestEvent<Record<string, any>, string | null>) => Promise<...>;
    }actions = {
    	default: async (event) => {
    	login: (event: Kit.RequestEvent<Record<string, any>, string | null>) => Promise<void>login: async (event: Kit.RequestEvent<Record<string, any>, string | null>event) => {
    		// TODO log the user in
    	},
    	register: (event: Kit.RequestEvent<Record<string, any>, string | null>) => Promise<void>register: async (event: Kit.RequestEvent<Record<string, any>, string | null>event) => {
    		// TODO register the user
    	}
    } satisfies type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }
    type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions;

To invoke a named action, add a query parameter with the name prefixed by a `/` character:

src/routes/login/+page

    <form method="POST" action="?/register">

src/routes/+layout

    <form method="POST" action="/login?/register">

As well as the `action` attribute, we can use the `formaction` attribute on a button to `POST` the same form data to a different action than the parent `<form>`:

src/routes/login/+page

    <form method="POST" action="?/login">
    	<label>
    		Email
    		<input name="email" type="email">
    	</label>
    	<label>
    		Password
    		<input name="password" type="password">
    	</label>
    	<button>Log in</button>
    	<button formaction="?/register">Register</button>
    </form>

> We can’t have default actions next to named actions, because if you POST to a named action without a redirect, the query parameter is persisted in the URL, which means the next default POST would go through the named action from before.

Anatomy of an action[](#Anatomy-of-an-action)
---------------------------------------------

Each action receives a `RequestEvent` object, allowing you to read the data with `request.formData()`. After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the `form` property on the corresponding page and through `page.form` app-wide until the next update.

src/routes/login/+page.server

    import * as module "$lib/server/db"db from '$lib/server/db';
    
    /** @type {import('./$types').PageServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageServerLoad}load({ cookies: CookiesGet or set cookies related to the current request
    cookies }) {
    	const const user: anyuser = await module "$lib/server/db"db.getUserFromSession(cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.get: (name: string, opts?: CookieParseOptions) => string | undefinedGets a cookie that was previously set with cookies.set, or from the request headers.
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.parse. See documentation hereget('sessionid'));
    	return { user: anyuser };
    }
    
    /** @satisfies {import('./$types').Actions} */
    export const const actions: {
        login: ({ cookies, request }: RequestEvent<Record<string, any>, string | null>) => Promise<{
            success: boolean;
        }>;
        register: (event: RequestEvent<Record<string, any>, string | null>) => Promise<...>;
    }@satisfies{import('./$types').Actions}actions = {
    	login: ({ cookies, request }: RequestEvent<Record<string, any>, string | null>) => Promise<{
        success: boolean;
    }>login: async ({ cookies: CookiesGet or set cookies related to the current request
    cookies, request: RequestThe original request object.
    request }) => {
    		const const data: FormDatadata = await request: RequestThe original request object.
    request.Body.formData(): Promise<FormData>MDN Reference
    formData();
    		const const email: FormDataEntryValue | nullemail = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('email');
    		const const password: FormDataEntryValue | nullpassword = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('password');
    
    		const const user: anyuser = await module "$lib/server/db"db.getUser(const email: FormDataEntryValue | nullemail);
    		cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.set: (name: string, value: string, opts: CookieSerializeOptions & {
        path: string;
    }) => voidSets a cookie. This will add a set-cookie header to the response, but also make the cookie available via cookies.get or cookies.getAll during the current request.
    The httpOnly and secure options are true by default (except on http://localhost, where secure is false), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The sameSite option defaults to lax.
    You must specify a path for the cookie. In most cases you should explicitly set path: '/' to make the cookie available throughout your app. You can use relative paths, or set path: '' to make the cookie only available on the current path and its children
    @paramname the name of the cookie@paramvalue the cookie value@paramopts the options, passed directly to cookie.serialize. See documentation hereset('sessionid', await module "$lib/server/db"db.createSession(const user: anyuser), { path: stringSpecifies the value for the 
    {@link 
    https://tools.ietf.org/html/rfc6265#section-5.2.4 Path Set-Cookie attribute
    }
    .
    By default, the path is considered the “default path”.
    path: '/' });
    
    		return { success: booleansuccess: true };
    	},
    	register: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>register: async (event: RequestEvent<Record<string, any>, string | null>event) => {
    		// TODO register the user
    	}
    };

    import * as module "$lib/server/db"db from '$lib/server/db';
    import type { type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad, type Actions = {
        [x: string]: Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = async ({ cookies: CookiesGet or set cookies related to the current request
    cookies }) => {
    	const const user: anyuser = await module "$lib/server/db"db.getUserFromSession(cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.get: (name: string, opts?: CookieParseOptions) => string | undefinedGets a cookie that was previously set with cookies.set, or from the request headers.
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.parse. See documentation hereget('sessionid'));
    	return { user: anyuser };
    };
    
    export const const actions: {
        login: ({ cookies, request }: RequestEvent<Record<string, any>, string | null>) => Promise<{
            success: boolean;
        }>;
        register: (event: RequestEvent<Record<string, any>, string | null>) => Promise<...>;
    }actions = {
    	login: ({ cookies, request }: RequestEvent<Record<string, any>, string | null>) => Promise<{
        success: boolean;
    }>login: async ({ cookies: CookiesGet or set cookies related to the current request
    cookies, request: RequestThe original request object.
    request }) => {
    		const const data: FormDatadata = await request: RequestThe original request object.
    request.Body.formData(): Promise<FormData>MDN Reference
    formData();
    		const const email: FormDataEntryValue | nullemail = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('email');
    		const const password: FormDataEntryValue | nullpassword = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('password');
    
    		const const user: anyuser = await module "$lib/server/db"db.getUser(const email: FormDataEntryValue | nullemail);
    		cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.set: (name: string, value: string, opts: CookieSerializeOptions & {
        path: string;
    }) => voidSets a cookie. This will add a set-cookie header to the response, but also make the cookie available via cookies.get or cookies.getAll during the current request.
    The httpOnly and secure options are true by default (except on http://localhost, where secure is false), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The sameSite option defaults to lax.
    You must specify a path for the cookie. In most cases you should explicitly set path: '/' to make the cookie available throughout your app. You can use relative paths, or set path: '' to make the cookie only available on the current path and its children
    @paramname the name of the cookie@paramvalue the cookie value@paramopts the options, passed directly to cookie.serialize. See documentation hereset('sessionid', await module "$lib/server/db"db.createSession(const user: anyuser), { path: stringSpecifies the value for the 
    {@link 
    https://tools.ietf.org/html/rfc6265#section-5.2.4 Path Set-Cookie attribute
    }
    .
    By default, the path is considered the “default path”.
    path: '/' });
    
    		return { success: booleansuccess: true };
    	},
    	register: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>register: async (event: RequestEvent<Record<string, any>, string | null>event) => {
    		// TODO register the user
    	}
    } satisfies type Actions = {
        [x: string]: Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions;

src/routes/login/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data, form } = $props();
    </script>
    
    {#if form?.success}
    	<!-- this message is ephemeral; it exists because the page was rendered in
    	       response to a form submission. it will vanish if the user reloads -->
    	<p>Successfully logged in! Welcome back, {data.user.name}</p>
    {/if}

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data, form }: PageProps = $props();
    </script>
    
    {#if form?.success}
    	<!-- this message is ephemeral; it exists because the page was rendered in
    	       response to a form submission. it will vanish if the user reloads -->
    	<p>Successfully logged in! Welcome back, {data.user.name}</p>
    {/if}

> Legacy mode
> 
> `PageProps` was added in 2.16.0. In earlier versions, you had to type the `data` and `form` properties individually:
> 
> +page
> 
>     /** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */
>     let { let data: anydata, let form: anyform } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();
> 
>     import type { import PageDataPageData, import ActionDataActionData } from './$types';
>     
>     let { let data: PageDatadata, let form: ActionDataform }: { data: PageDatadata: import PageDataPageData, form: ActionDataform: import ActionDataActionData } = function $props(): any
>     namespace $propsDeclares the props that a component accepts. Example:
>     let { optionalProp = 42, requiredProp, bindableProp = $bindable() }: { optionalProp?: number; requiredProps: string; bindableProp: boolean } = $props();https://svelte.dev/docs/svelte/$props
>     $props();
> 
> In Svelte 4, you’d use `export let data` and `export let form` instead to declare properties.

### Validation errors[](#Anatomy-of-an-action-Validation-errors)

If the request couldn’t be processed because of invalid data, you can return validation errors — along with the previously submitted form values — back to the user so that they can try again. The `fail` function lets you return an HTTP status code (typically 400 or 422, in the case of validation errors) along with the data. The status code is available through `page.status` and the data through `form`:

src/routes/login/+page.server

    import { function fail(status: number): ActionFailure<undefined> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.fail } from '@sveltejs/kit';
    import * as module "$lib/server/db"db from '$lib/server/db';
    
    /** @satisfies {import('./$types').Actions} */
    export const const actions: {
        login: ({ cookies, request }: RequestEvent<Record<string, any>, string | null>) => Promise<ActionFailure<{
            email: string | null;
            missing: boolean;
        }> | ActionFailure<{
            ...;
        }> | {
            ...;
        }>;
        register: (event: RequestEvent<...>) => Promise<...>;
    }@satisfies{import('./$types').Actions}actions = {
    	login: ({ cookies, request }: RequestEvent<Record<string, any>, string | null>) => Promise<ActionFailure<{
        email: string | null;
        missing: boolean;
    }> | ActionFailure<{
        email: FormDataEntryValue;
        incorrect: boolean;
    }> | {
        ...;
    }>login: async ({ cookies: CookiesGet or set cookies related to the current request
    cookies, request: RequestThe original request object.
    request }) => {
    		const const data: FormDatadata = await request: RequestThe original request object.
    request.Body.formData(): Promise<FormData>MDN Reference
    formData();
    		const const email: FormDataEntryValue | nullemail = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('email');
    		const const password: FormDataEntryValue | nullpassword = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('password');
    
    		if (!const email: FormDataEntryValue | nullemail) {
    			return fail<{
        email: string | null;
        missing: boolean;
    }>(status: number, data: {
        email: string | null;
        missing: boolean;
    }): ActionFailure<{
        email: string | null;
        missing: boolean;
    }> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.@paramdata Data associated with the failure (e.g. validation errors)fail(400, { email: string | nullemail, missing: booleanmissing: true });
    		}
    
    		const const user: anyuser = await module "$lib/server/db"db.getUser(const email: FormDataEntryValueemail);
    
    		if (!const user: anyuser || const user: anyuser.password !== module "$lib/server/db"db.hash(const password: FormDataEntryValue | nullpassword)) {
    			return fail<{
        email: FormDataEntryValue;
        incorrect: boolean;
    }>(status: number, data: {
        email: FormDataEntryValue;
        incorrect: boolean;
    }): ActionFailure<{
        email: FormDataEntryValue;
        incorrect: boolean;
    }> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.@paramdata Data associated with the failure (e.g. validation errors)fail(400, { email: FormDataEntryValueemail, incorrect: booleanincorrect: true });
    		}
    
    		cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.set: (name: string, value: string, opts: CookieSerializeOptions & {
        path: string;
    }) => voidSets a cookie. This will add a set-cookie header to the response, but also make the cookie available via cookies.get or cookies.getAll during the current request.
    The httpOnly and secure options are true by default (except on http://localhost, where secure is false), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The sameSite option defaults to lax.
    You must specify a path for the cookie. In most cases you should explicitly set path: '/' to make the cookie available throughout your app. You can use relative paths, or set path: '' to make the cookie only available on the current path and its children
    @paramname the name of the cookie@paramvalue the cookie value@paramopts the options, passed directly to cookie.serialize. See documentation hereset('sessionid', await module "$lib/server/db"db.createSession(const user: anyuser), { path: stringSpecifies the value for the 
    {@link 
    https://tools.ietf.org/html/rfc6265#section-5.2.4 Path Set-Cookie attribute
    }
    .
    By default, the path is considered the “default path”.
    path: '/' });
    
    		return { success: booleansuccess: true };
    	},
    	register: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>register: async (event: RequestEvent<Record<string, any>, string | null>event) => {
    		// TODO register the user
    	}
    };

    import { function fail(status: number): ActionFailure<undefined> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.fail } from '@sveltejs/kit';
    import * as module "$lib/server/db"db from '$lib/server/db';
    import type { type Actions = {
        [x: string]: Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions } from './$types';
    
    export const const actions: {
        login: ({ cookies, request }: RequestEvent<Record<string, any>, string | null>) => Promise<ActionFailure<{
            email: string | null;
            missing: boolean;
        }> | ActionFailure<{
            ...;
        }> | {
            ...;
        }>;
        register: (event: RequestEvent<...>) => Promise<...>;
    }actions = {
    	login: ({ cookies, request }: RequestEvent<Record<string, any>, string | null>) => Promise<ActionFailure<{
        email: string | null;
        missing: boolean;
    }> | ActionFailure<{
        email: FormDataEntryValue;
        incorrect: boolean;
    }> | {
        ...;
    }>login: async ({ cookies: CookiesGet or set cookies related to the current request
    cookies, request: RequestThe original request object.
    request }) => {
    		const const data: FormDatadata = await request: RequestThe original request object.
    request.Body.formData(): Promise<FormData>MDN Reference
    formData();
    		const const email: FormDataEntryValue | nullemail = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('email');
    		const const password: FormDataEntryValue | nullpassword = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('password');
    
    		if (!const email: FormDataEntryValue | nullemail) {
    			return fail<{
        email: string | null;
        missing: boolean;
    }>(status: number, data: {
        email: string | null;
        missing: boolean;
    }): ActionFailure<{
        email: string | null;
        missing: boolean;
    }> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.@paramdata Data associated with the failure (e.g. validation errors)fail(400, { email: string | nullemail, missing: booleanmissing: true });
    		}
    
    		const const user: anyuser = await module "$lib/server/db"db.getUser(const email: FormDataEntryValueemail);
    
    		if (!const user: anyuser || const user: anyuser.password !== module "$lib/server/db"db.hash(const password: FormDataEntryValue | nullpassword)) {
    			return fail<{
        email: FormDataEntryValue;
        incorrect: boolean;
    }>(status: number, data: {
        email: FormDataEntryValue;
        incorrect: boolean;
    }): ActionFailure<{
        email: FormDataEntryValue;
        incorrect: boolean;
    }> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.@paramdata Data associated with the failure (e.g. validation errors)fail(400, { email: FormDataEntryValueemail, incorrect: booleanincorrect: true });
    		}
    
    		cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.set: (name: string, value: string, opts: CookieSerializeOptions & {
        path: string;
    }) => voidSets a cookie. This will add a set-cookie header to the response, but also make the cookie available via cookies.get or cookies.getAll during the current request.
    The httpOnly and secure options are true by default (except on http://localhost, where secure is false), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The sameSite option defaults to lax.
    You must specify a path for the cookie. In most cases you should explicitly set path: '/' to make the cookie available throughout your app. You can use relative paths, or set path: '' to make the cookie only available on the current path and its children
    @paramname the name of the cookie@paramvalue the cookie value@paramopts the options, passed directly to cookie.serialize. See documentation hereset('sessionid', await module "$lib/server/db"db.createSession(const user: anyuser), { path: stringSpecifies the value for the 
    {@link 
    https://tools.ietf.org/html/rfc6265#section-5.2.4 Path Set-Cookie attribute
    }
    .
    By default, the path is considered the “default path”.
    path: '/' });
    
    		return { success: booleansuccess: true };
    	},
    	register: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>register: async (event: RequestEvent<Record<string, any>, string | null>event) => {
    		// TODO register the user
    	}
    } satisfies type Actions = {
        [x: string]: Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions;

> Note that as a precaution, we only return the email back to the page — not the password.

src/routes/login/+page

    <form method="POST" action="?/login">
    	{#if form?.missing}<p class="error">The email field is required</p>{/if}
    	{#if form?.incorrect}<p class="error">Invalid credentials!</p>{/if}
    	<label>
    		Email
    		<input name="email" type="email" value={form?.email ?? ''}>
    	</label>
    	<label>
    		Password
    		<input name="password" type="password">
    	</label>
    	<button>Log in</button>
    	<button formaction="?/register">Register</button>
    </form>

The returned data must be serializable as JSON. Beyond that, the structure is entirely up to you. For example, if you had multiple forms on the page, you could distinguish which `<form>` the returned `form` data referred to with an `id` property or similar.

### Redirects[](#Anatomy-of-an-action-Redirects)

Redirects (and errors) work exactly the same as in [`load`](load#Redirects):

src/routes/login/+page.server

    import { function fail(status: number): ActionFailure<undefined> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.fail, function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect } from '@sveltejs/kit';
    import * as module "$lib/server/db"db from '$lib/server/db';
    
    /** @satisfies {import('./$types').Actions} */
    export const const actions: {
        login: ({ cookies, request, url }: RequestEvent<Record<string, any>, string | null>) => Promise<ActionFailure<{
            email: FormDataEntryValue | null;
            missing: boolean;
        }> | ActionFailure<...> | {
            ...;
        }>;
        register: (event: RequestEvent<...>) => Promise<...>;
    }@satisfies{import('./$types').Actions}actions = {
    	login: ({ cookies, request, url }: RequestEvent<Record<string, any>, string | null>) => Promise<ActionFailure<{
        email: FormDataEntryValue | null;
        missing: boolean;
    }> | ActionFailure<...> | {
        ...;
    }>login: async ({ cookies: CookiesGet or set cookies related to the current request
    cookies, request: RequestThe original request object.
    request, url: URLThe requested URL.
    url }) => {
    		const const data: FormDatadata = await request: RequestThe original request object.
    request.Body.formData(): Promise<FormData>MDN Reference
    formData();
    		const const email: FormDataEntryValue | nullemail = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('email');
    		const const password: FormDataEntryValue | nullpassword = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('password');
    
    		const const user: anyuser = await module "$lib/server/db"db.getUser(const email: FormDataEntryValue | nullemail);
    		if (!const user: anyuser) {
    			return fail<{
        email: FormDataEntryValue | null;
        missing: boolean;
    }>(status: number, data: {
        email: FormDataEntryValue | null;
        missing: boolean;
    }): ActionFailure<...> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.@paramdata Data associated with the failure (e.g. validation errors)fail(400, { email: FormDataEntryValue | nullemail, missing: booleanmissing: true });
    		}
    
    		if (const user: anyuser.password !== module "$lib/server/db"db.hash(const password: FormDataEntryValue | nullpassword)) {
    			return fail<{
        email: FormDataEntryValue | null;
        incorrect: boolean;
    }>(status: number, data: {
        email: FormDataEntryValue | null;
        incorrect: boolean;
    }): ActionFailure<...> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.@paramdata Data associated with the failure (e.g. validation errors)fail(400, { email: FormDataEntryValue | nullemail, incorrect: booleanincorrect: true });
    		}
    
    		cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.set: (name: string, value: string, opts: CookieSerializeOptions & {
        path: string;
    }) => voidSets a cookie. This will add a set-cookie header to the response, but also make the cookie available via cookies.get or cookies.getAll during the current request.
    The httpOnly and secure options are true by default (except on http://localhost, where secure is false), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The sameSite option defaults to lax.
    You must specify a path for the cookie. In most cases you should explicitly set path: '/' to make the cookie available throughout your app. You can use relative paths, or set path: '' to make the cookie only available on the current path and its children
    @paramname the name of the cookie@paramvalue the cookie value@paramopts the options, passed directly to cookie.serialize. See documentation hereset('sessionid', await module "$lib/server/db"db.createSession(const user: anyuser), { path: stringSpecifies the value for the 
    {@link 
    https://tools.ietf.org/html/rfc6265#section-5.2.4 Path Set-Cookie attribute
    }
    .
    By default, the path is considered the “default path”.
    path: '/' });
    
    		if (url: URLThe requested URL.
    url.URL.searchParams: URLSearchParamsMDN Reference
    searchParams.URLSearchParams.has(name: string, value?: string): booleanReturns a Boolean indicating if such a search parameter exists.
    MDN Reference
    has('redirectTo')) {
    			function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect(303, url.searchParams.get('redirectTo'));
    		}
    
    		return { success: booleansuccess: true };
    	},
    	register: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>register: async (event: RequestEvent<Record<string, any>, string | null>event) => {
    		// TODO register the user
    	}
    };

    import { function fail(status: number): ActionFailure<undefined> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.fail, function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect } from '@sveltejs/kit';
    import * as module "$lib/server/db"db from '$lib/server/db';
    import type { type Actions = {
        [x: string]: Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions } from './$types';
    
    export const const actions: {
        login: ({ cookies, request, url }: RequestEvent<Record<string, any>, string | null>) => Promise<ActionFailure<{
            email: FormDataEntryValue | null;
            missing: boolean;
        }> | ActionFailure<...> | {
            ...;
        }>;
        register: (event: RequestEvent<...>) => Promise<...>;
    }actions = {
    	login: ({ cookies, request, url }: RequestEvent<Record<string, any>, string | null>) => Promise<ActionFailure<{
        email: FormDataEntryValue | null;
        missing: boolean;
    }> | ActionFailure<...> | {
        ...;
    }>login: async ({ cookies: CookiesGet or set cookies related to the current request
    cookies, request: RequestThe original request object.
    request, url: URLThe requested URL.
    url }) => {
    		const const data: FormDatadata = await request: RequestThe original request object.
    request.Body.formData(): Promise<FormData>MDN Reference
    formData();
    		const const email: FormDataEntryValue | nullemail = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('email');
    		const const password: FormDataEntryValue | nullpassword = const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('password');
    
    		const const user: anyuser = await module "$lib/server/db"db.getUser(const email: FormDataEntryValue | nullemail);
    		if (!const user: anyuser) {
    			return fail<{
        email: FormDataEntryValue | null;
        missing: boolean;
    }>(status: number, data: {
        email: FormDataEntryValue | null;
        missing: boolean;
    }): ActionFailure<...> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.@paramdata Data associated with the failure (e.g. validation errors)fail(400, { email: FormDataEntryValue | nullemail, missing: booleanmissing: true });
    		}
    
    		if (const user: anyuser.password !== module "$lib/server/db"db.hash(const password: FormDataEntryValue | nullpassword)) {
    			return fail<{
        email: FormDataEntryValue | null;
        incorrect: boolean;
    }>(status: number, data: {
        email: FormDataEntryValue | null;
        incorrect: boolean;
    }): ActionFailure<...> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.@paramdata Data associated with the failure (e.g. validation errors)fail(400, { email: FormDataEntryValue | nullemail, incorrect: booleanincorrect: true });
    		}
    
    		cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.set: (name: string, value: string, opts: CookieSerializeOptions & {
        path: string;
    }) => voidSets a cookie. This will add a set-cookie header to the response, but also make the cookie available via cookies.get or cookies.getAll during the current request.
    The httpOnly and secure options are true by default (except on http://localhost, where secure is false), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The sameSite option defaults to lax.
    You must specify a path for the cookie. In most cases you should explicitly set path: '/' to make the cookie available throughout your app. You can use relative paths, or set path: '' to make the cookie only available on the current path and its children
    @paramname the name of the cookie@paramvalue the cookie value@paramopts the options, passed directly to cookie.serialize. See documentation hereset('sessionid', await module "$lib/server/db"db.createSession(const user: anyuser), { path: stringSpecifies the value for the 
    {@link 
    https://tools.ietf.org/html/rfc6265#section-5.2.4 Path Set-Cookie attribute
    }
    .
    By default, the path is considered the “default path”.
    path: '/' });
    
    		if (url: URLThe requested URL.
    url.URL.searchParams: URLSearchParamsMDN Reference
    searchParams.URLSearchParams.has(name: string, value?: string): booleanReturns a Boolean indicating if such a search parameter exists.
    MDN Reference
    has('redirectTo')) {
    			function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect(303, url.searchParams.get('redirectTo'));
    		}
    
    		return { success: booleansuccess: true };
    	},
    	register: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>register: async (event: RequestEvent<Record<string, any>, string | null>event) => {
    		// TODO register the user
    	}
    } satisfies type Actions = {
        [x: string]: Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions;

Loading data[](#Loading-data)
-----------------------------

After an action runs, the page will be re-rendered (unless a redirect or an unexpected error occurs), with the action’s return value available to the page as the `form` prop. This means that your page’s `load` functions will run after the action completes.

Note that `handle` runs before the action is invoked, and does not rerun before the `load` functions. This means that if, for example, you use `handle` to populate `event.locals` based on a cookie, you must update `event.locals` when you set or delete the cookie in an action:

src/hooks.server

    /** @type {import('@sveltejs/kit').Handle} */
    export async function function handle(input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }): MaybePromise<...>@type{import('@sveltejs/kit').Handle}handle({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) {
    	event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user: {
        name: string;
    } | nulluser = await function getUser(sessionid: string | undefined): {
        name: string;
    }getUser(event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.get: (name: string, opts?: CookieParseOptions) => string | undefinedGets a cookie that was previously set with cookies.set, or from the request headers.
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.parse. See documentation hereget('sessionid'));
    	return resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event);
    }

    import type { type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle } from '@sveltejs/kit';
    
    export const const handle: Handlehandle: type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle = async ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) => {
    	event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user: {
        name: string;
    } | nulluser = await function getUser(sessionid: string | undefined): {
        name: string;
    }getUser(event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.get: (name: string, opts?: CookieParseOptions) => string | undefinedGets a cookie that was previously set with cookies.set, or from the request headers.
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.parse. See documentation hereget('sessionid'));
    	return resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event);
    };

src/routes/account/+page.server

    /** @type {import('./$types').PageServerLoad} */
    export function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageServerLoad}load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>event) {
    	return {
    		user: {
        name: string;
    } | nulluser: event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>event.RequestEvent<Record<string, any>, string | null>.locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user: {
        name: string;
    } | nulluser
    	};
    }
    
    /** @satisfies {import('./$types').Actions} */
    export const const actions: {
        logout: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>;
    }@satisfies{import('./$types').Actions}actions = {
    	logout: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>logout: async (event: RequestEvent<Record<string, any>, string | null>event) => {
    		event: RequestEvent<Record<string, any>, string | null>event.RequestEvent<Record<string, any>, string | null>.cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.delete: (name: string, opts: CookieSerializeOptions & {
        path: string;
    }) => voidDeletes a cookie by setting its value to an empty string and setting the expiry date in the past.
    You must specify a path for the cookie. In most cases you should explicitly set path: '/' to make the cookie available throughout your app. You can use relative paths, or set path: '' to make the cookie only available on the current path and its children
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.serialize. The path must match the path of the cookie you want to delete. See documentation heredelete('sessionid', { path: stringSpecifies the value for the 
    {@link 
    https://tools.ietf.org/html/rfc6265#section-5.2.4 Path Set-Cookie attribute
    }
    .
    By default, the path is considered the “default path”.
    path: '/' });
    		event: RequestEvent<Record<string, any>, string | null>event.RequestEvent<Params extends Partial<Record<string, string>> = Partial<Record<string, string>>, RouteId extends string | null = string | null>.locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user: {
        name: string;
    } | nulluser = null;
    	}
    };

    import type { type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad, type Actions = {
        [x: string]: Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>event) => {
    	return {
    		user: {
        name: string;
    } | nulluser: event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>event.RequestEvent<Record<string, any>, string | null>.locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user: {
        name: string;
    } | nulluser
    	};
    };
    
    export const const actions: {
        logout: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>;
    }actions = {
    	logout: (event: RequestEvent<Record<string, any>, string | null>) => Promise<void>logout: async (event: RequestEvent<Record<string, any>, string | null>event) => {
    		event: RequestEvent<Record<string, any>, string | null>event.RequestEvent<Record<string, any>, string | null>.cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.delete: (name: string, opts: CookieSerializeOptions & {
        path: string;
    }) => voidDeletes a cookie by setting its value to an empty string and setting the expiry date in the past.
    You must specify a path for the cookie. In most cases you should explicitly set path: '/' to make the cookie available throughout your app. You can use relative paths, or set path: '' to make the cookie only available on the current path and its children
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.serialize. The path must match the path of the cookie you want to delete. See documentation heredelete('sessionid', { path: stringSpecifies the value for the 
    {@link 
    https://tools.ietf.org/html/rfc6265#section-5.2.4 Path Set-Cookie attribute
    }
    .
    By default, the path is considered the “default path”.
    path: '/' });
    		event: RequestEvent<Record<string, any>, string | null>event.RequestEvent<Params extends Partial<Record<string, string>> = Partial<Record<string, string>>, RouteId extends string | null = string | null>.locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user: {
        name: string;
    } | nulluser = null;
    	}
    } satisfies type Actions = {
        [x: string]: Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions;

Progressive enhancement[](#Progressive-enhancement)
---------------------------------------------------

In the preceding sections we built a `/login` action that [works without client-side JavaScript](https://kryogenix.org/code/browser/everyonehasjs.html) — not a `fetch` in sight. That’s great, but when JavaScript _is_ available we can progressively enhance our form interactions to provide a better user experience.

### use:enhance[](#Progressive-enhancement-use:enhance)

The easiest way to progressively enhance a form is to add the `use:enhance` action:

src/routes/login/+page

    <script>
    	import { enhance } from '$app/forms';
    
    	/** @type {import('./$types').PageProps} */
    	let { form } = $props();
    </script>
    
    <form method="POST" use:enhance>

    <script lang="ts">
    	import { enhance } from '$app/forms';
    	import type { PageProps } from './$types';
    	let { form }: PageProps = $props();
    </script>
    
    <form method="POST" use:enhance>

> `use:enhance` can only be used with forms that have `method="POST"` and point to actions defined in a `+page.server.js` file. It will not work with `method="GET"`, which is the default for forms without a specified method. Attempting to use `use:enhance` on forms without `method="POST"` or posting to a `+server.js` endpoint will result in an error.

> Yes, it’s a little confusing that the `enhance` action and `<form action>` are both called ‘action’. These docs are action-packed. Sorry.

Without an argument, `use:enhance` will emulate the browser-native behaviour, just without the full-page reloads. It will:

*   update the `form` property, `page.form` and `page.status` on a successful or invalid response, but only if the action is on the same page you’re submitting from. For example, if your form looks like `<form action="/somewhere/else" ..>`, the `form` prop and the `page.form` state will _not_ be updated. This is because in the native form submission case you would be redirected to the page the action is on. If you want to have them updated either way, use [`applyAction`](#Progressive-enhancement-Customising-use:enhance)
*   reset the `<form>` element
*   invalidate all data using `invalidateAll` on a successful response
*   call `goto` on a redirect response
*   render the nearest `+error` boundary if an error occurs
*   [reset focus](accessibility#Focus-management) to the appropriate element

### Customising use:enhance[](#Progressive-enhancement-Customising-use:enhance)

To customise the behaviour, you can provide a `SubmitFunction` that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the `ActionResult`. Note that if you return a callback, the default behavior mentioned above is not triggered. To get it back, call `update`.

    <form
    	method="POST"
    	use:enhance={({ formElement, formData, action, cancel, submitter }) => {
    		// `formElement` is this `<form>` element
    		// `formData` is its `FormData` object that's about to be submitted
    		// `action` is the URL to which the form is posted
    		// calling `cancel()` will prevent the submission
    		// `submitter` is the `HTMLElement` that caused the form to be submitted
    
    		return async ({ result, update }) => {
    			// `result` is an `ActionResult` object
    			// `update` is a function which triggers the default logic that would be triggered if this callback wasn't set
    		};
    	}}
    >

You can use these functions to show and hide loading UI, and so on.

If you return a callback, you may need to reproduce part of the default `use:enhance` behaviour, but without invalidating all data on a successful response. You can do so with `applyAction`:

src/routes/login/+page

    <script>
    	import { enhance, applyAction } from '$app/forms';
    
    	/** @type {import('./$types').PageProps} */
    	let { form } = $props();
    </script>
    
    <form
    	method="POST"
    	use:enhance={({ formElement, formData, action, cancel }) => {
    		return async ({ result }) => {
    			// `result` is an `ActionResult` object
    			if (result.type === 'redirect') {
    				goto(result.location);
    			} else {
    				await applyAction(result);
    			}
    		};
    	}}
    >

    <script lang="ts">
    	import { enhance, applyAction } from '$app/forms';
    	import type { PageProps } from './$types';
    	let { form }: PageProps = $props();
    </script>
    
    <form
    	method="POST"
    	use:enhance={({ formElement, formData, action, cancel }) => {
    		return async ({ result }) => {
    			// `result` is an `ActionResult` object
    			if (result.type === 'redirect') {
    				goto(result.location);
    			} else {
    				await applyAction(result);
    			}
    		};
    	}}
    >

The behaviour of `applyAction(result)` depends on `result.type`:

*   `success`, `failure` — sets `page.status` to `result.status` and updates `form` and `page.form` to `result.data` (regardless of where you are submitting from, in contrast to `update` from `enhance`)
*   `redirect` — calls `goto(result.location, { invalidateAll: true })`
*   `error` — renders the nearest `+error` boundary with `result.error`

In all cases, [focus will be reset](accessibility#Focus-management).

### Custom event listener[](#Progressive-enhancement-Custom-event-listener)

We can also implement progressive enhancement ourselves, without `use:enhance`, with a normal event listener on the `<form>`:

src/routes/login/+page

    <script>
    	import { invalidateAll, goto } from '$app/navigation';
    	import { applyAction, deserialize } from '$app/forms';
    
    	/** @type {import('./$types').PageProps} */
    	let { form } = $props();
    
    	/** @param {SubmitEvent & { currentTarget: EventTarget & HTMLFormElement}} event */
    	async function handleSubmit(event) {
    		event.preventDefault();
    		const data = new FormData(event.currentTarget);
    
    		const response = await fetch(event.currentTarget.action, {
    			method: 'POST',
    			body: data
    		});
    
    		/** @type {import('@sveltejs/kit').ActionResult} */
    		const result = deserialize(await response.text());
    
    		if (result.type === 'success') {
    			// rerun all `load` functions, following the successful update
    			await invalidateAll();
    		}
    
    		applyAction(result);
    	}
    </script>
    
    <form method="POST" onsubmit={handleSubmit}>
    	<!-- content -->
    </form>

    <script lang="ts">
    	import { invalidateAll, goto } from '$app/navigation';
    	import { applyAction, deserialize } from '$app/forms';
    	import type { PageProps } from './$types';
    	import type { ActionResult } from '@sveltejs/kit';
    	let { form }: PageProps = $props();
    
    	async function handleSubmit(event: SubmitEvent & { currentTarget: EventTarget & HTMLFormElement}) {
    		event.preventDefault();
    		const data = new FormData(event.currentTarget);
    
    		const response = await fetch(event.currentTarget.action, {
    			method: 'POST',
    			body: data
    		});
    
    		const result: ActionResult = deserialize(await response.text());
    
    		if (result.type === 'success') {
    			// rerun all `load` functions, following the successful update
    			await invalidateAll();
    		}
    
    		applyAction(result);
    	}
    </script>
    
    <form method="POST" onsubmit={handleSubmit}>
    	<!-- content -->
    </form>

Note that you need to `deserialize` the response before processing it further using the corresponding method from `$app/forms`. `JSON.parse()` isn’t enough because form actions - like `load` functions - also support returning `Date` or `BigInt` objects.

If you have a `+server.js` alongside your `+page.server.js`, `fetch` requests will be routed there by default. To `POST` to an action in `+page.server.js` instead, use the custom `x-sveltekit-action` header:

    const const response: Responseresponse = await function fetch(input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response> (+1 overload)MDN Reference
    fetch(this.action, {
    	RequestInit.method?: string | undefinedA string to set request’s method.
    method: 'POST',
    	RequestInit.body?: BodyInit | null | undefinedA BodyInit object or null to set request’s body.
    body: data,
    	RequestInit.headers?: HeadersInit | undefinedA Headers object, an object literal, or an array of two-item arrays to set request’s headers.
    headers: {
    		'x-sveltekit-action': 'true'
    	}
    });

Alternatives[](#Alternatives)
-----------------------------

Form actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use [`+server.js`](routing#server) files to expose (for example) a JSON API. Here’s how such an interaction could look like:

src/routes/send-message/+page

    <script>
    	function rerun() {
    		fetch('/api/ci', {
    			method: 'POST'
    		});
    	}
    </script>
    
    <button onclick={rerun}>Rerun CI</button>

    <script lang="ts">
    	function rerun() {
    		fetch('/api/ci', {
    			method: 'POST'
    		});
    	}
    </script>
    
    <button onclick={rerun}>Rerun CI</button>

src/routes/api/ci/+server

    /** @type {import('./$types').RequestHandler} */
    export function function POST(): void@type{import('./$types').RequestHandler}POST() {
    	// do something
    }

    import type { type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler } from './$types';
    export const const POST: RequestHandlerPOST: type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler = () => {
    	// do something
    };

GET vs POST[](#GET-vs-POST)
---------------------------

As we’ve seen, to invoke a form action you must use `method="POST"`.

Some forms don’t need to `POST` data to the server — search inputs, for example. For these you can use `method="GET"` (or, equivalently, no `method` at all), and SvelteKit will treat them like `<a>` elements, using the client-side router instead of a full page navigation:

    <form action="/search">
    	<label>
    		Search
    		<input name="q">
    	</label>
    </form>

Submitting this form will navigate to `/search?q=...` and invoke your load function but will not invoke an action. As with `<a>` elements, you can set the [`data-sveltekit-reload`](link-options#data-sveltekit-reload), [`data-sveltekit-replacestate`](link-options#data-sveltekit-replacestate), [`data-sveltekit-keepfocus`](link-options#data-sveltekit-keepfocus) and [`data-sveltekit-noscroll`](link-options#data-sveltekit-noscroll) attributes on the `<form>` to control the router’s behaviour.

Further reading[](#Further-reading)
-----------------------------------

*   [Tutorial: Forms](/tutorial/kit/the-form-element)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/20-core-concepts/30-form-actions.md) [llms.txt](/docs/kit/form-actions/llms.txt)

previous next

[Loading data](/docs/kit/load) [Page options](/docs/kit/page-options)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitCore concepts

Page options
============

### On this page

*   [Page options](/docs/kit/page-options)
*   [prerender](#prerender)
*   [entries](#entries)
*   [ssr](#ssr)
*   [csr](#csr)
*   [trailingSlash](#trailingSlash)
*   [config](#config)
*   [Further reading](#Further-reading)

By default, SvelteKit will render (or [prerender](glossary#Prerendering)) any component first on the server and send it to the client as HTML. It will then render the component again in the browser to make it interactive in a process called [_hydration_](glossary#Hydration). For this reason, you need to ensure that components can run in both places. SvelteKit will then initialize a [_router_](routing) that takes over subsequent navigations.

You can control each of these on a page-by-page basis by exporting options from [`+page.js`](routing#page-page.js) or [`+page.server.js`](routing#page-page.server.js), or for groups of pages using a shared [`+layout.js`](routing#layout-layout.js) or [`+layout.server.js`](routing#layout-layout.server.js). To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered.

You can mix and match these options in different areas of your app. For example, you could prerender your marketing page for maximum speed, server-render your dynamic pages for SEO and accessibility and turn your admin section into an SPA by rendering it on the client only. This makes SvelteKit very versatile.

prerender[](#prerender)
-----------------------

It’s likely that at least some routes of your app can be represented as a simple HTML file generated at build time. These routes can be [_prerendered_](glossary#Prerendering).

+page.js/+page.server.js/+server

    export const const prerender: trueprerender = true;

Alternatively, you can set `export const prerender = true` in your root `+layout.js` or `+layout.server.js` and prerender everything except pages that are explicitly marked as _not_ prerenderable:

+page.js/+page.server.js/+server

    export const const prerender: falseprerender = false;

Routes with `prerender = true` will be excluded from manifests used for dynamic SSR, making your server (or serverless/edge functions) smaller. In some cases you might want to prerender a route but also include it in the manifest (for example, with a route like `/blog/[slug]` where you want to prerender your most recent/popular content but server-render the long tail) — for these cases, there’s a third option, ‘auto’:

+page.js/+page.server.js/+server

    export const const prerender: "auto"prerender = 'auto';

> If your entire app is suitable for prerendering, you can use [`adapter-static`](adapter-static), which will output files suitable for use with any static webserver.

The prerenderer will start at the root of your app and generate files for any prerenderable pages or `+server.js` routes it finds. Each page is scanned for `<a>` elements that point to other pages that are candidates for prerendering — because of this, you generally don’t need to specify which pages should be accessed. If you _do_ need to specify which pages should be accessed by the prerenderer, you can do so with [`config.kit.prerender.entries`](configuration#prerender), or by exporting an [`entries`](#entries) function from your dynamic route.

While prerendering, the value of `building` imported from [`$app/environment`]($app-environment) will be `true`.

### Prerendering server routes[](#prerender-Prerendering-server-routes)

Unlike the other page options, `prerender` also applies to `+server.js` files. These files are _not_ affected by layouts, but will inherit default values from the pages that fetch data from them, if any. For example if a `+page.js` contains this `load` function...

+page

    export const const prerender: trueprerender = true;
    
    /** @type {import('./$types').PageLoad} */
    export async function function load({ fetch }: {
        fetch: any;
    }): Promise<any>@type{import('./$types').PageLoad}load({ fetch: anyfetch }) {
    	const const res: anyres = await fetch: anyfetch('/my-server-route.json');
    	return await const res: anyres.json();
    }

    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    export const const prerender: trueprerender = true;
    
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here
    fetch }) => {
    	const const res: Responseres = await fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch('/my-server-route.json');
    	return await const res: Responseres.Body.json(): Promise<any>MDN Reference
    json();
    };

...then `src/routes/my-server-route.json/+server.js` will be treated as prerenderable if it doesn’t contain its own `export const prerender = false`.

### When not to prerender[](#prerender-When-not-to-prerender)

The basic rule is this: for a page to be prerenderable, any two users hitting it directly must get the same content from the server.

> Not all pages are suitable for prerendering. Any content that is prerendered will be seen by all users. You can of course fetch personalized data in `onMount` in a prerendered page, but this may result in a poorer user experience since it will involve blank initial content or loading indicators.

Note that you can still prerender pages that load data based on the page’s parameters, such as a `src/routes/blog/[slug]/+page.svelte` route.

Accessing [`url.searchParams`](load#Using-URL-data-url) during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in `onMount`).

Pages with [actions](form-actions) cannot be prerendered, because a server must be able to handle the action `POST` requests.

### Route conflicts[](#prerender-Route-conflicts)

Because prerendering writes to the filesystem, it isn’t possible to have two endpoints that would cause a directory and a file to have the same name. For example, `src/routes/foo/+server.js` and `src/routes/foo/bar/+server.js` would try to create `foo` and `foo/bar`, which is impossible.

For that reason among others, it’s recommended that you always include a file extension — `src/routes/foo.json/+server.js` and `src/routes/foo/bar.json/+server.js` would result in `foo.json` and `foo/bar.json` files living harmoniously side-by-side.

For _pages_, we skirt around this problem by writing `foo/index.html` instead of `foo`.

### Troubleshooting[](#prerender-Troubleshooting)

If you encounter an error like ‘The following routes were marked as prerenderable, but were not prerendered’ it’s because the route in question (or a parent layout, if it’s a page) has `export const prerender = true` but the page wasn’t reached by the prerendering crawler and thus wasn’t prerendered.

Since these routes cannot be dynamically server-rendered, this will cause errors when people try to access the route in question. There are a few ways to fix it:

*   Ensure that SvelteKit can find the route by following links from [`config.kit.prerender.entries`](configuration#prerender) or the [`entries`](#entries) page option. Add links to dynamic routes (i.e. pages with `[parameters]` ) to this option if they are not found through crawling the other entry points, else they are not prerendered because SvelteKit doesn’t know what value the parameters should have. Pages not marked as prerenderable will be ignored and their links to other pages will not be crawled, even if some of them would be prerenderable.
*   Ensure that SvelteKit can find the route by discovering a link to it from one of your other prerendered pages that have server-side rendering enabled.
*   Change `export const prerender = true` to `export const prerender = 'auto'`. Routes with `'auto'` can be dynamically server rendered

entries[](#entries)
-------------------

SvelteKit will discover pages to prerender automatically, by starting at _entry points_ and crawling them. By default, all your non-dynamic routes are considered entry points — for example, if you have these routes...

    /    # non-dynamic
    /blog# non-dynamic
    /blog/[slug]  # dynamic, because of `[slug]`

...SvelteKit will prerender `/` and `/blog`, and in the process discover links like `<a href="/blog/hello-world">` which give it new pages to prerender.

Most of the time, that’s enough. In some situations, links to pages like `/blog/hello-world` might not exist (or might not exist on prerendered pages), in which case we need to tell SvelteKit about their existence.

This can be done with [`config.kit.prerender.entries`](configuration#prerender), or by exporting an `entries` function from a `+page.js`, a `+page.server.js` or a `+server.js` belonging to a dynamic route:

src/routes/blog/\[slug\]/+page.server

    /** @type {import('./$types').EntryGenerator} */
    export function function entries(): {
        slug: string;
    }[]@type{import('./$types').EntryGenerator}entries() {
    	return [
    		{ slug: stringslug: 'hello-world' },
    		{ slug: stringslug: 'another-blog-post' }
    	];
    }
    
    export const const prerender: trueprerender = true;

    import type { type EntryGenerator = () => Promise<Array<Record<string, any>>> | Array<Record<string, any>>
    type EntryGenerator = () => Promise<Array<Record<string, any>>> | Array<Record<string, any>>EntryGenerator } from './$types';
    
    export const const entries: EntryGeneratorentries: type EntryGenerator = () => Promise<Array<Record<string, any>>> | Array<Record<string, any>>
    type EntryGenerator = () => Promise<Array<Record<string, any>>> | Array<Record<string, any>>EntryGenerator = () => {
    	return [
    		{ slug: stringslug: 'hello-world' },
    		{ slug: stringslug: 'another-blog-post' }
    	];
    };
    
    export const const prerender: trueprerender = true;

`entries` can be an `async` function, allowing you to (for example) retrieve a list of posts from a CMS or database, in the example above.

ssr[](#ssr)
-----------

Normally, SvelteKit renders your page on the server first and sends that HTML to the client where it’s [hydrated](glossary#Hydration). If you set `ssr` to `false`, it renders an empty ‘shell’ page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like `document` for example), but in most situations it’s not recommended ([see appendix](glossary#SSR)).

+page

    export const const ssr: falsessr = false;
    // If both `ssr` and `csr` are `false`, nothing will be rendered!

If you add `export const ssr = false` to your root `+layout.js`, your entire app will only be rendered on the client — which essentially means you turn your app into an SPA.

> If all your page options are boolean or string literal values, SvelteKit will evaluate them statically. If not, it will import your `+page.js` or `+layout.js` file on the server (both at build time, and at runtime if your app isn’t fully static) so it can evaluate the options. In the second case, browser-only code must not run when the module is loaded. In practice, this means you should import browser-only code in your `+page.svelte` or `+layout.svelte` file instead.

csr[](#csr)
-----------

Ordinarily, SvelteKit [hydrates](glossary#Hydration) your server-rendered HTML into an interactive client-side-rendered (CSR) page. Some pages don’t require JavaScript at all — many blog posts and ‘about’ pages fall into this category. In these cases you can disable CSR:

+page

    export const const csr: falsecsr = false;
    // If both `csr` and `ssr` are `false`, nothing will be rendered!

Disabling CSR does not ship any JavaScript to the client. This means:

*   The webpage should work with HTML and CSS only.
*   `<script>` tags inside all Svelte components are removed.
*   `<form>` elements cannot be [progressively enhanced](form-actions#Progressive-enhancement).
*   Links are handled by the browser with a full-page navigation.
*   Hot Module Replacement (HMR) will be disabled.

You can enable `csr` during development (for example to take advantage of HMR) like so:

+page

    import { const dev: booleanWhether the dev server is running. This is not guaranteed to correspond to NODE_ENV or MODE.
    dev } from '$app/environment';
    
    export const const csr: booleancsr = const dev: booleanWhether the dev server is running. This is not guaranteed to correspond to NODE_ENV or MODE.
    dev;

trailingSlash[](#trailingSlash)
-------------------------------

By default, SvelteKit will remove trailing slashes from URLs — if you visit `/about/`, it will respond with a redirect to `/about`. You can change this behaviour with the `trailingSlash` option, which can be one of `'never'` (the default), `'always'`, or `'ignore'`.

As with other page options, you can export this value from a `+layout.js` or a `+layout.server.js` and it will apply to all child pages. You can also export the configuration from `+server.js` files.

src/routes/+layout

    export const const trailingSlash: "always"trailingSlash = 'always';

This option also affects [prerendering](#prerender). If `trailingSlash` is `always`, a route like `/about` will result in an `about/index.html` file, otherwise it will create `about.html`, mirroring static webserver conventions.

> Ignoring trailing slashes is not recommended — the semantics of relative paths differ between the two cases (`./y` from `/x` is `/y`, but from `/x/` is `/x/y`), and `/x` and `/x/` are treated as separate URLs which is harmful to SEO.

config[](#config)
-----------------

With the concept of [adapters](adapters), SvelteKit is able to run on a variety of platforms. Each of these might have specific configuration to further tweak the deployment — for example on Vercel you could choose to deploy some parts of your app on the edge and others on serverless environments.

`config` is an object with key-value pairs at the top level. Beyond that, the concrete shape is dependent on the adapter you’re using. Every adapter should provide a `Config` interface to import for type safety. Consult the documentation of your adapter for more information.

src/routes/+page

    /** @type {import('some-adapter').Config} */
    export const const config: Config@type{import('some-adapter').Config}config = {
    	Config.runtime: stringruntime: 'edge'
    };

    import type { Config } from 'some-adapter';
    
    export const const config: Configconfig: Config = {
    	Config.runtime: stringruntime: 'edge'
    };

`config` objects are merged at the top level (but _not_ deeper levels). This means you don’t need to repeat all the values in a `+page.js` if you want to only override some of the values in the upper `+layout.js`. For example this layout configuration...

src/routes/+layout

    export const const config: {
        runtime: string;
        regions: string;
        foo: {
            bar: boolean;
        };
    }config = {
    	runtime: stringruntime: 'edge',
    	regions: stringregions: 'all',
    	foo: {
        bar: boolean;
    }foo: {
    		bar: booleanbar: true
    	}
    }

...is overridden by this page configuration...

src/routes/+page

    export const const config: {
        regions: string[];
        foo: {
            baz: boolean;
        };
    }config = {
    	regions: string[]regions: ['us1', 'us2'],
    	foo: {
        baz: boolean;
    }foo: {
    		baz: booleanbaz: true
    	}
    }

...which results in the config value `{ runtime: 'edge', regions: ['us1', 'us2'], foo: { baz: true } }` for that page.

Further reading[](#Further-reading)
-----------------------------------

*   [Tutorial: Page options](/tutorial/kit/page-options)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/20-core-concepts/40-page-options.md) [llms.txt](/docs/kit/page-options/llms.txt)

previous next

[Form actions](/docs/kit/form-actions) [State management](/docs/kit/state-management)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitCore concepts

State management
================

### On this page

*   [State management](/docs/kit/state-management)
*   [Avoid shared state on the server](#Avoid-shared-state-on-the-server)
*   [No side-effects in load](#No-side-effects-in-load)
*   [Using state and stores with context](#Using-state-and-stores-with-context)
*   [Component and page state is preserved](#Component-and-page-state-is-preserved)
*   [Storing state in the URL](#Storing-state-in-the-URL)
*   [Storing ephemeral state in snapshots](#Storing-ephemeral-state-in-snapshots)

If you’re used to building client-only apps, state management in an app that spans server and client might seem intimidating. This section provides tips for avoiding some common gotchas.

Avoid shared state on the server[](#Avoid-shared-state-on-the-server)
---------------------------------------------------------------------

Browsers are _stateful_ — state is stored in memory as the user interacts with the application. Servers, on the other hand, are _stateless_ — the content of the response is determined entirely by the content of the request.

Conceptually, that is. In reality, servers are often long-lived and shared by multiple users. For that reason it’s important not to store data in shared variables. For example, consider this code:

+page.server

    let let user: anyuser;
    
    /** @type {import('./$types').PageServerLoad} */
    export function function load(): {
        user: any;
    }@type{import('./$types').PageServerLoad}load() {
    	return { user: anyuser };
    }
    
    /** @satisfies {import('./$types').Actions} */
    export const const actions: {
        default: ({ request }: {
            request: any;
        }) => Promise<void>;
    }@satisfies{import('./$types').Actions}actions = {
    	default: ({ request }: {
        request: any;
    }) => Promise<void>default: async ({ request: anyrequest }) => {
    		const const data: anydata = await request: anyrequest.formData();
    
    		// NEVER DO THIS!
    		let user: anyuser = {
    			name: anyname: const data: anydata.get('name'),
    			embarrassingSecret: anyembarrassingSecret: const data: anydata.get('secret')
    		};
    	}
    }

    import type { type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad, type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }
    type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions } from './$types';
    let let user: anyuser;
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = () => {
    	return { user: anyuser };
    };
    
    export const const actions: {
        default: ({ request }: Kit.RequestEvent<Record<string, any>, string | null>) => Promise<void>;
    }actions = {
    	default: ({ request }: Kit.RequestEvent<Record<string, any>, string | null>) => Promise<void>default: async ({ request: RequestThe original request object.
    request }) => {
    		const const data: FormDatadata = await request: RequestThe original request object.
    request.Body.formData(): Promise<FormData>MDN Reference
    formData();
    
    		// NEVER DO THIS!
    		let user: anyuser = {
    			name: FormDataEntryValue | nullname: const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('name'),
    			embarrassingSecret: FormDataEntryValue | nullembarrassingSecret: const data: FormDatadata.FormData.get(name: string): FormDataEntryValue | nullMDN Reference
    get('secret')
    		};
    	}
    } satisfies type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }
    type Actions = {
        [x: string]: Kit.Action<Record<string, any>, void | Record<string, any>, string | null>;
    }Actions

The `user` variable is shared by everyone who connects to this server. If Alice submitted an embarrassing secret, and Bob visited the page after her, Bob would know Alice’s secret. In addition, when Alice returns to the site later in the day, the server may have restarted, losing her data.

Instead, you should _authenticate_ the user using [`cookies`](load#Cookies) and persist the data to a database.

No side-effects in load[](#No-side-effects-in-load)
---------------------------------------------------

For the same reason, your `load` functions should be _pure_ — no side-effects (except maybe the occasional `console.log(...)`). For example, you might be tempted to write to a store or global state inside a `load` function so that you can use the value in your components:

+page

    import { const user: {
        set: (value: any) => void;
    }user } from '$lib/user';
    
    /** @type {import('./$types').PageLoad} */
    export async function function load(event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageLoad}load({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here
    fetch }) {
    	const const response: Responseresponse = await fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch('/api/user');
    
    	// NEVER DO THIS!
    	const user: {
        set: (value: any) => void;
    }user.set: (value: any) => voidset(await const response: Responseresponse.Body.json(): Promise<any>MDN Reference
    json());
    }

    import { const user: {
        set: (value: any) => void;
    }user } from '$lib/user';
    import type { type PageLoad = (event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here
    fetch }) => {
    	const const response: Responseresponse = await fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch('/api/user');
    
    	// NEVER DO THIS!
    	const user: {
        set: (value: any) => void;
    }user.set: (value: any) => voidset(await const response: Responseresponse.Body.json(): Promise<any>MDN Reference
    json());
    };

As with the previous example, this puts one user’s information in a place that is shared by _all_ users. Instead, just return the data...

+page

    /** @type {import('./$types').PageServerLoad} */
    export async function function load({ fetch }: {
        fetch: any;
    }): Promise<{
        user: any;
    }>@type{import('./$types').PageServerLoad}load({ fetch: anyfetch }) {
    	const const response: anyresponse = await fetch: anyfetch('/api/user');
    
    	return {
    		user: anyuser: await const response: anyresponse.json()
    	};
    }

    import type { type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = async ({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here.
    fetch }) => {
    	const const response: Responseresponse = await fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch('/api/user');
    
    	return {
    		user: anyuser: await const response: Responseresponse.Body.json(): Promise<any>MDN Reference
    json()
    	};
    };

...and pass it around to the components that need it, or use [`page.data`](load#page.data).

If you’re not using SSR, then there’s no risk of accidentally exposing one user’s data to another. But you should still avoid side-effects in your `load` functions — your application will be much easier to reason about without them.

Using state and stores with context[](#Using-state-and-stores-with-context)
---------------------------------------------------------------------------

You might wonder how we’re able to use `page.data` and other [app state]($app-state) (or [app stores]($app-stores)) if we can’t use global state. The answer is that app state and app stores on the server use Svelte’s [context API](/tutorial/svelte/context-api) — the state (or store) is attached to the component tree with `setContext`, and when you subscribe you retrieve it with `getContext`. We can do the same thing with our own state:

src/routes/+layout

    <script>
    	import { setContext } from 'svelte';
    
    	/** @type {import('./$types').LayoutProps} */
    	let { data } = $props();
    
    	// Pass a function referencing our state
    	// to the context for child components to access
    	setContext('user', () => data.user);
    </script>

    <script lang="ts">
    	import { setContext } from 'svelte';
    	import type { LayoutProps } from './$types';
    	let { data }: LayoutProps = $props();
    
    	// Pass a function referencing our state
    	// to the context for child components to access
    	setContext('user', () => data.user);
    </script>

src/routes/user/+page

    <script>
    	import { getContext } from 'svelte';
    
    	// Retrieve user store from context
    	const user = getContext('user');
    </script>
    
    <p>Welcome {user().name}</p>

    <script lang="ts">
    	import { getContext } from 'svelte';
    
    	// Retrieve user store from context
    	const user = getContext('user');
    </script>
    
    <p>Welcome {user().name}</p>

> We’re passing a function into `setContext` to keep reactivity across boundaries. Read more about it [here](/docs/svelte/$state#Passing-state-into-functions)

> Legacy mode
> 
> You also use stores from `svelte/store` for this, but when using Svelte 5 it is recommended to make use of universal reactivity instead.

Updating the value of context-based state in deeper-level pages or components while the page is being rendered via SSR will not affect the value in the parent component because it has already been rendered by the time the state value is updated. In contrast, on the client (when CSR is enabled, which is the default) the value will be propagated and components, pages, and layouts higher in the hierarchy will react to the new value. Therefore, to avoid values ‘flashing’ during state updates during hydration, it is generally recommended to pass state down into components rather than up.

If you’re not using SSR (and can guarantee that you won’t need to use SSR in future) then you can safely keep state in a shared module, without using the context API.

Component and page state is preserved[](#Component-and-page-state-is-preserved)
-------------------------------------------------------------------------------

When you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this...

src/routes/blog/\[slug\]/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    
    	// THIS CODE IS BUGGY!
    	const wordCount = data.content.split(' ').length;
    	const estimatedReadingTime = wordCount / 250;
    </script>
    
    <header>
    	<h1>{data.title}</h1>
    	<p>Reading time: {Math.round(estimatedReadingTime)} minutes</p>
    </header>
    
    <div>{@html data.content}</div>

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data }: PageProps = $props();
    
    	// THIS CODE IS BUGGY!
    	const wordCount = data.content.split(' ').length;
    	const estimatedReadingTime = wordCount / 250;
    </script>
    
    <header>
    	<h1>{data.title}</h1>
    	<p>Reading time: {Math.round(estimatedReadingTime)} minutes</p>
    </header>
    
    <div>{@html data.content}</div>

...then navigating from `/blog/my-short-post` to `/blog/my-long-post` won’t cause the layout, page and any other components within to be destroyed and recreated. Instead the `data` prop (and by extension `data.title` and `data.content`) will update (as it would with any other Svelte component) and, because the code isn’t rerunning, lifecycle methods like `onMount` and `onDestroy` won’t rerun and `estimatedReadingTime` won’t be recalculated.

Instead, we need to make the value [_reactive_](/tutorial/svelte/state):

src/routes/blog/\[slug\]/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data } = $props();
    
    	let wordCount = $derived(data.content.split(' ').length);
    	let estimatedReadingTime = $derived(wordCount / 250);
    </script>

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data }: PageProps = $props();
    
    	let wordCount = $derived(data.content.split(' ').length);
    	let estimatedReadingTime = $derived(wordCount / 250);
    </script>

> If your code in `onMount` and `onDestroy` has to run again after navigation you can use [afterNavigate]($app-navigation#afterNavigate) and [beforeNavigate]($app-navigation#beforeNavigate) respectively.

Reusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. In the case that you do need to completely destroy and remount a component on navigation, you can use this pattern:

    <script>
    	import { page } from '$app/state';
    </script>
    
    {#key page.url.pathname}
    	<BlogPost title={data.title} content={data.title} />
    {/key}

Storing state in the URL[](#Storing-state-in-the-URL)
-----------------------------------------------------

If you have state that should survive a reload and/or affect SSR, such as filters or sorting rules on a table, URL search parameters (like `?sort=price&order=ascending`) are a good place to put them. You can put them in `<a href="...">` or `<form action="...">` attributes, or set them programmatically via `goto('?key=value')`. They can be accessed inside `load` functions via the `url` parameter, and inside components via `page.url.searchParams`.

Storing ephemeral state in snapshots[](#Storing-ephemeral-state-in-snapshots)
-----------------------------------------------------------------------------

Some UI state, such as ‘is the accordion open?’, is disposable — if the user navigates away or refreshes the page, it doesn’t matter if the state is lost. In some cases, you _do_ want the data to persist if the user navigates to a different page and comes back, but storing the state in the URL or in a database would be overkill. For this, SvelteKit provides [snapshots](snapshots), which let you associate component state with a history entry.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/20-core-concepts/50-state-management.md) [llms.txt](/docs/kit/state-management/llms.txt)

previous next

[Page options](/docs/kit/page-options) [Building your app](/docs/kit/building-your-app)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Building your app
=================

### On this page

*   [Building your app](/docs/kit/building-your-app)
*   [During the build](#During-the-build)
*   [Preview your app](#Preview-your-app)

Building a SvelteKit app happens in two stages, which both happen when you run `vite build` (usually via `npm run build`).

Firstly, Vite creates an optimized production build of your server code, your browser code, and your service worker (if you have one). [Prerendering](page-options#prerender) is executed at this stage, if appropriate.

Secondly, an _adapter_ takes this production build and tunes it for your target environment — more on this on the following pages.

During the build[](#During-the-build)
-------------------------------------

SvelteKit will load your `+page/layout(.server).js` files (and all files they import) for analysis during the build. Any code that should _not_ be executed at this stage must check that `building` from [`$app/environment`]($app-environment) is `false`:

    import { const building: booleanSvelteKit analyses your app during the build step by running it. During this process, building is true. This also applies during prerendering.
    building } from '$app/environment';
    import { import setupMyDatabasesetupMyDatabase } from '$lib/server/database';
    
    if (!const building: booleanSvelteKit analyses your app during the build step by running it. During this process, building is true. This also applies during prerendering.
    building) {
    	import setupMyDatabasesetupMyDatabase();
    }
    
    export function function load(): voidload() {
    	// ...
    }

Preview your app[](#Preview-your-app)
-------------------------------------

After building, you can view your production build locally with `vite preview` (via `npm run preview`). Note that this will run the app in Node, and so is not a perfect reproduction of your deployed app — adapter-specific adjustments like the [`platform` object](adapters#Platform-specific-context) do not apply to previews.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/10-building-your-app.md) [llms.txt](/docs/kit/building-your-app/llms.txt)

previous next

[State management](/docs/kit/state-management) [Adapters](/docs/kit/adapters)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Adapters
========

### On this page

*   [Adapters](/docs/kit/adapters)
*   [Using adapters](#Using-adapters)
*   [Platform-specific context](#Platform-specific-context)

Before you can deploy your SvelteKit app, you need to _adapt_ it for your deployment target. Adapters are small plugins that take the built app as input and generate output for deployment.

Official adapters exist for a variety of platforms — these are documented on the following pages:

*   [`@sveltejs/adapter-cloudflare`](adapter-cloudflare) for Cloudflare Workers and Cloudflare Pages
*   [`@sveltejs/adapter-netlify`](adapter-netlify) for Netlify
*   [`@sveltejs/adapter-node`](adapter-node) for Node servers
*   [`@sveltejs/adapter-static`](adapter-static) for static site generation (SSG)
*   [`@sveltejs/adapter-vercel`](adapter-vercel) for Vercel

Additional [community-provided adapters](https://sveltesociety.dev/packages?category=sveltekit-adapters) exist for other platforms.

Using adapters[](#Using-adapters)
---------------------------------

Your adapter is specified in `svelte.config.js`:

svelte.config

    import const adapter: (opts: any) => import("@sveltejs/kit").Adapteradapter from 'svelte-adapter-foo';
    
    /** @type {import('@sveltejs/kit').Config} */
    const const config: Config@type{import('@sveltejs/kit').Config}config = {
    	Config.kit?: KitConfig | undefinedSvelteKit options
    kit: {
    		KitConfig.adapter?: Adapter | undefinedYour adapter is run when executing vite build. It determines how the output is converted for different platforms.
    @defaultundefinedadapter: function adapter(opts: any): import("@sveltejs/kit").Adapteradapter({
    			// adapter options go here
    		})
    	}
    };
    
    export default const config: Config@type{import('@sveltejs/kit').Config}config;

Platform-specific context[](#Platform-specific-context)
-------------------------------------------------------

Some adapters may have access to additional information about the request. For example, Cloudflare Workers can access an `env` object containing KV namespaces etc. This can be passed to the `RequestEvent` used in [hooks](hooks) and [server routes](routing#server) as the `platform` property — consult each adapter’s documentation to learn more.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/20-adapters.md) [llms.txt](/docs/kit/adapters/llms.txt)

previous next

[Building your app](/docs/kit/building-your-app) [Zero-config deployments](/docs/kit/adapter-auto)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Zero-config deployments
=======================

### On this page

*   [Zero-config deployments](/docs/kit/adapter-auto)
*   [Environment-specific configuration](#Environment-specific-configuration)
*   [Adding community adapters](#Adding-community-adapters)

When you create a new SvelteKit project with `npx sv create`, it installs [`adapter-auto`](https://github.com/sveltejs/kit/tree/main/packages/adapter-auto) by default. This adapter automatically installs and uses the correct adapter for supported environments when you deploy:

*   [`@sveltejs/adapter-cloudflare`](adapter-cloudflare) for [Cloudflare Pages](https://developers.cloudflare.com/pages/)
*   [`@sveltejs/adapter-netlify`](adapter-netlify) for [Netlify](https://netlify.com/)
*   [`@sveltejs/adapter-vercel`](adapter-vercel) for [Vercel](https://vercel.com/)
*   [`svelte-adapter-azure-swa`](https://github.com/geoffrich/svelte-adapter-azure-swa) for [Azure Static Web Apps](https://docs.microsoft.com/en-us/azure/static-web-apps/)
*   [`svelte-kit-sst`](https://github.com/sst/v2/tree/master/packages/svelte-kit-sst) for [AWS via SST](https://sst.dev/docs/start/aws/svelte)
*   [`@sveltejs/adapter-node`](adapter-node) for [Google Cloud Run](https://cloud.google.com/run)

It’s recommended to install the appropriate adapter to your `devDependencies` once you’ve settled on a target environment, since this will add the adapter to your lockfile and slightly improve install times on CI.

Environment-specific configuration[](#Environment-specific-configuration)
-------------------------------------------------------------------------

To add configuration options, such as `{ edge: true }` in [`adapter-vercel`](adapter-vercel) and [`adapter-netlify`](adapter-netlify), you must install the underlying adapter — `adapter-auto` does not take any options.

Adding community adapters[](#Adding-community-adapters)
-------------------------------------------------------

You can add zero-config support for additional adapters by editing [adapters.js](https://github.com/sveltejs/kit/blob/main/packages/adapter-auto/adapters.js) and opening a pull request.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/30-adapter-auto.md) [llms.txt](/docs/kit/adapter-auto/llms.txt)

previous next

[Adapters](/docs/kit/adapters) [Node servers](/docs/kit/adapter-node)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Node servers
============

### On this page

*   [Node servers](/docs/kit/adapter-node)
*   [Usage](#Usage)
*   [Deploying](#Deploying)
*   [Environment variables](#Environment-variables)
*   [Options](#Options)
*   [Graceful shutdown](#Graceful-shutdown)
*   [Socket activation](#Socket-activation)
*   [Custom server](#Custom-server)

To generate a standalone Node server, use [`adapter-node`](https://github.com/sveltejs/kit/tree/main/packages/adapter-node).

Usage[](#Usage)
---------------

Install with `npm i -D @sveltejs/adapter-node`, then add the adapter to your `svelte.config.js`:

svelte.config

    import import adapteradapter from '@sveltejs/adapter-node';
    
    export default {
    	kit: {
        adapter: any;
    }kit: {
    		adapter: anyadapter: import adapteradapter()
    	}
    };

Deploying[](#Deploying)
-----------------------

First, build your app with `npm run build`. This will create the production server in the output directory specified in the adapter options, defaulting to `build`.

You will need the output directory, the project’s `package.json`, and the production dependencies in `node_modules` to run the application. Production dependencies can be generated by copying the `package.json` and `package-lock.json` and then running `npm ci --omit dev` (you can skip this step if your app doesn’t have any dependencies). You can then start your app with this command:

    node build

Development dependencies will be bundled into your app using [Rollup](https://rollupjs.org). To control whether a given package is bundled or externalised, place it in `devDependencies` or `dependencies` respectively in your `package.json`.

### Compressing responses[](#Deploying-Compressing-responses)

You will typically want to compress responses coming from the server. If you’re already deploying your server behind a reverse proxy for SSL or load balancing, it typically results in better performance to also handle compression at that layer since Node.js is single-threaded.

However, if you’re building a [custom server](#Custom-server) and do want to add a compression middleware there, note that we would recommend using [`@polka/compression`](https://www.npmjs.com/package/@polka/compression) since SvelteKit streams responses and the more popular `compression` package does not support streaming and may cause errors when used.

Environment variables[](#Environment-variables)
-----------------------------------------------

In `dev` and `preview`, SvelteKit will read environment variables from your `.env` file (or `.env.local`, or `.env.[mode]`, [as determined by Vite](https://vitejs.dev/guide/env-and-mode.html#env-files).)

In production, `.env` files are _not_ automatically loaded. To do so, install `dotenv` in your project...

    npm install dotenv

...and invoke it before running the built app:

    node -r dotenv/config build

If you use Node.js v20.6+, you can use the [`--env-file`](https://nodejs.org/en/learn/command-line/how-to-read-environment-variables-from-nodejs) flag instead:

    node --env-file=.env build

### PORT, HOST and SOCKET\_PATH[](#Environment-variables-PORT-HOST-and-SOCKET_PATH)

By default, the server will accept connections on `0.0.0.0` using port 3000. These can be customised with the `PORT` and `HOST` environment variables:

    HOST=127.0.0.1 PORT=4000 node build

Alternatively, the server can be configured to accept connections on a specified socket path. When this is done using the `SOCKET_PATH` environment variable, the `HOST` and `PORT` environment variables will be disregarded.

    SOCKET_PATH=/tmp/socket node build

### ORIGIN, PROTOCOL\_HEADER, HOST\_HEADER, and PORT\_HEADER[](#Environment-variables-ORIGIN-PROTOCOL_HEADER-HOST_HEADER-and-PORT_HEADER)

HTTP doesn’t give SvelteKit a reliable way to know the URL that is currently being requested. The simplest way to tell SvelteKit where the app is being served is to set the `ORIGIN` environment variable:

    ORIGIN=https://my.site node build
    
    # or e.g. for local previewing and testing
    ORIGIN=http://localhost:3000 node build

With this, a request for the `/stuff` pathname will correctly resolve to `https://my.site/stuff`. Alternatively, you can specify headers that tell SvelteKit about the request protocol and host, from which it can construct the origin URL:

    PROTOCOL_HEADER=x-forwarded-proto HOST_HEADER=x-forwarded-host node build

> [`x-forwarded-proto`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto) and [`x-forwarded-host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) are de facto standard headers that forward the original protocol and host if you’re using a reverse proxy (think load balancers and CDNs). You should only set these variables if your server is behind a trusted reverse proxy; otherwise, it’d be possible for clients to spoof these headers.
> 
> If you’re hosting your proxy on a non-standard port and your reverse proxy supports `x-forwarded-port`, you can also set `PORT_HEADER=x-forwarded-port`.

If `adapter-node` can’t correctly determine the URL of your deployment, you may experience this error when using [form actions](form-actions):

> Cross-site POST form submissions are forbidden

### ADDRESS\_HEADER and XFF\_DEPTH[](#Environment-variables-ADDRESS_HEADER-and-XFF_DEPTH)

The [`RequestEvent`](@sveltejs-kit#RequestEvent) object passed to hooks and endpoints includes an `event.getClientAddress()` function that returns the client’s IP address. By default this is the connecting `remoteAddress`. If your server is behind one or more proxies (such as a load balancer), this value will contain the innermost proxy’s IP address rather than the client’s, so we need to specify an `ADDRESS_HEADER` to read the address from:

    ADDRESS_HEADER=True-Client-IP node build

> Headers can easily be spoofed. As with `PROTOCOL_HEADER` and `HOST_HEADER`, you should [know what you’re doing](https://adam-p.ca/blog/2022/03/x-forwarded-for/) before setting these.

If the `ADDRESS_HEADER` is `X-Forwarded-For`, the header value will contain a comma-separated list of IP addresses. The `XFF_DEPTH` environment variable should specify how many trusted proxies sit in front of your server. E.g. if there are three trusted proxies, proxy 3 will forward the addresses of the original connection and the first two proxies:

    <client address>, <proxy 1 address>, <proxy 2 address>

Some guides will tell you to read the left-most address, but this leaves you [vulnerable to spoofing](https://adam-p.ca/blog/2022/03/x-forwarded-for/):

    <spoofed address>, <client address>, <proxy 1 address>, <proxy 2 address>

We instead read from the _right_, accounting for the number of trusted proxies. In this case, we would use `XFF_DEPTH=3`.

> If you need to read the left-most address instead (and don’t care about spoofing) — for example, to offer a geolocation service, where it’s more important for the IP address to be _real_ than _trusted_, you can do so by inspecting the `x-forwarded-for` header within your app.

### BODY\_SIZE\_LIMIT[](#Environment-variables-BODY_SIZE_LIMIT)

The maximum request body size to accept in bytes including while streaming. The body size can also be specified with a unit suffix for kilobytes (`K`), megabytes (`M`), or gigabytes (`G`). For example, `512K` or `1M`. Defaults to 512kb. You can disable this option with a value of `Infinity` (0 in older versions of the adapter) and implement a custom check in [`handle`](hooks#Server-hooks-handle) if you need something more advanced.

### SHUTDOWN\_TIMEOUT[](#Environment-variables-SHUTDOWN_TIMEOUT)

The number of seconds to wait before forcefully closing any remaining connections after receiving a `SIGTERM` or `SIGINT` signal. Defaults to `30`. Internally the adapter calls [`closeAllConnections`](https://nodejs.org/api/http.html#servercloseallconnections). See [Graceful shutdown](#Graceful-shutdown) for more details.

### IDLE\_TIMEOUT[](#Environment-variables-IDLE_TIMEOUT)

When using systemd socket activation, `IDLE_TIMEOUT` specifies the number of seconds after which the app is automatically put to sleep when receiving no requests. If not set, the app runs continuously. See [Socket activation](#Socket-activation) for more details.

Options[](#Options)
-------------------

The adapter can be configured with various options:

svelte.config

    import import adapteradapter from '@sveltejs/adapter-node';
    
    export default {
    	kit: {
        adapter: any;
    }kit: {
    		adapter: anyadapter: import adapteradapter({
    			// default options are shown
    			out: stringout: 'build',
    			precompress: booleanprecompress: true,
    			envPrefix: stringenvPrefix: ''
    		})
    	}
    };

### out[](#Options-out)

The directory to build the server to. It defaults to `build` — i.e. `node build` would start the server locally after it has been created.

### precompress[](#Options-precompress)

Enables precompressing using gzip and brotli for assets and prerendered pages. It defaults to `true`.

### envPrefix[](#Options-envPrefix)

If you need to change the name of the environment variables used to configure the deployment (for example, to deconflict with environment variables you don’t control), you can specify a prefix:

    envPrefix: 'MY_CUSTOM_';

    MY_CUSTOM_HOST=127.0.0.1 \
    MY_CUSTOM_PORT=4000 \
    MY_CUSTOM_ORIGIN=https://my.site \
    node build

Graceful shutdown[](#Graceful-shutdown)
---------------------------------------

By default `adapter-node` gracefully shuts down the HTTP server when a `SIGTERM` or `SIGINT` signal is received. It will:

1.  reject new requests ([`server.close`](https://nodejs.org/api/http.html#serverclosecallback))
2.  wait for requests that have already been made but not received a response yet to finish and close connections once they become idle ([`server.closeIdleConnections`](https://nodejs.org/api/http.html#servercloseidleconnections))
3.  and finally, close any remaining connections that are still active after [`SHUTDOWN_TIMEOUT`](#Environment-variables-SHUTDOWN_TIMEOUT) seconds. ([`server.closeAllConnections`](https://nodejs.org/api/http.html#servercloseallconnections))

> If you want to customize this behaviour you can use a [custom server](#Custom-server).

You can listen to the `sveltekit:shutdown` event which is emitted after the HTTP server has closed all connections. Unlike Node’s `exit` event, the `sveltekit:shutdown` event supports asynchronous operations and is always emitted when all connections are closed even if the server has dangling work such as open database connections.

    var process: NodeJS.Processprocess.NodeJS.Process.on(event: string | symbol, listener: (...args: any[]) => void): NodeJS.Process (+12 overloads)Adds the listener function to the end of the listeners array for the event
    named eventName. No checks are made to see if the listener has already
    been added. Multiple calls passing the same combination of eventName and
    listener will result in the listener being added, and called, multiple times.
    server.on('connection', (stream) => {
      console.log('someone connected!');
    });Returns a reference to the EventEmitter, so that calls can be chained.
    By default, event listeners are invoked in the order they are added. The emitter.prependListener() method can be used as an alternative to add the
    event listener to the beginning of the listeners array.
    import { EventEmitter } from 'node:events';
    const myEE = new EventEmitter();
    myEE.on('foo', () => console.log('a'));
    myEE.prependListener('foo', () => console.log('b'));
    myEE.emit('foo');
    // Prints:
    //   b
    //   a@sincev0.1.101@parameventName The name of the event.@paramlistener The callback functionon('sveltekit:shutdown', async (reason: anyreason) => {
      await jobs.stop();
      await db.close();
    });

The parameter `reason` has one of the following values:

*   `SIGINT` - shutdown was triggered by a `SIGINT` signal
*   `SIGTERM` - shutdown was triggered by a `SIGTERM` signal
*   `IDLE` - shutdown was triggered by [`IDLE_TIMEOUT`](#Environment-variables-IDLE_TIMEOUT)

Socket activation[](#Socket-activation)
---------------------------------------

Most Linux operating systems today use a modern process manager called systemd to start the server and run and manage services. You can configure your server to allocate a socket and start and scale your app on demand. This is called [socket activation](http://0pointer.de/blog/projects/socket-activated-containers.html). In this case, the OS will pass two environment variables to your app — `LISTEN_PID` and `LISTEN_FDS`. The adapter will then listen on file descriptor 3 which refers to a systemd socket unit that you will have to create.

> You can still use [`envPrefix`](#Options-envPrefix) with systemd socket activation. `LISTEN_PID` and `LISTEN_FDS` are always read without a prefix.

To take advantage of socket activation follow these steps.

1.  Run your app as a [systemd service](https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html). It can either run directly on the host system or inside a container (using Docker or a systemd portable service for example). If you additionally pass an [`IDLE_TIMEOUT`](#Environment-variables-IDLE_TIMEOUT) environment variable to your app it will gracefully shutdown if there are no requests for `IDLE_TIMEOUT` seconds. systemd will automatically start your app again when new requests are coming in.

/etc/systemd/system/myapp

    [Service]
    Environment=NODE_ENV=production IDLE_TIMEOUT=60
    ExecStart=/usr/bin/node /usr/bin/myapp/build

2.  Create an accompanying [socket unit](https://www.freedesktop.org/software/systemd/man/latest/systemd.socket.html). The adapter only accepts a single socket.

/etc/systemd/system/myapp

    [Socket]
    ListenStream=3000
    
    [Install]
    WantedBy=sockets.target

3.  Make sure systemd has recognised both units by running `sudo systemctl daemon-reload`. Then enable the socket on boot and start it immediately using `sudo systemctl enable --now myapp.socket`. The app will then automatically start once the first request is made to `localhost:3000`.

Custom server[](#Custom-server)
-------------------------------

The adapter creates two files in your build directory — `index.js` and `handler.js`. Running `index.js` — e.g. `node build`, if you use the default build directory — will start a server on the configured port.

Alternatively, you can import the `handler.js` file, which exports a handler suitable for use with [Express](https://github.com/expressjs/express), [Connect](https://github.com/senchalabs/connect) or [Polka](https://github.com/lukeed/polka) (or even just the built-in [`http.createServer`](https://nodejs.org/dist/latest/docs/api/http.html#httpcreateserveroptions-requestlistener)) and set up your own server:

my-server

    import { import handlerhandler } from './build/handler.js';
    import import expressexpress from 'express';
    
    const const app: anyapp = import expressexpress();
    
    // add a route that lives separately from the SvelteKit app
    const app: anyapp.get('/healthcheck', (req, res) => {
    
    	res: anyres.end('ok');
    });
    
    // let SvelteKit handle everything else, including serving prerendered pages and static assets
    const app: anyapp.use(import handlerhandler);
    
    const app: anyapp.listen(3000, () => {
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('listening on port 3000');
    });

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/40-adapter-node.md) [llms.txt](/docs/kit/adapter-node/llms.txt)

previous next

[Zero-config deployments](/docs/kit/adapter-auto) [Static site generation](/docs/kit/adapter-static)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Static site generation
======================

### On this page

*   [Static site generation](/docs/kit/adapter-static)
*   [Usage](#Usage)
*   [Zero-config support](#Zero-config-support)
*   [Options](#Options)
*   [GitHub Pages](#GitHub-Pages)

To use SvelteKit as a static site generator (SSG), use [`adapter-static`](https://github.com/sveltejs/kit/tree/main/packages/adapter-static).

This will prerender your entire site as a collection of static files. If you’d like to prerender only some pages and dynamically server-render others, you will need to use a different adapter together with [the `prerender` option](page-options#prerender).

Usage[](#Usage)
---------------

Install with `npm i -D @sveltejs/adapter-static`, then add the adapter to your `svelte.config.js`:

svelte.config

    import import adapteradapter from '@sveltejs/adapter-static';
    
    export default {
    	kit: {
        adapter: any;
    }kit: {
    		adapter: anyadapter: import adapteradapter({
    			// default options are shown. On some platforms
    			// these options are set automatically — see below
    			pages: stringpages: 'build',
    			assets: stringassets: 'build',
    			fallback: undefinedfallback: var undefinedundefined,
    			precompress: booleanprecompress: false,
    			strict: booleanstrict: true
    		})
    	}
    };

...and add the [`prerender`](page-options#prerender) option to your root layout:

src/routes/+layout

    // This can be false if you're using a fallback (i.e. SPA mode)
    export const const prerender: trueprerender = true;

> You must ensure SvelteKit’s [`trailingSlash`](page-options#trailingSlash) option is set appropriately for your environment. If your host does not render `/a.html` upon receiving a request for `/a` then you will need to set `trailingSlash: 'always'` in your root layout to create `/a/index.html` instead.

Zero-config support[](#Zero-config-support)
-------------------------------------------

Some platforms have zero-config support (more to come in future):

*   [Vercel](https://vercel.com)

On these platforms, you should omit the adapter options so that `adapter-static` can provide the optimal configuration:

svelte.config

    export default {
    	kit: {
        adapter: any;
    }kit: {
    		adapter: anyadapter: adapter({...})
    	}
    };

Options[](#Options)
-------------------

### pages[](#Options-pages)

The directory to write prerendered pages to. It defaults to `build`.

### assets[](#Options-assets)

The directory to write static assets (the contents of `static`, plus client-side JS and CSS generated by SvelteKit) to. Ordinarily this should be the same as `pages`, and it will default to whatever the value of `pages` is, but in rare circumstances you might need to output pages and assets to separate locations.

### fallback[](#Options-fallback)

Specify a fallback page for [SPA mode](single-page-apps), e.g. `index.html` or `200.html` or `404.html`.

### precompress[](#Options-precompress)

If `true`, precompresses files with brotli and gzip. This will generate `.br` and `.gz` files.

### strict[](#Options-strict)

By default, `adapter-static` checks that either all pages and endpoints (if any) of your app were prerendered, or you have the `fallback` option set. This check exists to prevent you from accidentally publishing an app where some parts of it are not accessible, because they are not contained in the final output. If you know this is ok (for example when a certain page only exists conditionally), you can set `strict` to `false` to turn off this check.

GitHub Pages[](#GitHub-Pages)
-----------------------------

When building for [GitHub Pages](https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages), if your repo name is not equivalent to `your-username.github.io`, make sure to update [`config.kit.paths.base`](configuration#paths) to match your repo name. This is because the site will be served from `https://your-username.github.io/your-repo-name` rather than from the root.

You’ll also want to generate a fallback `404.html` page to replace the default 404 page shown by GitHub Pages.

A config for GitHub Pages might look like the following:

svelte.config

    import import adapteradapter from '@sveltejs/adapter-static';
    
    /** @type {import('@sveltejs/kit').Config} */
    const const config: {
        kit: {
            adapter: any;
            paths: {
     base: string | undefined;
            };
        };
    }@type{import('@sveltejs/kit').Config}config = {
    	kit: {
        adapter: any;
        paths: {
            base: string | undefined;
        };
    }kit: {
    		adapter: anyadapter: import adapteradapter({
    			fallback: stringfallback: '404.html'
    		}),
    		paths: {
        base: string | undefined;
    }paths: {
    			base: string | undefinedbase: var process: NodeJS.Processprocess.NodeJS.Process.argv: string[]The process.argv property returns an array containing the command-line
    arguments passed when the Node.js process was launched. The first element will
    be 
    {@link 
    execPath
    }
    . See process.argv0 if access to the original value
    of argv[0] is needed. The second element will be the path to the JavaScript
    file being executed. The remaining elements will be any additional command-line
    arguments.
    For example, assuming the following script for process-args.js:
    import { argv } from 'node:process';
    
    // print process.argv
    argv.forEach((val, index) => {
      console.log(`${index}: ${val}`);
    });Launching the Node.js process as:
    node process-args.js one two=three fourWould generate the output:
    0: /usr/local/bin/node
    1: /Users/mjr/work/node/process-args.js
    2: one
    3: two=three
    4: four@sincev0.1.27argv.Array<string>.includes(searchElement: string, fromIndex?: number): booleanDetermines whether an array includes a certain element, returning true or false as appropriate.
    @paramsearchElement The element to search for.@paramfromIndex The position in this array at which to begin searching for searchElement.includes('dev') ? '' : var process: NodeJS.Processprocess.NodeJS.Process.env: NodeJS.ProcessEnvThe process.env property returns an object containing the user environment.
    See environ(7).
    An example of this object looks like:
    {
      TERM: 'xterm-256color',
      SHELL: '/usr/local/bin/bash',
      USER: 'maciej',
      PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
      PWD: '/Users/maciej',
      EDITOR: 'vim',
      SHLVL: '1',
      HOME: '/Users/maciej',
      LOGNAME: 'maciej',
      _: '/usr/local/bin/node'
    }It is possible to modify this object, but such modifications will not be
    reflected outside the Node.js process, or (unless explicitly requested)
    to other Worker threads.
    In other words, the following example would not work:
    node -e 'process.env.foo = "bar"' &#x26;#x26;&#x26;#x26; echo $fooWhile the following will:
    import { env } from 'node:process';
    
    env.foo = 'bar';
    console.log(env.foo);Assigning a property on process.env will implicitly convert the value
    to a string. This behavior is deprecated. Future versions of Node.js may
    throw an error when the value is not a string, number, or boolean.
    import { env } from 'node:process';
    
    env.test = null;
    console.log(env.test);
    // => 'null'
    env.test = undefined;
    console.log(env.test);
    // => 'undefined'Use delete to delete a property from process.env.
    import { env } from 'node:process';
    
    env.TEST = 1;
    delete env.TEST;
    console.log(env.TEST);
    // => undefinedOn Windows operating systems, environment variables are case-insensitive.
    import { env } from 'node:process';
    
    env.TEST = 1;
    console.log(env.test);
    // => 1Unless explicitly specified when creating a Worker instance,
    each Worker thread has its own copy of process.env, based on its
    parent thread’s process.env, or whatever was specified as the env option
    to the Worker constructor. Changes to process.env will not be visible
    across Worker threads, and only the main thread can make changes that
    are visible to the operating system or to native add-ons. On Windows, a copy of process.env on a Worker instance operates in a case-sensitive manner
    unlike the main thread.
    @sincev0.1.27env.string | undefinedBASE_PATH
    		}
    	}
    };
    
    export default const config: {
        kit: {
            adapter: any;
            paths: {
     base: string | undefined;
            };
        };
    }@type{import('@sveltejs/kit').Config}config;

You can use GitHub actions to automatically deploy your site to GitHub Pages when you make a change. Here’s an example workflow:

.github/workflows/deploy

    name: Deploy to GitHub Pages
    
    on:
      push:
        branches: 'main'
    
    jobs:
      build_site:
        runs-on: ubuntu-latest
        steps:
          - name: Checkout
            uses: actions/checkout@v4
    
          # If you're using pnpm, add this step then change the commands and cache key below to use `pnpm`
          # - name: Install pnpm
          #   uses: pnpm/action-setup@v3
          #   with:
          #     version: 8
    
          - name: Install Node.js
            uses: actions/setup-node@v4
            with:
     node-version: 20
     cache: npm
    
          - name: Install dependencies
            run: npm install
    
          - name: build
            env:
     BASE_PATH: '/${{ github.event.repository.name }}'
            run: |
     npm run build
    
          - name: Upload Artifacts
            uses: actions/upload-pages-artifact@v3
            with:
     # this should match the `pages` option in your adapter-static options
     path: 'build/'
    
      deploy:
        needs: build_site
        runs-on: ubuntu-latest
    
        permissions:
          pages: write
          id-token: write
    
        environment:
          name: github-pages
          url: ${{ steps.deployment.outputs.page_url }}
    
        steps:
          - name: Deploy
            id: deployment
            uses: actions/deploy-pages@v4

If you’re not using GitHub actions to deploy your site (for example, you’re pushing the built site to its own repo), add an empty `.nojekyll` file in your `static` directory to prevent Jekyll from interfering.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/50-adapter-static.md) [llms.txt](/docs/kit/adapter-static/llms.txt)

previous next

[Node servers](/docs/kit/adapter-node) [Single-page apps](/docs/kit/single-page-apps)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Single-page apps
================

### On this page

*   [Single-page apps](/docs/kit/single-page-apps)
*   [Usage](#Usage)
*   [Apache](#Apache)
*   [Prerendering individual pages](#Prerendering-individual-pages)

You can turn any SvelteKit app, using any adapter, into a fully client-rendered single-page app (SPA) by disabling SSR at the root layout:

src/routes/+layout

    export const const ssr: falsessr = false;

> In most situations this is not recommended: it harms SEO, tends to slow down perceived performance, and makes your app inaccessible to users if JavaScript fails or is disabled (which happens [more often than you probably think](https://kryogenix.org/code/browser/everyonehasjs.html)).

If you don’t have any server-side logic (i.e. `+page.server.js`, `+layout.server.js` or `+server.js` files) you can use [`adapter-static`](adapter-static) to create your SPA by adding a _fallback page_.

Usage[](#Usage)
---------------

Install with `npm i -D @sveltejs/adapter-static`, then add the adapter to your `svelte.config.js` with the following options:

svelte.config

    import import adapteradapter from '@sveltejs/adapter-static';
    
    export default {
    	kit: {
        adapter: any;
    }kit: {
    		adapter: anyadapter: import adapteradapter({
    			fallback: stringfallback: '200.html' // may differ from host to host
    		})
    	}
    };

The `fallback` page is an HTML page created by SvelteKit from your page template (e.g. `app.html`) that loads your app and navigates to the correct route. For example [Surge](https://surge.sh/help/adding-a-200-page-for-client-side-routing), a static web host, lets you add a `200.html` file that will handle any requests that don’t correspond to static assets or prerendered pages.

On some hosts it may be `index.html` or something else entirely — consult your platform’s documentation.

> Note that the fallback page will always contain absolute asset paths (i.e. beginning with `/` rather than `.`) regardless of the value of [`paths.relative`](configuration#paths), since it is used to respond to requests for arbitrary paths.

Apache[](#Apache)
-----------------

To run an SPA on [Apache](https://httpd.apache.org/), you should add a `static/.htaccess` file to route requests to the fallback page:

    <IfModule mod_rewrite.c>
    	RewriteEngine On
    	RewriteBase /
    	RewriteRule ^200\.html$ - [L]
    	RewriteCond %{REQUEST_FILENAME} !-f
    	RewriteCond %{REQUEST_FILENAME} !-d
    	RewriteRule . /200.html [L]
    </IfModule>

Prerendering individual pages[](#Prerendering-individual-pages)
---------------------------------------------------------------

If you want certain pages to be prerendered, you can re-enable `ssr` alongside `prerender` for just those parts of your app:

src/routes/my-prerendered-page/+page

    export const const prerender: trueprerender = true;
    export const const ssr: truessr = true;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/55-single-page-apps.md) [llms.txt](/docs/kit/single-page-apps/llms.txt)

previous next

[Static site generation](/docs/kit/adapter-static) [Cloudflare](/docs/kit/adapter-cloudflare)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Cloudflare
==========

### On this page

*   [Cloudflare](/docs/kit/adapter-cloudflare)
*   [Comparisons](#Comparisons)
*   [Usage](#Usage)
*   [Options](#Options)
*   [Cloudflare Workers](#Cloudflare-Workers)
*   [Cloudflare Pages](#Cloudflare-Pages)
*   [Runtime APIs](#Runtime-APIs)
*   [Headers and redirects](#Headers-and-redirects)
*   [Troubleshooting](#Troubleshooting)
*   [Migrating from Workers Sites](#Migrating-from-Workers-Sites)

To deploy to [Cloudflare Workers](https://workers.cloudflare.com/) or [Cloudflare Pages](https://pages.cloudflare.com/), use [`adapter-cloudflare`](https://github.com/sveltejs/kit/tree/main/packages/adapter-cloudflare).

This adapter will be installed by default when you use [`adapter-auto`](adapter-auto). If you plan on staying with Cloudflare, you can switch from [`adapter-auto`](adapter-auto) to using this adapter directly so that `event.platform` is emulated during local development, type declarations are automatically applied, and the ability to set Cloudflare-specific options is provided.

Comparisons[](#Comparisons)
---------------------------

*   `adapter-cloudflare` – supports all SvelteKit features; builds for Cloudflare Workers Static Assets and Cloudflare Pages
*   `adapter-cloudflare-workers` – deprecated. Supports all SvelteKit features; builds for Cloudflare Workers Sites
*   `adapter-static` – only produces client-side static assets; compatible with Cloudflare Workers Static Assets and Cloudflare Pages

Usage[](#Usage)
---------------

Install with `npm i -D @sveltejs/adapter-cloudflare`, then add the adapter to your `svelte.config.js`:

svelte.config

    import import adapteradapter from '@sveltejs/adapter-cloudflare';
    
    export default {
    	kit: {
        adapter: any;
    }kit: {
    		adapter: anyadapter: import adapteradapter({
    			// See below for an explanation of these options
    			config: undefinedconfig: var undefinedundefined,
    			platformProxy: {
        configPath: undefined;
        environment: undefined;
        persist: undefined;
    }platformProxy: {
    				configPath: undefinedconfigPath: var undefinedundefined,
    				environment: undefinedenvironment: var undefinedundefined,
    				persist: undefinedpersist: var undefinedundefined
    			},
    			fallback: stringfallback: 'plaintext',
    			routes: {
        include: string[];
        exclude: string[];
    }routes: {
    				include: string[]include: ['/*'],
    				exclude: string[]exclude: ['<all>']
    			}
    		})
    	}
    };

Options[](#Options)
-------------------

### config[](#Options-config)

Path to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). If you would like to use a Wrangler configuration filename other than `wrangler.jsonc`, `wrangler.json`, or `wrangler.toml` you can specify it using this option.

### platformProxy[](#Options-platformProxy)

Preferences for the emulated `platform.env` local bindings. See the [getPlatformProxy](https://developers.cloudflare.com/workers/wrangler/api/#parameters-1) Wrangler API documentation for a full list of options.

### fallback[](#Options-fallback)

Whether to render a plaintext 404.html page or a rendered SPA fallback page for non-matching asset requests.

For Cloudflare Workers, the default behaviour is to return a null-body 404-status response for non-matching assets requests. However, if the [`assets.not_found_handling`](https://developers.cloudflare.com/workers/static-assets/routing/#2-not_found_handling) Wrangler configuration setting is set to `"404-page"`, this page will be served if a request fails to match an asset. If `assets.not_found_handling` is set to `"single-page-application"`, the adapter will render a SPA fallback index.html page regardless of the `fallback` option specified.

For Cloudflare Pages, this page will only be served when a request that matches an entry in `routes.exclude` fails to match an asset.

Most of the time `plaintext` is sufficient, but if you are using `routes.exclude` to manually exclude a set of prerendered pages without exceeding the 100 route limit, you may wish to use `spa` instead to avoid showing an unstyled 404 page to users.

See Cloudflare Pages’ [Not Found behaviour](https://developers.cloudflare.com/pages/configuration/serving-pages/#not-found-behavior) for more info.

### routes[](#Options-routes)

Only for Cloudflare Pages. Allows you to customise the [`_routes.json`](https://developers.cloudflare.com/pages/functions/routing/#create-a-_routesjson-file) file generated by `adapter-cloudflare`.

*   `include` defines routes that will invoke a function, and defaults to `['/*']`
*   `exclude` defines routes that will _not_ invoke a function — this is a faster and cheaper way to serve your app’s static assets. This array can include the following special values:
    *   `<build>` contains your app’s build artifacts (the files generated by Vite)
    *   `<files>` contains the contents of your `static` directory
    *   `<prerendered>` contains a list of prerendered pages
    *   `<all>` (the default) contains all of the above

You can have up to 100 `include` and `exclude` rules combined. Generally you can omit the `routes` options, but if (for example) your `<prerendered>` paths exceed that limit, you may find it helpful to manually create an `exclude` list that includes `'/articles/*'` instead of the auto-generated `['/articles/foo', '/articles/bar', '/articles/baz', ...]`.

Cloudflare Workers[](#Cloudflare-Workers)
-----------------------------------------

### Basic configuration[](#Cloudflare-Workers-Basic-configuration)

When building for Cloudflare Workers, this adapter expects to find a [Wrangler configuration file](https://developers.cloudflare.com/workers/configuration/sites/configuration/) in the project root. It should look something like this:

wrangler

    {
    	"name": "<any-name-you-want>",
    	"main": ".svelte-kit/cloudflare/_worker.js",
    	"compatibility_date": "2025-01-01",
    	"assets": {
    		"binding": "ASSETS",
    		"directory": ".svelte-kit/cloudflare",
    	}
    }

### Deployment[](#Cloudflare-Workers-Deployment)

Please follow the [framework guide](https://developers.cloudflare.com/workers/frameworks/framework-guides/svelte/) for Cloudflare Workers to begin.

Cloudflare Pages[](#Cloudflare-Pages)
-------------------------------------

### Deployment[](#Cloudflare-Pages-Deployment)

Please follow the [Get Started Guide](https://developers.cloudflare.com/pages/get-started/) for Cloudflare Pages to begin.

If you’re using the [Git integration](https://developers.cloudflare.com/pages/get-started/git-integration/), your build settings should look like this:

*   Framework preset – SvelteKit
*   Build command – `npm run build` or `vite build`
*   Build output directory – `.svelte-kit/cloudflare`

### Further reading[](#Cloudflare-Pages-Further-reading)

You may wish to refer to [Cloudflare’s documentation for deploying a SvelteKit site on Cloudflare Pages](https://developers.cloudflare.com/pages/framework-guides/deploy-a-svelte-kit-site/).

### Notes[](#Cloudflare-Pages-Notes)

Functions contained in the [`/functions` directory](https://developers.cloudflare.com/pages/functions/routing/) at the project’s root will _not_ be included in the deployment. Instead, functions should be implemented as [server endpoints](routing#server) in your SvelteKit app, which is compiled to a [single `_worker.js` file](https://developers.cloudflare.com/pages/functions/advanced-mode/).

Runtime APIs[](#Runtime-APIs)
-----------------------------

The [`env`](https://developers.cloudflare.com/workers/runtime-apis/fetch-event#parameters) object contains your project’s [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/), which consist of KV/DO namespaces, etc. It is passed to SvelteKit via the `platform` property, along with [`context`](https://developers.cloudflare.com/workers/runtime-apis/context/), [`caches`](https://developers.cloudflare.com/workers/runtime-apis/cache/), and [`cf`](https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties), meaning that you can access it in hooks and endpoints:

    export async function function POST({ request, platform }: {
        request: any;
        platform: any;
    }): Promise<void>POST({ request, platform }) {
    
    	const const x: anyx = platform: anyplatform.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');
    }

> SvelteKit’s built-in [`$env` module]($env-static-private) should be preferred for environment variables.

To make these types available to your app, install [`@cloudflare/workers-types`](https://www.npmjs.com/package/@cloudflare/workers-types) and reference them in your `src/app.d.ts`:

src/app.d

    import { interface KVNamespace<Key extends string = string>KVNamespace, interface DurableObjectNamespace<T extends Rpc.DurableObjectBranded | undefined = undefined>DurableObjectNamespace } from '@cloudflare/workers-types';
    
    declare global {
    	namespace App {
    		interface interface App.PlatformIf your adapter provides platform-specific context via event.platform, you can specify it here.
    Platform {
    			App.Platform.env?: {
        YOUR_KV_NAMESPACE: KVNamespace;
        YOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;
    } | undefinedenv?: {
    				type YOUR_KV_NAMESPACE: KVNamespace<string>YOUR_KV_NAMESPACE: interface KVNamespace<Key extends string = string>KVNamespace;
    				type YOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace<undefined>YOUR_DURABLE_OBJECT_NAMESPACE: interface DurableObjectNamespace<T extends Rpc.DurableObjectBranded | undefined = undefined>DurableObjectNamespace;
    			};
    		}
    	}
    }
    
    export {};

### Testing locally[](#Runtime-APIs-Testing-locally)

Cloudflare specific values in the `platform` property are emulated during dev and preview modes. Local [bindings](https://developers.cloudflare.com/workers/wrangler/configuration/#bindings) are created based on your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/) and are used to populate `platform.env` during development and preview. Use the adapter config [`platformProxy` option](#Options-platformProxy) to change your preferences for the bindings.

For testing the build, you should use [Wrangler](https://developers.cloudflare.com/workers/wrangler/) version 4. Once you have built your site, run `wrangler dev .svelte-kit/cloudflare` if you’re testing for Cloudflare Workers or `wrangler pages dev .svelte-kit/cloudflare` for Cloudflare Pages.

Headers and redirects[](#Headers-and-redirects)
-----------------------------------------------

The [`_headers`](https://developers.cloudflare.com/pages/configuration/headers/) and [`_redirects`](https://developers.cloudflare.com/pages/configuration/redirects/) files, specific to Cloudflare, can be used for static asset responses (like images) by putting them into the project root folder.

However, they will have no effect on responses dynamically rendered by SvelteKit, which should return custom headers or redirect responses from [server endpoints](routing#server) or with the [`handle`](hooks#Server-hooks-handle) hook.

Troubleshooting[](#Troubleshooting)
-----------------------------------

### Node.js compatibility[](#Troubleshooting-Node.js-compatibility)

If you would like to enable [Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/), you can add the `nodejs_compat` compatibility flag to your Wrangler configuration file:

wrangler

    {
    	"compatibility_flags": ["nodejs_compat"]
    }

### Worker size limits[](#Troubleshooting-Worker-size-limits)

When deploying your application, the server generated by SvelteKit is bundled into a single file. Wrangler will fail to publish your worker if it exceeds [the size limits](https://developers.cloudflare.com/workers/platform/limits/#worker-size) after minification. You’re unlikely to hit this limit usually, but some large libraries can cause this to happen. In that case, you can try to reduce the size of your worker by only importing such libraries on the client side. See [the FAQ](./faq#How-do-I-use-a-client-side-library-accessing-document-or-window) for more information.

### Accessing the file system[](#Troubleshooting-Accessing-the-file-system)

You can’t use `fs` in Cloudflare Workers — you must [prerender](page-options#prerender) the routes in question.

Migrating from Workers Sites[](#Migrating-from-Workers-Sites)
-------------------------------------------------------------

Cloudflare no longer recommends using [Workers Sites](https://developers.cloudflare.com/workers/configuration/sites/configuration/) and instead recommends using [Workers Static Assets](https://developers.cloudflare.com/workers/static-assets/). To migrate, replace `@sveltejs/adapter-cloudflare-workers` with `@sveltejs/adapter-cloudflare` and remove all `site` configuration settings from your Wrangler configuration file, then add the `assets.directory` and `assets.binding` configuration settings:

### svelte.config.js[](#Migrating-from-Workers-Sites-svelte.config.js)

svelte.config

    import adapter from '@sveltejs/adapter-cloudflare-workers';
    import import adapteradapter from '@sveltejs/adapter-cloudflare';
    
    export default {
    	kit: {
        adapter: any;
    }kit: {
    		adapter: anyadapter: import adapteradapter()
    	}
    };

### wrangler.toml[](#Migrating-from-Workers-Sites-wrangler.toml)

wrangler

    site.bucket = ".cloudflare/public"
    assets.directory = ".cloudflare/public"
    assets.binding = "ASSETS"

### wrangler.jsonc[](#Migrating-from-Workers-Sites-wrangler.jsonc)

wrangler

    {
    	"site": {
    		"bucket": ".cloudflare/public"
    	},
    	"assets": {
    		"directory": ".cloudflare/public",
    		"binding": "ASSETS"
    	}
    }

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/60-adapter-cloudflare.md) [llms.txt](/docs/kit/adapter-cloudflare/llms.txt)

previous next

[Single-page apps](/docs/kit/single-page-apps) [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Cloudflare Workers
==================

### On this page

*   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
*   [Usage](#Usage)
*   [Options](#Options)
*   [Basic Configuration](#Basic-Configuration)
*   [Runtime APIs](#Runtime-APIs)
*   [Troubleshooting](#Troubleshooting)

> `adapter-cloudflare-workers` has been deprecated in favour of [`adapter-cloudflare`](adapter-cloudflare). We recommend using `adapter-cloudflare` to deploy to Cloudflare Workers with [Static Assets](https://developers.cloudflare.com/workers/static-assets/) since Cloudflare Workers Sites will be deprecated in favour of it.

To deploy to [Cloudflare Workers](https://workers.cloudflare.com/) with [Workers Sites](https://developers.cloudflare.com/workers/configuration/sites/), use `adapter-cloudflare-workers`.

Usage[](#Usage)
---------------

Install with `npm i -D @sveltejs/adapter-cloudflare-workers`, then add the adapter to your `svelte.config.js`:

svelte.config

    import import adapteradapter from '@sveltejs/adapter-cloudflare-workers';
    
    export default {
    	kit: {
        adapter: any;
    }kit: {
    		adapter: anyadapter: import adapteradapter({
    			// see below for options that can be set here
    		})
    	}
    };

Options[](#Options)
-------------------

### config[](#Options-config)

Path to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). If you would like to use a Wrangler configuration filename other than `wrangler.jsonc`, `wrangler.json`, or `wrangler.toml` you can specify it using this option.

### platformProxy[](#Options-platformProxy)

Preferences for the emulated `platform.env` local bindings. See the [getPlatformProxy](https://developers.cloudflare.com/workers/wrangler/api/#parameters-1) Wrangler API documentation for a full list of options.

Basic Configuration[](#Basic-Configuration)
-------------------------------------------

This adapter expects to find a [Wrangler configuration file](https://developers.cloudflare.com/workers/configuration/sites/configuration/) in the project root. It should look something like this:

wrangler

    {
    	"name": "<your-service-name>",
    	"account_id": "<your-account-id>",
    	"main": "./.cloudflare/worker.js",
    	"site": {
    		"bucket": "./.cloudflare/public"
    	},
    	"build": {
    		"command": "npm run build"
    	},
    	"compatibility_date": "2021-11-12"
    }

`<your-service-name>` can be anything. `<your-account-id>` can be found by running `wrangler whoami` using the Wrangler CLI tool or by logging into your [Cloudflare dashboard](https://dash.cloudflare.com) and grabbing it from the end of the URL:

    https://dash.cloudflare.com/<your-account-id>/home

> You should add the `.cloudflare` directory (or whichever directories you specified for `main` and `site.bucket`) and the `.wrangler` directory to your `.gitignore`.

You will need to install [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/) and log in, if you haven’t already:

    npm i -D wrangler
    wrangler login

Then, you can build your app and deploy it:

    wrangler deploy

Runtime APIs[](#Runtime-APIs)
-----------------------------

The [`env`](https://developers.cloudflare.com/workers/runtime-apis/fetch-event#parameters) object contains your project’s [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/), which consist of KV/DO namespaces, etc. It is passed to SvelteKit via the `platform` property, along with [`context`](https://developers.cloudflare.com/workers/runtime-apis/context/), [`caches`](https://developers.cloudflare.com/workers/runtime-apis/cache/), and [`cf`](https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties), meaning that you can access it in hooks and endpoints:

    export async function function POST({ request, platform }: {
        request: any;
        platform: any;
    }): Promise<void>POST({ request, platform }) {
    
    	const const x: anyx = platform: anyplatform.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');
    }

> SvelteKit’s built-in [`$env` module]($env-static-private) should be preferred for environment variables.

To make these types available to your app, install [`@cloudflare/workers-types`](https://www.npmjs.com/package/@cloudflare/workers-types) and reference them in your `src/app.d.ts`:

src/app.d

    import { interface KVNamespace<Key extends string = string>KVNamespace, interface DurableObjectNamespace<T extends Rpc.DurableObjectBranded | undefined = undefined>DurableObjectNamespace } from '@cloudflare/workers-types';
    
    declare global {
    	namespace App {
    		interface interface App.PlatformIf your adapter provides platform-specific context via event.platform, you can specify it here.
    Platform {
    			App.Platform.env?: {
        YOUR_KV_NAMESPACE: KVNamespace;
        YOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;
    } | undefinedenv?: {
    				type YOUR_KV_NAMESPACE: KVNamespace<string>YOUR_KV_NAMESPACE: interface KVNamespace<Key extends string = string>KVNamespace;
    				type YOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace<undefined>YOUR_DURABLE_OBJECT_NAMESPACE: interface DurableObjectNamespace<T extends Rpc.DurableObjectBranded | undefined = undefined>DurableObjectNamespace;
    			};
    		}
    	}
    }
    
    export {};

### Testing Locally[](#Runtime-APIs-Testing-Locally)

Cloudflare Workers specific values in the `platform` property are emulated during dev and preview modes. Local [bindings](https://developers.cloudflare.com/workers/wrangler/configuration/#bindings) are created based on your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/) and are used to populate `platform.env` during development and preview. Use the adapter config [`platformProxy` option](#Options-platformProxy) to change your preferences for the bindings.

For testing the build, you should use [Wrangler](https://developers.cloudflare.com/workers/wrangler/) version 4. Once you have built your site, run `wrangler dev`.

Troubleshooting[](#Troubleshooting)
-----------------------------------

### Node.js compatibility[](#Troubleshooting-Node.js-compatibility)

If you would like to enable [Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/), you can add the `nodejs_compat` compatibility flag to your Wrangler configuration file:

wrangler

    {
    	"compatibility_flags": ["nodejs_compat"]
    }

### Worker size limits[](#Troubleshooting-Worker-size-limits)

When deploying your application, the server generated by SvelteKit is bundled into a single file. Wrangler will fail to publish your worker if it exceeds [the size limits](https://developers.cloudflare.com/workers/platform/limits/#worker-size) after minification. You’re unlikely to hit this limit usually, but some large libraries can cause this to happen. In that case, you can try to reduce the size of your worker by only importing such libraries on the client side. See [the FAQ](./faq#How-do-I-use-a-client-side-library-accessing-document-or-window) for more information.

### Accessing the file system[](#Troubleshooting-Accessing-the-file-system)

You can’t use `fs` in Cloudflare Workers — you must [prerender](page-options#prerender) the routes in question.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/70-adapter-cloudflare-workers.md) [llms.txt](/docs/kit/adapter-cloudflare-workers/llms.txt)

previous next

[Cloudflare](/docs/kit/adapter-cloudflare) [Netlify](/docs/kit/adapter-netlify)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Netlify
=======

### On this page

*   [Netlify](/docs/kit/adapter-netlify)
*   [Usage](#Usage)
*   [Netlify Edge Functions](#Netlify-Edge-Functions)
*   [Netlify alternatives to SvelteKit functionality](#Netlify-alternatives-to-SvelteKit-functionality)
*   [Troubleshooting](#Troubleshooting)

To deploy to Netlify, use [`adapter-netlify`](https://github.com/sveltejs/kit/tree/main/packages/adapter-netlify).

This adapter will be installed by default when you use [`adapter-auto`](adapter-auto), but adding it to your project allows you to specify Netlify-specific options.

Usage[](#Usage)
---------------

Install with `npm i -D @sveltejs/adapter-netlify`, then add the adapter to your `svelte.config.js`:

svelte.config

    import import adapteradapter from '@sveltejs/adapter-netlify';
    
    export default {
    	kit: {
        adapter: any;
    }kit: {
    		// default options are shown
    		adapter: anyadapter: import adapteradapter({
    			// if true, will create a Netlify Edge Function rather
    			// than using standard Node-based functions
    			edge: booleanedge: false,
    
    			// if true, will split your app into multiple functions
    			// instead of creating a single one for the entire app.
    			// if `edge` is true, this option cannot be used
    			split: booleansplit: false
    		})
    	}
    };

Then, make sure you have a [netlify.toml](https://docs.netlify.com/configure-builds/file-based-configuration) file in the project root. This will determine where to write static assets based on the `build.publish` settings, as per this sample configuration:

    [build]
    	command = "npm run build"
    	publish = "build"

If the `netlify.toml` file or the `build.publish` value is missing, a default value of `"build"` will be used. Note that if you have set the publish directory in the Netlify UI to something else then you will need to set it in `netlify.toml` too, or use the default value of `"build"`.

### Node version[](#Usage-Node-version)

New projects will use the current Node LTS version by default. However, if you’re upgrading a project you created a while ago it may be stuck on an older version. See [the Netlify docs](https://docs.netlify.com/configure-builds/manage-dependencies/#node-js-and-javascript) for details on manually specifying a current Node version.

Netlify Edge Functions[](#Netlify-Edge-Functions)
-------------------------------------------------

SvelteKit supports [Netlify Edge Functions](https://docs.netlify.com/netlify-labs/experimental-features/edge-functions/). If you pass the option `edge: true` to the `adapter` function, server-side rendering will happen in a Deno-based edge function that’s deployed close to the site visitor. If set to `false` (the default), the site will deploy to Node-based Netlify Functions.

svelte.config

    import import adapteradapter from '@sveltejs/adapter-netlify';
    
    export default {
    	kit: {
        adapter: any;
    }kit: {
    		adapter: anyadapter: import adapteradapter({
    			// will create a Netlify Edge Function using Deno-based
    			// rather than using standard Node-based functions
    			edge: booleanedge: true
    		})
    	}
    };

Netlify alternatives to SvelteKit functionality[](#Netlify-alternatives-to-SvelteKit-functionality)
---------------------------------------------------------------------------------------------------

You may build your app using functionality provided directly by SvelteKit without relying on any Netlify functionality. Using the SvelteKit versions of these features will allow them to be used in dev mode, tested with integration tests, and to work with other adapters should you ever decide to switch away from Netlify. However, in some scenarios you may find it beneficial to use the Netlify versions of these features. One example would be if you’re migrating an app that’s already hosted on Netlify to SvelteKit.

### \_headers and \_redirects[](#Netlify-alternatives-to-SvelteKit-functionality-_headers-and-_redirects)

The [`_headers`](https://docs.netlify.com/routing/headers/#syntax-for-the-headers-file) and [`_redirects`](https://docs.netlify.com/routing/redirects/redirect-options/) files specific to Netlify can be used for static asset responses (like images) by putting them into the project root folder.

### Redirect rules[](#Netlify-alternatives-to-SvelteKit-functionality-Redirect-rules)

During compilation, redirect rules are automatically appended to your `_redirects` file. (If it doesn’t exist yet, it will be created.) That means:

*   `[[redirects]]` in `netlify.toml` will never match as `_redirects` has a [higher priority](https://docs.netlify.com/routing/redirects/#rule-processing-order). So always put your rules in the [`_redirects` file](https://docs.netlify.com/routing/redirects/#syntax-for-the-redirects-file).
*   `_redirects` shouldn’t have any custom “catch all” rules such as `/* /foobar/:splat`. Otherwise the automatically appended rule will never be applied as Netlify is only processing [the first matching rule](https://docs.netlify.com/routing/redirects/#rule-processing-order).

### Netlify Forms[](#Netlify-alternatives-to-SvelteKit-functionality-Netlify-Forms)

1.  Create your Netlify HTML form as described [here](https://docs.netlify.com/forms/setup/#html-forms), e.g. as `/routes/contact/+page.svelte`. (Don’t forget to add the hidden `form-name` input element!)
2.  Netlify’s build bot parses your HTML files at deploy time, which means your form must be [prerendered](page-options#prerender) as HTML. You can either add `export const prerender = true` to your `contact.svelte` to prerender just that page or set the `kit.prerender.force: true` option to prerender all pages.
3.  If your Netlify form has a [custom success message](https://docs.netlify.com/forms/setup/#success-messages) like `<form netlify ... action="/success">` then ensure the corresponding `/routes/success/+page.svelte` exists and is prerendered.

### Netlify Functions[](#Netlify-alternatives-to-SvelteKit-functionality-Netlify-Functions)

With this adapter, SvelteKit endpoints are hosted as [Netlify Functions](https://docs.netlify.com/functions/overview/). Netlify function handlers have additional context, including [Netlify Identity](https://docs.netlify.com/visitor-access/identity/) information. You can access this context via the `event.platform.context` field inside your hooks and `+page.server` or `+layout.server` endpoints. These are [serverless functions](https://docs.netlify.com/functions/overview/) when the `edge` property is `false` in the adapter config or [edge functions](https://docs.netlify.com/edge-functions/overview/#app) when it is `true`.

+page.server

    export const const load: (event: any) => Promise<void>load = async (event) => {
    	const const context: anycontext = event: anyevent.platform.context;
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(const context: anycontext); // shows up in your functions log in the Netlify app
    };

Additionally, you can add your own Netlify functions by creating a directory for them and adding the configuration to your `netlify.toml` file. For example:

    [build]
    	command = "npm run build"
    	publish = "build"
    
    [functions]
    	directory = "functions"

Troubleshooting[](#Troubleshooting)
-----------------------------------

### Accessing the file system[](#Troubleshooting-Accessing-the-file-system)

You can’t use `fs` in edge deployments.

You _can_ use it in serverless deployments, but it won’t work as expected, since files are not copied from your project into your deployment. Instead, use the [`read`]($app-server#read) function from `$app/server` to access your files. `read` does not work inside edge deployments (this may change in future).

Alternatively, you can [prerender](page-options#prerender) the routes in question.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/80-adapter-netlify.md) [llms.txt](/docs/kit/adapter-netlify/llms.txt)

previous next

[Cloudflare Workers](/docs/kit/adapter-cloudflare-workers) [Vercel](/docs/kit/adapter-vercel)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Vercel
======

### On this page

*   [Vercel](/docs/kit/adapter-vercel)
*   [Usage](#Usage)
*   [Deployment configuration](#Deployment-configuration)
*   [Image Optimization](#Image-Optimization)
*   [Incremental Static Regeneration](#Incremental-Static-Regeneration)
*   [Environment variables](#Environment-variables)
*   [Skew protection](#Skew-protection)
*   [Notes](#Notes)
*   [Troubleshooting](#Troubleshooting)

To deploy to Vercel, use [`adapter-vercel`](https://github.com/sveltejs/kit/tree/main/packages/adapter-vercel).

This adapter will be installed by default when you use [`adapter-auto`](adapter-auto), but adding it to your project allows you to specify Vercel-specific options.

Usage[](#Usage)
---------------

Install with `npm i -D @sveltejs/adapter-vercel`, then add the adapter to your `svelte.config.js`:

svelte.config

    import function adapter(config?: Config): Adapteradapter from '@sveltejs/adapter-vercel';
    
    export default {
    	kit: {
        adapter: Adapter;
    }kit: {
    		adapter: Adapteradapter: function adapter(config?: Config): Adapteradapter({
    			// see below for options that can be set here
    		})
    	}
    };

Deployment configuration[](#Deployment-configuration)
-----------------------------------------------------

To control how your routes are deployed to Vercel as functions, you can specify deployment configuration, either through the option shown above or with [`export const config`](page-options#config) inside `+server.js`, `+page(.server).js` and `+layout(.server).js` files.

For example you could deploy some parts of your app as [Edge Functions](https://vercel.com/docs/concepts/functions/edge-functions)...

about/+page

    /** @type {import('@sveltejs/adapter-vercel').Config} */
    export const const config: {
        runtime: string;
    }@type{import('@sveltejs/adapter-vercel').Config}config = {
    	runtime: stringruntime: 'edge'
    };

    import type { type Config = (EdgeConfig | ServerlessConfig) & {
        images?: ImagesConfig;
    }Config } from '@sveltejs/adapter-vercel';
    
    export const const config: Configconfig: type Config = (EdgeConfig | ServerlessConfig) & {
        images?: ImagesConfig;
    }Config = {
    	runtime: "edge"runtime: 'edge'
    };

...and others as [Serverless Functions](https://vercel.com/docs/concepts/functions/serverless-functions) (note that by specifying `config` inside a layout, it applies to all child pages):

admin/+layout

    /** @type {import('@sveltejs/adapter-vercel').Config} */
    export const const config: {
        runtime: string;
    }@type{import('@sveltejs/adapter-vercel').Config}config = {
    	runtime: stringruntime: 'nodejs22.x'
    };

    import type { type Config = (EdgeConfig | ServerlessConfig) & {
        images?: ImagesConfig;
    }Config } from '@sveltejs/adapter-vercel';
    
    export const const config: Configconfig: type Config = (EdgeConfig | ServerlessConfig) & {
        images?: ImagesConfig;
    }Config = {
    	ServerlessConfig.runtime?: `nodejs${number}.x` | undefinedWhether to use Edge Functions ('edge') or Serverless Functions ('nodejs18.x', 'nodejs20.x' etc).
    @defaultSame as the build environmentruntime: 'nodejs22.x'
    };

The following options apply to all functions:

*   `runtime`: `'edge'`, `'nodejs18.x'`, `'nodejs20.x'` or `'nodejs22.x'`. By default, the adapter will select the `'nodejs<version>.x'` corresponding to the Node version your project is configured to use on the Vercel dashboard
*   `regions`: an array of [edge network regions](https://vercel.com/docs/concepts/edge-network/regions) (defaulting to `["iad1"]` for serverless functions) or `'all'` if `runtime` is `edge` (its default). Note that multiple regions for serverless functions are only supported on Enterprise plans
*   `split`: if `true`, causes a route to be deployed as an individual function. If `split` is set to `true` at the adapter level, all routes will be deployed as individual functions

Additionally, the following option applies to edge functions:

*   `external`: an array of dependencies that esbuild should treat as external when bundling functions. This should only be used to exclude optional dependencies that will not run outside Node

And the following option apply to serverless functions:

*   `memory`: the amount of memory available to the function. Defaults to `1024` Mb, and can be decreased to `128` Mb or [increased](https://vercel.com/docs/concepts/limits/overview#serverless-function-memory) in 64Mb increments up to `3008` Mb on Pro or Enterprise accounts
*   `maxDuration`: [maximum execution duration](https://vercel.com/docs/functions/runtimes#max-duration) of the function. Defaults to `10` seconds for Hobby accounts, `15` for Pro and `900` for Enterprise
*   `isr`: configuration Incremental Static Regeneration, described below

If your functions need to access data in a specific region, it’s recommended that they be deployed in the same region (or close to it) for optimal performance.

Image Optimization[](#Image-Optimization)
-----------------------------------------

You may set the `images` config to control how Vercel builds your images. See the [image configuration reference](https://vercel.com/docs/build-output-api/v3/configuration#images) for full details. As an example, you may set:

svelte.config

    import function adapter(config?: Config): Adapteradapter from '@sveltejs/adapter-vercel';
    
    export default {
    	kit: {
        adapter: Adapter;
    }kit: {
    		adapter: Adapteradapter: function adapter(config?: Config): Adapteradapter({
    			images?: ImagesConfig | undefinedhttps://vercel.com/docs/build-output-api/v3/configuration#images
    images: {
    				sizes: number[]sizes: [640, 828, 1200, 1920, 3840],
    				formats?: ImageFormat[] | undefinedformats: ['image/avif', 'image/webp'],
    				minimumCacheTTL?: number | undefinedminimumCacheTTL: 300,
    				domains: string[]domains: ['example-app.vercel.app'],
    			}
    		})
    	}
    };

Incremental Static Regeneration[](#Incremental-Static-Regeneration)
-------------------------------------------------------------------

Vercel supports [Incremental Static Regeneration](https://vercel.com/docs/incremental-static-regeneration) (ISR), which provides the performance and cost advantages of prerendered content with the flexibility of dynamically rendered content.

> Use ISR only on routes where every visitor should see the same content (much like when you prerender). If there’s anything user-specific happening (like session cookies), they should happen on the client via JavaScript only to not leak sensitive information across visits

To add ISR to a route, include the `isr` property in your `config` object:

    import { import BYPASS_TOKENBYPASS_TOKEN } from '$env/static/private';
    
    export const const config: {
        isr: {
            expiration: number;
            bypassToken: any;
            allowQuery: string[];
        };
    }config = {
    	isr: {
        expiration: number;
        bypassToken: any;
        allowQuery: string[];
    }isr: {
    		expiration: numberexpiration: 60,
    		bypassToken: anybypassToken: import BYPASS_TOKENBYPASS_TOKEN,
    		allowQuery: string[]allowQuery: ['search']
    	}
    };

> Using ISR on a route with `export const prerender = true` will have no effect, since the route is prerendered at build time

The `expiration` property is required; all others are optional. The properties are discussed in more detail below.

### expiration[](#Incremental-Static-Regeneration-expiration)

The expiration time (in seconds) before the cached asset will be re-generated by invoking the Serverless Function. Setting the value to `false` means it will never expire. In that case, you likely want to define a bypass token to re-generate on demand.

### bypassToken[](#Incremental-Static-Regeneration-bypassToken)

A random token that can be provided in the URL to bypass the cached version of the asset, by requesting the asset with a `__prerender_bypass=<token>` cookie.

Making a `GET` or `HEAD` request with `x-prerender-revalidate: <token>` will force the asset to be re-validated.

Note that the `BYPASS_TOKEN` string must be at least 32 characters long. You could generate one using the JavaScript console like so:

    var crypto: CryptoMDN Reference
    crypto.Crypto.randomUUID(): `${string}-${string}-${string}-${string}-${string}`Available only in secure contexts.
    MDN Reference
    randomUUID();

Set this string as an environment variable on Vercel by logging in and going to your project then Settings > Environment Variables. For “Key” put `BYPASS_TOKEN` and for “value” use the string generated above, then hit “Save”.

To get this key known about for local development, you can use the [Vercel CLI](https://vercel.com/docs/cli/env) by running the `vercel env pull` command locally like so:

    vercel env pull .env.development.local

### allowQuery[](#Incremental-Static-Regeneration-allowQuery)

A list of valid query parameters that contribute to the cache key. Other parameters (such as utm tracking codes) will be ignored, ensuring that they do not result in content being re-generated unnecessarily. By default, query parameters are ignored.

> Pages that are [prerendered](page-options#prerender) will ignore ISR configuration.

Environment variables[](#Environment-variables)
-----------------------------------------------

Vercel makes a set of [deployment-specific environment variables](https://vercel.com/docs/concepts/projects/environment-variables#system-environment-variables) available. Like other environment variables, these are accessible from `$env/static/private` and `$env/dynamic/private` (sometimes — more on that later), and inaccessible from their public counterparts. To access one of these variables from the client:

+layout.server

    import { import VERCEL_COMMIT_REFVERCEL_COMMIT_REF } from '$env/static/private';
    
    /** @type {import('./$types').LayoutServerLoad} */
    export function function load(): {
        deploymentGitBranch: any;
    }@type{import('./$types').LayoutServerLoad}load() {
    	return {
    		deploymentGitBranch: anydeploymentGitBranch: import VERCEL_COMMIT_REFVERCEL_COMMIT_REF
    	};
    }

    import { import VERCEL_COMMIT_REFVERCEL_COMMIT_REF } from '$env/static/private';
    import type { type LayoutServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type LayoutServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad } from './$types';
    
    export const const load: LayoutServerLoadload: type LayoutServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type LayoutServerLoad = (event: Kit.ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>LayoutServerLoad = () => {
    	return {
    		deploymentGitBranch: anydeploymentGitBranch: import VERCEL_COMMIT_REFVERCEL_COMMIT_REF
    	};
    };

+layout

    <script>
    	/** @type {import('./$types').LayoutProps} */
    	let { data } = $props();
    </script>
    
    <p>This staging environment was deployed from {data.deploymentGitBranch}.</p>

    <script lang="ts">
    	import type { LayoutProps } from './$types';
    
    	let { data }: LayoutProps = $props();
    </script>
    
    <p>This staging environment was deployed from {data.deploymentGitBranch}.</p>

Since all of these variables are unchanged between build time and run time when building on Vercel, we recommend using `$env/static/private` — which will statically replace the variables, enabling optimisations like dead code elimination — rather than `$env/dynamic/private`.

Skew protection[](#Skew-protection)
-----------------------------------

When a new version of your app is deployed, assets belonging to the previous version may no longer be accessible. If a user is actively using your app when this happens, it can cause errors when they navigate — this is known as _version skew_. SvelteKit mitigates this by detecting errors resulting from version skew and causing a hard reload to get the latest version of the app, but this will cause any client-side state to be lost. (You can also proactively mitigate it by observing [`updated.current`]($app-state#updated) from `$app/state`, which tells clients when a new version has been deployed.)

[Skew protection](https://vercel.com/docs/deployments/skew-protection) is a Vercel feature that routes client requests to their original deployment. When a user visits your app, a cookie is set with the deployment ID, and any subsequent requests will be routed to that deployment for as long as skew protection is active. When they reload the page, they will get the newest deployment. (`updated.current` is exempted from this behaviour, and so will continue to report new deployments.) To enable it, visit the Advanced section of your project settings on Vercel.

Cookie-based skew protection comes with one caveat: if a user has multiple versions of your app open in multiple tabs, requests from older versions will be routed to the newer one, meaning they will fall back to SvelteKit’s built-in skew protection.

Notes[](#Notes)
---------------

### Vercel functions[](#Notes-Vercel-functions)

If you have Vercel functions contained in the `api` directory at the project’s root, any requests for `/api/*` will _not_ be handled by SvelteKit. You should implement these as [API routes](routing#server) in your SvelteKit app instead, unless you need to use a non-JavaScript language in which case you will need to ensure that you don’t have any `/api/*` routes in your SvelteKit app.

### Node version[](#Notes-Node-version)

Projects created before a certain date may default to using an older Node version than what SvelteKit currently requires. You can [change the Node version in your project settings](https://vercel.com/docs/concepts/functions/serverless-functions/runtimes/node-js#node.js-version).

Troubleshooting[](#Troubleshooting)
-----------------------------------

### Accessing the file system[](#Troubleshooting-Accessing-the-file-system)

You can’t use `fs` in edge functions.

You _can_ use it in serverless functions, but it won’t work as expected, since files are not copied from your project into your deployment. Instead, use the [`read`]($app-server#read) function from `$app/server` to access your files. `read` does not work inside routes deployed as edge functions (this may change in future).

Alternatively, you can [prerender](page-options#prerender) the routes in question.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/90-adapter-vercel.md) [llms.txt](/docs/kit/adapter-vercel/llms.txt)

previous next

[Netlify](/docs/kit/adapter-netlify) [Writing adapters](/docs/kit/writing-adapters)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBuild and deploy

Writing adapters
================

### On this page

*   [Writing adapters](/docs/kit/writing-adapters)

If an adapter for your preferred environment doesn’t yet exist, you can build your own. We recommend [looking at the source for an adapter](https://github.com/sveltejs/kit/tree/main/packages) to a platform similar to yours and copying it as a starting point.

Adapter packages implement the following API, which creates an `Adapter`:

    /** @param {AdapterSpecificOptions} options */
    export default function (options: any@paramoptions options) {
    	/** @type {import('@sveltejs/kit').Adapter} */
    	const const adapter: Adapter@type{import('@sveltejs/kit').Adapter}adapter = {
    		Adapter.name: stringThe name of the adapter, using for logging. Will typically correspond to the package name.
    name: 'adapter-package-name',
    		async Adapter.adapt: (builder: Builder) => MaybePromise<void>This function is called after SvelteKit has built your app.
    @parambuilder An object provided by SvelteKit that contains methods for adapting the appadapt(builder: Builderbuilder) {
    			// adapter implementation
    		},
    		async Adapter.emulate?: (() => MaybePromise<Emulator>) | undefinedCreates an Emulator, which allows the adapter to influence the environment
    during dev, build and prerendering
    emulate() {
    			return {
    				async Emulator.platform?(details: {
        config: any;
        prerender: PrerenderOption;
    }): MaybePromise<App.Platform>A function that is called with the current route config and prerender option
    and returns an App.Platform object
    platform({ config: anyconfig, prerender: PrerenderOptionprerender }) {
    					// the returned object becomes `event.platform` during dev, build and
    					// preview. Its shape is that of `App.Platform`
    				}
    			}
    		},
    		Adapter.supports?: {
        read?: (details: {
            config: any;
            route: {
                id: string;
            };
        }) => boolean;
    } | undefinedChecks called during dev and build to determine whether specific features will work in production with this adapter
    supports: {
    			read: ({ config: anyconfig, route: {
        id: string;
    }route }) => {
    				// Return `true` if the route with the given `config` can use `read`
    				// from `$app/server` in production, return `false` if it can't.
    				// Or throw a descriptive error describing how to configure the deployment
    			}
    		}
    	};
    
    	return const adapter: Adapter@type{import('@sveltejs/kit').Adapter}adapter;
    }

Of these, `name` and `adapt` are required. `emulate` and `supports` are optional.

Within the `adapt` method, there are a number of things that an adapter should do:

*   Clear out the build directory
*   Write SvelteKit output with `builder.writeClient`, `builder.writeServer`, and `builder.writePrerendered`
*   Output code that:
    *   Imports `Server` from `${builder.getServerDirectory()}/index.js`
    *   Instantiates the app with a manifest generated with `builder.generateManifest({ relativePath })`
    *   Listens for requests from the platform, converts them to a standard [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) if necessary, calls the `server.respond(request, { getClientAddress })` function to generate a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) and responds with it
    *   expose any platform-specific information to SvelteKit via the `platform` option passed to `server.respond`
    *   Globally shims `fetch` to work on the target platform, if necessary. SvelteKit provides a `@sveltejs/kit/node/polyfills` helper for platforms that can use `undici`
*   Bundle the output to avoid needing to install dependencies on the target platform, if necessary
*   Put the user’s static files and the generated JS/CSS in the correct location for the target platform

Where possible, we recommend putting the adapter output under the `build/` directory with any intermediate output placed under `.svelte-kit/[adapter-name]`.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/25-build-and-deploy/99-writing-adapters.md) [llms.txt](/docs/kit/writing-adapters/llms.txt)

previous next

[Vercel](/docs/kit/adapter-vercel) [Advanced routing](/docs/kit/advanced-routing)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAdvanced

Advanced routing
================

### On this page

*   [Advanced routing](/docs/kit/advanced-routing)
*   [Rest parameters](#Rest-parameters)
*   [Optional parameters](#Optional-parameters)
*   [Matching](#Matching)
*   [Sorting](#Sorting)
*   [Encoding](#Encoding)
*   [Advanced layouts](#Advanced-layouts)
*   [Further reading](#Further-reading)

Rest parameters[](#Rest-parameters)
-----------------------------------

If the number of route segments is unknown, you can use rest syntax — for example you might implement GitHub’s file viewer like so...

    /[org]/[repo]/tree/[branch]/[...file]

...in which case a request for `/sveltejs/kit/tree/main/documentation/docs/04-advanced-routing.md` would result in the following parameters being available to the page:

    {
    	org: 'sveltejs',
    	repo: 'kit',
    	branch: 'main',
    	file: 'documentation/docs/04-advanced-routing.md'
    }

> `src/routes/a/[...rest]/z/+page.svelte` will match `/a/z` (i.e. there’s no parameter at all) as well as `/a/b/z` and `/a/b/c/z` and so on. Make sure you check that the value of the rest parameter is valid, for example using a [matcher](#Matching).

### 404 pages[](#Rest-parameters-404-pages)

Rest parameters also allow you to render custom 404s. Given these routes...

    src/routes/
    ├ marx-brothers/
    │ ├ chico/
    │ ├ harpo/
    │ ├ groucho/
    │ └ +error.svelte
    └ +error.svelte

...the `marx-brothers/+error.svelte` file will _not_ be rendered if you visit `/marx-brothers/karl`, because no route was matched. If you want to render the nested error page, you should create a route that matches any `/marx-brothers/*` request, and return a 404 from it:

    src/routes/
    ├ marx-brothers/
    | ├ [...path]/
    │ ├ chico/
    │ ├ harpo/
    │ ├ groucho/
    │ └ +error.svelte
    └ +error.svelte

src/routes/marx-brothers/\[...path\]/+page

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    
    /** @type {import('./$types').PageLoad} */
    export function function load(event: any): void@type{import('./$types').PageLoad}load(event: anyevent) {
    	function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, 'Not Found');
    }

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    import type { type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>
    type PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = (event: Kit.LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>event) => {
    	function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, 'Not Found');
    };

> If you don’t handle 404 cases, they will appear in [`handleError`](hooks#Shared-hooks-handleError)

Optional parameters[](#Optional-parameters)
-------------------------------------------

A route like `[lang]/home` contains a parameter named `lang` which is required. Sometimes it’s beneficial to make these parameters optional, so that in this example both `home` and `en/home` point to the same page. You can do that by wrapping the parameter in another bracket pair: `[[lang]]/home`

Note that an optional route parameter cannot follow a rest parameter (`[...rest]/[[optional]]`), since parameters are matched ‘greedily’ and the optional parameter would always be unused.

Matching[](#Matching)
---------------------

A route like `src/routes/fruits/[page]` would match `/fruits/apple`, but it would also match `/fruits/rocketship`. We don’t want that. You can ensure that route parameters are well-formed by adding a _matcher_ — which takes the parameter string (`"apple"` or `"rocketship"`) and returns `true` if it is valid — to your [`params`](configuration#files) directory...

src/params/fruit

    /**
     * @param {string} param
     * @return {param is ('apple' | 'orange')}
     * @satisfies {import('@sveltejs/kit').ParamMatcher}
     */
    export function function match(param: any): boolean@paramparam @return@satisfies{import('@sveltejs/kit').ParamMatcher}match(param: any@paramparam param) {
    	return param: any@paramparam param === 'apple' || param: any@paramparam param === 'orange';
    }

    import type { type ParamMatcher = (param: string) => booleanThe shape of a param matcher. See matching for more info.
    ParamMatcher } from '@sveltejs/kit';
    
    export const const match: (param: string) => param is ("apple" | "orange")match = ((param: stringparam: string): param: stringparam is ('apple' | 'orange') => {
    	return param: stringparam === 'apple' || param: stringparam === 'orange';
    }) satisfies type ParamMatcher = (param: string) => booleanThe shape of a param matcher. See matching for more info.
    ParamMatcher;

...and augmenting your routes:

    src/routes/fruits/[page=fruit]

If the pathname doesn’t match, SvelteKit will try to match other routes (using the sort order specified below), before eventually returning a 404.

Each module in the `params` directory corresponds to a matcher, with the exception of `*.test.js` and `*.spec.js` files which may be used to unit test your matchers.

> Matchers run both on the server and in the browser.

Sorting[](#Sorting)
-------------------

It’s possible for multiple routes to match a given path. For example each of these routes would match `/foo-abc`:

    src/routes/[...catchall]/+page.svelte
    src/routes/[[a=x]]/+page.svelte
    src/routes/[b]/+page.svelte
    src/routes/foo-[c]/+page.svelte
    src/routes/foo-abc/+page.svelte

SvelteKit needs to know which route is being requested. To do so, it sorts them according to the following rules...

*   More specific routes are higher priority (e.g. a route with no parameters is more specific than a route with one dynamic parameter, and so on)
*   Parameters with [matchers](#Matching) (`[name=type]`) are higher priority than those without (`[name]`)
*   `[[optional]]` and `[...rest]` parameters are ignored unless they are the final part of the route, in which case they are treated with lowest priority. In other words `x/[[y]]/z` is treated equivalently to `x/z` for the purposes of sorting
*   Ties are resolved alphabetically

...resulting in this ordering, meaning that `/foo-abc` will invoke `src/routes/foo-abc/+page.svelte`, and `/foo-def` will invoke `src/routes/foo-[c]/+page.svelte` rather than less specific routes:

    src/routes/foo-abc/+page.svelte
    src/routes/foo-[c]/+page.svelte
    src/routes/[[a=x]]/+page.svelte
    src/routes/[b]/+page.svelte
    src/routes/[...catchall]/+page.svelte

Encoding[](#Encoding)
---------------------

Some characters can’t be used on the filesystem — `/` on Linux and Mac, `\ / : * ? " < > |` on Windows. The `#` and `%` characters have special meaning in URLs, and the `[ ] ( )` characters have special meaning to SvelteKit, so these also can’t be used directly as part of your route.

To use these characters in your routes, you can use hexadecimal escape sequences, which have the format `[x+nn]` where `nn` is a hexadecimal character code:

*   `\` — `[x+5c]`
*   `/` — `[x+2f]`
*   `:` — `[x+3a]`
*   `*` — `[x+2a]`
*   `?` — `[x+3f]`
*   `"` — `[x+22]`
*   `<` — `[x+3c]`
*   `>` — `[x+3e]`
*   `|` — `[x+7c]`
*   `#` — `[x+23]`
*   `%` — `[x+25]`
*   `[` — `[x+5b]`
*   `]` — `[x+5d]`
*   `(` — `[x+28]`
*   `)` — `[x+29]`

For example, to create a `/smileys/:-)` route, you would create a `src/routes/smileys/[x+3a]-[x+29]/+page.svelte` file.

You can determine the hexadecimal code for a character with JavaScript:

    ':'.String.charCodeAt(index: number): numberReturns the Unicode value of the character at the specified location.
    @paramindex The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.charCodeAt(0).Number.toString(radix?: number): stringReturns a string representation of an object.
    @paramradix Specifies a radix for converting numeric values to strings. This value is only used for numbers.toString(16); // '3a', hence '[x+3a]'

You can also use Unicode escape sequences. Generally you won’t need to as you can use the unencoded character directly, but if — for some reason — you can’t have a filename with an emoji in it, for example, then you can use the escaped characters. In other words, these are equivalent:

    src/routes/[u+d83e][u+dd2a]/+page.svelte
    src/routes/🤪/+page.svelte

The format for a Unicode escape sequence is `[u+nnnn]` where `nnnn` is a valid value between `0000` and `10ffff`. (Unlike JavaScript string escaping, there’s no need to use surrogate pairs to represent code points above `ffff`.) To learn more about Unicode encodings, consult [Programming with Unicode](https://unicodebook.readthedocs.io/unicode_encodings.html).

> Since TypeScript [struggles](https://github.com/microsoft/TypeScript/issues/13399) with directories with a leading `.` character, you may find it useful to encode these characters when creating e.g. [`.well-known`](https://en.wikipedia.org/wiki/Well-known_URI) routes: `src/routes/[x+2e]well-known/...`

Advanced layouts[](#Advanced-layouts)
-------------------------------------

By default, the _layout hierarchy_ mirrors the _route hierarchy_. In some cases, that might not be what you want.

### (group)[](#Advanced-layouts-\(group\))

Perhaps you have some routes that are ‘app’ routes that should have one layout (e.g. `/dashboard` or `/item`), and others that are ‘marketing’ routes that should have a different layout (`/about` or `/testimonials`). We can group these routes with a directory whose name is wrapped in parentheses — unlike normal directories, `(app)` and `(marketing)` do not affect the URL pathname of the routes inside them:

    src/routes/
    │ (app)/
    │ ├ dashboard/
    │ ├ item/
    │ └ +layout.svelte
    │ (marketing)/
    │ ├ about/
    │ ├ testimonials/
    │ └ +layout.svelte
    ├ admin/
    └ +layout.svelte

You can also put a `+page` directly inside a `(group)`, for example if `/` should be an `(app)` or a `(marketing)` page.

### Breaking out of layouts[](#Advanced-layouts-Breaking-out-of-layouts)

The root layout applies to every page of your app — if omitted, it defaults to `{@render children()}`. If you want some pages to have a different layout hierarchy than the rest, then you can put your entire app inside one or more groups _except_ the routes that should not inherit the common layouts.

In the example above, the `/admin` route does not inherit either the `(app)` or `(marketing)` layouts.

### +page@[](#Advanced-layouts-page)

Pages can break out of the current layout hierarchy on a route-by-route basis. Suppose we have an `/item/[id]/embed` route inside the `(app)` group from the previous example:

    src/routes/
    ├ (app)/
    │ ├ item/
    │ │ ├ [id]/
    │ │ │ ├ embed/
    │ │ │ │ └ +page.svelte
    │ │ │ └ +layout.svelte
    │ │ └ +layout.svelte
    │ └ +layout.svelte
    └ +layout.svelte

Ordinarily, this would inherit the root layout, the `(app)` layout, the `item` layout and the `[id]` layout. We can reset to one of those layouts by appending `@` followed by the segment name — or, for the root layout, the empty string. In this example, we can choose from the following options:

*   `+page@[id].svelte` - inherits from `src/routes/(app)/item/[id]/+layout.svelte`
*   `+page@item.svelte` - inherits from `src/routes/(app)/item/+layout.svelte`
*   `+page@(app).svelte` - inherits from `src/routes/(app)/+layout.svelte`
*   `+page@.svelte` - inherits from `src/routes/+layout.svelte`

    src/routes/
    ├ (app)/
    │ ├ item/
    │ │ ├ [id]/
    │ │ │ ├ embed/
    │ │ │ │ └ +page@(app).svelte
    │ │ │ └ +layout.svelte
    │ │ └ +layout.svelte
    │ └ +layout.svelte
    └ +layout.svelte

### +layout@[](#Advanced-layouts-layout)

Like pages, layouts can _themselves_ break out of their parent layout hierarchy, using the same technique. For example, a `+layout@.svelte` component would reset the hierarchy for all its child routes.

    src/routes/
    ├ (app)/
    │ ├ item/
    │ │ ├ [id]/
    │ │ │ ├ embed/
    │ │ │ │ └ +page.svelte  // uses (app)/item/[id]/+layout.svelte
    │ │ │ ├ +layout.svelte  // inherits from (app)/item/+layout@.svelte
    │ │ │ └ +page.svelte    // uses (app)/item/+layout@.svelte
    │ │ └ +layout@.svelte   // inherits from root layout, skipping (app)/+layout.svelte
    │ └ +layout.svelte
    └ +layout.svelte

### When to use layout groups[](#Advanced-layouts-When-to-use-layout-groups)

Not all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex `(group)` nesting, or that you don’t want to introduce a `(group)` for a single outlier. It’s perfectly fine to use other means such as composition (reusable `load` functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use:

src/routes/nested/route/+layout@

    <script>
    	import ReusableLayout from '$lib/ReusableLayout.svelte';
    	let { data, children } = $props();
    </script>
    
    <ReusableLayout {data}>
    	{@render children()}
    </ReusableLayout>

    <script lang="ts">
    	import ReusableLayout from '$lib/ReusableLayout.svelte';
    	let { data, children } = $props();
    </script>
    
    <ReusableLayout {data}>
    	{@render children()}
    </ReusableLayout>

src/routes/nested/route/+layout

    import { function reusableLoad(event: import("@sveltejs/kit").LoadEvent): Promise<Record<string, any>>reusableLoad } from '$lib/reusable-load-function';
    
    /** @type {import('./$types').PageLoad} */
    export function function load(event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageLoad}load(event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>event) {
    	// Add additional logic here, if needed
    	return function reusableLoad(event: import("@sveltejs/kit").LoadEvent): Promise<Record<string, any>>reusableLoad(event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>event);
    }

    import { function reusableLoad(event: import("@sveltejs/kit").LoadEvent): Promise<Record<string, any>>reusableLoad } from '$lib/reusable-load-function';
    import type { type PageLoad = (event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = (event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>event) => {
    	// Add additional logic here, if needed
    	return function reusableLoad(event: import("@sveltejs/kit").LoadEvent): Promise<Record<string, any>>reusableLoad(event: LoadEvent<Record<string, any>, Record<string, any> | null, Record<string, any>, string | null>event);
    };

Further reading[](#Further-reading)
-----------------------------------

*   [Tutorial: Advanced Routing](/tutorial/kit/optional-params)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/30-advanced/10-advanced-routing.md) [llms.txt](/docs/kit/advanced-routing/llms.txt)

previous next

[Writing adapters](/docs/kit/writing-adapters) [Hooks](/docs/kit/hooks)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAdvanced

Hooks
=====

### On this page

*   [Hooks](/docs/kit/hooks)
*   [Server hooks](#Server-hooks)
*   [Shared hooks](#Shared-hooks)
*   [Universal hooks](#Universal-hooks)
*   [Further reading](#Further-reading)

‘Hooks’ are app-wide functions you declare that SvelteKit will call in response to specific events, giving you fine-grained control over the framework’s behaviour.

There are three hooks files, all optional:

*   `src/hooks.server.js` — your app’s server hooks
*   `src/hooks.client.js` — your app’s client hooks
*   `src/hooks.js` — your app’s hooks that run on both the client and server

Code in these modules will run when the application starts up, making them useful for initializing database clients and so on.

> You can configure the location of these files with [`config.kit.files.hooks`](configuration#files).

Server hooks[](#Server-hooks)
-----------------------------

The following hooks can be added to `src/hooks.server.js`:

### handle[](#Server-hooks-handle)

This function runs every time the SvelteKit server receives a [request](web-standards#Fetch-APIs-Request) — whether that happens while the app is running, or during [prerendering](page-options#prerender) — and determines the [response](web-standards#Fetch-APIs-Response). It receives an `event` object representing the request and a function called `resolve`, which renders the route and generates a `Response`. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).

src/hooks.server

    /** @type {import('@sveltejs/kit').Handle} */
    export async function function handle({ event, resolve }: {
        event: any;
        resolve: any;
    }): Promise<any>@type{import('@sveltejs/kit').Handle}handle({ event: anyevent, resolve: anyresolve }) {
    	if (event: anyevent.url.pathname.startsWith('/custom')) {
    		return new var Response: new (body?: BodyInit | null, init?: ResponseInit) => ResponseThis Fetch API interface represents the response to a request.
    MDN Reference
    Response('custom response');
    	}
    
    	const const response: anyresponse = await resolve: anyresolve(event: anyevent);
    	return const response: anyresponse;
    }

    import type { type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle } from '@sveltejs/kit';
    
    export const const handle: Handlehandle: type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle = async ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) => {
    	if (event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.url: URLThe requested URL.
    url.URL.pathname: stringMDN Reference
    pathname.String.startsWith(searchString: string, position?: number): booleanReturns true if the sequence of elements of searchString converted to a String is the
    same as the corresponding elements of this object (converted to a String) starting at
    position. Otherwise returns false.
    startsWith('/custom')) {
    		return new var Response: new (body?: BodyInit | null, init?: ResponseInit) => ResponseThis Fetch API interface represents the response to a request.
    MDN Reference
    Response('custom response');
    	}
    
    	const const response: Responseresponse = await resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event);
    	return const response: Responseresponse;
    };

> Requests for static assets — which includes pages that were already prerendered — are _not_ handled by SvelteKit.

If unimplemented, defaults to `({ event, resolve }) => resolve(event)`.

During prerendering, SvelteKit crawls your pages for links and renders each route it finds. Rendering the route invokes the `handle` function (and all other route dependencies, like `load`). If you need to exclude some code from running during this phase, check that the app is not [`building`]($app-environment#building) beforehand.

### locals[](#Server-hooks-locals)

To add custom data to the request, which is passed to handlers in `+server.js` and server `load` functions, populate the `event.locals` object, as shown below.

src/hooks.server

    /** @type {import('@sveltejs/kit').Handle} */
    export async function function handle(input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }): MaybePromise<...>@type{import('@sveltejs/kit').Handle}handle({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) {
    	event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user: Useruser = await const getUserInformation: (cookie: string | void) => Promise<User>getUserInformation(event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.get: (name: string, opts?: CookieParseOptions) => string | undefinedGets a cookie that was previously set with cookies.set, or from the request headers.
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.parse. See documentation hereget('sessionid'));
    
    	const const response: Responseresponse = await resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event);
    
    	// Note that modifying response headers isn't always safe.
    	// Response objects can have immutable headers
    	// (e.g. Response.redirect() returned from an endpoint).
    	// Modifying immutable headers throws a TypeError.
    	// In that case, clone the response or avoid creating a
    	// response object with immutable headers.
    	const response: Responseresponse.Response.headers: HeadersMDN Reference
    headers.Headers.set(name: string, value: string): voidMDN Reference
    set('x-custom-header', 'potato');
    
    	return const response: Responseresponse;
    }

    import type { type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle } from '@sveltejs/kit';
    
    export const const handle: Handlehandle: type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle = async ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) => {
    	event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.locals: App.LocalsContains custom data that was added to the request within the server handle hook.
    locals.App.Locals.user: Useruser = await const getUserInformation: (cookie: string | void) => Promise<User>getUserInformation(event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.cookies: CookiesGet or set cookies related to the current request
    cookies.Cookies.get: (name: string, opts?: CookieParseOptions) => string | undefinedGets a cookie that was previously set with cookies.set, or from the request headers.
    @paramname the name of the cookie@paramopts the options, passed directly to cookie.parse. See documentation hereget('sessionid'));
    
    	const const response: Responseresponse = await resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event);
    
    	// Note that modifying response headers isn't always safe.
    	// Response objects can have immutable headers
    	// (e.g. Response.redirect() returned from an endpoint).
    	// Modifying immutable headers throws a TypeError.
    	// In that case, clone the response or avoid creating a
    	// response object with immutable headers.
    	const response: Responseresponse.Response.headers: HeadersMDN Reference
    headers.Headers.set(name: string, value: string): voidMDN Reference
    set('x-custom-header', 'potato');
    
    	return const response: Responseresponse;
    };

You can define multiple `handle` functions and execute them with [the `sequence` helper function](@sveltejs-kit-hooks).

`resolve` also supports a second, optional parameter that gives you more control over how the response will be rendered. That parameter is an object that can have the following fields:

*   `transformPageChunk(opts: { html: string, done: boolean }): MaybePromise<string | undefined>` — applies custom transforms to HTML. If `done` is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML (they could include an element’s opening tag but not its closing tag, for example) but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components.
*   `filterSerializedResponseHeaders(name: string, value: string): boolean` — determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`. By default, none will be included.
*   `preload(input: { type: 'js' | 'css' | 'font' | 'asset', path: string }): boolean` — determines what files should be added to the `<head>` tag to preload it. The method is called with each file that was found at build time while constructing the code chunks — so if you for example have `import './styles.css` in your `+page.svelte`, `preload` will be called with the resolved path to that CSS file when visiting that page. Note that in dev mode `preload` is _not_ called, since it depends on analysis that happens at build time. Preloading can improve performance by downloading assets sooner, but it can also hurt if too much is downloaded unnecessarily. By default, `js` and `css` files will be preloaded. `asset` files are not preloaded at all currently, but we may add this later after evaluating feedback.

src/hooks.server

    /** @type {import('@sveltejs/kit').Handle} */
    export async function function handle({ event, resolve }: {
        event: any;
        resolve: any;
    }): Promise<any>@type{import('@sveltejs/kit').Handle}handle({ event: anyevent, resolve: anyresolve }) {
    	const const response: anyresponse = await resolve: anyresolve(event: anyevent, {
    		transformPageChunk: ({ html }: {
        html: any;
    }) => anytransformPageChunk: ({ html: anyhtml }) => html: anyhtml.replace('old', 'new'),
    		filterSerializedResponseHeaders: (name: any) => anyfilterSerializedResponseHeaders: (name: anyname) => name: anyname.startsWith('x-'),
    		preload: ({ type, path }: {
        type: any;
        path: any;
    }) => anypreload: ({ type: anytype, path: anypath }) => type: anytype === 'js' || path: anypath.includes('/important/')
    	});
    
    	return const response: anyresponse;
    }

    import type { type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle } from '@sveltejs/kit';
    
    export const const handle: Handlehandle: type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle = async ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) => {
    	const const response: Responseresponse = await resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event, {
    		ResolveOptions.transformPageChunk?: ((input: {
        html: string;
        done: boolean;
    }) => MaybePromise<string | undefined>) | undefinedApplies custom transforms to HTML. If done is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML
    (they could include an element’s opening tag but not its closing tag, for example)
    but they will always be split at sensible boundaries such as %sveltekit.head% or layout/page components.
    @paraminput the html chunk and the info if this is the last chunktransformPageChunk: ({ html: stringhtml }) => html: stringhtml.String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)Replaces text in a string, using a regular expression or search string.
    @paramsearchValue A string or regular expression to search for.@paramreplaceValue A string containing the text to replace. When the {@linkcode searchValue} is a RegExp, all matches are replaced if the g flag is set (or only those matches at the beginning, if the y flag is also present). Otherwise, only the first match of {@linkcode searchValue} is replaced.replace('old', 'new'),
    		ResolveOptions.filterSerializedResponseHeaders?: ((name: string, value: string) => boolean) | undefinedDetermines which headers should be included in serialized responses when a load function loads a resource with fetch.
    By default, none will be included.
    @paramname header name@paramvalue header valuefilterSerializedResponseHeaders: (name: stringname) => name: stringname.String.startsWith(searchString: string, position?: number): booleanReturns true if the sequence of elements of searchString converted to a String is the
    same as the corresponding elements of this object (converted to a String) starting at
    position. Otherwise returns false.
    startsWith('x-'),
    		ResolveOptions.preload?: ((input: {
        type: "font" | "css" | "js" | "asset";
        path: string;
    }) => boolean) | undefinedDetermines what should be added to the &#x3C;head> tag to preload it.
    By default, js and css files will be preloaded.
    @paraminput the type of the file and its pathpreload: ({ type: "font" | "css" | "js" | "asset"type, path: stringpath }) => type: "font" | "css" | "js" | "asset"type === 'js' || path: stringpath.String.includes(searchString: string, position?: number): booleanReturns true if searchString appears as a substring of the result of converting this
    object to a String, at one or more positions that are
    greater than or equal to position; otherwise, returns false.
    @paramsearchString search string@paramposition If position is undefined, 0 is assumed, so as to search all of the String.includes('/important/')
    	});
    
    	return const response: Responseresponse;
    };

Note that `resolve(...)` will never throw an error, it will always return a `Promise<Response>` with the appropriate status code. If an error is thrown elsewhere during `handle`, it is treated as fatal, and SvelteKit will respond with a JSON representation of the error or a fallback error page — which can be customised via `src/error.html` — depending on the `Accept` header. You can read more about error handling [here](errors).

### handleFetch[](#Server-hooks-handleFetch)

This function allows you to modify (or replace) the result of an [`event.fetch`](load#Making-fetch-requests) call that runs on the server (or during prerendering) inside an endpoint, `load`, `action`, `handle`, `handleError` or `reroute`.

For example, your `load` function might make a request to a public URL like `https://api.yourapp.com` when the user performs a client-side navigation to the respective page, but during SSR it might make sense to hit the API directly (bypassing whatever proxies and load balancers sit between it and the public internet).

src/hooks.server

    /** @type {import('@sveltejs/kit').HandleFetch} */
    export async function function handleFetch({ request, fetch }: {
        request: any;
        fetch: any;
    }): Promise<any>@type{import('@sveltejs/kit').HandleFetch}handleFetch({ request: anyrequest, fetch: anyfetch }) {
    	if (request: anyrequest.url.startsWith('https://api.yourapp.com/')) {
    		// clone the original request, but change the URL
    		request: anyrequest = new var Request: new (input: RequestInfo | URL, init?: RequestInit) => RequestThis Fetch API interface represents a resource request.
    MDN Reference
    Request(
    			request: anyrequest.url.replace('https://api.yourapp.com/', 'http://localhost:9999/'),
    			request: anyrequest
    		);
    	}
    
    	return fetch: anyfetch(request: anyrequest);
    }

    import type { type HandleFetch = (input: {
        event: RequestEvent;
        request: Request;
        fetch: typeof fetch;
    }) => MaybePromise<Response>The handleFetch hook allows you to modify (or replace) a fetch request that happens inside a load function that runs on the server (or during pre-rendering)
    HandleFetch } from '@sveltejs/kit';
    
    export const const handleFetch: HandleFetchhandleFetch: type HandleFetch = (input: {
        event: RequestEvent;
        request: Request;
        fetch: typeof fetch;
    }) => MaybePromise<Response>The handleFetch hook allows you to modify (or replace) a fetch request that happens inside a load function that runs on the server (or during pre-rendering)
    HandleFetch = async ({ request: Requestrequest, fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch }) => {
    	if (request: Requestrequest.Request.url: stringReturns the URL of request as a string.
    MDN Reference
    url.String.startsWith(searchString: string, position?: number): booleanReturns true if the sequence of elements of searchString converted to a String is the
    same as the corresponding elements of this object (converted to a String) starting at
    position. Otherwise returns false.
    startsWith('https://api.yourapp.com/')) {
    		// clone the original request, but change the URL
    		request: Requestrequest = new var Request: new (input: RequestInfo | URL, init?: RequestInit) => RequestThis Fetch API interface represents a resource request.
    MDN Reference
    Request(
    			request: Requestrequest.Request.url: stringReturns the URL of request as a string.
    MDN Reference
    url.String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)Replaces text in a string, using a regular expression or search string.
    @paramsearchValue A string or regular expression to search for.@paramreplaceValue A string containing the text to replace. When the {@linkcode searchValue} is a RegExp, all matches are replaced if the g flag is set (or only those matches at the beginning, if the y flag is also present). Otherwise, only the first match of {@linkcode searchValue} is replaced.replace('https://api.yourapp.com/', 'http://localhost:9999/'),
    			request: Requestrequest
    		);
    	}
    
    	return fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch(request: Requestrequest);
    };

Requests made with `event.fetch` follow the browser’s credentials model — for same-origin requests, `cookie` and `authorization` headers are forwarded unless the `credentials` option is set to `"omit"`. For cross-origin requests, `cookie` will be included if the request URL belongs to a subdomain of the app — for example if your app is on `my-domain.com`, and your API is on `api.my-domain.com`, cookies will be included in the request.

There is one caveat: if your app and your API are on sibling subdomains — `www.my-domain.com` and `api.my-domain.com` for example — then a cookie belonging to a common parent domain like `my-domain.com` will _not_ be included, because SvelteKit has no way to know which domain the cookie belongs to. In these cases you will need to manually include the cookie using `handleFetch`:

src/hooks.server

    /** @type {import('@sveltejs/kit').HandleFetch} */
    export async function function handleFetch({ event, request, fetch }: {
        event: any;
        request: any;
        fetch: any;
    }): Promise<any>@type{import('@sveltejs/kit').HandleFetch}handleFetch({ event: anyevent, request: anyrequest, fetch: anyfetch }) {
    	if (request: anyrequest.url.startsWith('https://api.my-domain.com/')) {
    		request: anyrequest.headers.set('cookie', event: anyevent.request.headers.get('cookie'));
    	}
    
    	return fetch: anyfetch(request: anyrequest);
    }

    import type { type HandleFetch = (input: {
        event: RequestEvent;
        request: Request;
        fetch: typeof fetch;
    }) => MaybePromise<Response>The handleFetch hook allows you to modify (or replace) a fetch request that happens inside a load function that runs on the server (or during pre-rendering)
    HandleFetch } from '@sveltejs/kit';
    export const const handleFetch: HandleFetchhandleFetch: type HandleFetch = (input: {
        event: RequestEvent;
        request: Request;
        fetch: typeof fetch;
    }) => MaybePromise<Response>The handleFetch hook allows you to modify (or replace) a fetch request that happens inside a load function that runs on the server (or during pre-rendering)
    HandleFetch = async ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, request: Requestrequest, fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch }) => {
    	if (request: Requestrequest.Request.url: stringReturns the URL of request as a string.
    MDN Reference
    url.String.startsWith(searchString: string, position?: number): booleanReturns true if the sequence of elements of searchString converted to a String is the
    same as the corresponding elements of this object (converted to a String) starting at
    position. Otherwise returns false.
    startsWith('https://api.my-domain.com/')) {
    		request: Requestrequest.Request.headers: HeadersReturns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the “Host” header.
    MDN Reference
    headers.Headers.set(name: string, value: string): voidMDN Reference
    set('cookie', event: RequestEvent<Partial<Record<string, string>>, string | null>event.RequestEvent<Partial<Record<string, string>>, string | null>.request: RequestThe original request object.
    request.Request.headers: HeadersReturns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the “Host” header.
    MDN Reference
    headers.Headers.get(name: string): string | nullMDN Reference
    get('cookie'));
    	}
    
    	return fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch(request: Requestrequest);
    };

Shared hooks[](#Shared-hooks)
-----------------------------

The following can be added to `src/hooks.server.js` _and_ `src/hooks.client.js`:

### handleError[](#Shared-hooks-handleError)

If an [unexpected error](errors#Unexpected-errors) is thrown during loading, rendering, or from an endpoint, this function will be called with the `error`, `event`, `status` code and `message`. This allows for two things:

*   you can log the error
*   you can generate a custom representation of the error that is safe to show to users, omitting sensitive details like messages and stack traces. The returned value, which defaults to `{ message }`, becomes the value of `$page.error`.

For errors thrown from your code (or library code called by your code) the status will be 500 and the message will be “Internal Error”. While `error.message` may contain sensitive information that should not be exposed to users, `message` is safe (albeit meaningless to the average user).

To add more information to the `$page.error` object in a type-safe way, you can customize the expected shape by declaring an `App.Error` interface (which must include `message: string`, to guarantee sensible fallback behavior). This allows you to — for example — append a tracking ID for users to quote in correspondence with your technical support staff:

src/app.d

    declare global {
    	namespace App {
    		interface interface App.ErrorDefines the common shape of expected and unexpected errors. Expected errors are thrown using the error function. Unexpected errors are handled by the handleError hooks which should return this shape.
    Error {
    			App.Error.message: stringmessage: string;
    			App.Error.errorId: stringerrorId: string;
    		}
    	}
    }
    
    export {};

src/hooks.server

    import * as module "@sentry/sveltekit"Sentry from '@sentry/sveltekit';
    
    module "@sentry/sveltekit"Sentry.const init: (opts: any) => voidinit({/*...*/})
    
    /** @type {import('@sveltejs/kit').HandleServerError} */
    export async function function handleError(input: {
        error: unknown;
        event: RequestEvent;
        status: number;
        message: string;
    }): MaybePromise<void | App.Error>@type{import('@sveltejs/kit').HandleServerError}handleError({ error: unknownerror, event: RequestEvent<Partial<Record<string, string>>, string | null>event, status: numberstatus, message: stringmessage }) {
    	const const errorId: `${string}-${string}-${string}-${string}-${string}`errorId = var crypto: CryptoMDN Reference
    crypto.Crypto.randomUUID(): `${string}-${string}-${string}-${string}-${string}`Available only in secure contexts.
    MDN Reference
    randomUUID();
    
    	// example integration with https://sentry.io/
    	module "@sentry/sveltekit"Sentry.const captureException: (error: any, opts: any) => voidcaptureException(error: unknownerror, {
    		extra: {
        event: RequestEvent<Partial<Record<string, string>>, string | null>;
        errorId: `${string}-${string}-${string}-${string}-${string}`;
        status: number;
    }extra: { event: RequestEvent<Partial<Record<string, string>>, string | null>event, errorId: `${string}-${string}-${string}-${string}-${string}`errorId, status: numberstatus }
    	});
    
    	return {
    		App.Error.message: stringmessage: 'Whoops!',
    		errorId
    	};
    }

    import * as module "@sentry/sveltekit"Sentry from '@sentry/sveltekit';
    import type { type HandleServerError = (input: {
        error: unknown;
        event: RequestEvent;
        status: number;
        message: string;
    }) => MaybePromise<void | App.Error>The server-side handleError hook runs when an unexpected error is thrown while responding to a request.
    If an unexpected error is thrown during loading or rendering, this function will be called with the error and the event.
    Make sure that this function never throws an error.
    HandleServerError } from '@sveltejs/kit';
    
    module "@sentry/sveltekit"Sentry.const init: (opts: any) => voidinit({/*...*/})
    
    export const const handleError: HandleServerErrorhandleError: type HandleServerError = (input: {
        error: unknown;
        event: RequestEvent;
        status: number;
        message: string;
    }) => MaybePromise<void | App.Error>The server-side handleError hook runs when an unexpected error is thrown while responding to a request.
    If an unexpected error is thrown during loading or rendering, this function will be called with the error and the event.
    Make sure that this function never throws an error.
    HandleServerError = async ({ error: unknownerror, event: RequestEvent<Partial<Record<string, string>>, string | null>event, status: numberstatus, message: stringmessage }) => {
    	const const errorId: `${string}-${string}-${string}-${string}-${string}`errorId = var crypto: CryptoMDN Reference
    crypto.Crypto.randomUUID(): `${string}-${string}-${string}-${string}-${string}`Available only in secure contexts.
    MDN Reference
    randomUUID();
    
    	// example integration with https://sentry.io/
    	module "@sentry/sveltekit"Sentry.const captureException: (error: any, opts: any) => voidcaptureException(error: unknownerror, {
    		extra: {
        event: RequestEvent<Partial<Record<string, string>>, string | null>;
        errorId: `${string}-${string}-${string}-${string}-${string}`;
        status: number;
    }extra: { event: RequestEvent<Partial<Record<string, string>>, string | null>event, errorId: `${string}-${string}-${string}-${string}-${string}`errorId, status: numberstatus }
    	});
    
    	return {
    		App.Error.message: stringmessage: 'Whoops!',
    		errorId: `${string}-${string}-${string}-${string}-${string}`errorId
    	};
    };

src/hooks.client

    import * as module "@sentry/sveltekit"Sentry from '@sentry/sveltekit';
    
    module "@sentry/sveltekit"Sentry.const init: (opts: any) => voidinit({/*...*/})
    
    /** @type {import('@sveltejs/kit').HandleClientError} */
    export async function function handleError(input: {
        error: unknown;
        event: NavigationEvent;
        status: number;
        message: string;
    }): MaybePromise<void | App.Error>@type{import('@sveltejs/kit').HandleClientError}handleError({ error: unknownerror, event: NavigationEvent<Partial<Record<string, string>>, string | null>event, status: numberstatus, message: stringmessage }) {
    	const const errorId: `${string}-${string}-${string}-${string}-${string}`errorId = var crypto: CryptoMDN Reference
    crypto.Crypto.randomUUID(): `${string}-${string}-${string}-${string}-${string}`Available only in secure contexts.
    MDN Reference
    randomUUID();
    
    	// example integration with https://sentry.io/
    	module "@sentry/sveltekit"Sentry.const captureException: (error: any, opts: any) => voidcaptureException(error: unknownerror, {
    		extra: {
        event: NavigationEvent<Partial<Record<string, string>>, string | null>;
        errorId: `${string}-${string}-${string}-${string}-${string}`;
        status: number;
    }extra: { event: NavigationEvent<Partial<Record<string, string>>, string | null>event, errorId: `${string}-${string}-${string}-${string}-${string}`errorId, status: numberstatus }
    	});
    
    	return {
    		App.Error.message: stringmessage: 'Whoops!',
    		errorId
    	};
    }

    import * as module "@sentry/sveltekit"Sentry from '@sentry/sveltekit';
    import type { type HandleClientError = (input: {
        error: unknown;
        event: NavigationEvent;
        status: number;
        message: string;
    }) => MaybePromise<void | App.Error>The client-side handleError hook runs when an unexpected error is thrown while navigating.
    If an unexpected error is thrown during loading or the following render, this function will be called with the error and the event.
    Make sure that this function never throws an error.
    HandleClientError } from '@sveltejs/kit';
    
    module "@sentry/sveltekit"Sentry.const init: (opts: any) => voidinit({/*...*/})
    
    export const const handleError: HandleClientErrorhandleError: type HandleClientError = (input: {
        error: unknown;
        event: NavigationEvent;
        status: number;
        message: string;
    }) => MaybePromise<void | App.Error>The client-side handleError hook runs when an unexpected error is thrown while navigating.
    If an unexpected error is thrown during loading or the following render, this function will be called with the error and the event.
    Make sure that this function never throws an error.
    HandleClientError = async ({ error: unknownerror, event: NavigationEvent<Partial<Record<string, string>>, string | null>event, status: numberstatus, message: stringmessage }) => {
    	const const errorId: `${string}-${string}-${string}-${string}-${string}`errorId = var crypto: CryptoMDN Reference
    crypto.Crypto.randomUUID(): `${string}-${string}-${string}-${string}-${string}`Available only in secure contexts.
    MDN Reference
    randomUUID();
    
    	// example integration with https://sentry.io/
    	module "@sentry/sveltekit"Sentry.const captureException: (error: any, opts: any) => voidcaptureException(error: unknownerror, {
    		extra: {
        event: NavigationEvent<Partial<Record<string, string>>, string | null>;
        errorId: `${string}-${string}-${string}-${string}-${string}`;
        status: number;
    }extra: { event: NavigationEvent<Partial<Record<string, string>>, string | null>event, errorId: `${string}-${string}-${string}-${string}-${string}`errorId, status: numberstatus }
    	});
    
    	return {
    		App.Error.message: stringmessage: 'Whoops!',
    		errorId: `${string}-${string}-${string}-${string}-${string}`errorId
    	};
    };

> In `src/hooks.client.js`, the type of `handleError` is `HandleClientError` instead of `HandleServerError`, and `event` is a `NavigationEvent` rather than a `RequestEvent`.

This function is not called for _expected_ errors (those thrown with the [`error`](@sveltejs-kit#error) function imported from `@sveltejs/kit`).

During development, if an error occurs because of a syntax error in your Svelte code, the passed in error has a `frame` property appended highlighting the location of the error.

> Make sure that `handleError` _never_ throws an error

### init[](#Shared-hooks-init)

This function runs once, when the server is created or the app starts in the browser, and is a useful place to do asynchronous work such as initializing a database connection.

> If your environment supports top-level await, the `init` function is really no different from writing your initialisation logic at the top level of the module, but some environments — most notably, Safari — don’t.

src/hooks.server

    import * as import dbdb from '$lib/server/database';
    
    /** @type {import('@sveltejs/kit').ServerInit} */
    export async function function init(): Promise<void>@type{import('@sveltejs/kit').ServerInit}init() {
    	await import dbdb.connect();
    }

    import * as import dbdb from '$lib/server/database';
    import type { type ServerInit = () => MaybePromise<void>The init will be invoked before the server responds to its first request
    @since2.10.0ServerInit } from '@sveltejs/kit';
    
    export const const init: ServerInitinit: type ServerInit = () => MaybePromise<void>The init will be invoked before the server responds to its first request
    @since2.10.0ServerInit = async () => {
    	await import dbdb.connect();
    };

> In the browser, asynchronous work in `init` will delay hydration, so be mindful of what you put in there.

Universal hooks[](#Universal-hooks)
-----------------------------------

The following can be added to `src/hooks.js`. Universal hooks run on both server and client (not to be confused with shared hooks, which are environment-specific).

### reroute[](#Universal-hooks-reroute)

This function runs before `handle` and allows you to change how URLs are translated into routes. The returned pathname (which defaults to `url.pathname`) is used to select the route and its parameters.

For example, you might have a `src/routes/[[lang]]/about/+page.svelte` page, which should be accessible as `/en/about` or `/de/ueber-uns` or `/fr/a-propos`. You could implement this with `reroute`:

src/hooks

    
    /** @type {Record<string, string>} */
    const const translated: {
        '/en/about': string;
        '/de/ueber-uns': string;
        '/fr/a-propos': string;
    }@type{Record<string, string>}translated = {
    	'/en/about': '/en/about',
    	'/de/ueber-uns': '/de/about',
    	'/fr/a-propos': '/fr/about',
    };
    
    /** @type {import('@sveltejs/kit').Reroute} */
    export function function reroute({ url }: {
        url: any;
    }): any@type{import('@sveltejs/kit').Reroute}reroute({ url: anyurl }) {
    	if (url: anyurl.pathname in const translated: {
        '/en/about': string;
        '/de/ueber-uns': string;
        '/fr/a-propos': string;
    }@type{Record<string, string>}translated) {
    		return const translated: {
        '/en/about': string;
        '/de/ueber-uns': string;
        '/fr/a-propos': string;
    }@type{Record<string, string>}translated[url: anyurl.pathname];
    	}
    }

    import type { type Reroute = (event: {
        url: URL;
        fetch: typeof fetch;
    }) => MaybePromise<string | void>The reroute hook allows you to modify the URL before it is used to determine which route to render.
    @since2.3.0Reroute } from '@sveltejs/kit';
    const const translated: Record<string, string>translated: type Record<K extends keyof any, T> = { [P in K]: T; }Construct a type with a set of properties K of type T
    Record<string, string> = {
    	'/en/about': '/en/about',
    	'/de/ueber-uns': '/de/about',
    	'/fr/a-propos': '/fr/about',
    };
    
    export const const reroute: Reroutereroute: type Reroute = (event: {
        url: URL;
        fetch: typeof fetch;
    }) => MaybePromise<string | void>The reroute hook allows you to modify the URL before it is used to determine which route to render.
    @since2.3.0Reroute = ({ url: URLurl }) => {
    	if (url: URLurl.URL.pathname: stringMDN Reference
    pathname in const translated: Record<string, string>translated) {
    		return const translated: Record<string, string>translated[url: URLurl.URL.pathname: stringMDN Reference
    pathname];
    	}
    };

The `lang` parameter will be correctly derived from the returned pathname.

Using `reroute` will _not_ change the contents of the browser’s address bar, or the value of `event.url`.

Since version 2.18, the `reroute` hook can be asynchronous, allowing it to (for example) fetch data from your backend to decide where to reroute to. Use this carefully and make sure it’s fast, as it will delay navigation otherwise. If you need to fetch data, use the `fetch` provided as an argument. It has the [same benefits](load#Making-fetch-requests) as the `fetch` provided to `load` functions, with the caveat that `params` and `id` are unavailable to [`handleFetch`](#Server-hooks-handleFetch) because the route is not yet known.

src/hooks

    
    /** @type {import('@sveltejs/kit').Reroute} */
    export async function function reroute({ url, fetch }: {
        url: any;
        fetch: any;
    }): Promise<any>@type{import('@sveltejs/kit').Reroute}reroute({ url: anyurl, fetch: anyfetch }) {
    	// Ask a special endpoint within your app about the destination
    	if (url: anyurl.pathname === '/api/reroute') return;
    
    	const const api: URLapi = new var URL: new (url: string | URL, base?: string | URL) => URLThe URL interface represents an object providing static methods used for creating object URLs.
    MDN Reference
    URL class is a global reference for require('url').URL
    https://nodejs.org/api/url.html#the-whatwg-url-api
    @sincev10.0.0URL('/api/reroute', url: anyurl);
    	const api: URLapi.URL.searchParams: URLSearchParamsMDN Reference
    searchParams.URLSearchParams.set(name: string, value: string): voidSets the value associated to a given search parameter to the given value. If there were several values, delete the others.
    MDN Reference
    set('pathname', url: anyurl.pathname);
    
    	const const result: anyresult = await fetch: anyfetch(const api: URLapi).then(r: anyr => r: anyr.json());
    	return const result: anyresult.pathname;
    }

    import type { type Reroute = (event: {
        url: URL;
        fetch: typeof fetch;
    }) => MaybePromise<string | void>The reroute hook allows you to modify the URL before it is used to determine which route to render.
    @since2.3.0Reroute } from '@sveltejs/kit';
    export const const reroute: Reroutereroute: type Reroute = (event: {
        url: URL;
        fetch: typeof fetch;
    }) => MaybePromise<string | void>The reroute hook allows you to modify the URL before it is used to determine which route to render.
    @since2.3.0Reroute = async ({ url: URLurl, fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch }) => {
    	// Ask a special endpoint within your app about the destination
    	if (url: URLurl.URL.pathname: stringMDN Reference
    pathname === '/api/reroute') return;
    
    	const const api: URLapi = new var URL: new (url: string | URL, base?: string | URL) => URLThe URL interface represents an object providing static methods used for creating object URLs.
    MDN Reference
    URL class is a global reference for require('url').URL
    https://nodejs.org/api/url.html#the-whatwg-url-api
    @sincev10.0.0URL('/api/reroute', url: URLurl);
    	const api: URLapi.URL.searchParams: URLSearchParamsMDN Reference
    searchParams.URLSearchParams.set(name: string, value: string): voidSets the value associated to a given search parameter to the given value. If there were several values, delete the others.
    MDN Reference
    set('pathname', url: URLurl.URL.pathname: stringMDN Reference
    pathname);
    
    	const const result: anyresult = await fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch(const api: URLapi).Promise<Response>.then<any, never>(onfulfilled?: ((value: Response) => any) | null | undefined, onrejected?: ((reason: any) => PromiseLike<never>) | null | undefined): Promise<any>Attaches callbacks for the resolution and/or rejection of the Promise.
    @paramonfulfilled The callback to execute when the Promise is resolved.@paramonrejected The callback to execute when the Promise is rejected.@returnsA Promise for the completion of which ever callback is executed.then(r: Responser => r: Responser.Body.json(): Promise<any>MDN Reference
    json());
    	return const result: anyresult.pathname;
    };

> `reroute` is considered a pure, idempotent function. As such, it must always return the same output for the same input and not have side effects. Under these assumptions, SvelteKit caches the result of `reroute` on the client so it is only called once per unique URL.

### transport[](#Universal-hooks-transport)

This is a collection of _transporters_, which allow you to pass custom types — returned from `load` and form actions — across the server/client boundary. Each transporter contains an `encode` function, which encodes values on the server (or returns `false` for anything that isn’t an instance of the type) and a corresponding `decode` function:

src/hooks

    import { import VectorVector } from '$lib/math';
    
    /** @type {import('@sveltejs/kit').Transport} */
    export const const transport: {
        Vector: {
            encode: (value: any) => false | any[];
            decode: ([x, y]: [any, any]) => any;
        };
    }@type{import('@sveltejs/kit').Transport}transport = {
    	type Vector: {
        encode: (value: any) => false | any[];
        decode: ([x, y]: [any, any]) => any;
    }Vector: {
    		encode: (value: any) => false | any[]encode: (value: anyvalue) => value: anyvalue instanceof import VectorVector && [value: anyvalue.x, value: anyvalue.y],
    		decode: ([x, y]: [any, any]) => anydecode: ([x: anyx, y: anyy]) => new import VectorVector(x: anyx, y: anyy)
    	}
    };

    import { import VectorVector } from '$lib/math';
    import type { type Transport = {
        [x: string]: Transporter<any, any>;
    }The transport hook allows you to transport custom types across the server/client boundary.
    Each transporter has a pair of encode and decode functions. On the server, encode determines whether a value is an instance of the custom type and, if so, returns a non-falsy encoding of the value which can be an object or an array (or false otherwise).
    In the browser, decode turns the encoding back into an instance of the custom type.
    import type { Transport } from '@sveltejs/kit';
    
    declare class MyCustomType {
    	data: any
    }
    
    // hooks.js
    export const transport: Transport = {
    	MyCustomType: {
    		encode: (value) => value instanceof MyCustomType &#x26;&#x26; [value.data],
    		decode: ([data]) => new MyCustomType(data)
    	}
    };@since2.11.0Transport } from '@sveltejs/kit';
    
    export const const transport: Transporttransport: type Transport = {
        [x: string]: Transporter<any, any>;
    }The transport hook allows you to transport custom types across the server/client boundary.
    Each transporter has a pair of encode and decode functions. On the server, encode determines whether a value is an instance of the custom type and, if so, returns a non-falsy encoding of the value which can be an object or an array (or false otherwise).
    In the browser, decode turns the encoding back into an instance of the custom type.
    import type { Transport } from '@sveltejs/kit';
    
    declare class MyCustomType {
    	data: any
    }
    
    // hooks.js
    export const transport: Transport = {
    	MyCustomType: {
    		encode: (value) => value instanceof MyCustomType &#x26;&#x26; [value.data],
    		decode: ([data]) => new MyCustomType(data)
    	}
    };@since2.11.0Transport = {
    	type Vector: {
        encode: (value: any) => false | any[];
        decode: ([x, y]: any) => any;
    }Vector: {
    		Transporter<any, any>.encode: (value: any) => anyencode: (value: anyvalue) => value: anyvalue instanceof import VectorVector && [value: anyvalue.x, value: anyvalue.y],
    		Transporter<any, any>.decode: (data: any) => anydecode: ([x: anyx, y: anyy]) => new import VectorVector(x: anyx, y: anyy)
    	}
    };

Further reading[](#Further-reading)
-----------------------------------

*   [Tutorial: Hooks](/tutorial/kit/handle)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/30-advanced/20-hooks.md) [llms.txt](/docs/kit/hooks/llms.txt)

previous next

[Advanced routing](/docs/kit/advanced-routing) [Errors](/docs/kit/errors)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAdvanced

Errors
======

### On this page

*   [Errors](/docs/kit/errors)
*   [Error objects](#Error-objects)
*   [Expected errors](#Expected-errors)
*   [Unexpected errors](#Unexpected-errors)
*   [Responses](#Responses)
*   [Type safety](#Type-safety)
*   [Further reading](#Further-reading)

Errors are an inevitable fact of software development. SvelteKit handles errors differently depending on where they occur, what kind of errors they are, and the nature of the incoming request.

Error objects[](#Error-objects)
-------------------------------

SvelteKit distinguishes between expected and unexpected errors, both of which are represented as simple `{ message: string }` objects by default.

You can add additional properties, like a `code` or a tracking `id`, as shown in the examples below. (When using TypeScript this requires you to redefine the `Error` type as described in [type safety](errors#Type-safety)).

Expected errors[](#Expected-errors)
-----------------------------------

An _expected_ error is one created with the [`error`](@sveltejs-kit#error) helper imported from `@sveltejs/kit`:

src/routes/blog/\[slug\]/+page.server

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    import * as module "$lib/server/database"db from '$lib/server/database';
    
    /** @type {import('./$types').PageServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageServerLoad}load({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) {
    	const const post: {
        title: string;
        content: string;
    } | undefinedpost = await module "$lib/server/database"db.function getPost(slug: string): Promise<{
        title: string;
        content: string;
    } | undefined>getPost(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug);
    
    	if (!const post: {
        title: string;
        content: string;
    } | undefinedpost) {
    		function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, {
    			App.Error.message: stringmessage: 'Not found'
    		});
    	}
    
    	return { post: {
        title: string;
        content: string;
    }post };
    }

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit';
    import * as module "$lib/server/database"db from '$lib/server/database';
    import type { type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad } from './$types';
    
    export const const load: PageServerLoadload: type PageServerLoad = (event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageServerLoad = async ({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) => {
    	const const post: {
        title: string;
        content: string;
    } | undefinedpost = await module "$lib/server/database"db.function getPost(slug: string): Promise<{
        title: string;
        content: string;
    } | undefined>getPost(params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.slug);
    
    	if (!const post: {
        title: string;
        content: string;
    } | undefinedpost) {
    		function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, {
    			App.Error.message: stringmessage: 'Not found'
    		});
    	}
    
    	return { post: {
        title: string;
        content: string;
    }post };
    };

This throws an exception that SvelteKit catches, causing it to set the response status code to 404 and render an [`+error.svelte`](routing#error) component, where `page.error` is the object provided as the second argument to `error(...)`.

src/routes/+error

    <script>
    	import { page } from '$app/state';
    </script>
    
    <h1>{page.error.message}</h1>

    <script lang="ts">
    	import { page } from '$app/state';
    </script>
    
    <h1>{page.error.message}</h1>

> Legacy mode
> 
> `$app/state` was added in SvelteKit 2.12. If you’re using an earlier version or are using Svelte 4, use `$app/stores` instead.

You can add extra properties to the error object if needed...

    function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, {
    	App.Error.message: stringmessage: 'Not found',
    	App.Error.code: stringcode: 'NOT_FOUND'
    });

...otherwise, for convenience, you can pass a string as the second argument:

    error(404, { message: 'Not found' });
    function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(404, 'Not found');

> [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the `error` yourself

Unexpected errors[](#Unexpected-errors)
---------------------------------------

An _unexpected_ error is any other exception that occurs while handling a request. Since these can contain sensitive information, unexpected error messages and stack traces are not exposed to users.

By default, unexpected errors are printed to the console (or, in production, your server logs), while the error that is exposed to the user has a generic shape:

    { "message": "Internal Error" }

Unexpected errors will go through the [`handleError`](hooks#Shared-hooks-handleError) hook, where you can add your own error handling — for example, sending errors to a reporting service, or returning a custom error object which becomes `$page.error`.

Responses[](#Responses)
-----------------------

If an error occurs inside `handle` or inside a [`+server.js`](routing#server) request handler, SvelteKit will respond with either a fallback error page or a JSON representation of the error object, depending on the request’s `Accept` headers.

You can customise the fallback error page by adding a `src/error.html` file:

    <!DOCTYPE html>
    <html lang="en">
    	<head>
    		<meta charset="utf-8" />
    		<title>%sveltekit.error.message%</title>
    	</head>
    	<body>
    		<h1>My custom error page</h1>
    		<p>Status: %sveltekit.status%</p>
    		<p>Message: %sveltekit.error.message%</p>
    	</body>
    </html>

SvelteKit will replace `%sveltekit.status%` and `%sveltekit.error.message%` with their corresponding values.

If the error instead occurs inside a `load` function while rendering a page, SvelteKit will render the [`+error.svelte`](routing#error) component nearest to where the error occurred. If the error occurs inside a `load` function in `+layout(.server).js`, the closest error boundary in the tree is an `+error.svelte` file _above_ that layout (not next to it).

The exception is when the error occurs inside the root `+layout.js` or `+layout.server.js`, since the root layout would ordinarily _contain_ the `+error.svelte` component. In this case, SvelteKit uses the fallback error page.

Type safety[](#Type-safety)
---------------------------

If you’re using TypeScript and need to customize the shape of errors, you can do so by declaring an `App.Error` interface in your app (by convention, in `src/app.d.ts`, though it can live anywhere that TypeScript can ‘see’):

src/app.d

    declare global {
    	namespace App {
    		interface interface App.ErrorDefines the common shape of expected and unexpected errors. Expected errors are thrown using the error function. Unexpected errors are handled by the handleError hooks which should return this shape.
    Error {
    			App.Error.code: stringcode: string;
    			App.Error.id: stringid: string;
    		}
    	}
    }
    
    export {};

This interface always includes a `message: string` property.

Further reading[](#Further-reading)
-----------------------------------

*   [Tutorial: Errors and redirects](/tutorial/kit/error-basics)
*   [Tutorial: Hooks](/tutorial/kit/handle)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/30-advanced/25-errors.md) [llms.txt](/docs/kit/errors/llms.txt)

previous next

[Hooks](/docs/kit/hooks) [Link options](/docs/kit/link-options)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAdvanced

Link options
============

### On this page

*   [Link options](/docs/kit/link-options)
*   [data-sveltekit-preload-data](#data-sveltekit-preload-data)
*   [data-sveltekit-preload-code](#data-sveltekit-preload-code)
*   [data-sveltekit-reload](#data-sveltekit-reload)
*   [data-sveltekit-replacestate](#data-sveltekit-replacestate)
*   [data-sveltekit-keepfocus](#data-sveltekit-keepfocus)
*   [data-sveltekit-noscroll](#data-sveltekit-noscroll)
*   [Disabling options](#Disabling-options)

In SvelteKit, `<a>` elements (rather than framework-specific `<Link>` components) are used to navigate between the routes of your app. If the user clicks on a link whose `href` is ‘owned’ by the app (as opposed to, say, a link to an external site) then SvelteKit will navigate to the new page by importing its code and then calling any `load` functions it needs to fetch data.

You can customise the behaviour of links with `data-sveltekit-*` attributes. These can be applied to the `<a>` itself, or to a parent element.

These options also apply to `<form>` elements with [`method="GET"`](form-actions#GET-vs-POST).

data-sveltekit-preload-data[](#data-sveltekit-preload-data)
-----------------------------------------------------------

Before the browser registers that the user has clicked on a link, we can detect that they’ve hovered the mouse over it (on desktop) or that a `touchstart` or `mousedown` event was triggered. In both cases, we can make an educated guess that a `click` event is coming.

SvelteKit can use this information to get a head start on importing the code and fetching the page’s data, which can give us an extra couple of hundred milliseconds — the difference between a user interface that feels laggy and one that feels snappy.

We can control this behaviour with the `data-sveltekit-preload-data` attribute, which can have one of two values:

*   `"hover"` means that preloading will start if the mouse comes to a rest over a link. On mobile, preloading begins on `touchstart`
*   `"tap"` means that preloading will start as soon as a `touchstart` or `mousedown` event is registered

The default project template has a `data-sveltekit-preload-data="hover"` attribute applied to the `<body>` element in `src/app.html`, meaning that every link is preloaded on hover by default:

    <body data-sveltekit-preload-data="hover">
    	<div style="display: contents">%sveltekit.body%</div>
    </body>

Sometimes, calling `load` when the user hovers over a link might be undesirable, either because it’s likely to result in false positives (a click needn’t follow a hover) or because data is updating very quickly and a delay could mean staleness.

In these cases, you can specify the `"tap"` value, which causes SvelteKit to call `load` only when the user taps or clicks on a link:

    <a data-sveltekit-preload-data="tap" href="/stonks">
    	Get current stonk values
    </a>

> You can also programmatically invoke `preloadData` from `$app/navigation`.

Data will never be preloaded if the user has chosen reduced data usage, meaning [`navigator.connection.saveData`](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData) is `true`.

data-sveltekit-preload-code[](#data-sveltekit-preload-code)
-----------------------------------------------------------

Even in cases where you don’t want to preload _data_ for a link, it can be beneficial to preload the _code_. The `data-sveltekit-preload-code` attribute works similarly to `data-sveltekit-preload-data`, except that it can take one of four values, in decreasing ‘eagerness’:

*   `"eager"` means that links will be preloaded straight away
*   `"viewport"` means that links will be preloaded once they enter the viewport
*   `"hover"` - as above, except that only code is preloaded
*   `"tap"` - as above, except that only code is preloaded

Note that `viewport` and `eager` only apply to links that are present in the DOM immediately following navigation — if a link is added later (in an `{#if ...}` block, for example) it will not be preloaded until triggered by `hover` or `tap`. This is to avoid performance pitfalls resulting from aggressively observing the DOM for changes.

> Since preloading code is a prerequisite for preloading data, this attribute will only have an effect if it specifies a more eager value than any `data-sveltekit-preload-data` attribute that is present.

As with `data-sveltekit-preload-data`, this attribute will be ignored if the user has chosen reduced data usage.

data-sveltekit-reload[](#data-sveltekit-reload)
-----------------------------------------------

Occasionally, we need to tell SvelteKit not to handle a link, but allow the browser to handle it. Adding a `data-sveltekit-reload` attribute to a link...

    <a data-sveltekit-reload href="/path">Path</a>

...will cause a full-page navigation when the link is clicked.

Links with a `rel="external"` attribute will receive the same treatment. In addition, they will be ignored during [prerendering](page-options#prerender).

data-sveltekit-replacestate[](#data-sveltekit-replacestate)
-----------------------------------------------------------

Sometimes you don’t want navigation to create a new entry in the browser’s session history. Adding a `data-sveltekit-replacestate` attribute to a link...

    <a data-sveltekit-replacestate href="/path">Path</a>

...will replace the current `history` entry rather than creating a new one with `pushState` when the link is clicked.

data-sveltekit-keepfocus[](#data-sveltekit-keepfocus)
-----------------------------------------------------

Sometimes you don’t want [focus to be reset](accessibility#Focus-management) after navigation. For example, maybe you have a search form that submits as the user is typing, and you want to keep focus on the text input. Adding a `data-sveltekit-keepfocus` attribute to it...

    <form data-sveltekit-keepfocus>
    	<input type="text" name="query">
    </form>

...will cause the currently focused element to retain focus after navigation. In general, avoid using this attribute on links, since the focused element would be the `<a>` tag (and not a previously focused element) and screen reader and other assistive technology users often expect focus to be moved after a navigation. You should also only use this attribute on elements that still exist after navigation. If the element no longer exists, the user’s focus will be lost, making for a confusing experience for assistive technology users.

data-sveltekit-noscroll[](#data-sveltekit-noscroll)
---------------------------------------------------

When navigating to internal links, SvelteKit mirrors the browser’s default navigation behaviour: it will change the scroll position to 0,0 so that the user is at the very top left of the page (unless the link includes a `#hash`, in which case it will scroll to the element with a matching ID).

In certain cases, you may wish to disable this behaviour. Adding a `data-sveltekit-noscroll` attribute to a link...

    <a href="path" data-sveltekit-noscroll>Path</a>

...will prevent scrolling after the link is clicked.

Disabling options[](#Disabling-options)
---------------------------------------

To disable any of these options inside an element where they have been enabled, use the `"false"` value:

    <div data-sveltekit-preload-data>
    	<!-- these links will be preloaded -->
    	<a href="/a">a</a>
    	<a href="/b">b</a>
    	<a href="/c">c</a>
    
    	<div data-sveltekit-preload-data="false">
    		<!-- these links will NOT be preloaded -->
    		<a href="/d">d</a>
    		<a href="/e">e</a>
    		<a href="/f">f</a>
    	</div>
    </div>

To apply an attribute to an element conditionally, do this:

    <div data-sveltekit-preload-data={condition ? 'hover' : false}>

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/30-advanced/30-link-options.md) [llms.txt](/docs/kit/link-options/llms.txt)

previous next

[Errors](/docs/kit/errors) [Service workers](/docs/kit/service-workers)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAdvanced

Service workers
===============

### On this page

*   [Service workers](/docs/kit/service-workers)
*   [Inside the service worker](#Inside-the-service-worker)
*   [During development](#During-development)
*   [Type safety](#Type-safety)
*   [Other solutions](#Other-solutions)
*   [References](#References)

Service workers act as proxy servers that handle network requests inside your app. This makes it possible to make your app work offline, but even if you don’t need offline support (or can’t realistically implement it because of the type of app you’re building), it’s often worth using service workers to speed up navigation by precaching your built JS and CSS.

In SvelteKit, if you have a `src/service-worker.js` file (or `src/service-worker/index.js`) it will be bundled and automatically registered. You can change the [location of your service worker](configuration#files) if you need to.

You can [disable automatic registration](configuration#serviceWorker) if you need to register the service worker with your own logic or use another solution. The default registration looks something like this:

    if ('serviceWorker' in var navigator: NavigatorMDN Reference
    navigator) {
    	function addEventListener<"load">(type: "load", listener: (this: Window, ev: Event) => any, options?: boolean | AddEventListenerOptions): void (+1 overload)addEventListener('load', function () {
    		var navigator: NavigatorMDN Reference
    navigator.Navigator.serviceWorker: ServiceWorkerContainerAvailable only in secure contexts.
    MDN Reference
    serviceWorker.ServiceWorkerContainer.register(scriptURL: string | URL, options?: RegistrationOptions): Promise<ServiceWorkerRegistration>MDN Reference
    register('./path/to/service-worker.js');
    	});
    }

Inside the service worker[](#Inside-the-service-worker)
-------------------------------------------------------

Inside the service worker you have access to the [`$service-worker` module]($service-worker), which provides you with the paths to all static assets, build files and prerendered pages. You’re also provided with an app version string, which you can use for creating a unique cache name, and the deployment’s `base` path. If your Vite config specifies `define` (used for global variable replacements), this will be applied to service workers as well as your server/client builds.

The following example caches the built app and any files in `static` eagerly, and caches all other requests as they happen. This would make each page work offline once visited.

    /// <reference types="@sveltejs/kit" />
    import { const build: string[]An array of URL strings representing the files generated by Vite, suitable for caching with cache.addAll(build).
    During development, this is an empty array.
    build, const files: string[]An array of URL strings representing the files in your static directory, or whatever directory is specified by config.kit.files.assets. You can customize which files are included from static directory using config.kit.serviceWorker.files
    files, const version: stringSee config.kit.version. It’s useful for generating unique cache names inside your service worker, so that a later deployment of your app can invalidate old caches.
    version } from '$service-worker';
    
    // Create a unique cache name for this deployment
    const const CACHE: stringCACHE = `cache-${const version: stringSee config.kit.version. It’s useful for generating unique cache names inside your service worker, so that a later deployment of your app can invalidate old caches.
    version}`;
    
    const const ASSETS: string[]ASSETS = [
    	...const build: string[]An array of URL strings representing the files generated by Vite, suitable for caching with cache.addAll(build).
    During development, this is an empty array.
    build, // the app itself
    	...const files: string[]An array of URL strings representing the files in your static directory, or whatever directory is specified by config.kit.files.assets. You can customize which files are included from static directory using config.kit.serviceWorker.files
    files  // everything in `static`
    ];
    
    var self: Window & typeof globalThisMDN Reference
    self.function addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void (+1 overload)Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options’s capture.
    When set to true, options’s capture prevents callback from being invoked when the event’s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event’s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event’s eventPhase attribute value is AT_TARGET.
    When set to true, options’s passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    When set to true, options’s once indicates that the callback will only be invoked once after which the event listener will be removed.
    If an AbortSignal is passed for options’s signal, then the event listener will be removed when signal is aborted.
    The event listener is appended to target’s event listener list and is not appended if it has the same type, callback, and capture.
    MDN Reference
    addEventListener('install', (event: Eventevent) => {
    	// Create a new cache and add all files to it
    	async function function (local function) addFilesToCache(): Promise<void>addFilesToCache() {
    		const const cache: Cachecache = await var caches: CacheStorageAvailable only in secure contexts.
    MDN Reference
    caches.CacheStorage.open(cacheName: string): Promise<Cache>MDN Reference
    open(const CACHE: stringCACHE);
    		await const cache: Cachecache.Cache.addAll(requests: Iterable<RequestInfo>): Promise<void> (+1 overload)MDN Reference
    addAll(const ASSETS: string[]ASSETS);
    	}
    
    	event: Eventevent.waitUntil(function (local function) addFilesToCache(): Promise<void>addFilesToCache());
    });
    
    var self: Window & typeof globalThisMDN Reference
    self.function addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void (+1 overload)Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options’s capture.
    When set to true, options’s capture prevents callback from being invoked when the event’s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event’s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event’s eventPhase attribute value is AT_TARGET.
    When set to true, options’s passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    When set to true, options’s once indicates that the callback will only be invoked once after which the event listener will be removed.
    If an AbortSignal is passed for options’s signal, then the event listener will be removed when signal is aborted.
    The event listener is appended to target’s event listener list and is not appended if it has the same type, callback, and capture.
    MDN Reference
    addEventListener('activate', (event: Eventevent) => {
    	// Remove previous cached data from disk
    	async function function (local function) deleteOldCaches(): Promise<void>deleteOldCaches() {
    		for (const const key: stringkey of await var caches: CacheStorageAvailable only in secure contexts.
    MDN Reference
    caches.CacheStorage.keys(): Promise<string[]>MDN Reference
    keys()) {
    			if (const key: stringkey !== const CACHE: stringCACHE) await var caches: CacheStorageAvailable only in secure contexts.
    MDN Reference
    caches.CacheStorage.delete(cacheName: string): Promise<boolean>MDN Reference
    delete(const key: stringkey);
    		}
    	}
    
    	event: Eventevent.waitUntil(function (local function) deleteOldCaches(): Promise<void>deleteOldCaches());
    });
    
    var self: Window & typeof globalThisMDN Reference
    self.function addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void (+1 overload)Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options’s capture.
    When set to true, options’s capture prevents callback from being invoked when the event’s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event’s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event’s eventPhase attribute value is AT_TARGET.
    When set to true, options’s passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    When set to true, options’s once indicates that the callback will only be invoked once after which the event listener will be removed.
    If an AbortSignal is passed for options’s signal, then the event listener will be removed when signal is aborted.
    The event listener is appended to target’s event listener list and is not appended if it has the same type, callback, and capture.
    MDN Reference
    addEventListener('fetch', (event: Eventevent) => {
    	// ignore POST requests etc
    	if (event: Eventevent.request.method !== 'GET') return;
    
    	async function function (local function) respond(): Promise<Response>respond() {
    		const const url: URLurl = new var URL: new (url: string | URL, base?: string | URL) => URLThe URL interface represents an object providing static methods used for creating object URLs.
    MDN Reference
    URL class is a global reference for require('url').URL
    https://nodejs.org/api/url.html#the-whatwg-url-api
    @sincev10.0.0URL(event: Eventevent.request.url);
    		const const cache: Cachecache = await var caches: CacheStorageAvailable only in secure contexts.
    MDN Reference
    caches.CacheStorage.open(cacheName: string): Promise<Cache>MDN Reference
    open(const CACHE: stringCACHE);
    
    		// `build`/`files` can always be served from the cache
    		if (const ASSETS: string[]ASSETS.Array<string>.includes(searchElement: string, fromIndex?: number): booleanDetermines whether an array includes a certain element, returning true or false as appropriate.
    @paramsearchElement The element to search for.@paramfromIndex The position in this array at which to begin searching for searchElement.includes(const url: URLurl.URL.pathname: stringMDN Reference
    pathname)) {
    			const const response: Response | undefinedresponse = await const cache: Cachecache.Cache.match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>MDN Reference
    match(const url: URLurl.URL.pathname: stringMDN Reference
    pathname);
    
    			if (const response: Response | undefinedresponse) {
    				return const response: Responseresponse;
    			}
    		}
    
    		// for everything else, try the network first, but
    		// fall back to the cache if we're offline
    		try {
    			const const response: Responseresponse = await function fetch(input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response> (+1 overload)MDN Reference
    fetch(event: Eventevent.request);
    
    			// if we're offline, fetch can return a value that is not a Response
    			// instead of throwing - and we can't pass this non-Response to respondWith
    			if (!(const response: Responseresponse instanceof var Response: {
        new (body?: BodyInit | null, init?: ResponseInit): Response;
        prototype: Response;
        error(): Response;
        json(data: any, init?: ResponseInit): Response;
        redirect(url: string | URL, status?: number): Response;
    }This Fetch API interface represents the response to a request.
    MDN Reference
    Response)) {
    				throw new var Error: ErrorConstructor
    new (message?: string, options?: ErrorOptions) => Error (+1 overload)Error('invalid response from fetch');
    			}
    
    			if (const response: Responseresponse.Response.status: numberMDN Reference
    status === 200) {
    				const cache: Cachecache.Cache.put(request: RequestInfo | URL, response: Response): Promise<void>MDN Reference
    put(event: Eventevent.request, const response: Responseresponse.Response.clone(): ResponseMDN Reference
    clone());
    			}
    
    			return const response: Responseresponse;
    		} catch (function (local var) err: unknownerr) {
    			const const response: Response | undefinedresponse = await const cache: Cachecache.Cache.match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>MDN Reference
    match(event: Eventevent.request);
    
    			if (const response: Response | undefinedresponse) {
    				return const response: Responseresponse;
    			}
    
    			// if there's no cache, then just error out
    			// as there is nothing we can do to respond to this request
    			throw function (local var) err: unknownerr;
    		}
    	}
    
    	event: Eventevent.respondWith(function (local function) respond(): Promise<Response>respond());
    });

> Be careful when caching! In some cases, stale data might be worse than data that’s unavailable while offline. Since browsers will empty caches if they get too full, you should also be careful about caching large assets like video files.

During development[](#During-development)
-----------------------------------------

The service worker is bundled for production, but not during development. For that reason, only browsers that support [modules in service workers](https://web.dev/es-modules-in-sw) will be able to use them at dev time. If you are manually registering your service worker, you will need to pass the `{ type: 'module' }` option in development:

    import { const dev: booleanWhether the dev server is running. This is not guaranteed to correspond to NODE_ENV or MODE.
    dev } from '$app/environment';
    
    var navigator: NavigatorMDN Reference
    navigator.Navigator.serviceWorker: ServiceWorkerContainerAvailable only in secure contexts.
    MDN Reference
    serviceWorker.ServiceWorkerContainer.register(scriptURL: string | URL, options?: RegistrationOptions): Promise<ServiceWorkerRegistration>MDN Reference
    register('/service-worker.js', {
    	RegistrationOptions.type?: WorkerType | undefinedtype: const dev: booleanWhether the dev server is running. This is not guaranteed to correspond to NODE_ENV or MODE.
    dev ? 'module' : 'classic'
    });

> `build` and `prerendered` are empty arrays during development

Type safety[](#Type-safety)
---------------------------

Setting up proper types for service workers requires some manual setup. Inside your `service-worker.js`, add the following to the top of your file:

    /// <reference types="@sveltejs/kit" />
    /// <reference no-default-lib="true"/>
    /// <reference lib="esnext" />
    /// <reference lib="webworker" />
    
    const sw = /** @type {ServiceWorkerGlobalScope} */ (/** @type {unknown} */ (self));

    /// <reference types="@sveltejs/kit" />
    /// <reference no-default-lib="true"/>
    /// <reference lib="esnext" />
    /// <reference lib="webworker" />
    
    const sw = self as unknown as ServiceWorkerGlobalScope;

This disables access to DOM typings like `HTMLElement` which are not available inside a service worker and instantiates the correct globals. The reassignment of `self` to `sw` allows you to type cast it in the process (there are a couple of ways to do this, but this is the easiest that requires no additional files). Use `sw` instead of `self` in the rest of the file. The reference to the SvelteKit types ensures that the `$service-worker` import has proper type definitions. If you import `$env/static/public` you either have to `// @ts-ignore` the import or add `/// <reference types="../.svelte-kit/ambient.d.ts" />` to the reference types.

Other solutions[](#Other-solutions)
-----------------------------------

SvelteKit’s service worker implementation is designed to be easy to work with and is probably a good solution for most users. However, outside of SvelteKit, many PWA applications leverage the [Workbox](https://web.dev/learn/pwa/workbox) library. If you’re used to using Workbox you may prefer [Vite PWA plugin](https://vite-pwa-org.netlify.app/frameworks/sveltekit.html).

References[](#References)
-------------------------

For more general information on service workers, we recommend [the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers).

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/30-advanced/40-service-workers.md) [llms.txt](/docs/kit/service-workers/llms.txt)

previous next

[Link options](/docs/kit/link-options) [Server-only modules](/docs/kit/server-only-modules)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAdvanced

Server-only modules
===================

### On this page

*   [Server-only modules](/docs/kit/server-only-modules)
*   [Private environment variables](#Private-environment-variables)
*   [Server-only utilities](#Server-only-utilities)
*   [Your modules](#Your-modules)
*   [How it works](#How-it-works)
*   [Further reading](#Further-reading)

Like a good friend, SvelteKit keeps your secrets. When writing your backend and frontend in the same repository, it can be easy to accidentally import sensitive data into your front-end code (environment variables containing API keys, for example). SvelteKit provides a way to prevent this entirely: server-only modules.

Private environment variables[](#Private-environment-variables)
---------------------------------------------------------------

The [`$env/static/private`]($env-static-private) and [`$env/dynamic/private`]($env-dynamic-private) modules can only be imported into modules that only run on the server, such as [`hooks.server.js`](hooks#Server-hooks) or [`+page.server.js`](routing#page-page.server.js).

Server-only utilities[](#Server-only-utilities)
-----------------------------------------------

The [`$app/server`]($app-server) module, which contains a [`read`]($app-server#read) function for reading assets from the filesystem, can likewise only be imported by code that runs on the server.

Your modules[](#Your-modules)
-----------------------------

You can make your own modules server-only in two ways:

*   adding `.server` to the filename, e.g. `secrets.server.js`
*   placing them in `$lib/server`, e.g. `$lib/server/secrets.js`

How it works[](#How-it-works)
-----------------------------

Any time you have public-facing code that imports server-only code (whether directly or indirectly)...

$lib/server/secrets

    export const atlantisCoordinates = [/* redacted */];
    

src/routes/utils

    export { export atlantisCoordinatesatlantisCoordinates } from '$lib/server/secrets.js';
    
    export const const add: (a: any, b: any) => anyadd = (a, b) => a: anya + b: anyb;
    
    

src/routes/+page

    <script>
    	import { add } from './utils.js';
    </script>

...SvelteKit will error:

    Cannot import $lib/server/secrets.js into public-facing code:
    - src/routes/+page.svelte
    	- src/routes/utils.js
    		- $lib/server/secrets.js

Even though the public-facing code — `src/routes/+page.svelte` — only uses the `add` export and not the secret `atlantisCoordinates` export, the secret code could end up in JavaScript that the browser downloads, and so the import chain is considered unsafe.

This feature also works with dynamic imports, even interpolated ones like ``await import(`./${foo}.js`)``, with one small caveat: during development, if there are two or more dynamic imports between the public-facing code and the server-only module, the illegal import will not be detected the first time the code is loaded.

> Unit testing frameworks like Vitest do not distinguish between server-only and public-facing code. For this reason, illegal import detection is disabled when running tests, as determined by `process.env.TEST === 'true'`.

Further reading[](#Further-reading)
-----------------------------------

*   [Tutorial: Environment variables](/tutorial/kit/env-static-private)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/30-advanced/50-server-only-modules.md) [llms.txt](/docs/kit/server-only-modules/llms.txt)

previous next

[Service workers](/docs/kit/service-workers) [Snapshots](/docs/kit/snapshots)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAdvanced

Snapshots
=========

### On this page

*   [Snapshots](/docs/kit/snapshots)

Ephemeral DOM state — like scroll positions on sidebars, the content of `<input>` elements and so on — is discarded when you navigate from one page to another.

For example, if the user fills out a form but navigates away and then back before submitting, or if the user refreshes the page, the values they filled in will be lost. In cases where it’s valuable to preserve that input, you can take a _snapshot_ of DOM state, which can then be restored if the user navigates back.

To do this, export a `snapshot` object with `capture` and `restore` methods from a `+page.svelte` or `+layout.svelte`:

+page

    <script>
    	let comment = $state('');
    
    	/** @type {import('./$types').Snapshot<string>} */
    	export const snapshot = {
    		capture: () => comment,
    		restore: (value) => comment = value
    	};
    </script>
    
    <form method="POST">
    	<label for="comment">Comment</label>
    	<textarea id="comment" bind:value={comment} />
    	<button>Post comment</button>
    </form>

    <script lang="ts">
    	import type { Snapshot } from './$types';
    
    	let comment = $state('');
    
    	export const snapshot: Snapshot<string> = {
    		capture: () => comment,
    		restore: (value) => comment = value
    	};
    </script>
    
    <form method="POST">
    	<label for="comment">Comment</label>
    	<textarea id="comment" bind:value={comment} />
    	<button>Post comment</button>
    </form>

When you navigate away from this page, the `capture` function is called immediately before the page updates, and the returned value is associated with the current entry in the browser’s history stack. If you navigate back, the `restore` function is called with the stored value as soon as the page is updated.

The data must be serializable as JSON so that it can be persisted to `sessionStorage`. This allows the state to be restored when the page is reloaded, or when the user navigates back from a different site.

> Avoid returning very large objects from `capture` — once captured, objects will be retained in memory for the duration of the session, and in extreme cases may be too large to persist to `sessionStorage`.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/30-advanced/65-snapshots.md) [llms.txt](/docs/kit/snapshots/llms.txt)

previous next

[Server-only modules](/docs/kit/server-only-modules) [Shallow routing](/docs/kit/shallow-routing)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAdvanced

Shallow routing
===============

### On this page

*   [Shallow routing](/docs/kit/shallow-routing)
*   [API](#API)
*   [Loading data for a route](#Loading-data-for-a-route)
*   [Caveats](#Caveats)

As you navigate around a SvelteKit app, you create _history entries_. Clicking the back and forward buttons traverses through this list of entries, re-running any `load` functions and replacing page components as necessary.

Sometimes, it’s useful to create history entries _without_ navigating. For example, you might want to show a modal dialog that the user can dismiss by navigating back. This is particularly valuable on mobile devices, where swipe gestures are often more natural than interacting directly with the UI. In these cases, a modal that is _not_ associated with a history entry can be a source of frustration, as a user may swipe backwards in an attempt to dismiss it and find themselves on the wrong page.

SvelteKit makes this possible with the [`pushState`]($app-navigation#pushState) and [`replaceState`]($app-navigation#replaceState) functions, which allow you to associate state with a history entry without navigating. For example, to implement a history-driven modal:

+page

    <script>
    	import { pushState } from '$app/navigation';
    	import { page } from '$app/state';
    	import Modal from './Modal.svelte';
    
    	function showModal() {
    		pushState('', {
    			showModal: true
    		});
    	}
    </script>
    
    {#if page.state.showModal}
    	<Modal close={() => history.back()} />
    {/if}

    <script lang="ts">
    	import { pushState } from '$app/navigation';
    	import { page } from '$app/state';
    	import Modal from './Modal.svelte';
    
    	function showModal() {
    		pushState('', {
    			showModal: true
    		});
    	}
    </script>
    
    {#if page.state.showModal}
    	<Modal close={() => history.back()} />
    {/if}

The modal can be dismissed by navigating back (unsetting `page.state.showModal`) or by interacting with it in a way that causes the `close` callback to run, which will navigate back programmatically.

API[](#API)
-----------

The first argument to `pushState` is the URL, relative to the current URL. To stay on the current URL, use `''`.

The second argument is the new page state, which can be accessed via the [page object]($app-state#page) as `page.state`. You can make page state type-safe by declaring an [`App.PageState`](types#PageState) interface (usually in `src/app.d.ts`).

To set page state without creating a new history entry, use `replaceState` instead of `pushState`.

> Legacy mode
> 
> `page.state` from `$app/state` was added in SvelteKit 2.12. If you’re using an earlier version or are using Svelte 4, use `$page.state` from `$app/stores` instead.

Loading data for a route[](#Loading-data-for-a-route)
-----------------------------------------------------

When shallow routing, you may want to render another `+page.svelte` inside the current page. For example, clicking on a photo thumbnail could pop up the detail view without navigating to the photo page.

For this to work, you need to load the data that the `+page.svelte` expects. A convenient way to do this is to use [`preloadData`]($app-navigation#preloadData) inside the `click` handler of an `<a>` element. If the element (or a parent) uses [`data-sveltekit-preload-data`](link-options#data-sveltekit-preload-data), the data will have already been requested, and `preloadData` will reuse that request.

src/routes/photos/+page

    <script>
    	import { preloadData, pushState, goto } from '$app/navigation';
    	import { page } from '$app/state';
    	import Modal from './Modal.svelte';
    	import PhotoPage from './[id]/+page.svelte';
    
    	let { data } = $props();
    </script>
    
    {#each data.thumbnails as thumbnail}
    	<a
    		href="/photos/{thumbnail.id}"
    		onclick={async (e) => {
    			if (innerWidth < 640        // bail if the screen is too small
    				|| e.shiftKey             // or the link is opened in a new window
    				|| e.metaKey || e.ctrlKey // or a new tab (mac: metaKey, win/linux: ctrlKey)
    				// should also consider clicking with a mouse scroll wheel
    			) return;
    
    			// prevent navigation
    			e.preventDefault();
    
    			const { href } = e.currentTarget;
    
    			// run `load` functions (or rather, get the result of the `load` functions
    			// that are already running because of `data-sveltekit-preload-data`)
    			const result = await preloadData(href);
    
    			if (result.type === 'loaded' && result.status === 200) {
    				pushState(href, { selected: result.data });
    			} else {
    				// something bad happened! try navigating
    				goto(href);
    			}
    		}}
    	>
    		<img alt={thumbnail.alt} src={thumbnail.src} />
    	</a>
    {/each}
    
    {#if page.state.selected}
    	<Modal onclose={() => history.back()}>
    		<!-- pass page data to the +page.svelte component,
    		     just like SvelteKit would on navigation -->
    		<PhotoPage data={page.state.selected} />
    	</Modal>
    {/if}

    <script lang="ts">
    	import { preloadData, pushState, goto } from '$app/navigation';
    	import { page } from '$app/state';
    	import Modal from './Modal.svelte';
    	import PhotoPage from './[id]/+page.svelte';
    
    	let { data } = $props();
    </script>
    
    {#each data.thumbnails as thumbnail}
    	<a
    		href="/photos/{thumbnail.id}"
    		onclick={async (e) => {
    			if (innerWidth < 640        // bail if the screen is too small
    				|| e.shiftKey             // or the link is opened in a new window
    				|| e.metaKey || e.ctrlKey // or a new tab (mac: metaKey, win/linux: ctrlKey)
    				// should also consider clicking with a mouse scroll wheel
    			) return;
    
    			// prevent navigation
    			e.preventDefault();
    
    			const { href } = e.currentTarget;
    
    			// run `load` functions (or rather, get the result of the `load` functions
    			// that are already running because of `data-sveltekit-preload-data`)
    			const result = await preloadData(href);
    
    			if (result.type === 'loaded' && result.status === 200) {
    				pushState(href, { selected: result.data });
    			} else {
    				// something bad happened! try navigating
    				goto(href);
    			}
    		}}
    	>
    		<img alt={thumbnail.alt} src={thumbnail.src} />
    	</a>
    {/each}
    
    {#if page.state.selected}
    	<Modal onclose={() => history.back()}>
    		<!-- pass page data to the +page.svelte component,
    		     just like SvelteKit would on navigation -->
    		<PhotoPage data={page.state.selected} />
    	</Modal>
    {/if}

Caveats[](#Caveats)
-------------------

During server-side rendering, `page.state` is always an empty object. The same is true for the first page the user lands on — if the user reloads the page (or returns from another document), state will _not_ be applied until they navigate.

Shallow routing is a feature that requires JavaScript to work. Be mindful when using it and try to think of sensible fallback behavior in case JavaScript isn’t available.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/30-advanced/67-shallow-routing.md) [llms.txt](/docs/kit/shallow-routing/llms.txt)

previous next

[Snapshots](/docs/kit/snapshots) [Packaging](/docs/kit/packaging)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAdvanced

Packaging
=========

### On this page

*   [Packaging](/docs/kit/packaging)
*   [Anatomy of a package.json](#Anatomy-of-a-package.json)
*   [TypeScript](#TypeScript)
*   [Best practices](#Best-practices)
*   [Source maps](#Source-maps)
*   [Options](#Options)
*   [Publishing](#Publishing)
*   [Caveats](#Caveats)

You can use SvelteKit to build apps as well as component libraries, using the `@sveltejs/package` package (`npx sv create` has an option to set this up for you).

When you’re creating an app, the contents of `src/routes` is the public-facing stuff; [`src/lib`]($lib) contains your app’s internal library.

A component library has the exact same structure as a SvelteKit app, except that `src/lib` is the public-facing bit, and your root `package.json` is used to publish the package. `src/routes` might be a documentation or demo site that accompanies the library, or it might just be a sandbox you use during development.

Running the `svelte-package` command from `@sveltejs/package` will take the contents of `src/lib` and generate a `dist` directory (which can be [configured](#Options)) containing the following:

*   All the files in `src/lib`. Svelte components will be preprocessed, TypeScript files will be transpiled to JavaScript.
*   Type definitions (`d.ts` files) which are generated for Svelte, JavaScript and TypeScript files. You need to install `typescript >= 4.0.0` for this. Type definitions are placed next to their implementation, hand-written `d.ts` files are copied over as is. You can [disable generation](#Options), but we strongly recommend against it — people using your library might use TypeScript, for which they require these type definition files.

> `@sveltejs/package` version 1 generated a `package.json`. This is no longer the case and it will now use the `package.json` from your project and validate that it is correct instead. If you’re still on version 1, see [this PR](https://github.com/sveltejs/kit/pull/8922) for migration instructions.

Anatomy of a package.json[](#Anatomy-of-a-package.json)
-------------------------------------------------------

Since you’re now building a library for public use, the contents of your `package.json` will become more important. Through it, you configure the entry points of your package, which files are published to npm, and which dependencies your library has. Let’s go through the most important fields one by one.

### name[](#Anatomy-of-a-package.json-name)

This is the name of your package. It will be available for others to install using that name, and visible on `https://npmjs.com/package/<name>`.

    {
    	"name": "your-library"
    }

Read more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#name).

### license[](#Anatomy-of-a-package.json-license)

Every package should have a license field so people know how they are allowed to use it. A very popular license which is also very permissive in terms of distribution and reuse without warranty is `MIT`.

    {
    	"license": "MIT"
    }

Read more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#license). Note that you should also include a `LICENSE` file in your package.

### files[](#Anatomy-of-a-package.json-files)

This tells npm which files it will pack up and upload to npm. It should contain your output folder (`dist` by default). Your `package.json` and `README` and `LICENSE` will always be included, so you don’t need to specify them.

    {
    	"files": ["dist"]
    }

To exclude unnecessary files (such as unit tests, or modules that are only imported from `src/routes` etc) you can add them to an `.npmignore` file. This will result in smaller packages that are faster to install.

Read more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#files).

### exports[](#Anatomy-of-a-package.json-exports)

The `"exports"` field contains the package’s entry points. If you set up a new library project through `npx sv create`, it’s set to a single export, the package root:

    {
    	"exports": {
    		".": {
    			"types": "./dist/index.d.ts",
    			"svelte": "./dist/index.js"
    		}
    	}
    }

This tells bundlers and tooling that your package only has one entry point, the root, and everything should be imported through that, like this:

    import { import SomethingSomething } from 'your-library';
    

The `types` and `svelte` keys are [export conditions](https://nodejs.org/api/packages.html#conditional-exports). They tell tooling what file to import when they look up the `your-library` import:

*   TypeScript sees the `types` condition and looks up the type definition file. If you don’t publish type definitions, omit this condition.
*   Svelte-aware tooling sees the `svelte` condition and knows this is a Svelte component library. If you publish a library that does not export any Svelte components and that could also work in non-Svelte projects (for example a Svelte store library), you can replace this condition with `default`.

> Previous versions of `@sveltejs/package` also added a `package.json` export. This is no longer part of the template because all tooling can now deal with a `package.json` not being explicitly exported.

You can adjust `exports` to your liking and provide more entry points. For example, if instead of a `src/lib/index.js` file that re-exported components you wanted to expose a `src/lib/Foo.svelte` component directly, you could create the following export map...

    {
    	"exports": {
    		"./Foo.svelte": {
    			"types": "./dist/Foo.svelte.d.ts",
    			"svelte": "./dist/Foo.svelte"
    		}
    	}
    }

...and a consumer of your library could import the component like so:

    import module "your-library/Foo.svelte"Foo from 'your-library/Foo.svelte';

> Beware that doing this will need additional care if you provide type definitions. Read more about the caveat [here](#TypeScript)

In general, each key of the exports map is the path the user will have to use to import something from your package, and the value is the path to the file that will be imported or a map of export conditions which in turn contains these file paths.

Read more about `exports` [here](https://nodejs.org/docs/latest-v18.x/api/packages.html#package-entry-points).

### svelte[](#Anatomy-of-a-package.json-svelte)

This is a legacy field that enabled tooling to recognise Svelte component libraries. It’s no longer necessary when using the `svelte` [export condition](#Anatomy-of-a-package.json-exports), but for backwards compatibility with outdated tooling that doesn’t yet know about export conditions it’s good to keep it around. It should point towards your root entry point.

    {
    	"svelte": "./dist/index.js"
    }

### sideEffects[](#Anatomy-of-a-package.json-sideEffects)

The `sideEffects` field in `package.json` is used by bundlers to determine if a module may contain code that has side effects. A module is considered to have side effects if it makes changes that are observable from other scripts outside the module when it’s imported. For example, side effects include modifying global variables or the prototype of built-in JavaScript objects. Because a side effect could potentially affect the behavior of other parts of the application, these files/modules will be included in the final bundle regardless of whether their exports are used in the application. It is a best practice to avoid side effects in your code.

Setting the `sideEffects` field in `package.json` can help the bundler to be more aggressive in eliminating unused exports from the final bundle, a process known as tree-shaking. This results in smaller and more efficient bundles. Different bundlers handle `sideEffects` in various manners. While not necessary for Vite, we recommend that libraries state that all CSS files have side effects so that your library will be [compatible with webpack](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free). This is the configuration that comes with newly created projects:

package

    {
    	"sideEffects": ["**/*.css"]
    }

> If the scripts in your library have side effects, ensure that you update the `sideEffects` field. All scripts are marked as side effect free by default in newly created projects. If a file with side effects is incorrectly marked as having no side effects, it can result in broken functionality.

If your package has files with side effects, you can specify them in an array:

package

    {
    	"sideEffects": [
    		"**/*.css",
    		"./dist/sideEffectfulFile.js"
    	]
    }

This will treat only the specified files as having side effects.

TypeScript[](#TypeScript)
-------------------------

You should ship type definitions for your library even if you don’t use TypeScript yourself so that people who do get proper intellisense when using your library. `@sveltejs/package` makes the process of generating types mostly opaque to you. By default, when packaging your library, type definitions are auto-generated for JavaScript, TypeScript and Svelte files. All you need to ensure is that the `types` condition in the [exports](#Anatomy-of-a-package.json-exports) map points to the correct files. When initialising a library project through `npx sv create`, this is automatically setup for the root export.

If you have something else than a root export however — for example providing a `your-library/foo` import — you need to take additional care for providing type definitions. Unfortunately, TypeScript by default will _not_ resolve the `types` condition for an export like `{ "./foo": { "types": "./dist/foo.d.ts", ... }}`. Instead, it will search for a `foo.d.ts` relative to the root of your library (i.e. `your-library/foo.d.ts` instead of `your-library/dist/foo.d.ts`). To fix this, you have two options:

The first option is to require people using your library to set the `moduleResolution` option in their `tsconfig.json` (or `jsconfig.json`) to `bundler` (available since TypeScript 5, the best and recommended option in the future), `node16` or `nodenext`. This opts TypeScript into actually looking at the exports map and resolving the types correctly.

The second option is to (ab)use the `typesVersions` feature from TypeScript to wire up the types. This is a field inside `package.json` TypeScript uses to check for different type definitions depending on the TypeScript version, and also contains a path mapping feature for that. We leverage that path mapping feature to get what we want. For the mentioned `foo` export above, the corresponding `typesVersions` looks like this:

    {
    	"exports": {
    		"./foo": {
    			"types": "./dist/foo.d.ts",
    			"svelte": "./dist/foo.js"
    		}
    	},
    	"typesVersions": {
    		">4.0": {
    			"foo": ["./dist/foo.d.ts"]
    		}
    	}
    }

`>4.0` tells TypeScript to check the inner map if the used TypeScript version is greater than 4 (which should in practice always be true). The inner map tells TypeScript that the typings for `your-library/foo` are found within `./dist/foo.d.ts`, which essentially replicates the `exports` condition. You also have `*` as a wildcard at your disposal to make many type definitions at once available without repeating yourself. Note that if you opt into `typesVersions` you have to declare all type imports through it, including the root import (which is defined as `"index.d.ts": [..]`).

You can read more about that feature [here](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#version-selection-with-typesversions).

Best practices[](#Best-practices)
---------------------------------

You should avoid using SvelteKit-specific modules like `$app/environment` in your packages unless you intend for them to only be consumable by other SvelteKit projects. E.g. rather than using `import { browser } from '$app/environment'` you could use `import { BROWSER } from 'esm-env'` ([see esm-env docs](https://github.com/benmccann/esm-env)). You may also wish to pass in things like the current URL or a navigation action as a prop rather than relying directly on `$app/state`, `$app/navigation`, etc. Writing your app in this more generic fashion will also make it easier to setup tools for testing, UI demos and so on.

Ensure that you add [aliases](configuration#alias) via `svelte.config.js` (not `vite.config.js` or `tsconfig.json`), so that they are processed by `svelte-package`.

You should think carefully about whether or not the changes you make to your package are a bug fix, a new feature, or a breaking change, and update the package version accordingly. Note that if you remove any paths from `exports` or any `export` conditions inside them from your existing library, that should be regarded as a breaking change.

    {
    	"exports": {
    		".": {
    			"types": "./dist/index.d.ts",
    // changing `svelte` to `default` is a breaking change:
    			"svelte": "./dist/index.js"
    			"default": "./dist/index.js"
    		},
    // removing this is a breaking change:
    		"./foo": {
    			"types": "./dist/foo.d.ts",
    			"svelte": "./dist/foo.js",
    			"default": "./dist/foo.js"
    		},
    // adding this is ok:
    		"./bar": {
    			"types": "./dist/bar.d.ts",
    			"svelte": "./dist/bar.js",
    			"default": "./dist/bar.js"
    		}
    	}
    }

Source maps[](#Source-maps)
---------------------------

You can create so-called declaration maps (`d.ts.map` files) by setting `"declarationMap": true` in your `tsconfig.json`. This will allow editors such as VS Code to go to the original `.ts` or `.svelte` file when using features like _Go to Definition_. This means you also need to publish your source files alongside your dist folder in a way that the relative path inside the declaration files leads to a file on disk. Assuming that you have all your library code inside `src/lib` as suggested by Svelte’s CLI, this is as simple as adding `src/lib` to `files` in your `package.json`:

    {
    	"files": [
    		"dist",
    		"!dist/**/*.test.*",
    		"!dist/**/*.spec.*",
    		"src/lib",
    		"!src/lib/**/*.test.*",
    		"!src/lib/**/*.spec.*"
    	]
    }

Options[](#Options)
-------------------

`svelte-package` accepts the following options:

*   `-w` / `--watch` — watch files in `src/lib` for changes and rebuild the package
*   `-i` / `--input` — the input directory which contains all the files of the package. Defaults to `src/lib`
*   `-o` / `--output` — the output directory where the processed files are written to. Your `package.json`’s `exports` should point to files inside there, and the `files` array should include that folder. Defaults to `dist`
*   `-t` / `--types` — whether or not to create type definitions (`d.ts` files). We strongly recommend doing this as it fosters ecosystem library quality. Defaults to `true`
*   `--tsconfig` - the path to a tsconfig or jsconfig. When not provided, searches for the next upper tsconfig/jsconfig in the workspace path.

Publishing[](#Publishing)
-------------------------

To publish the generated package:

    npm publish

Caveats[](#Caveats)
-------------------

All relative file imports need to be fully specified, adhering to Node’s ESM algorithm. This means that for a file like `src/lib/something/index.js`, you must include the filename with the extension:

    import { import somethingsomething } from './something/index.js';
    

If you are using TypeScript, you need to import `.ts` files the same way, but using a `.js` file ending, _not_ a `.ts` file ending. (This is a TypeScript design decision outside our control.) Setting `"moduleResolution": "NodeNext"` in your `tsconfig.json` or `jsconfig.json` will help you with this.

All files except Svelte files (preprocessed) and TypeScript files (transpiled to JavaScript) are copied across as-is.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/30-advanced/70-packaging.md) [llms.txt](/docs/kit/packaging/llms.txt)

previous next

[Shallow routing](/docs/kit/shallow-routing) [Auth](/docs/kit/auth)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBest practices

Auth
====

### On this page

*   [Auth](/docs/kit/auth)
*   [Sessions vs tokens](#Sessions-vs-tokens)
*   [Integration points](#Integration-points)
*   [Guides](#Guides)

Auth refers to authentication and authorization, which are common needs when building a web application. Authentication means verifying that the user is who they say they are based on their provided credentials. Authorization means determining which actions they are allowed to take.

Sessions vs tokens[](#Sessions-vs-tokens)
-----------------------------------------

After the user has provided their credentials such as a username and password, we want to allow them to use the application without needing to provide their credentials again for future requests. Users are commonly authenticated on subsequent requests with either a session identifier or signed token such as a JSON Web Token (JWT).

Session IDs are most commonly stored in a database. They can be immediately revoked, but require a database query to be made on each request.

In contrast, JWT generally are not checked against a datastore, which means they cannot be immediately revoked. The advantage of this method is improved latency and reduced load on your datastore.

Integration points[](#Integration-points)
-----------------------------------------

Auth [cookies](@sveltejs-kit#Cookies) can be checked inside [server hooks](hooks#Server-hooks). If a user is found matching the provided credentials, the user information can be stored in [`locals`](hooks#Server-hooks-handle).

Guides[](#Guides)
-----------------

[Lucia](https://lucia-auth.com/) is a good reference for session-based web app auth. It contains example code snippets and projects for implementing session-based auth within SvelteKit and other JS projects. You can add code which follows the Lucia guide to your project with `npx sv create` when creating a new project or `npx sv add lucia` for an existing project.

An auth system is tightly coupled to a web framework because most of the code lies in validating user input, handling errors, and directing users to the appropriate next page. As a result, many of the generic JS auth libraries include one or more web frameworks within them. For this reason, many users will find it preferrable to follow a SvelteKit-specific guide such as the examples found in [Lucia](https://lucia-auth.com/) rather than having multiple web frameworks inside their project.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/40-best-practices/03-auth.md) [llms.txt](/docs/kit/auth/llms.txt)

previous next

[Packaging](/docs/kit/packaging) [Performance](/docs/kit/performance)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBest practices

Performance
===========

### On this page

*   [Performance](/docs/kit/performance)
*   [Diagnosing issues](#Diagnosing-issues)
*   [Optimizing assets](#Optimizing-assets)
*   [Reducing code size](#Reducing-code-size)
*   [Navigation](#Navigation)
*   [Hosting](#Hosting)
*   [Further reading](#Further-reading)

Out of the box, SvelteKit does a lot of work to make your applications as performant as possible:

*   Code-splitting, so that only the code you need for the current page is loaded
*   Asset preloading, so that ‘waterfalls’ (of files requesting other files) are prevented
*   File hashing, so that your assets can be cached forever
*   Request coalescing, so that data fetched from separate server `load` functions is grouped into a single HTTP request
*   Parallel loading, so that separate universal `load` functions fetch data simultaneously
*   Data inlining, so that requests made with `fetch` during server rendering can be replayed in the browser without issuing a new request
*   Conservative invalidation, so that `load` functions are only re-run when necessary
*   Prerendering (configurable on a per-route basis, if necessary) so that pages without dynamic data can be served instantaneously
*   Link preloading, so that data and code requirements for a client-side navigation are eagerly anticipated

Nevertheless, we can’t (yet) eliminate all sources of slowness. To eke out maximum performance, you should be mindful of the following tips.

Diagnosing issues[](#Diagnosing-issues)
---------------------------------------

Google’s [PageSpeed Insights](https://pagespeed.web.dev/) and (for more advanced analysis) [WebPageTest](https://www.webpagetest.org/) are excellent ways to understand the performance characteristics of a site that is already deployed to the internet.

Your browser also includes useful developer tools for analysing your site, whether deployed or running locally:

*   Chrome - [Lighthouse](https://developer.chrome.com/docs/lighthouse/overview#devtools), [Network](https://developer.chrome.com/docs/devtools/network), and [Performance](https://developer.chrome.com/docs/devtools/performance) devtools
*   Edge - [Lighthouse](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/lighthouse/lighthouse-tool), [Network](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/network/), and [Performance](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/evaluate-performance/) devtools
*   Firefox - [Network](https://firefox-source-docs.mozilla.org/devtools-user/network_monitor/) and [Performance](https://hacks.mozilla.org/2022/03/performance-tool-in-firefox-devtools-reloaded/) devtools
*   Safari - [enhancing the performance of your webpage](https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/Web_Inspector_Tutorial/EnhancingyourWebpagesPerformance/EnhancingyourWebpagesPerformance.html)

Note that your site running locally in `dev` mode will exhibit different behaviour than your production app, so you should do performance testing in [preview](building-your-app#Preview-your-app) mode after building.

### Instrumenting[](#Diagnosing-issues-Instrumenting)

If you see in the network tab of your browser that an API call is taking a long time and you’d like to understand why, you may consider instrumenting your backend with a tool like [OpenTelemetry](https://opentelemetry.io/) or [Server-Timing headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server-Timing).

Optimizing assets[](#Optimizing-assets)
---------------------------------------

### Images[](#Optimizing-assets-Images)

Reducing the size of image files is often one of the most impactful changes you can make to a site’s performance. Svelte provides the `@sveltejs/enhanced-img` package, detailed on the [images](images) page, for making this easier. Additionally, Lighthouse is useful for identifying the worst offenders.

### Videos[](#Optimizing-assets-Videos)

Video files can be very large, so extra care should be taken to ensure that they’re optimized:

*   Compress videos with tools such as [Handbrake](https://handbrake.fr/). Consider converting the videos to web-friendly formats such as `.webm` or `.mp4`.
*   You can [lazy-load videos](https://web.dev/articles/lazy-loading-video) located below the fold with `preload="none"` (though note that this will slow down playback when the user _does_ initiate it).
*   Strip the audio track out of muted videos using a tool like [FFmpeg](https://ffmpeg.org/).

### Fonts[](#Optimizing-assets-Fonts)

SvelteKit automatically preloads critical `.js` and `.css` files when the user visits a page, but it does _not_ preload fonts by default, since this may cause unnecessary files (such as font weights that are referenced by your CSS but not actually used on the current page) to be downloaded. Having said that, preloading fonts correctly can make a big difference to how fast your site feels. In your [`handle`](hooks#Server-hooks-handle) hook, you can call `resolve` with a `preload` filter that includes your fonts.

You can reduce the size of font files by [subsetting](https://web.dev/learn/performance/optimize-web-fonts#subset_your_web_fonts) your fonts.

Reducing code size[](#Reducing-code-size)
-----------------------------------------

### Svelte version[](#Reducing-code-size-Svelte-version)

We recommend running the latest version of Svelte. Svelte 5 is smaller and faster than Svelte 4, which is smaller and faster than Svelte 3.

### Packages[](#Reducing-code-size-Packages)

[`rollup-plugin-visualizer`](https://www.npmjs.com/package/rollup-plugin-visualizer) can be helpful for identifying which packages are contributing the most to the size of your site. You may also find opportunities to remove code by manually inspecting the build output (use `build: { minify: false }` in your [Vite config](https://vitejs.dev/config/build-options.html#build-minify) to make the output readable, but remember to undo that before deploying your app), or via the network tab of your browser’s devtools.

### External scripts[](#Reducing-code-size-External-scripts)

Try to minimize the number of third-party scripts running in the browser. For example, instead of using JavaScript-based analytics consider using server-side implementations, such as those offered by many platforms with SvelteKit adapters including [Cloudflare](https://www.cloudflare.com/web-analytics/), [Netlify](https://docs.netlify.com/monitor-sites/site-analytics/), and [Vercel](https://vercel.com/docs/analytics).

To run third party scripts in a web worker (which avoids blocking the main thread), use [Partytown’s SvelteKit integration](https://partytown.builder.io/sveltekit).

### Selective loading[](#Reducing-code-size-Selective-loading)

Code imported with static `import` declarations will be automatically bundled with the rest of your page. If there is a piece of code you need only when some condition is met, use the dynamic `import(...)` form to selectively lazy-load the component.

Navigation[](#Navigation)
-------------------------

### Preloading[](#Navigation-Preloading)

You can speed up client-side navigations by eagerly preloading the necessary code and data, using [link options](link-options). This is configured by default on the `<body>` element when you create a new SvelteKit app.

### Non-essential data[](#Navigation-Non-essential-data)

For slow-loading data that isn’t needed immediately, the object returned from your `load` function can contain promises rather than the data itself. For server `load` functions, this will cause the data to [stream](load#Streaming-with-promises) in after the navigation (or initial page load).

### Preventing waterfalls[](#Navigation-Preventing-waterfalls)

One of the biggest performance killers is what is referred to as a _waterfall_, which is a series of requests that is made sequentially. This can happen on the server or in the browser.

*   Asset waterfalls can occur in the browser when your HTML requests JS which requests CSS which requests a background image and web font. SvelteKit will largely solve this class of problems for you by adding [`modulepreload`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/modulepreload) tags or headers, but you should view [the network tab in your devtools](#Diagnosing-issues) to check whether additional resources need to be preloaded. Pay special attention to this if you use web [fonts](#Optimizing-assets-Fonts) since they need to be handled manually.
*   If a universal `load` function makes an API call to fetch the current user, then uses the details from that response to fetch a list of saved items, and then uses _that_ response to fetch the details for each item, the browser will end up making multiple sequential requests. This is deadly for performance, especially for users that are physically located far from your backend. Avoid this issue by using [server `load` functions](load#Universal-vs-server) where possible.
*   Server `load` functions are also not immune to waterfalls (though they are much less costly since they rarely involve roundtrips with high latency). For example if you query a database to get the current user and then use that data to make a second query for a list of saved items, it will typically be more performant to issue a single query with a database join.

Hosting[](#Hosting)
-------------------

Your frontend should be located in the same data center as your backend to minimize latency. For sites with no central backend, many SvelteKit adapters support deploying to the _edge_, which means handling each user’s requests from a nearby server. This can reduce load times significantly. Some adapters even support [configuring deployment on a per-route basis](page-options#config). You should also consider serving images from a CDN (which are typically edge networks) — the hosts for many SvelteKit adapters will do this automatically.

Ensure your host uses HTTP/2 or newer. Vite’s code splitting creates numerous small files for improved cacheability, which results in excellent performance, but this does assume that your files can be loaded in parallel with HTTP/2.

Further reading[](#Further-reading)
-----------------------------------

For the most part, building a performant SvelteKit app is the same as building any performant web app. You should be able to apply information from general performance resources such as [Core Web Vitals](https://web.dev/explore/learn-core-web-vitals) to any web experience you build.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/40-best-practices/05-performance.md) [llms.txt](/docs/kit/performance/llms.txt)

previous next

[Auth](/docs/kit/auth) [Icons](/docs/kit/icons)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBest practices

Icons
=====

### On this page

*   [Icons](/docs/kit/icons)
*   [CSS](#CSS)
*   [Svelte](#Svelte)

CSS[](#CSS)
-----------

A great way to use icons is to define them purely via CSS. Iconify offers support for [many popular icon sets](https://icon-sets.iconify.design/) that [can be included via CSS](https://iconify.design/docs/usage/css/). This method can also be used with popular CSS frameworks by leveraging the Iconify [Tailwind CSS plugin](https://iconify.design/docs/usage/css/tailwind/) or [UnoCSS plugin](https://iconify.design/docs/usage/css/unocss/). As opposed to libraries based on Svelte components, it doesn’t require each icon to be imported into your `.svelte` file.

Svelte[](#Svelte)
-----------------

There are many [icon libraries for Svelte](https://www.sveltesociety.dev/packages?category=icons). When choosing an icon library, it is recommended to avoid those that provide a `.svelte` file per icon as these libraries can have thousands of `.svelte` files which really slow down [Vite’s dependency optimization](https://vite.dev/guide/dep-pre-bundling.html). This can become especially pathological if the icons are imported both via an umbrella import and subpath import [as described in the `vite-plugin-svelte` FAQ](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#what-is-going-on-with-vite-and-pre-bundling-dependencies).

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/40-best-practices/06-icons.md) [llms.txt](/docs/kit/icons/llms.txt)

previous next

[Performance](/docs/kit/performance) [Images](/docs/kit/images)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBest practices

Images
======

### On this page

*   [Images](/docs/kit/images)
*   [Vite’s built-in handling](#Vite's-built-in-handling)
*   [@sveltejs/enhanced-img](#sveltejs-enhanced-img)
*   [Loading images dynamically from a CDN](#Loading-images-dynamically-from-a-CDN)
*   [Best practices](#Best-practices)

Images can have a big impact on your app’s performance. For best results, you should optimize them by doing the following:

*   generate optimal formats like `.avif` and `.webp`
*   create different sizes for different screens
*   ensure that assets can be cached effectively

Doing this manually is tedious. There are a variety of techniques you can use, depending on your needs and preferences.

Vite’s built-in handling[](#Vite's-built-in-handling)
-----------------------------------------------------

[Vite will automatically process imported assets](https://vitejs.dev/guide/assets.html) for improved performance. This includes assets referenced via the CSS `url()` function. Hashes will be added to the filenames so that they can be cached, and assets smaller than `assetsInlineLimit` will be inlined. Vite’s asset handling is most often used for images, but is also useful for video, audio, etc.

    <script>
    	import logo from '$lib/assets/logo.png';
    </script>
    
    <img alt="The project logo" src={logo} />

@sveltejs/enhanced-img[](#sveltejs-enhanced-img)
------------------------------------------------

`@sveltejs/enhanced-img` is a plugin offered on top of Vite’s built-in asset handling. It provides plug and play image processing that serves smaller file formats like `avif` or `webp`, automatically sets the intrinsic `width` and `height` of the image to avoid layout shift, creates images of multiple sizes for various devices, and strips EXIF data for privacy. It will work in any Vite-based project including, but not limited to, SvelteKit projects.

> As a build plugin, `@sveltejs/enhanced-img` can only optimize files located on your machine during the build process. If you have an image located elsewhere (such as a path served from your database, CMS, or backend), please read about [loading images dynamically from a CDN](#Loading-images-dynamically-from-a-CDN).

### Setup[](#sveltejs-enhanced-img-Setup)

Install:

    npm install --save-dev @sveltejs/enhanced-img

Adjust `vite.config.js`:

    import { function sveltekit(): Promise<Plugin<any>[]>Returns the SvelteKit Vite plugins.
    sveltekit } from '@sveltejs/kit/vite';
    import { function enhancedImages(): Promise<Plugin[]>enhancedImages } from '@sveltejs/enhanced-img';
    import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)Type helper to make it easier to use vite.config.ts
    accepts a direct 
    {@link 
    UserConfig
    }
     object, or a function that returns it.
    The function receives a 
    {@link 
    ConfigEnv
    }
     object.
    defineConfig } from 'vite';
    
    export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)Type helper to make it easier to use vite.config.ts
    accepts a direct 
    {@link 
    UserConfig
    }
     object, or a function that returns it.
    The function receives a 
    {@link 
    ConfigEnv
    }
     object.
    defineConfig({
    	UserConfig.plugins?: PluginOption[] | undefinedArray of vite plugins to use.
    plugins: [
    		function enhancedImages(): Promise<Plugin[]>enhancedImages(), // must come before the SvelteKit plugin
    		function sveltekit(): Promise<Plugin<any>[]>Returns the SvelteKit Vite plugins.
    sveltekit()
    	]
    });

Building will take longer on the first build due to the computational expense of transforming images. However, the build output will be cached in `./node_modules/.cache/imagetools` so that subsequent builds will be fast.

### Basic usage[](#sveltejs-enhanced-img-Basic-usage)

Use in your `.svelte` components by using `<enhanced:img>` rather than `<img>` and referencing the image file with a [Vite asset import](https://vitejs.dev/guide/assets.html#static-asset-handling) path:

    <enhanced:img src="./path/to/your/image.jpg" alt="An alt text" />

At build time, your `<enhanced:img>` tag will be replaced with an `<img>` wrapped by a `<picture>` providing multiple image types and sizes. It’s only possible to downscale images without losing quality, which means that you should provide the highest resolution image that you need — smaller versions will be generated for the various device types that may request an image.

You should provide your image at 2x resolution for HiDPI displays (a.k.a. retina displays). `<enhanced:img>` will automatically take care of serving smaller versions to smaller devices.

> if you wish to use a [tag name CSS selector](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Styling_basics/Basic_selectors#type_selectors) in your `<style>` block you will need to write `enhanced\:img` to escape the colon in the tag name.

### Dynamically choosing an image[](#sveltejs-enhanced-img-Dynamically-choosing-an-image)

You can also manually import an image asset and pass it to an `<enhanced:img>`. This is useful when you have a collection of static images and would like to dynamically choose one or [iterate over them](https://github.com/sveltejs/kit/blob/0ab1733e394b6310895a1d3bf0f126ce34531170/sites/kit.svelte.dev/src/routes/home/Showcase.svelte). In this case you will need to update both the `import` statement and `<img>` element as shown below to indicate you’d like process them.

    <script>
    	import MyImage from './path/to/your/image.jpg?enhanced';
    </script>
    
    <enhanced:img src={MyImage} alt="some alt text" />

You can also use [Vite’s `import.meta.glob`](https://vitejs.dev/guide/features.html#glob-import). Note that you will have to specify `enhanced` via a [custom query](https://vitejs.dev/guide/features.html#custom-queries):

    <script>
    	const imageModules = import.meta.glob(
    		'/path/to/assets/*.{avif,gif,heif,jpeg,jpg,png,tiff,webp,svg}',
    		{
    			eager: true,
    			query: {
    				enhanced: true
    			}
    		}
    	)
    </script>
    
    {#each Object.entries(imageModules) as [_path, module]}
    	<enhanced:img src={module.default} alt="some alt text" />
    {/each}

### Intrinsic Dimensions[](#sveltejs-enhanced-img-Intrinsic-Dimensions)

`width` and `height` are optional as they can be inferred from the source image and will be automatically added when the `<enhanced:img>` tag is preprocessed. With these attributes, the browser can reserve the correct amount of space, preventing [layout shift](https://web.dev/articles/cls). If you’d like to use a different `width` and `height` you can style the image with CSS. Because the preprocessor adds a `width` and `height` for you, if you’d like one of the dimensions to be automatically calculated then you will need to specify that:

    <style>
    	.hero-image img {
    		width: var(--size);
    		height: auto;
    	}
    </style>

### srcset and sizes[](#sveltejs-enhanced-img-srcset-and-sizes)

If you have a large image, such as a hero image taking the width of the design, you should specify `sizes` so that smaller versions are requested on smaller devices. E.g. if you have a 1280px image you may want to specify something like:

    <enhanced:img src="./image.png" sizes="min(1280px, 100vw)"/>

If `sizes` is specified, `<enhanced:img>` will generate small images for smaller devices and populate the `srcset` attribute.

The smallest picture generated automatically will have a width of 540px. If you’d like smaller images or would otherwise like to specify custom widths, you can do that with the `w` query parameter:

    <enhanced:img
      src="./image.png?w=1280;640;400"
      sizes="(min-width:1920px) 1280px, (min-width:1080px) 640px, (min-width:768px) 400px"
    />

If `sizes` is not provided, then a HiDPI/Retina image and a standard resolution image will be generated. The image you provide should be 2x the resolution you wish to display so that the browser can display that image on devices with a high [device pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio).

### Per-image transforms[](#sveltejs-enhanced-img-Per-image-transforms)

By default, enhanced images will be transformed to more efficient formats. However, you may wish to apply other transforms such as a blur, quality, flatten, or rotate operation. You can run per-image transforms by appending a query string:

    <enhanced:img src="./path/to/your/image.jpg?blur=15" alt="An alt text" />

[See the imagetools repo for the full list of directives](https://github.com/JonasKruckenberg/imagetools/blob/main/docs/directives.md).

Loading images dynamically from a CDN[](#Loading-images-dynamically-from-a-CDN)
-------------------------------------------------------------------------------

In some cases, the images may not be accessible at build time — e.g. they may live inside a content management system or elsewhere.

Using a content delivery network (CDN) can allow you to optimize these images dynamically, and provides more flexibility with regards to sizes, but it may involve some setup overhead and usage costs. Depending on caching strategy, the browser may not be able to use a cached copy of the asset until a [304 response](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304) is received from the CDN. Building HTML to target CDNs allows using an `<img>` tag since the CDN can serve the appropriate format based on the `User-Agent` header, whereas build-time optimizations must produce `<picture>` tags with multiple sources. Finally, some CDNs may generate images lazily, which could have a negative performance impact for sites with low traffic and frequently changing images.

CDNs can generally be used without any need for a library. However, there are a number of libraries with Svelte support that make it easier. [`@unpic/svelte`](https://unpic.pics/img/svelte/) is a CDN-agnostic library with support for a large number of providers. You may also find that specific CDNs like [Cloudinary](https://svelte.cloudinary.dev/) have Svelte support. Finally, some content management systems (CMS) which support Svelte (such as [Contentful](https://www.contentful.com/sveltekit-starter-guide/), [Storyblok](https://github.com/storyblok/storyblok-svelte), and [Contentstack](https://www.contentstack.com/docs/developers/sample-apps/build-a-starter-website-with-sveltekit-and-contentstack)) have built-in support for image handling.

Best practices[](#Best-practices)
---------------------------------

*   For each image type, use the appropriate solution from those discussed above. You can mix and match all three solutions in one project. For example, you may use Vite’s built-in handling to provide images for `<meta>` tags, display images on your homepage with `@sveltejs/enhanced-img`, and display user-submitted content with a dynamic approach.
*   Consider serving all images via CDN regardless of the image optimization types you use. CDNs reduce latency by distributing copies of static assets globally.
*   Your original images should have a good quality/resolution and should have 2x the width it will be displayed at to serve HiDPI devices. Image processing can size images down to save bandwidth when serving smaller screens, but it would be a waste of bandwidth to invent pixels to size images up.
*   For images which are much larger than the width of a mobile device (roughly 400px), such as a hero image taking the width of the page design, specify `sizes` so that smaller images can be served on smaller devices.
*   For important images, such as the [largest contentful paint (LCP)](https://web.dev/articles/lcp) image, set `fetchpriority="high"` and avoid `loading="lazy"` to prioritize loading as early as possible.
*   Give the image a container or styling so that it is constrained and does not jump around while the page is loading affecting your [cumulative layout shift (CLS)](https://web.dev/articles/cls). `width` and `height` help the browser to reserve space while the image is still loading, so `@sveltejs/enhanced-img` will add a `width` and `height` for you.
*   Always provide a good `alt` text. The Svelte compiler will warn you if you don’t do this.
*   Do not use `em` or `rem` in `sizes` and change the default size of these measures. When used in `sizes` or `@media` queries, `em` and `rem` are both defined to mean the user’s default `font-size`. For a `sizes` declaration like `sizes="(min-width: 768px) min(100vw, 108rem), 64rem"`, the actual `em` or `rem` that controls how the image is laid out on the page can be different if changed by CSS. For example, do not do something like `html { font-size: 62.5%; }` as the slot reserved by the browser preloader will now end up being larger than the actual slot of the CSS object model once it has been created.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/40-best-practices/07-images.md) [llms.txt](/docs/kit/images/llms.txt)

previous next

[Icons](/docs/kit/icons) [Accessibility](/docs/kit/accessibility)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBest practices

Accessibility
=============

### On this page

*   [Accessibility](/docs/kit/accessibility)
*   [Route announcements](#Route-announcements)
*   [Focus management](#Focus-management)
*   [The “lang” attribute](#The-lang-attribute)
*   [Further reading](#Further-reading)

SvelteKit strives to provide an accessible platform for your app by default. Svelte’s [compile-time accessibility checks](../svelte/compiler-warnings) will also apply to any SvelteKit application you build.

Here’s how SvelteKit’s built-in accessibility features work and what you need to do to help these features to work as well as possible. Keep in mind that while SvelteKit provides an accessible foundation, you are still responsible for making sure your application code is accessible. If you’re new to accessibility, see the [“further reading”](accessibility#Further-reading) section of this guide for additional resources.

We recognize that accessibility can be hard to get right. If you want to suggest improvements to how SvelteKit handles accessibility, please [open a GitHub issue](https://github.com/sveltejs/kit/issues).

Route announcements[](#Route-announcements)
-------------------------------------------

In traditional server-rendered applications, every navigation (e.g. clicking on an `<a>` tag) triggers a full page reload. When this happens, screen readers and other assistive technology will read out the new page’s title so that users understand that the page has changed.

Since navigation between pages in SvelteKit happens without reloading the page (known as [client-side routing](glossary#Routing)), SvelteKit injects a [live region](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) onto the page that will read out the new page name after each navigation. This determines the page name to announce by inspecting the `<title>` element.

Because of this behavior, every page in your app should have a unique, descriptive title. In SvelteKit, you can do this by placing a `<svelte:head>` element on each page:

src/routes/+page

    <svelte:head>
    	<title>Todo List</title>
    </svelte:head>

This will allow screen readers and other assistive technology to identify the new page after a navigation occurs. Providing a descriptive title is also important for [SEO](seo#Manual-setup-title-and-meta).

Focus management[](#Focus-management)
-------------------------------------

In traditional server-rendered applications, every navigation will reset focus to the top of the page. This ensures that people browsing the web with a keyboard or screen reader will start interacting with the page from the beginning.

To simulate this behavior during client-side routing, SvelteKit focuses the `<body>` element after each navigation and [enhanced form submission](form-actions#Progressive-enhancement). There is one exception - if an element with the [`autofocus`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus) attribute is present, SvelteKit will focus that element instead. Make sure to [consider the implications for assistive technology](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus#accessibility_considerations) when using that attribute.

If you want to customize SvelteKit’s focus management, you can use the `afterNavigate` hook:

    import { function afterNavigate(callback: (navigation: import("@sveltejs/kit").AfterNavigate) => void): voidA lifecycle function that runs the supplied callback when the current component mounts, and also whenever we navigate to a URL.
    afterNavigate must be called during a component initialization. It remains active as long as the component is mounted.
    afterNavigate } from '$app/navigation';
    
    function afterNavigate(callback: (navigation: import("@sveltejs/kit").AfterNavigate) => void): voidA lifecycle function that runs the supplied callback when the current component mounts, and also whenever we navigate to a URL.
    afterNavigate must be called during a component initialization. It remains active as long as the component is mounted.
    afterNavigate(() => {
    	/** @type {HTMLElement | null} */
    	const const to_focus: Element | null@type{HTMLElement | null}to_focus = var document: DocumentMDN Reference
    document.ParentNode.querySelector<Element>(selectors: string): Element | null (+4 overloads)Returns the first element that is a descendant of node that matches selectors.
    MDN Reference
    querySelector('.focus-me');
    	const to_focus: Element | null@type{HTMLElement | null}to_focus?.focus();
    });

You can also programmatically navigate to a different page using the [`goto`]($app-navigation#goto) function. By default, this will have the same client-side routing behavior as clicking on a link. However, `goto` also accepts a `keepFocus` option that will preserve the currently-focused element instead of resetting focus. If you enable this option, make sure the currently-focused element still exists on the page after navigation. If the element no longer exists, the user’s focus will be lost, making for a confusing experience for assistive technology users.

The “lang” attribute[](#The-lang-attribute)
-------------------------------------------

By default, SvelteKit’s page template sets the default language of the document to English. If your content is not in English, you should update the `<html>` element in `src/app.html` to have the correct [`lang`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang#accessibility) attribute. This will ensure that any assistive technology reading the document uses the correct pronunciation. For example, if your content is in German, you should update `app.html` to the following:

src/app

    <html lang="de">

If your content is available in multiple languages, you should set the `lang` attribute based on the language of the current page. You can do this with SvelteKit’s [handle hook](hooks#Server-hooks-handle):

src/app

    <html lang="%lang%">

src/hooks.server

    /** @type {import('@sveltejs/kit').Handle} */
    export function function handle({ event, resolve }: {
        event: any;
        resolve: any;
    }): any@type{import('@sveltejs/kit').Handle}handle({ event: anyevent, resolve: anyresolve }) {
    	return resolve: anyresolve(event: anyevent, {
    		transformPageChunk: ({ html }: {
        html: any;
    }) => anytransformPageChunk: ({ html: anyhtml }) => html: anyhtml.replace('%lang%', function get_lang(event: any): string@paramevent get_lang(event: anyevent))
    	});
    }

    import type { type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle } from '@sveltejs/kit';
    
    export const const handle: Handlehandle: type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle = ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) => {
    	return resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event, {
    		ResolveOptions.transformPageChunk?: ((input: {
        html: string;
        done: boolean;
    }) => MaybePromise<string | undefined>) | undefinedApplies custom transforms to HTML. If done is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML
    (they could include an element’s opening tag but not its closing tag, for example)
    but they will always be split at sensible boundaries such as %sveltekit.head% or layout/page components.
    @paraminput the html chunk and the info if this is the last chunktransformPageChunk: ({ html: stringhtml }) => html: stringhtml.String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)Replaces text in a string, using a regular expression or search string.
    @paramsearchValue A string or regular expression to search for.@paramreplaceValue A string containing the text to replace. When the {@linkcode searchValue} is a RegExp, all matches are replaced if the g flag is set (or only those matches at the beginning, if the y flag is also present). Otherwise, only the first match of {@linkcode searchValue} is replaced.replace('%lang%', function get_lang(event: any): string@paramevent get_lang(event: RequestEvent<Partial<Record<string, string>>, string | null>event))
    	});
    };

Further reading[](#Further-reading)
-----------------------------------

For the most part, building an accessible SvelteKit app is the same as building an accessible web app. You should be able to apply information from the following general accessibility resources to any web experience you build:

*   [MDN Web Docs: Accessibility](https://developer.mozilla.org/en-US/docs/Learn/Accessibility)
*   [The A11y Project](https://www.a11yproject.com/)
*   [How to Meet WCAG (Quick Reference)](https://www.w3.org/WAI/WCAG21/quickref/)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/40-best-practices/10-accessibility.md) [llms.txt](/docs/kit/accessibility/llms.txt)

previous next

[Images](/docs/kit/images) [SEO](/docs/kit/seo)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitBest practices

SEO
===

### On this page

*   [SEO](/docs/kit/seo)
*   [Out of the box](#Out-of-the-box)
*   [Manual setup](#Manual-setup)

The most important aspect of SEO is to create high-quality content that is widely linked to from around the web. However, there are a few technical considerations for building sites that rank well.

Out of the box[](#Out-of-the-box)
---------------------------------

### SSR[](#Out-of-the-box-SSR)

While search engines have got better in recent years at indexing content that was rendered with client-side JavaScript, server-side rendered content is indexed more frequently and reliably. SvelteKit employs SSR by default, and while you can disable it in [`handle`](hooks#Server-hooks-handle), you should leave it on unless you have a good reason not to.

> SvelteKit’s rendering is highly configurable and you can implement [dynamic rendering](https://developers.google.com/search/docs/advanced/javascript/dynamic-rendering) if necessary. It’s not generally recommended, since SSR has other benefits beyond SEO.

### Performance[](#Out-of-the-box-Performance)

Signals such as [Core Web Vitals](https://web.dev/vitals/#core-web-vitals) impact search engine ranking. Because Svelte and SvelteKit introduce minimal overhead, it’s easier to build high performance sites. You can test your site’s performance using Google’s [PageSpeed Insights](https://pagespeed.web.dev/) or [Lighthouse](https://developers.google.com/web/tools/lighthouse). Read [the performance page](performance) for more details.

### Normalized URLs[](#Out-of-the-box-Normalized-URLs)

SvelteKit redirects pathnames with trailing slashes to ones without (or vice versa depending on your [configuration](page-options#trailingSlash)), as duplicate URLs are bad for SEO.

Manual setup[](#Manual-setup)
-----------------------------

### <title> and <meta>[](#Manual-setup-title-and-meta)

Every page should have well-written and unique `<title>` and `<meta name="description">` elements inside a [`<svelte:head>`](../svelte/svelte-head). Guidance on how to write descriptive titles and descriptions, along with other suggestions on making content understandable by search engines, can be found on Google’s [Lighthouse SEO audits](https://web.dev/lighthouse-seo/) documentation.

> A common pattern is to return SEO-related `data` from page [`load`](load) functions, then use it (as [`page.data`]($app-state)) in a `<svelte:head>` in your root [layout](routing#layout).

### Sitemaps[](#Manual-setup-Sitemaps)

[Sitemaps](https://developers.google.com/search/docs/advanced/sitemaps/build-sitemap) help search engines prioritize pages within your site, particularly when you have a large amount of content. You can create a sitemap dynamically using an endpoint:

src/routes/sitemap.xml/+server

    export async function function GET(): Promise<Response>GET() {
    	return new var Response: new (body?: BodyInit | null, init?: ResponseInit) => ResponseThis Fetch API interface represents the response to a request.
    MDN Reference
    Response(
    		`
    		<?xml version="1.0" encoding="UTF-8" ?>
    		<urlset
    			xmlns="https://www.sitemaps.org/schemas/sitemap/0.9"
    			xmlns:xhtml="https://www.w3.org/1999/xhtml"
    			xmlns:mobile="https://www.google.com/schemas/sitemap-mobile/1.0"
    			xmlns:news="https://www.google.com/schemas/sitemap-news/0.9"
    			xmlns:image="https://www.google.com/schemas/sitemap-image/1.1"
    			xmlns:video="https://www.google.com/schemas/sitemap-video/1.1"
    		>
    			<!-- <url> elements go here -->
    		</urlset>`.String.trim(): stringRemoves the leading and trailing white space and line terminator characters from a string.
    trim(),
    		{
    			ResponseInit.headers?: HeadersInit | undefinedheaders: {
    				'Content-Type': 'application/xml'
    			}
    		}
    	);
    }

### AMP[](#Manual-setup-AMP)

An unfortunate reality of modern web development is that it is sometimes necessary to create an [Accelerated Mobile Pages (AMP)](https://amp.dev/) version of your site. In SvelteKit this can be done by setting the [`inlineStyleThreshold`](configuration#inlineStyleThreshold) option...

svelte.config

    /** @type {import('@sveltejs/kit').Config} */
    const const config: {
        kit: {
            inlineStyleThreshold: number;
        };
    }@type{import('@sveltejs/kit').Config}config = {
    	kit: {
        inlineStyleThreshold: number;
    }kit: {
    		// since <link rel="stylesheet"> isn't
    		// allowed, inline all styles
    		inlineStyleThreshold: numberinlineStyleThreshold: var Infinity: numberInfinity
    	}
    };
    
    export default const config: {
        kit: {
            inlineStyleThreshold: number;
        };
    }@type{import('@sveltejs/kit').Config}config;

...disabling `csr` in your root `+layout.js` / `+layout.server.js`...

src/routes/+layout.server

    export const const csr: falsecsr = false;

...adding `amp` to your `app.html`

    <html amp>
    ...

...and transforming the HTML using `transformPageChunk` along with `transform` imported from `@sveltejs/amp`:

src/hooks.server

    import * as import ampamp from '@sveltejs/amp';
    
    /** @type {import('@sveltejs/kit').Handle} */
    export async function function handle({ event, resolve }: {
        event: any;
        resolve: any;
    }): Promise<any>@type{import('@sveltejs/kit').Handle}handle({ event: anyevent, resolve: anyresolve }) {
    	let let buffer: stringbuffer = '';
    	return await resolve: anyresolve(event: anyevent, {
    		transformPageChunk: ({ html, done }: {
        html: any;
        done: any;
    }) => string | undefinedtransformPageChunk: ({ html: anyhtml, done: anydone }) => {
    			let buffer: stringbuffer += html: anyhtml;
    			if (done: anydone) return import ampamp.function transform(html: string): stringtransform(let buffer: stringbuffer);
    		}
    	});
    }

    import * as import ampamp from '@sveltejs/amp';
    import type { type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle } from '@sveltejs/kit';
    
    export const const handle: Handlehandle: type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle = async ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) => {
    	let let buffer: stringbuffer = '';
    	return await resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event, {
    		ResolveOptions.transformPageChunk?: ((input: {
        html: string;
        done: boolean;
    }) => MaybePromise<string | undefined>) | undefinedApplies custom transforms to HTML. If done is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML
    (they could include an element’s opening tag but not its closing tag, for example)
    but they will always be split at sensible boundaries such as %sveltekit.head% or layout/page components.
    @paraminput the html chunk and the info if this is the last chunktransformPageChunk: ({ html: stringhtml, done: booleandone }) => {
    			let buffer: stringbuffer += html: stringhtml;
    			if (done: booleandone) return import ampamp.function transform(html: string): stringtransform(let buffer: stringbuffer);
    		}
    	});
    };

To prevent shipping any unused CSS as a result of transforming the page to amp, we can use [`dropcss`](https://www.npmjs.com/package/dropcss):

src/hooks.server

    import * as import ampamp from '@sveltejs/amp';
    import module "dropcss"dropcss from 'dropcss';
    
    /** @type {import('@sveltejs/kit').Handle} */
    export async function function handle(input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }): MaybePromise<...>@type{import('@sveltejs/kit').Handle}handle({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) {
    	let let buffer: stringbuffer = '';
    
    	return await resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event, {
    		ResolveOptions.transformPageChunk?: ((input: {
        html: string;
        done: boolean;
    }) => MaybePromise<string | undefined>) | undefinedApplies custom transforms to HTML. If done is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML
    (they could include an element’s opening tag but not its closing tag, for example)
    but they will always be split at sensible boundaries such as %sveltekit.head% or layout/page components.
    @paraminput the html chunk and the info if this is the last chunktransformPageChunk: ({ html: stringhtml, done: booleandone }) => {
    			let buffer: stringbuffer += html: stringhtml;
    
    			if (done: booleandone) {
    				let let css: stringcss = '';
    				const const markup: stringmarkup = import ampamp
    					.function transform(html: string): stringtransform(let buffer: stringbuffer)
    					.String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)Replaces text in a string, using a regular expression or search string.
    @paramsearchValue A string or regular expression to search for.@paramreplaceValue A string containing the text to replace. When the {@linkcode searchValue} is a RegExp, all matches are replaced if the g flag is set (or only those matches at the beginning, if the y flag is also present). Otherwise, only the first match of {@linkcode searchValue} is replaced.replace('⚡', 'amp') // dropcss can't handle this character
    					.String.replace(searchValue: {
        [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
    }, replacer: (substring: string, ...args: any[]) => string): string (+3 overloads)Replaces text in a string, using an object that supports replacement within a string.
    @paramsearchValue A object can search for and replace matches within a string.@paramreplacer A function that returns the replacement text.replace(/<style amp-custom([^>]*?)>([^]+?)<\/style>/, (match: stringmatch, attributes: anyattributes, contents: anycontents) => {
    						let css: stringcss = contents: anycontents;
    						return `<style amp-custom${attributes: anyattributes}></style>`;
    					});
    
    				let css: stringcss = module "dropcss"dropcss({ css: stringcss, html: stringhtml: const markup: stringmarkup }).css;
    				return const markup: stringmarkup.String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)Replaces text in a string, using a regular expression or search string.
    @paramsearchValue A string or regular expression to search for.@paramreplaceValue A string containing the text to replace. When the {@linkcode searchValue} is a RegExp, all matches are replaced if the g flag is set (or only those matches at the beginning, if the y flag is also present). Otherwise, only the first match of {@linkcode searchValue} is replaced.replace('</style>', `${let css: stringcss}</style>`);
    			}
    		}
    	});
    }
    

    import * as import ampamp from '@sveltejs/amp';
    import module "dropcss"dropcss from 'dropcss';
    import type { type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle } from '@sveltejs/kit';
    
    export const const handle: Handlehandle: type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle = async ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) => {
    	let let buffer: stringbuffer = '';
    
    	return await resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event, {
    		ResolveOptions.transformPageChunk?: ((input: {
        html: string;
        done: boolean;
    }) => MaybePromise<string | undefined>) | undefinedApplies custom transforms to HTML. If done is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML
    (they could include an element’s opening tag but not its closing tag, for example)
    but they will always be split at sensible boundaries such as %sveltekit.head% or layout/page components.
    @paraminput the html chunk and the info if this is the last chunktransformPageChunk: ({ html: stringhtml, done: booleandone }) => {
    			let buffer: stringbuffer += html: stringhtml;
    
    			if (done: booleandone) {
    				let let css: stringcss = '';
    				const const markup: stringmarkup = import ampamp
    					.function transform(html: string): stringtransform(let buffer: stringbuffer)
    					.String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)Replaces text in a string, using a regular expression or search string.
    @paramsearchValue A string or regular expression to search for.@paramreplaceValue A string containing the text to replace. When the {@linkcode searchValue} is a RegExp, all matches are replaced if the g flag is set (or only those matches at the beginning, if the y flag is also present). Otherwise, only the first match of {@linkcode searchValue} is replaced.replace('⚡', 'amp') // dropcss can't handle this character
    					.String.replace(searchValue: {
        [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
    }, replacer: (substring: string, ...args: any[]) => string): string (+3 overloads)Replaces text in a string, using an object that supports replacement within a string.
    @paramsearchValue A object can search for and replace matches within a string.@paramreplacer A function that returns the replacement text.replace(/<style amp-custom([^>]*?)>([^]+?)<\/style>/, (match: stringmatch, attributes: anyattributes, contents: anycontents) => {
    						let css: stringcss = contents: anycontents;
    						return `<style amp-custom${attributes: anyattributes}></style>`;
    					});
    
    				let css: stringcss = module "dropcss"dropcss({ css: stringcss, html: stringhtml: const markup: stringmarkup }).css;
    				return const markup: stringmarkup.String.replace(searchValue: string | RegExp, replaceValue: string): string (+3 overloads)Replaces text in a string, using a regular expression or search string.
    @paramsearchValue A string or regular expression to search for.@paramreplaceValue A string containing the text to replace. When the {@linkcode searchValue} is a RegExp, all matches are replaced if the g flag is set (or only those matches at the beginning, if the y flag is also present). Otherwise, only the first match of {@linkcode searchValue} is replaced.replace('</style>', `${let css: stringcss}</style>`);
    			}
    		}
    	});
    };

> It’s a good idea to use the `handle` hook to validate the transformed HTML using `amphtml-validator`, but only if you’re prerendering pages since it’s very slow.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/40-best-practices/20-seo.md) [llms.txt](/docs/kit/seo/llms.txt)

previous next

[Accessibility](/docs/kit/accessibility) [Frequently asked questions](/docs/kit/faq)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAppendix

Frequently asked questions
==========================

### On this page

*   [Frequently asked questions](/docs/kit/faq)
*   [Other resources](#Other-resources)
*   [What can I make with SvelteKit?](#What-can-I-make-with-SvelteKit)
*   [How do I include details from package.json in my application?](#How-do-I-include-details-from-package.json-in-my-application)
*   [How do I fix the error I’m getting trying to include a package?](#How-do-I-fix-the-error-I'm-getting-trying-to-include-a-package)
*   [How do I use the view transitions API?](#How-do-I-use-the-view-transitions-API)
*   [How do I set up a database?](#How-do-I-set-up-a-database)
*   [How do I use a client-side library accessing document or window?](#How-do-I-use-a-client-side-library-accessing-document-or-window)
*   [How do I use a different backend API server?](#How-do-I-use-a-different-backend-API-server)
*   [How do I use middleware?](#How-do-I-use-middleware)
*   [How do I use Yarn?](#How-do-I-use-Yarn)

Other resources[](#Other-resources)
-----------------------------------

Please see [the Svelte FAQ](../svelte/faq) and [`vite-plugin-svelte` FAQ](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md) as well for the answers to questions deriving from those libraries.

What can I make with SvelteKit?[](#What-can-I-make-with-SvelteKit)
------------------------------------------------------------------

See [the documentation regarding project types](project-types) for more details.

How do I include details from package.json in my application?[](#How-do-I-include-details-from-package.json-in-my-application)
------------------------------------------------------------------------------------------------------------------------------

If you’d like to include your application’s version number or other information from `package.json` in your application, you can load JSON like so:

svelte.config

    import import pkgpkg from './package.json' with { type: 'json' };

How do I fix the error I’m getting trying to include a package?[](#How-do-I-fix-the-error-I'm-getting-trying-to-include-a-package)
----------------------------------------------------------------------------------------------------------------------------------

Most issues related to including a library are due to incorrect packaging. You can check if a library’s packaging is compatible with Node.js by entering it into [the publint website](https://publint.dev/).

Here are a few things to keep in mind when checking if a library is packaged correctly:

*   `exports` takes precedence over the other entry point fields such as `main` and `module`. Adding an `exports` field may not be backwards-compatible as it prevents deep imports.
*   ESM files should end with `.mjs` unless `"type": "module"` is set in which any case CommonJS files should end with `.cjs`.
*   `main` should be defined if `exports` is not. It should be either a CommonJS or ESM file and adhere to the previous bullet. If a `module` field is defined, it should refer to an ESM file.
*   Svelte components should be distributed as uncompiled `.svelte` files with any JS in the package written as ESM only. Custom script and style languages, like TypeScript and SCSS, should be preprocessed as vanilla JS and CSS respectively. We recommend using [`svelte-package`](./packaging) for packaging Svelte libraries, which will do this for you.

Libraries work best in the browser with Vite when they distribute an ESM version, especially if they are dependencies of a Svelte component library. You may wish to suggest to library authors that they provide an ESM version. However, CommonJS (CJS) dependencies should work as well since, by default, [`vite-plugin-svelte` will ask Vite to pre-bundle them](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#what-is-going-on-with-vite-and-pre-bundling-dependencies) using `esbuild` to convert them to ESM.

If you are still encountering issues we recommend searching both [the Vite issue tracker](https://github.com/vitejs/vite/issues) and the issue tracker of the library in question. Sometimes issues can be worked around by fiddling with the [`optimizeDeps`](https://vitejs.dev/config/#dep-optimization-options) or [`ssr`](https://vitejs.dev/config/#ssr-options) config values though we recommend this as only a short-term workaround in favor of fixing the library in question.

How do I use the view transitions API?[](#How-do-I-use-the-view-transitions-API)
--------------------------------------------------------------------------------

While SvelteKit does not have any specific integration with [view transitions](https://developer.chrome.com/docs/web-platform/view-transitions/), you can call `document.startViewTransition` in [`onNavigate`]($app-navigation#onNavigate) to trigger a view transition on every client-side navigation.

    import { function onNavigate(callback: (navigation: import("@sveltejs/kit").OnNavigate) => MaybePromise<void | (() => void)>): voidA lifecycle function that runs the supplied callback immediately before we navigate to a new URL except during full-page navigations.
    If you return a Promise, SvelteKit will wait for it to resolve before completing the navigation. This allows you to — for example — use document.startViewTransition. Avoid promises that are slow to resolve, since navigation will appear stalled to the user.
    If a function (or a Promise that resolves to a function) is returned from the callback, it will be called once the DOM has updated.
    onNavigate must be called during a component initialization. It remains active as long as the component is mounted.
    onNavigate } from '$app/navigation';
    
    function onNavigate(callback: (navigation: import("@sveltejs/kit").OnNavigate) => MaybePromise<void | (() => void)>): voidA lifecycle function that runs the supplied callback immediately before we navigate to a new URL except during full-page navigations.
    If you return a Promise, SvelteKit will wait for it to resolve before completing the navigation. This allows you to — for example — use document.startViewTransition. Avoid promises that are slow to resolve, since navigation will appear stalled to the user.
    If a function (or a Promise that resolves to a function) is returned from the callback, it will be called once the DOM has updated.
    onNavigate must be called during a component initialization. It remains active as long as the component is mounted.
    onNavigate((navigation: OnNavigatenavigation) => {
    	if (!var document: DocumentMDN Reference
    document.Document.startViewTransition(callbackOptions?: ViewTransitionUpdateCallback): ViewTransitionMDN Reference
    startViewTransition) return;
    
    	return new var Promise: PromiseConstructor
    new <void | (() => void)>(executor: (resolve: (value: void | (() => void) | PromiseLike<void | (() => void)>) => void, reject: (reason?: any) => void) => void) => Promise<void | (() => void)>Creates a new Promise.
    @paramexecutor A callback used to initialize the promise. This callback is passed two arguments:
    a resolve callback used to resolve the promise with a value or the result of another promise,
    and a reject callback used to reject the promise with a provided reason or error.Promise((resolve: (value: void | (() => void) | PromiseLike<void | (() => void)>) => voidresolve) => {
    		var document: DocumentMDN Reference
    document.Document.startViewTransition(callbackOptions?: ViewTransitionUpdateCallback): ViewTransitionMDN Reference
    startViewTransition(async () => {
    			resolve: (value: void | (() => void) | PromiseLike<void | (() => void)>) => voidresolve();
    			await navigation: OnNavigatenavigation.Navigation.complete: Promise<void>A promise that resolves once the navigation is complete, and rejects if the navigation
    fails or is aborted. In the case of a willUnload navigation, the promise will never resolve
    complete;
    		});
    	});
    });

For more, see [“Unlocking view transitions”](/blog/view-transitions) on the Svelte blog.

How do I set up a database?[](#How-do-I-set-up-a-database)
----------------------------------------------------------

Put the code to query your database in a [server route](./routing#server) - don’t query the database in .svelte files. You can create a `db.js` or similar that sets up a connection immediately and makes the client accessible throughout the app as a singleton. You can execute any one-time setup code in `hooks.server.js` and import your database helpers into any endpoint that needs them.

You can use [the Svelte CLI](/docs/cli/overview) to automatically set up database integrations.

How do I use a client-side library accessing document or window?[](#How-do-I-use-a-client-side-library-accessing-document-or-window)
------------------------------------------------------------------------------------------------------------------------------------

If you need access to the `document` or `window` variables or otherwise need code to run only on the client-side you can wrap it in a `browser` check:

    import { const browser: booleantrue if the app is running in the browser.
    browser } from '$app/environment';
    
    if (const browser: booleantrue if the app is running in the browser.
    browser) {
    	// client-only code here
    }

You can also run code in `onMount` if you’d like to run it after the component has been first rendered to the DOM:

    import { function onMount<T>(fn: () => NotFunction<T> | Promise<NotFunction<T>> | (() => any)): voidonMount, like $effect, schedules a function to run as soon as the component has been mounted to the DOM.
    Unlike $effect, the provided function only runs once.
    It must be called during the component’s initialisation (but doesn’t need to live inside the component;
    it can be called from an external module). If a function is returned synchronously from onMount,
    it will be called when the component is unmounted.
    onMount functions do not run during server-side rendering.
    onMount } from 'svelte';
    
    onMount<void>(fn: () => void | (() => any) | Promise<void>): voidonMount, like $effect, schedules a function to run as soon as the component has been mounted to the DOM.
    Unlike $effect, the provided function only runs once.
    It must be called during the component’s initialisation (but doesn’t need to live inside the component;
    it can be called from an external module). If a function is returned synchronously from onMount,
    it will be called when the component is unmounted.
    onMount functions do not run during server-side rendering.
    onMount(async () => {
    	const { const method: anymethod } = await import('some-browser-only-library');
    	const method: anymethod('hello world');
    });

If the library you’d like to use is side-effect free you can also statically import it and it will be tree-shaken out in the server-side build where `onMount` will be automatically replaced with a no-op:

    import { function onMount<T>(fn: () => NotFunction<T> | Promise<NotFunction<T>> | (() => any)): voidonMount, like $effect, schedules a function to run as soon as the component has been mounted to the DOM.
    Unlike $effect, the provided function only runs once.
    It must be called during the component’s initialisation (but doesn’t need to live inside the component;
    it can be called from an external module). If a function is returned synchronously from onMount,
    it will be called when the component is unmounted.
    onMount functions do not run during server-side rendering.
    onMount } from 'svelte';
    import { module "some-browser-only-library"method } from 'some-browser-only-library';
    
    onMount<void>(fn: () => void | (() => any) | Promise<void>): voidonMount, like $effect, schedules a function to run as soon as the component has been mounted to the DOM.
    Unlike $effect, the provided function only runs once.
    It must be called during the component’s initialisation (but doesn’t need to live inside the component;
    it can be called from an external module). If a function is returned synchronously from onMount,
    it will be called when the component is unmounted.
    onMount functions do not run during server-side rendering.
    onMount(() => {
    	module "some-browser-only-library"method('hello world');
    });

Finally, you may also consider using an `{#await}` block:

index

    <script>
    	import { browser } from '$app/environment';
    
    	const ComponentConstructor = browser ?
    		import('some-browser-only-library').then((module) => module.Component) :
    		new Promise(() => {});
    </script>
    
    {#await ComponentConstructor}
    	<p>Loading...</p>
    {:then component}
    	<svelte:component this={component} />
    {:catch error}
    	<p>Something went wrong: {error.message}</p>
    {/await}

    <script lang="ts">
    	import { browser } from '$app/environment';
    
    	const ComponentConstructor = browser ?
    		import('some-browser-only-library').then((module) => module.Component) :
    		new Promise(() => {});
    </script>
    
    {#await ComponentConstructor}
    	<p>Loading...</p>
    {:then component}
    	<svelte:component this={component} />
    {:catch error}
    	<p>Something went wrong: {error.message}</p>
    {/await}

How do I use a different backend API server?[](#How-do-I-use-a-different-backend-API-server)
--------------------------------------------------------------------------------------------

You can use [`event.fetch`](./load#Making-fetch-requests) to request data from an external API server, but be aware that you would need to deal with [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS), which will result in complications such as generally requiring requests to be preflighted resulting in higher latency. Requests to a separate subdomain may also increase latency due to an additional DNS lookup, TLS setup, etc. If you wish to use this method, you may find [`handleFetch`](./hooks#Server-hooks-handleFetch) helpful.

Another approach is to set up a proxy to bypass CORS headaches. In production, you would rewrite a path like `/api` to the API server; for local development, use Vite’s [`server.proxy`](https://vitejs.dev/config/server-options.html#server-proxy) option.

How to setup rewrites in production will depend on your deployment platform. If rewrites aren’t an option, you could alternatively add an [API route](./routing#server):

src/routes/api/\[...path\]/+server

    /** @type {import('./$types').RequestHandler} */
    export function function GET({ params, url }: {
        params: any;
        url: any;
    }): Promise<Response>@type{import('./$types').RequestHandler}GET({ params: anyparams, url: anyurl }) {
    	return function fetch(input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response> (+1 overload)MDN Reference
    fetch(`https://my-api-server.com/${params: anyparams.path + url: anyurl.search}`);
    }

    import type { type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler } from './$types';
    
    export const const GET: RequestHandlerGET: type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>
    type RequestHandler = (event: Kit.RequestEvent<Record<string, any>, string | null>) => MaybePromise<Response>RequestHandler = ({ params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params, url: URLThe requested URL.
    url }) => {
    	return function fetch(input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response> (+1 overload)MDN Reference
    fetch(`https://my-api-server.com/${params: Record<string, any>The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params.path + url: URLThe requested URL.
    url.URL.search: stringMDN Reference
    search}`);
    };

(Note that you may also need to proxy `POST` / `PATCH` etc requests, and forward `request.headers`, depending on your needs.)

How do I use middleware?[](#How-do-I-use-middleware)
----------------------------------------------------

`adapter-node` builds a middleware that you can use with your own server for production mode. In dev, you can add middleware to Vite by using a Vite plugin. For example:

    import { module "@sveltejs/kit/vite"sveltekit } from '@sveltejs/kit/vite';
    
    /** @type {import('vite').Plugin} */
    const const myPlugin: Plugin<any>@type{import('vite').Plugin}myPlugin = {
    	OutputPlugin.name: stringname: 'log-request-middleware',
    	Plugin<any>.configureServer?: ObjectHook<ServerHook> | undefinedConfigure the vite server. The hook receives the 
    {@link 
    ViteDevServer
    }
    instance. This can also be used to store a reference to the server
    for use in other hooks.
    The hooks will be called before internal middlewares are applied. A hook
    can return a post hook that will be called after internal middlewares
    are applied. Hook can be async functions and will be called in series.
    configureServer(server: ViteDevServerserver) {
    		server: ViteDevServerserver.ViteDevServer.middlewares: Connect.ServerA connect app instance.
    
    Can be used to attach custom middlewares to the dev server.
    Can also be used as the handler function of a custom http server
    or as a middleware in any connect-style Node.js frameworks
    
    https://github.com/senchalabs/connect#use-middleware
    middlewares.Connect.Server.use(fn: Connect.NextHandleFunction): Connect.Server (+3 overloads)Utilize the given middleware handle to the given route,
    defaulting to /. This “route” is the mount-point for the
    middleware, when given a value other than / the middleware
    is only effective when that segment is present in the request’s
    pathname.
    For example if we were to mount a function at /admin, it would
    be invoked on /admin, and /admin/settings, however it would
    not be invoked for /, or /posts.
    use((req: Connect.IncomingMessagereq, res: ServerResponse<IncomingMessage>res, next: Connect.NextFunctionnext) => {
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(`Got request ${req: Connect.IncomingMessagereq.IncomingMessage.url?: string | undefinedOnly valid for request obtained from 
    {@link 
    Server
    }
    .
    Request URL string. This contains only the URL that is present in the actual
    HTTP request. Take the following request:
    GET /status?name=ryan HTTP/1.1
    Accept: text/plainTo parse the URL into its parts:
    new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);When request.url is '/status?name=ryan' and process.env.HOST is undefined:
    $ node
    > new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);
    URL {
      href: 'http://localhost/status?name=ryan',
      origin: 'http://localhost',
      protocol: 'http:',
      username: '',
      password: '',
      host: 'localhost',
      hostname: 'localhost',
      port: '',
      pathname: '/status',
      search: '?name=ryan',
      searchParams: URLSearchParams { 'name' => 'ryan' },
      hash: ''
    }Ensure that you set process.env.HOST to the server’s host name, or consider replacing this part entirely. If using req.headers.host, ensure proper
    validation is used, as clients may specify a custom Host header.
    @sincev0.1.90url}`);
    			next: (err?: any) => voidnext();
    		});
    	}
    };
    
    /** @type {import('vite').UserConfig} */
    const const config: UserConfig@type{import('vite').UserConfig}config = {
    	UserConfig.plugins?: PluginOption[] | undefinedArray of vite plugins to use.
    plugins: [const myPlugin: Plugin<any>@type{import('vite').Plugin}myPlugin, module "@sveltejs/kit/vite"sveltekit()]
    };
    
    export default const config: UserConfig@type{import('vite').UserConfig}config;

See [Vite’s `configureServer` docs](https://vitejs.dev/guide/api-plugin.html#configureserver) for more details including how to control ordering.

How do I use Yarn?[](#How-do-I-use-Yarn)
----------------------------------------

### Does it work with Yarn 2?[](#How-do-I-use-Yarn-Does-it-work-with-Yarn-2)

Sort of. The Plug’n'Play feature, aka ‘pnp’, is broken (it deviates from the Node module resolution algorithm, and [doesn’t yet work with native JavaScript modules](https://github.com/yarnpkg/berry/issues/638) which SvelteKit — along with an [increasing number of packages](https://blog.sindresorhus.com/get-ready-for-esm-aa53530b3f77) — uses). You can use `nodeLinker: 'node-modules'` in your [`.yarnrc.yml`](https://yarnpkg.com/configuration/yarnrc#nodeLinker) file to disable pnp, but it’s probably easier to just use npm or [pnpm](https://pnpm.io/), which is similarly fast and efficient but without the compatibility headaches.

### How do I use with Yarn 3?[](#How-do-I-use-Yarn-How-do-I-use-with-Yarn-3)

Currently ESM Support within the latest Yarn (version 3) is considered [experimental](https://github.com/yarnpkg/berry/pull/2161).

The below seems to work although your results may vary. First create a new application:

    yarn create svelte myapp
    cd myapp

And enable Yarn Berry:

    yarn set version berry
    yarn install

One of the more interesting features of Yarn Berry is the ability to have a single global cache for packages, instead of having multiple copies for each project on the disk. However, setting `enableGlobalCache` to true causes building to fail, so it is recommended to add the following to the `.yarnrc.yml` file:

    nodeLinker: node-modules

This will cause packages to be downloaded into a local node\_modules directory but avoids the above problem and is your best bet for using version 3 of Yarn at this point in time.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/60-appendix/10-faq.md) [llms.txt](/docs/kit/faq/llms.txt)

previous next

[SEO](/docs/kit/seo) [Integrations](/docs/kit/integrations)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAppendix

Integrations
============

### On this page

*   [Integrations](/docs/kit/integrations)
*   [vitePreprocess](#vitePreprocess)
*   [Adders](#Adders)
*   [Directory](#Directory)
*   [Additional integrations](#Additional-integrations)
*   [Vite plugins](#Vite-plugins)
*   [Integration FAQs](#Integration-FAQs)

vitePreprocess[](#vitePreprocess)
---------------------------------

Including [`vitePreprocess`](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/preprocess.md) in your project will allow you to use the various flavors of CSS that Vite supports: PostCSS, SCSS, Less, Stylus, and SugarSS. If you set your project up with TypeScript it will be included by default:

    // svelte.config.js
    import { function vitePreprocess(opts?: VitePreprocessOptions | undefined): import("svelte/compiler").PreprocessorGroupvitePreprocess } from '@sveltejs/vite-plugin-svelte';
    
    export default {
      preprocess: PreprocessorGroup[]preprocess: [function vitePreprocess(opts?: VitePreprocessOptions | undefined): import("svelte/compiler").PreprocessorGroupvitePreprocess()]
    };

You will also need to use a preprocessor if you’re using TypeScript with Svelte 4. TypeScript is supported natively in Svelte 5 if you’re using only the type syntax. To use more complex TypeScript syntax in Svelte 5, you will need still need a preprocessor and can use `vitePreprocess({ script: true })`.

Adders[](#Adders)
-----------------

Run `npx sv add` to setup many different complex integrations with a single command including:

*   prettier (formatting)
*   eslint (linting)
*   vitest (unit testing)
*   playwright (e2e testing)
*   lucia (auth)
*   tailwind (CSS)
*   drizzle (DB)
*   paraglide (i18n)
*   mdsvex (markdown)
*   storybook (frontend workshop)

Directory[](#Directory)
-----------------------

See [sveltesociety.dev](https://sveltesociety.dev/) for a full listing of [packages](https://sveltesociety.dev/packages) and [templates](https://sveltesociety.dev/templates) available for use with Svelte and SvelteKit.

Additional integrations[](#Additional-integrations)
---------------------------------------------------

### svelte-preprocess[](#Additional-integrations-svelte-preprocess)

`svelte-preprocess` has some additional functionality not found in `vitePreprocess` such as support for Pug, Babel, and global styles. However, `vitePreprocess` may be faster and require less configuration, so it is used by default. Note that CoffeeScript is [not supported](https://github.com/sveltejs/kit/issues/2920#issuecomment-996469815) by SvelteKit.

You will need to install `svelte-preprocess` with `npm install --save-dev svelte-preprocess` and [add it to your `svelte.config.js`](https://github.com/sveltejs/svelte-preprocess/blob/main/docs/usage.md#with-svelte-config). After that, you will often need to [install the corresponding library](https://github.com/sveltejs/svelte-preprocess/blob/main/docs/getting-started.md) such as `npm install -D sass` or `npm install -D less`.

Vite plugins[](#Vite-plugins)
-----------------------------

Since SvelteKit projects are built with Vite, you can use Vite plugins to enhance your project. See a list of available plugins at [`vitejs/awesome-vite`](https://github.com/vitejs/awesome-vite?tab=readme-ov-file#plugins).

Integration FAQs[](#Integration-FAQs)
-------------------------------------

[The SvelteKit FAQ](./faq) answers many questions about how to do X with SvelteKit, which may be helpful if you still have questions.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/60-appendix/20-integrations.md) [llms.txt](/docs/kit/integrations/llms.txt)

previous next

[Frequently asked questions](/docs/kit/faq) [Breakpoint Debugging](/docs/kit/debugging)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAppendix

Breakpoint Debugging
====================

### On this page

*   [Breakpoint Debugging](/docs/kit/debugging)
*   [Visual Studio Code](#Visual-Studio-Code)
*   [Other Editors](#Other-Editors)
*   [Google Chrome and Microsoft Edge Developer Tools](#Google-Chrome-and-Microsoft-Edge-Developer-Tools)
*   [References](#References)

In addition to the [`@debug`](../svelte/@debug) tag, you can also debug Svelte and SvelteKit projects using breakpoints within various tools and development environments. This includes both frontend and backend code.

The following guides assume your JavaScript runtime environment is Node.js.

Visual Studio Code[](#Visual-Studio-Code)
-----------------------------------------

With the built-in debug terminal, you can set up breakpoints in source files within VSCode.

1.  Open the command palette: `CMD/Ctrl` + `Shift` + `P`.
2.  Find and launch “Debug: JavaScript Debug Terminal”.
3.  Start your project using the debug terminal. For example: `npm run dev`.
4.  Set some breakpoints in your client or server-side source code.
5.  Trigger the breakpoint.

### Launch via debug pane[](#Visual-Studio-Code-Launch-via-debug-pane)

You may alternatively set up a `.vscode/launch.json` in your project. To set one up automatically:

1.  Go to the “Run and Debug” pane.
2.  In the “Run” select menu, choose “Node.js...”.
3.  Select the “run script” that corresponds to your project, such as “Run script: dev”.
4.  Press the “Start debugging” play button, or hit `F5` to begin breakpoint debugging.

Here’s an example `launch.json`:

    {
    	"version": "0.2.0",
    	"configurations": [
    		{
    			"command": "npm run dev",
    			"name": "Run development server",
    			"request": "launch",
    			"type": "node-terminal"
    		}
    	]
    }

Further reading: [https://code.visualstudio.com/docs/editor/debugging](https://code.visualstudio.com/docs/editor/debugging).

Other Editors[](#Other-Editors)
-------------------------------

If you use a different editor, these community guides might be useful for you:

*   [WebStorm Svelte: Debug Your Application](https://www.jetbrains.com/help/webstorm/svelte.html#ws_svelte_debug)
*   [Debugging JavaScript Frameworks in Neovim](https://theosteiner.de/debugging-javascript-frameworks-in-neovim)

Google Chrome and Microsoft Edge Developer Tools[](#Google-Chrome-and-Microsoft-Edge-Developer-Tools)
-----------------------------------------------------------------------------------------------------

It’s possible to debug Node.js applications using a browser-based debugger.

> Note this only works with debugging client-side SvelteKit source maps.

1.  Run the `--inspect` flag when starting the Vite server with Node.js. For instance: `NODE_OPTIONS="--inspect" npm run dev`
2.  Open your site in a new tab. Typically at `localhost:5173`.
3.  Open your browser’s dev tools, and click on the “Open dedicated DevTools for Node.js” icon near the top-left. It should display the Node.js logo.
4.  Set up breakpoints and debug your application.

You may alternatively open the debugger devtools by navigating to `chrome://inspect` in Google Chrome, or `edge://inspect` in Microsoft Edge.

References[](#References)
-------------------------

*   [Debugging Node.js](https://nodejs.org/en/learn/getting-started/debugging)

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/60-appendix/25-debugging.md) [llms.txt](/docs/kit/debugging/llms.txt)

previous next

[Integrations](/docs/kit/integrations) [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAppendix

Migrating to SvelteKit v2
=========================

### On this page

*   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
*   [redirect and error are no longer thrown by you](#redirect-and-error-are-no-longer-thrown-by-you)
*   [path is required when setting cookies](#path-is-required-when-setting-cookies)
*   [Top-level promises are no longer awaited](#Top-level-promises-are-no-longer-awaited)
*   [goto(...) changes](#goto\(\)-changes)
*   [paths are now relative by default](#paths-are-now-relative-by-default)
*   [Server fetches are not trackable anymore](#Server-fetches-are-not-trackable-anymore)
*   [preloadCode arguments must be prefixed with base](#preloadCode-arguments-must-be-prefixed-with-base)
*   [resolvePath has been removed](#resolvePath-has-been-removed)
*   [Improved error handling](#Improved-error-handling)
*   [Dynamic environment variables cannot be used during prerendering](#Dynamic-environment-variables-cannot-be-used-during-prerendering)
*   [form and data have been removed from use:enhance callbacks](#form-and-data-have-been-removed-from-use:enhance-callbacks)
*   [Forms containing file inputs must use multipart/form-data](#Forms-containing-file-inputs-must-use-multipart-form-data)
*   [Generated tsconfig.json is more strict](#Generated-tsconfig.json-is-more-strict)
*   [getRequest no longer throws errors](#getRequest-no-longer-throws-errors)
*   [vitePreprocess is no longer exported from @sveltejs/kit/vite](#vitePreprocess-is-no-longer-exported-from-sveltejs-kit-vite)
*   [Updated dependency requirements](#Updated-dependency-requirements)
*   [SvelteKit 2.12: $app/stores deprecated](#SvelteKit-2.12:-$app-stores-deprecated)

Upgrading from SvelteKit version 1 to version 2 should be mostly seamless. There are a few breaking changes to note, which are listed here. You can use `npx sv migrate sveltekit-2` to migrate some of these changes automatically.

We highly recommend upgrading to the most recent 1.x version before upgrading to 2.0, so that you can take advantage of targeted deprecation warnings. We also recommend [updating to Svelte 4](../svelte/v4-migration-guide) first: Later versions of SvelteKit 1.x support it, and SvelteKit 2.0 requires it.

redirect and error are no longer thrown by you[](#redirect-and-error-are-no-longer-thrown-by-you)
-------------------------------------------------------------------------------------------------

Previously, you had to `throw` the values returned from `error(...)` and `redirect(...)` yourself. In SvelteKit 2 this is no longer the case — calling the functions is sufficient.

    import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error } from '@sveltejs/kit'
    
    // ...
    throw error(500, 'something went wrong');
    function error(status: number, body?: {
        message: string;
    } extends App.Error ? App.Error | string | undefined : never): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error(500, 'something went wrong');

`svelte-migrate` will do these changes automatically for you.

If the error or redirect is thrown inside a `try {...}` block (hint: don’t do this!), you can distinguish them from unexpected errors using [`isHttpError`](@sveltejs-kit#isHttpError) and [`isRedirect`](@sveltejs-kit#isRedirect) imported from `@sveltejs/kit`.

path is required when setting cookies[](#path-is-required-when-setting-cookies)
-------------------------------------------------------------------------------

When receiving a `Set-Cookie` header that doesn’t specify a `path`, browsers will [set the cookie path](https://www.rfc-editor.org/rfc/rfc6265#section-5.1.4) to the parent of the resource in question. This behaviour isn’t particularly helpful or intuitive, and frequently results in bugs because the developer expected the cookie to apply to the domain as a whole.

As of SvelteKit 2.0, you need to set a `path` when calling `cookies.set(...)`, `cookies.delete(...)` or `cookies.serialize(...)` so that there’s no ambiguity. Most of the time, you probably want to use `path: '/'`, but you can set it to whatever you like, including relative paths — `''` means ‘the current path’, `'.'` means ‘the current directory’.

    /** @type {import('./$types').PageServerLoad} */
    export function function load({ cookies }: {
        cookies: any;
    }): {
        response: any;
    }@type{import('./$types').PageServerLoad}load({ cookies: anycookies }) {
    	cookies: anycookies.set(const name: void@deprecatedname, value, { path: stringpath: '/' });
    	return { response: anyresponse }
    }

`svelte-migrate` will add comments highlighting the locations that need to be adjusted.

Top-level promises are no longer awaited[](#Top-level-promises-are-no-longer-awaited)
-------------------------------------------------------------------------------------

In SvelteKit version 1, if the top-level properties of the object returned from a `load` function were promises, they were automatically awaited. With the introduction of [streaming](/blog/streaming-snapshots-sveltekit) this behavior became a bit awkward as it forces you to nest your streamed data one level deep.

As of version 2, SvelteKit no longer differentiates between top-level and non-top-level promises. To get back the blocking behavior, use `await` (with `Promise.all` to prevent waterfalls, where appropriate):

    // If you have a single promise
    /** @type {import('./$types').PageServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageServerLoad}load({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here.
    fetch }) {
    	const const response: anyresponse = await fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch(const url: stringurl).Promise<Response>.then<any, never>(onfulfilled?: ((value: Response) => any) | null | undefined, onrejected?: ((reason: any) => PromiseLike<never>) | null | undefined): Promise<any>Attaches callbacks for the resolution and/or rejection of the Promise.
    @paramonfulfilled The callback to execute when the Promise is resolved.@paramonrejected The callback to execute when the Promise is rejected.@returnsA Promise for the completion of which ever callback is executed.then(r: Responser => r: Responser.Body.json(): Promise<any>MDN Reference
    json());
    	return { response: anyresponse }
    }

    // If you have multiple promises
    /** @type {import('./$types').PageServerLoad} */
    export async function function load(event: ServerLoadEvent<Record<string, any>, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageServerLoad}load({ fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here.
    fetch }) {
    	const a = fetch(url1).then(r => r.json());
    	const b = fetch(url2).then(r => r.json());
    	const [const a: anya, const b: anyb] = await var Promise: PromiseConstructorRepresents the completion of an asynchronous operation
    Promise.PromiseConstructor.all<[Promise<any>, Promise<any>]>(values: [Promise<any>, Promise<any>]): Promise<[any, any]> (+1 overload)Creates a Promise that is resolved with an array of results when all of the provided Promises
    resolve, or rejected when any Promise is rejected.
    @paramvalues An array of Promises.@returnsA new Promise.all([
    	  fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch(const url1: stringurl1).Promise<Response>.then<any, never>(onfulfilled?: ((value: Response) => any) | null | undefined, onrejected?: ((reason: any) => PromiseLike<never>) | null | undefined): Promise<any>Attaches callbacks for the resolution and/or rejection of the Promise.
    @paramonfulfilled The callback to execute when the Promise is resolved.@paramonrejected The callback to execute when the Promise is rejected.@returnsA Promise for the completion of which ever callback is executed.then(r: Responser => r: Responser.Body.json(): Promise<any>MDN Reference
    json()),
    	  fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response> (+1 overload)MDN Reference
    fetch(const url2: stringurl2).Promise<Response>.then<any, never>(onfulfilled?: ((value: Response) => any) | null | undefined, onrejected?: ((reason: any) => PromiseLike<never>) | null | undefined): Promise<any>Attaches callbacks for the resolution and/or rejection of the Promise.
    @paramonfulfilled The callback to execute when the Promise is resolved.@paramonrejected The callback to execute when the Promise is rejected.@returnsA Promise for the completion of which ever callback is executed.then(r: Responser => r: Responser.Body.json(): Promise<any>MDN Reference
    json()),
    	]);
    	return { a: anya, b: anyb };
    }

goto(...) changes[](#goto\(\)-changes)
--------------------------------------

`goto(...)` no longer accepts external URLs. To navigate to an external URL, use `window.location.href = url`. The `state` object now determines `$page.state` and must adhere to the `App.PageState` interface, if declared. See [shallow routing](shallow-routing) for more details.

paths are now relative by default[](#paths-are-now-relative-by-default)
-----------------------------------------------------------------------

In SvelteKit 1, `%sveltekit.assets%` in your `app.html` was replaced with a relative path by default (i.e. `.` or `..` or `../..` etc, depending on the path being rendered) during server-side rendering unless the [`paths.relative`](configuration#paths) config option was explicitly set to `false`. The same was true for `base` and `assets` imported from `$app/paths`, but only if the `paths.relative` option was explicitly set to `true`.

This inconsistency is fixed in version 2. Paths are either always relative or always absolute, depending on the value of [`paths.relative`](configuration#paths). It defaults to `true` as this results in more portable apps: if the `base` is something other than the app expected (as is the case when viewed on the [Internet Archive](https://archive.org/), for example) or unknown at build time (as is the case when deploying to [IPFS](https://ipfs.tech/) and so on), fewer things are likely to break.

Server fetches are not trackable anymore[](#Server-fetches-are-not-trackable-anymore)
-------------------------------------------------------------------------------------

Previously it was possible to track URLs from `fetch`es on the server in order to rerun load functions. This poses a possible security risk (private URLs leaking), and as such it was behind the `dangerZone.trackServerFetches` setting, which is now removed.

preloadCode arguments must be prefixed with base[](#preloadCode-arguments-must-be-prefixed-with-base)
-----------------------------------------------------------------------------------------------------

SvelteKit exposes two functions, [`preloadCode`]($app-navigation#preloadCode) and [`preloadData`]($app-navigation#preloadData), for programmatically loading the code and data associated with a particular path. In version 1, there was a subtle inconsistency — the path passed to `preloadCode` did not need to be prefixed with the `base` path (if set), while the path passed to `preloadData` did.

This is fixed in SvelteKit 2 — in both cases, the path should be prefixed with `base` if it is set.

Additionally, `preloadCode` now takes a single argument rather than _n_ arguments.

resolvePath has been removed[](#resolvePath-has-been-removed)
-------------------------------------------------------------

SvelteKit 1 included a function called `resolvePath` which allows you to resolve a route ID (like `/blog/[slug]`) and a set of parameters (like `{ slug: 'hello' }`) to a pathname. Unfortunately the return value didn’t include the `base` path, limiting its usefulness in cases where `base` was set.

As such, SvelteKit 2 replaces `resolvePath` with a (slightly better named) function called `resolveRoute`, which is imported from `$app/paths` and which takes `base` into account.

    import { resolvePath } from '@sveltejs/kit';
    import { base } from '$app/paths';
    import { function resolveRoute(id: string, params: Record<string, string | undefined>): stringPopulate a route ID with params to resolve a pathname.
    @examplejs import { resolveRoute } from '$app/paths';  resolveRoute(   `/blog/[slug]/[...somethingElse]`,   {     slug: 'hello-world',     somethingElse: 'something/else'   } ); // `/blog/hello-world/something/else` resolveRoute } from '$app/paths';
    
    const path = base + resolvePath('/blog/[slug]', { slug });
    const const path: stringpath = function resolveRoute(id: string, params: Record<string, string | undefined>): stringPopulate a route ID with params to resolve a pathname.
    @examplejs import { resolveRoute } from '$app/paths';  resolveRoute(   `/blog/[slug]/[...somethingElse]`,   {     slug: 'hello-world',     somethingElse: 'something/else'   } ); // `/blog/hello-world/something/else` resolveRoute('/blog/[slug]', { slug: anyslug });

`svelte-migrate` will do the method replacement for you, though if you later prepend the result with `base`, you need to remove that yourself.

Improved error handling[](#Improved-error-handling)
---------------------------------------------------

Errors are handled inconsistently in SvelteKit 1. Some errors trigger the `handleError` hook but there is no good way to discern their status (for example, the only way to tell a 404 from a 500 is by seeing if `event.route.id` is `null`), while others (such as 405 errors for `POST` requests to pages without actions) don’t trigger `handleError` at all, but should. In the latter case, the resulting `$page.error` will deviate from the [`App.Error`](types#Error) type, if it is specified.

SvelteKit 2 cleans this up by calling `handleError` hooks with two new properties: `status` and `message`. For errors thrown from your code (or library code called by your code) the status will be `500` and the message will be `Internal Error`. While `error.message` may contain sensitive information that should not be exposed to users, `message` is safe.

Dynamic environment variables cannot be used during prerendering[](#Dynamic-environment-variables-cannot-be-used-during-prerendering)
-------------------------------------------------------------------------------------------------------------------------------------

The `$env/dynamic/public` and `$env/dynamic/private` modules provide access to _run time_ environment variables, as opposed to the _build time_ environment variables exposed by `$env/static/public` and `$env/static/private`.

During prerendering in SvelteKit 1, they are one and the same. As such, prerendered pages that make use of ‘dynamic’ environment variables are really ‘baking in’ build time values, which is incorrect. Worse, `$env/dynamic/public` is populated in the browser with these stale values if the user happens to land on a prerendered page before navigating to dynamically-rendered pages.

Because of this, dynamic environment variables can no longer be read during prerendering in SvelteKit 2 — you should use the `static` modules instead. If the user lands on a prerendered page, SvelteKit will request up-to-date values for `$env/dynamic/public` from the server (by default from a module called `/_app/env.js`) instead of reading them from the server-rendered HTML.

form and data have been removed from use:enhance callbacks[](#form-and-data-have-been-removed-from-use:enhance-callbacks)
-------------------------------------------------------------------------------------------------------------------------

If you provide a callback to [`use:enhance`](form-actions#Progressive-enhancement-use:enhance), it will be called with an object containing various useful properties.

In SvelteKit 1, those properties included `form` and `data`. These were deprecated some time ago in favour of `formElement` and `formData`, and have been removed altogether in SvelteKit 2.

Forms containing file inputs must use multipart/form-data[](#Forms-containing-file-inputs-must-use-multipart-form-data)
-----------------------------------------------------------------------------------------------------------------------

If a form contains an `<input type="file">` but does not have an `enctype="multipart/form-data"` attribute, non-JS submissions will omit the file. SvelteKit 2 will throw an error if it encounters a form like this during a `use:enhance` submission to ensure that your forms work correctly when JavaScript is not present.

Generated tsconfig.json is more strict[](#Generated-tsconfig.json-is-more-strict)
---------------------------------------------------------------------------------

Previously, the generated `tsconfig.json` was trying its best to still produce a somewhat valid config when your `tsconfig.json` included `paths` or `baseUrl`. In SvelteKit 2, the validation is more strict and will warn when you use either `paths` or `baseUrl` in your `tsconfig.json`. These settings are used to generate path aliases and you should use [the `alias` config](configuration#alias) option in your `svelte.config.js` instead, to also create a corresponding alias for the bundler.

getRequest no longer throws errors[](#getRequest-no-longer-throws-errors)
-------------------------------------------------------------------------

The `@sveltejs/kit/node` module exports helper functions for use in Node environments, including `getRequest` which turns a Node [`ClientRequest`](https://nodejs.org/api/http.html#class-httpclientrequest) into a standard [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object.

In SvelteKit 1, `getRequest` could throw if the `Content-Length` header exceeded the specified size limit. In SvelteKit 2, the error will not be thrown until later, when the request body (if any) is being read. This enables better diagnostics and simpler code.

vitePreprocess is no longer exported from @sveltejs/kit/vite[](#vitePreprocess-is-no-longer-exported-from-sveltejs-kit-vite)
----------------------------------------------------------------------------------------------------------------------------

Since `@sveltejs/vite-plugin-svelte` is now a peer dependency, SvelteKit 2 no longer re-exports `vitePreprocess`. You should import it directly from `@sveltejs/vite-plugin-svelte`.

Updated dependency requirements[](#Updated-dependency-requirements)
-------------------------------------------------------------------

SvelteKit 2 requires Node `18.13` or higher, and the following minimum dependency versions:

*   `svelte@4`
*   `vite@5`
*   `typescript@5`
*   `@sveltejs/vite-plugin-svelte@3` (this is now required as a `peerDependency` of SvelteKit — previously it was directly depended upon)
*   `@sveltejs/adapter-cloudflare@3` (if you’re using these adapters)
*   `@sveltejs/adapter-cloudflare-workers@2`
*   `@sveltejs/adapter-netlify@3`
*   `@sveltejs/adapter-node@2`
*   `@sveltejs/adapter-static@3`
*   `@sveltejs/adapter-vercel@4`

`svelte-migrate` will update your `package.json` for you.

As part of the TypeScript upgrade, the generated `tsconfig.json` (the one your `tsconfig.json` extends from) now uses `"moduleResolution": "bundler"` (which is recommended by the TypeScript team, as it properly resolves types from packages with an `exports` map in package.json) and `verbatimModuleSyntax` (which replaces the existing `importsNotUsedAsValues` and `preserveValueImports` flags — if you have those in your `tsconfig.json`, remove them. `svelte-migrate` will do this for you).

SvelteKit 2.12: $app/stores deprecated[](#SvelteKit-2.12:-$app-stores-deprecated)
---------------------------------------------------------------------------------

SvelteKit 2.12 introduced `$app/state` based on the [Svelte 5 runes API](/docs/svelte/what-are-runes). `$app/state` provides everything that `$app/stores` provides but with more flexibility as to where and how you use it. Most importantly, the `page` object is now fine-grained, e.g. updates to `page.state` will not invalidate `page.data` and vice-versa.

As a consequence, `$app/stores` is deprecated and subject to be removed in SvelteKit 3. We recommend [upgrading to Svelte 5](/docs/svelte/v5-migration-guide), if you haven’t already, and then migrate away from `$app/stores`. Most of the replacements should be pretty simple: Replace the `$app/stores` import with `$app/state` and remove the `$` prefixes from the usage sites.

    <script>
    	import { page } from '$app/stores';
    	import { page } from '$app/state';
    </script>
    
    {$page.data}
    {page.data}

Use `npx sv migrate app-state` to auto-migrate most of your `$app/stores` usages inside `.svelte` components.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/60-appendix/30-migrating-to-sveltekit-2.md) [llms.txt](/docs/kit/migrating-to-sveltekit-2/llms.txt)

previous next

[Breakpoint Debugging](/docs/kit/debugging) [Migrating from Sapper](/docs/kit/migrating)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAppendix

Migrating from Sapper
=====================

### On this page

*   [Migrating from Sapper](/docs/kit/migrating)
*   [package.json](#package.json)
*   [Project files](#Project-files)
*   [Pages and layouts](#Pages-and-layouts)
*   [Endpoints](#Endpoints)
*   [Integrations](#Integrations)

SvelteKit is the successor to Sapper and shares many elements of its design.

If you have an existing Sapper app that you plan to migrate to SvelteKit, there are a number of changes you will need to make. You may find it helpful to view [some examples](additional-resources#Examples) while migrating.

package.json[](#package.json)
-----------------------------

### type: “module”[](#package.json-type:-module)

Add `"type": "module"` to your `package.json`. You can do this step separately from the rest as part of an incremental migration if you are using Sapper 0.29.3 or newer.

### dependencies[](#package.json-dependencies)

Remove `polka` or `express`, if you’re using one of those, and any middleware such as `sirv` or `compression`.

### devDependencies[](#package.json-devDependencies)

Remove `sapper` from your `devDependencies` and replace it with `@sveltejs/kit` and whichever [adapter](adapters) you plan to use (see [next section](migrating#Project-files-Configuration)).

### scripts[](#package.json-scripts)

Any scripts that reference `sapper` should be updated:

*   `sapper build` should become `vite build` using the Node [adapter](adapters)
*   `sapper export` should become `vite build` using the static [adapter](adapters)
*   `sapper dev` should become `vite dev`
*   `node __sapper__/build` should become `node build`

Project files[](#Project-files)
-------------------------------

The bulk of your app, in `src/routes`, can be left where it is, but several project files will need to be moved or updated.

### Configuration[](#Project-files-Configuration)

Your `webpack.config.js` or `rollup.config.js` should be replaced with a `svelte.config.js`, as documented [here](configuration). Svelte preprocessor options should be moved to `config.preprocess`.

You will need to add an [adapter](adapters). `sapper build` is roughly equivalent to [adapter-node](adapter-node) while `sapper export` is roughly equivalent to [adapter-static](adapter-static), though you might prefer to use an adapter designed for the platform you’re deploying to.

If you were using plugins for filetypes that are not automatically handled by [Vite](https://vitejs.dev), you will need to find Vite equivalents and add them to the [Vite config](project-structure#Project-files-vite.config.js).

### src/client.js[](#Project-files-src-client.js)

This file has no equivalent in SvelteKit. Any custom logic (beyond `sapper.start(...)`) should be expressed in your `+layout.svelte` file, inside an `onMount` callback.

### src/server.js[](#Project-files-src-server.js)

When using `adapter-node` the equivalent is a [custom server](adapter-node#Custom-server). Otherwise, this file has no direct equivalent, since SvelteKit apps can run in serverless environments.

### src/service-worker.js[](#Project-files-src-service-worker.js)

Most imports from `@sapper/service-worker` have equivalents in [`$service-worker`]($service-worker):

*   `files` is unchanged
*   `routes` has been removed
*   `shell` is now `build`
*   `timestamp` is now `version`

### src/template.html[](#Project-files-src-template.html)

The `src/template.html` file should be renamed `src/app.html`.

Remove `%sapper.base%`, `%sapper.scripts%` and `%sapper.styles%`. Replace `%sapper.head%` with `%sveltekit.head%` and `%sapper.html%` with `%sveltekit.body%`. The `<div id="sapper">` is no longer necessary.

### src/node\_modules[](#Project-files-src-node_modules)

A common pattern in Sapper apps is to put your internal library in a directory inside `src/node_modules`. This doesn’t work with Vite, so we use [`src/lib`]($lib) instead.

Pages and layouts[](#Pages-and-layouts)
---------------------------------------

### Renamed files[](#Pages-and-layouts-Renamed-files)

Routes now are made up of the folder name exclusively to remove ambiguity, the folder names leading up to a `+page.svelte` correspond to the route. See [the routing docs](routing) for an overview. The following shows a old/new comparison:

| Old | New |
| --- | --- |
| routes/about/index.svelte | routes/about/+page.svelte |
| routes/about.svelte | routes/about/+page.svelte |

Your custom error page component should be renamed from `_error.svelte` to `+error.svelte`. Any `_layout.svelte` files should likewise be renamed `+layout.svelte`. [Any other files are ignored](routing#Other-files).

### Imports[](#Pages-and-layouts-Imports)

The `goto`, `prefetch` and `prefetchRoutes` imports from `@sapper/app` should be replaced with `goto`, `preloadData` and `preloadCode` imports respectively from [`$app/navigation`]($app-navigation).

The `stores` import from `@sapper/app` should be replaced — see the [Stores](migrating#Pages-and-layouts-Stores) section below.

Any files you previously imported from directories in `src/node_modules` will need to be replaced with [`$lib`]($lib) imports.

### Preload[](#Pages-and-layouts-Preload)

As before, pages and layouts can export a function that allows data to be loaded before rendering takes place.

This function has been renamed from `preload` to [`load`](load), it now lives in a `+page.js` (or `+layout.js`) next to its `+page.svelte` (or `+layout.svelte`), and its API has changed. Instead of two arguments — `page` and `session` — there is a single `event` argument.

There is no more `this` object, and consequently no `this.fetch`, `this.error` or `this.redirect`. Instead, you can get [`fetch`](load#Making-fetch-requests) from the input methods, and both [`error`](load#Errors) and [`redirect`](load#Redirects) are now thrown.

### Stores[](#Pages-and-layouts-Stores)

In Sapper, you would get references to provided stores like so:

    import { module "@sapper/app"stores } from '@sapper/app';
    const { const preloading: anypreloading, const page: anypage, const session: anysession } = module "@sapper/app"stores();

The `page` store still exists; `preloading` has been replaced with a `navigating` store that contains `from` and `to` properties. `page` now has `url` and `params` properties, but no `path` or `query`.

You access them differently in SvelteKit. `stores` is now `getStores`, but in most cases it is unnecessary since you can import `navigating`, and `page` directly from [`$app/stores`]($app-stores). If you’re on Svelte 5 and SvelteKit 2.12 or higher, consider using [`$app/state`]($app-state) instead.

### Routing[](#Pages-and-layouts-Routing)

Regex routes are no longer supported. Instead, use [advanced route matching](advanced-routing#Matching).

### Segments[](#Pages-and-layouts-Segments)

Previously, layout components received a `segment` prop indicating the child segment. This has been removed; you should use the more flexible `$page.url.pathname` (or `page.url.pathname`) value to derive the segment you’re interested in.

### URLs[](#Pages-and-layouts-URLs)

In Sapper, all relative URLs were resolved against the base URL — usually `/`, unless the `basepath` option was used — rather than against the current page.

This caused problems and is no longer the case in SvelteKit. Instead, relative URLs are resolved against the current page (or the destination page, for `fetch` URLs in `load` functions) instead. In most cases, it’s easier to use root-relative (i.e. starts with `/`) URLs, since their meaning is not context-dependent.

### <a> attributes[](#Pages-and-layouts-a-attributes)

*   `sapper:prefetch` is now `data-sveltekit-preload-data`
*   `sapper:noscroll` is now `data-sveltekit-noscroll`

Endpoints[](#Endpoints)
-----------------------

In Sapper, [server routes](routing#server) received the `req` and `res` objects exposed by Node’s `http` module (or the augmented versions provided by frameworks like Polka and Express).

SvelteKit is designed to be agnostic as to where the app is running — it could be running on a Node server, but could equally be running on a serverless platform or in a Cloudflare Worker. For that reason, you no longer interact directly with `req` and `res`. Your endpoints will need to be updated to match the new signature.

To support this environment-agnostic behavior, `fetch` is now available in the global context, so you don’t need to import `node-fetch`, `cross-fetch`, or similar server-side fetch implementations in order to use it.

Integrations[](#Integrations)
-----------------------------

See [integrations](./integrations) for detailed information about integrations.

### HTML minifier[](#Integrations-HTML-minifier)

Sapper includes `html-minifier` by default. SvelteKit does not include this, but you can add it as a prod dependency and then use it through a [hook](hooks#Server-hooks-handle):

    import { module "html-minifier"minify } from 'html-minifier';
    import { const building: booleanSvelteKit analyses your app during the build step by running it. During this process, building is true. This also applies during prerendering.
    building } from '$app/environment';
    
    const const minification_options: {
        collapseBooleanAttributes: boolean;
        collapseWhitespace: boolean;
        conservativeCollapse: boolean;
        decodeEntities: boolean;
        html5: boolean;
        ignoreCustomComments: RegExp[];
        minifyCSS: boolean;
        ... 8 more ...;
        sortClassName: boolean;
    }minification_options = {
    	collapseBooleanAttributes: booleancollapseBooleanAttributes: true,
    	collapseWhitespace: booleancollapseWhitespace: true,
    	conservativeCollapse: booleanconservativeCollapse: true,
    	decodeEntities: booleandecodeEntities: true,
    	html5: booleanhtml5: true,
    	ignoreCustomComments: RegExp[]ignoreCustomComments: [/^#/],
    	minifyCSS: booleanminifyCSS: true,
    	minifyJS: booleanminifyJS: false,
    	removeAttributeQuotes: booleanremoveAttributeQuotes: true,
    	removeComments: booleanremoveComments: false, // some hydration code needs comments, so leave them in
    	removeOptionalTags: booleanremoveOptionalTags: true,
    	removeRedundantAttributes: booleanremoveRedundantAttributes: true,
    	removeScriptTypeAttributes: booleanremoveScriptTypeAttributes: true,
    	removeStyleLinkTypeAttributes: booleanremoveStyleLinkTypeAttributes: true,
    	sortAttributes: booleansortAttributes: true,
    	sortClassName: booleansortClassName: true
    };
    
    /** @type {import('@sveltejs/kit').Handle} */
    export async function function handle(input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }): MaybePromise<...>@type{import('@sveltejs/kit').Handle}handle({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) {
    	let let page: stringpage = '';
    
    	return resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event, {
    		ResolveOptions.transformPageChunk?: ((input: {
        html: string;
        done: boolean;
    }) => MaybePromise<string | undefined>) | undefinedApplies custom transforms to HTML. If done is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML
    (they could include an element’s opening tag but not its closing tag, for example)
    but they will always be split at sensible boundaries such as %sveltekit.head% or layout/page components.
    @paraminput the html chunk and the info if this is the last chunktransformPageChunk: ({ html: stringhtml, done: booleandone }) => {
    			let page: stringpage += html: stringhtml;
    			if (done: booleandone) {
    				return const building: booleanSvelteKit analyses your app during the build step by running it. During this process, building is true. This also applies during prerendering.
    building ? module "html-minifier"minify(let page: stringpage, const minification_options: {
        collapseBooleanAttributes: boolean;
        collapseWhitespace: boolean;
        conservativeCollapse: boolean;
        decodeEntities: boolean;
        html5: boolean;
        ignoreCustomComments: RegExp[];
        minifyCSS: boolean;
        ... 8 more ...;
        sortClassName: boolean;
    }minification_options) : let page: stringpage;
    			}
    		}
    	});
    }

Note that `prerendering` is `false` when using `vite preview` to test the production build of the site, so to verify the results of minifying, you’ll need to inspect the built HTML files directly.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/60-appendix/40-migrating.md) [llms.txt](/docs/kit/migrating/llms.txt)

previous next

[Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2) [Additional resources](/docs/kit/additional-resources)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAppendix

Additional resources
====================

### On this page

*   [Additional resources](/docs/kit/additional-resources)
*   [FAQs](#FAQs)
*   [Examples](#Examples)
*   [Support](#Support)

FAQs[](#FAQs)
-------------

Please see the [SvelteKit FAQ](faq) for solutions to common issues and helpful tips and tricks.

The [Svelte FAQ](../svelte/faq) and [`vite-plugin-svelte` FAQ](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md) may also be helpful for questions deriving from those libraries.

Examples[](#Examples)
---------------------

We’ve written and published a few different SvelteKit sites as examples:

*   [`sveltejs/realworld`](https://github.com/sveltejs/realworld) contains an example blog site
*   [A HackerNews clone](https://github.com/sveltejs/sites/tree/master/sites/hn.svelte.dev)
*   [`svelte.dev`](https://github.com/sveltejs/svelte.dev)

SvelteKit users have also published plenty of examples on GitHub, under the [#sveltekit](https://github.com/topics/sveltekit) and [#sveltekit-template](https://github.com/topics/sveltekit-template) topics, as well as on [the Svelte Society site](https://sveltesociety.dev/templates?category=sveltekit). Note that these have not been vetted by the maintainers and may not be up to date.

Support[](#Support)
-------------------

You can ask for help on [Discord](/chat) and [StackOverflow](https://stackoverflow.com/questions/tagged/sveltekit). Please first search for information related to your issue in the FAQ, Google or another search engine, issue tracker, and Discord chat history in order to be respectful of others’ time. There are many more people asking questions than answering them, so this will help in allowing the community to grow in a scalable fashion.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/60-appendix/50-additional-resources.md) [llms.txt](/docs/kit/additional-resources/llms.txt)

previous next

[Migrating from Sapper](/docs/kit/migrating) [Glossary](/docs/kit/glossary)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitAppendix

Glossary
========

### On this page

*   [Glossary](/docs/kit/glossary)
*   [CSR](#CSR)
*   [Edge](#Edge)
*   [Hydration](#Hydration)
*   [ISR](#ISR)
*   [MPA](#MPA)
*   [Prerendering](#Prerendering)
*   [PWA](#PWA)
*   [Routing](#Routing)
*   [SPA](#SPA)
*   [SSG](#SSG)
*   [SSR](#SSR)

The core of SvelteKit provides a highly configurable rendering engine. This section describes some of the terms used when discussing rendering. A reference for setting these options is provided in the documentation above.

CSR[](#CSR)
-----------

Client-side rendering (CSR) is the generation of the page contents in the web browser using JavaScript.

In SvelteKit, client-side rendering will be used by default, but you can turn off JavaScript with [the `csr = false` page option](page-options#csr).

Edge[](#Edge)
-------------

Rendering on the edge refers to rendering an application in a content delivery network (CDN) near the user. Edge rendering allows the request and response for a page to travel a shorter distance thus improving latency.

Hydration[](#Hydration)
-----------------------

Svelte components store some state and update the DOM when the state is updated. When fetching data during SSR, by default SvelteKit will store this data and transmit it to the client along with the server-rendered HTML. The components can then be initialized on the client with that data without having to call the same API endpoints again. Svelte will then check that the DOM is in the expected state and attach event listeners in a process called hydration. Once the components are fully hydrated, they can react to changes to their properties just like any newly created Svelte component.

In SvelteKit, pages will be hydrated by default, but you can turn off JavaScript with [the `csr = false` page option](page-options#csr).

ISR[](#ISR)
-----------

Incremental static regeneration (ISR) allows you to generate static pages on your site as visitors request those pages without redeploying. This may reduces build times compared to [SSG](#SSG) sites with a large number of pages. You can do [ISR with `adapter-vercel`](adapter-vercel#Incremental-Static-Regeneration).

MPA[](#MPA)
-----------

Traditional applications that render each page view on the server — such as those written in languages other than JavaScript — are often referred to as multi-page apps (MPA).

Prerendering[](#Prerendering)
-----------------------------

Prerendering means computing the contents of a page at build time and saving the HTML for display. This approach has the same benefits as traditional server-rendered pages, but avoids recomputing the page for each visitor and so scales nearly for free as the number of visitors increases. The tradeoff is that the build process is more expensive and prerendered content can only be updated by building and deploying a new version of the application.

Not all pages can be prerendered. The basic rule is this: for content to be prerenderable, any two users hitting it directly must get the same content from the server, and the page must not contain [actions](form-actions). Note that you can still prerender content that is loaded based on the page’s parameters as long as all users will be seeing the same prerendered content.

Pre-rendered pages are not limited to static content. You can build personalized pages if user-specific data is fetched and rendered client-side. This is subject to the caveat that you will experience the downsides of not doing SSR for that content as discussed above.

In SvelteKit, you can control prerendering with [the `prerender` page option](page-options#prerender) and [`prerender` config](configuration#prerender) in `svelte.config.js`.

PWA[](#PWA)
-----------

A progressive web app (PWA) is an app that’s built using web APIs and technologies, but functions like a mobile or desktop app. Sites served as [PWAs can be installed](https://web.dev/learn/pwa/installation), allowing you to add a shortcut to the application on your launcher, home screen, or start menu. Many PWAs will utilize [service workers](service-workers) to build offline capabilities.

Routing[](#Routing)
-------------------

By default, when you navigate to a new page (by clicking on a link or using the browser’s forward or back buttons), SvelteKit will intercept the attempted navigation and handle it instead of allowing the browser to send a request to the server for the destination page. SvelteKit will then update the displayed contents on the client by rendering the component for the new page, which in turn can make calls to the necessary API endpoints. This process of updating the page on the client in response to attempted navigation is called client-side routing.

In SvelteKit, client-side routing will be used by default, but you can skip it with [`data-sveltekit-reload`](link-options#data-sveltekit-reload).

SPA[](#SPA)
-----------

A single-page app (SPA) is an application in which all requests to the server load a single HTML file which then does client-side rendering of the requested contents based on the requested URL. All navigation is handled on the client-side in a process called client-side routing with per-page contents being updated and common layout elements remaining largely unchanged. SPAs do not provide SSR and thus have worse performance and SEO characteristics. However, some applications are not greatly impacted by these shortcomings such as a complex business application behind a login where SEO would not be important and it is known that users will be accessing the application from a consistent computing environment.

In SvelteKit, you can [build an SPA with `adapter-static`](single-page-apps).

SSG[](#SSG)
-----------

Static Site Generation (SSG) is a term that refers to a site where every page is prerendered. One benefit of fully prerendering a site is that you do not need to maintain or pay for servers to perform SSR. Once generated, the site can be served from CDNs, leading to great “time to first byte” performance. This delivery model is often referred to as JAMstack.

In SvelteKit, you can do static site generation by using [`adapter-static`](adapter-static) or by configuring every page to be prerendered using [the `prerender` page option](page-options#prerender) or [`prerender` config](configuration#prerender) in `svelte.config.js`.

SSR[](#SSR)
-----------

Server-side rendering (SSR) is the generation of the page contents on the server. SSR is generally preferred for SEO. While some search engines can index content that is dynamically generated on the client-side it may take longer even in these cases. It also tends to improve perceived performance and makes your app accessible to users if JavaScript fails or is disabled (which happens [more often than you probably think](https://kryogenix.org/code/browser/everyonehasjs.html)).

In SvelteKit, pages are server-side rendered by default. You can disable SSR with [the `ssr` page option](page-options#ssr).

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/60-appendix/60-glossary.md) [llms.txt](/docs/kit/glossary/llms.txt)

previous next

[Additional resources](/docs/kit/additional-resources) [@sveltejs/kit](/docs/kit/@sveltejs-kit)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

@sveltejs/kit
=============

### On this page

*   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
*   [Server](#Server)
*   [VERSION](#VERSION)
*   [error](#error)
*   [fail](#fail)
*   [isActionFailure](#isActionFailure)
*   [isHttpError](#isHttpError)
*   [isRedirect](#isRedirect)
*   [json](#json)
*   [normalizeUrl](#normalizeUrl)
*   [redirect](#redirect)
*   [text](#text)
*   [Action](#Action)
*   [ActionFailure](#ActionFailure)
*   [ActionResult](#ActionResult)
*   [Actions](#Actions)
*   [Adapter](#Adapter)
*   [AfterNavigate](#AfterNavigate)
*   [AwaitedActions](#AwaitedActions)
*   [BeforeNavigate](#BeforeNavigate)
*   [Builder](#Builder)
*   [ClientInit](#ClientInit)
*   [Config](#Config)
*   [Cookies](#Cookies)
*   [Emulator](#Emulator)
*   [Handle](#Handle)
*   [HandleClientError](#HandleClientError)
*   [HandleFetch](#HandleFetch)
*   [HandleServerError](#HandleServerError)
*   [HttpError](#HttpError)
*   [KitConfig](#KitConfig)
*   [LessThan](#LessThan)
*   [Load](#Load)
*   [LoadEvent](#LoadEvent)
*   [LoadProperties](#LoadProperties)
*   [Navigation](#Navigation)
*   [NavigationEvent](#NavigationEvent)
*   [NavigationTarget](#NavigationTarget)
*   [NavigationType](#NavigationType)
*   [NumericRange](#NumericRange)
*   [OnNavigate](#OnNavigate)
*   [Page](#Page)
*   [ParamMatcher](#ParamMatcher)
*   [PrerenderOption](#PrerenderOption)
*   [Redirect](#Redirect)
*   [RequestEvent](#RequestEvent)
*   [RequestHandler](#RequestHandler)
*   [Reroute](#Reroute)
*   [ResolveOptions](#ResolveOptions)
*   [RouteDefinition](#RouteDefinition)
*   [SSRManifest](#SSRManifest)
*   [ServerInit](#ServerInit)
*   [ServerInitOptions](#ServerInitOptions)
*   [ServerLoad](#ServerLoad)
*   [ServerLoadEvent](#ServerLoadEvent)
*   [Snapshot](#Snapshot)
*   [SubmitFunction](#SubmitFunction)
*   [Transport](#Transport)
*   [Transporter](#Transporter)
*   [Private types](#Private-types)
*   [AdapterEntry](#AdapterEntry)
*   [Csp](#Csp)
*   [CspDirectives](#CspDirectives)
*   [HttpMethod](#HttpMethod)
*   [Logger](#Logger)
*   [MaybePromise](#MaybePromise)
*   [PrerenderEntryGeneratorMismatchHandler](#PrerenderEntryGeneratorMismatchHandler)
*   [PrerenderEntryGeneratorMismatchHandlerValue](#PrerenderEntryGeneratorMismatchHandlerValue)
*   [PrerenderHttpErrorHandler](#PrerenderHttpErrorHandler)
*   [PrerenderHttpErrorHandlerValue](#PrerenderHttpErrorHandlerValue)
*   [PrerenderMap](#PrerenderMap)
*   [PrerenderMissingIdHandler](#PrerenderMissingIdHandler)
*   [PrerenderMissingIdHandlerValue](#PrerenderMissingIdHandlerValue)
*   [PrerenderOption](#PrerenderOption)
*   [Prerendered](#Prerendered)
*   [RequestOptions](#RequestOptions)
*   [RouteSegment](#RouteSegment)
*   [TrailingSlash](#TrailingSlash)

    import {
    	class ServerServer,
    	const VERSION: stringVERSION,
    	function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
    When called during request handling, this will cause SvelteKit to
    return an error response without invoking handleError.
    Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
    @paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.@throwsHttpError This error instructs SvelteKit to initiate HTTP error handling.@throwsError If the provided status is invalid (not between 400 and 599).error,
    	function fail(status: number): ActionFailure<undefined> (+1 overload)Create an ActionFailure object.
    @paramstatus The HTTP status code. Must be in the range 400-599.fail,
    	function isActionFailure(e: unknown): e is ActionFailureChecks whether this is an action failure thrown by 
    {@link 
    fail
    }
    .
    @parame The object to check.isActionFailure,
    	function isHttpError<T extends number>(e: unknown, status?: T | undefined): e is (HttpError_1 & {
        status: T extends undefined ? never : T;
    })Checks whether this is an error thrown by 
    {@link 
    error
    }
    .
    @paramstatus The status to filter for.isHttpError,
    	function isRedirect(e: unknown): e is Redirect_1Checks whether this is a redirect thrown by 
    {@link 
    redirect
    }
    .
    @parame The object to check.isRedirect,
    	function json(data: any, init?: ResponseInit | undefined): ResponseCreate a JSON Response object from the supplied data.
    @paramdata The value that will be serialized as JSON.@paraminit Options such as status and headers that will be added to the response. Content-Type: application/json and Content-Length headers will be added automatically.json,
    	function normalizeUrl(url: URL | string): {
        url: URL;
        wasNormalized: boolean;
        denormalize: (url?: string | URL) => URL;
    }Strips possible SvelteKit-internal suffixes and trailing slashes from the URL pathname.
    Returns the normalized URL as well as a method for adding the potential suffix back
    based on a new pathname (possibly including search) or URL.
    import { normalizeUrl } from '@sveltejs/kit';
    
    const { url, denormalize } = normalizeUrl('/blog/post/__data.json');
    console.log(url.pathname); // /blog/post
    console.log(denormalize('/blog/post/a')); // /blog/post/a/__data.json@since2.18.0normalizeUrl,
    	function redirect(status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | ({} & number), location: string | URL): neverRedirect a request. When called during request handling, SvelteKit will return a redirect response.
    Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.
    Most common status codes:
    
    303 See Other: redirect as a GET request (often used after a form POST request)
    307 Temporary Redirect: redirect will keep the request method
    308 Permanent Redirect: redirect will keep the request method, SEO will be transferred to the new page
    
    See all redirect status codes
    @paramstatus The HTTP status code. Must be in the range 300-308.@paramlocation The location to redirect to.@throwsRedirect This error instructs SvelteKit to redirect to the specified location.@throwsError If the provided status is invalid.redirect,
    	function text(body: string, init?: ResponseInit | undefined): ResponseCreate a Response object from the supplied body.
    @parambody The value that will be used as-is.@paraminit Options such as status and headers that will be added to the response. A Content-Length header will be added automatically.text
    } from '@sveltejs/kit';

Server[](#Server)
-----------------

    class Server {…}

    constructor(manifest: SSRManifest);

    init(options: ServerInitOptions): Promise<void>;

    respond(request: Request, options: RequestOptions): Promise<Response>;

VERSION[](#VERSION)
-------------------

    const VERSION: string;

error[](#error)
---------------

Throws an error with a HTTP status code and an optional message. When called during request handling, this will cause SvelteKit to return an error response without invoking `handleError`. Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.

    function error(status: number, body: App.Error): never;

    function error(
    	status: number,
    	body?: {
    		message: string;
    	} extends App.Error
    		? App.Error | string | undefined
    		: never
    ): never;

fail[](#fail)
-------------

Create an `ActionFailure` object. Call when form submission fails.

    function fail(status: number): ActionFailure<undefined>;

    function fail<
    	T extends Record<string, unknown> | undefined = undefined
    >(status: number, data: T): ActionFailure<T>;

isActionFailure[](#isActionFailure)
-----------------------------------

Checks whether this is an action failure thrown by `fail`.

    function isActionFailure(e: unknown): e is ActionFailure;

isHttpError[](#isHttpError)
---------------------------

Checks whether this is an error thrown by `error`.

    function isHttpError<T extends number>(
    	e: unknown,
    	status?: T | undefined
    ): e is HttpError_1 & {
    	status: T extends undefined ? never : T;
    };

isRedirect[](#isRedirect)
-------------------------

Checks whether this is a redirect thrown by `redirect`.

    function isRedirect(e: unknown): e is Redirect_1;

json[](#json)
-------------

Create a JSON `Response` object from the supplied data.

    function json(
    	data: any,
    	init?: ResponseInit | undefined
    ): Response;

normalizeUrl[](#normalizeUrl)
-----------------------------

> Available since 2.18.0

Strips possible SvelteKit-internal suffixes and trailing slashes from the URL pathname. Returns the normalized URL as well as a method for adding the potential suffix back based on a new pathname (possibly including search) or URL.

    import { function normalizeUrl(url: URL | string): {
        url: URL;
        wasNormalized: boolean;
        denormalize: (url?: string | URL) => URL;
    }Strips possible SvelteKit-internal suffixes and trailing slashes from the URL pathname.
    Returns the normalized URL as well as a method for adding the potential suffix back
    based on a new pathname (possibly including search) or URL.
    import { normalizeUrl } from '@sveltejs/kit';
    
    const { url, denormalize } = normalizeUrl('/blog/post/__data.json');
    console.log(url.pathname); // /blog/post
    console.log(denormalize('/blog/post/a')); // /blog/post/a/__data.json@since2.18.0normalizeUrl } from '@sveltejs/kit';
    
    const { const url: URLurl, const denormalize: (url?: string | URL) => URLdenormalize } = function normalizeUrl(url: URL | string): {
        url: URL;
        wasNormalized: boolean;
        denormalize: (url?: string | URL) => URL;
    }Strips possible SvelteKit-internal suffixes and trailing slashes from the URL pathname.
    Returns the normalized URL as well as a method for adding the potential suffix back
    based on a new pathname (possibly including search) or URL.
    import { normalizeUrl } from '@sveltejs/kit';
    
    const { url, denormalize } = normalizeUrl('/blog/post/__data.json');
    console.log(url.pathname); // /blog/post
    console.log(denormalize('/blog/post/a')); // /blog/post/a/__data.json@since2.18.0normalizeUrl('/blog/post/__data.json');
    var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(const url: URLurl.URL.pathname: stringMDN Reference
    pathname); // /blog/post
    var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(const denormalize: (url?: string | URL) => URLdenormalize('/blog/post/a')); // /blog/post/a/__data.json

    function normalizeUrl(url: URL | string): {
    	url: URL;
    	wasNormalized: boolean;
    	denormalize: (url?: string | URL) => URL;
    };

redirect[](#redirect)
---------------------

Redirect a request. When called during request handling, SvelteKit will return a redirect response. Make sure you’re not catching the thrown redirect, which would prevent SvelteKit from handling it.

Most common status codes:

*   `303 See Other`: redirect as a GET request (often used after a form POST request)
*   `307 Temporary Redirect`: redirect will keep the request method
*   `308 Permanent Redirect`: redirect will keep the request method, SEO will be transferred to the new page

[See all redirect status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages)

    function redirect(
    	status:
    		| 300
    		| 301
    		| 302
    		| 303
    		| 304
    		| 305
    		| 306
    		| 307
    		| 308
    		| ({} & number),
    	location: string | URL
    ): never;

text[](#text)
-------------

Create a `Response` object from the supplied body.

    function text(
    	body: string,
    	init?: ResponseInit | undefined
    ): Response;

Action[](#Action)
-----------------

Shape of a form action method that is part of `export const actions = {...}` in `+page.server.js`. See [form actions](/docs/kit/form-actions) for more information.

    type Action<
    	Params extends Partial<Record<string, string>> = Partial<
    		Record<string, string>
    	>,
    	OutputData extends Record<string, any> | void = Record<
    		string,
    		any
    	> | void,
    	RouteId extends string | null = string | null
    > = (
    	event: RequestEvent<Params, RouteId>
    ) => MaybePromise<OutputData>;

ActionFailure[](#ActionFailure)
-------------------------------

    interface ActionFailure<
    	T extends Record<string, unknown> | undefined = undefined
    > {…}

    status: number;

    data: T;

    [uniqueSymbol]: true;

ActionResult[](#ActionResult)
-----------------------------

When calling a form action via fetch, the response will be one of these shapes.

    <form method="post" use:enhance={() => {
    	return ({ result }) => {
    		// result is of type ActionResult
    	};
    }}

    type ActionResult<
    	Success extends
    		| Record<string, unknown>
    		| undefined = Record<string, any>,
    	Failure extends
    		| Record<string, unknown>
    		| undefined = Record<string, any>
    > =
    	| { type: 'success'; status: number; data?: Success }
    	| { type: 'failure'; status: number; data?: Failure }
    	| { type: 'redirect'; status: number; location: string }
    	| { type: 'error'; status?: number; error: any };

Actions[](#Actions)
-------------------

Shape of the `export const actions = {...}` object in `+page.server.js`. See [form actions](/docs/kit/form-actions) for more information.

    type Actions<
    	Params extends Partial<Record<string, string>> = Partial<
    		Record<string, string>
    	>,
    	OutputData extends Record<string, any> | void = Record<
    		string,
    		any
    	> | void,
    	RouteId extends string | null = string | null
    > = Record<string, Action<Params, OutputData, RouteId>>;

Adapter[](#Adapter)
-------------------

[Adapters](/docs/kit/adapters) are responsible for taking the production build and turning it into something that can be deployed to a platform of your choosing.

    interface Adapter {…}

    name: string;

The name of the adapter, using for logging. Will typically correspond to the package name.

    adapt: (builder: Builder) => MaybePromise<void>;

*   `builder` An object provided by SvelteKit that contains methods for adapting the app

This function is called after SvelteKit has built your app.

    supports?: {…}

Checks called during dev and build to determine whether specific features will work in production with this adapter.

    read?: (details: { config: any; route: { id: string } }) => boolean;

*   `details.config` The merged route config

Test support for `read` from `$app/server`.

    emulate?: () => MaybePromise<Emulator>;

Creates an `Emulator`, which allows the adapter to influence the environment during dev, build and prerendering.

AfterNavigate[](#AfterNavigate)
-------------------------------

The argument passed to [`afterNavigate`](/docs/kit/$app-navigation#afterNavigate) callbacks.

    interface AfterNavigate extends Omit<Navigation, 'type'> {…}

    type: Exclude<NavigationType, 'leave'>;

The type of navigation:

*   `enter`: The app has hydrated/started
*   `form`: The user submitted a `<form>`
*   `link`: Navigation was triggered by a link click
*   `goto`: Navigation was triggered by a `goto(...)` call or a redirect
*   `popstate`: Navigation was triggered by back/forward navigation

    willUnload: false;

Since `afterNavigate` callbacks are called after a navigation completes, they will never be called with a navigation that unloads the page.

AwaitedActions[](#AwaitedActions)
---------------------------------

    type AwaitedActions<
    	T extends Record<string, (...args: any) => any>
    > = OptionalUnion<
    	{
    		[Key in keyof T]: UnpackValidationError<
    			Awaited<ReturnType<T[Key]>>
    		>;
    	}[keyof T]
    >;

BeforeNavigate[](#BeforeNavigate)
---------------------------------

The argument passed to [`beforeNavigate`](/docs/kit/$app-navigation#beforeNavigate) callbacks.

    interface BeforeNavigate extends Navigation {…}

    cancel: () => void;

Call this to prevent the navigation from starting.

Builder[](#Builder)
-------------------

This object is passed to the `adapt` function of adapters. It contains various methods and properties that are useful for adapting the app.

    interface Builder {…}

    log: Logger;

Print messages to the console. `log.info` and `log.minor` are silent unless Vite’s `logLevel` is `info`.

    rimraf: (dir: string) => void;

Remove `dir` and all its contents.

    mkdirp: (dir: string) => void;

Create `dir` and any required parent directories.

    config: ValidatedConfig;

The fully resolved `svelte.config.js`.

    prerendered: Prerendered;

Information about prerendered pages and assets, if any.

    routes: RouteDefinition[];

An array of all routes (including prerendered)

    createEntries: (fn: (route: RouteDefinition) => AdapterEntry) => Promise<void>;

*   `fn` A function that groups a set of routes into an entry point
*   deprecated Use `builder.routes` instead

Create separate functions that map to one or more routes of your app.

    findServerAssets: (routes: RouteDefinition[]) => string[];

Find all the assets imported by server files belonging to `routes`

    generateFallback: (dest: string) => Promise<void>;

Generate a fallback page for a static webserver to use when no route is matched. Useful for single-page apps.

    generateEnvModule: () => void;

Generate a module exposing build-time environment variables as `$env/dynamic/public`.

    generateManifest: (opts: { relativePath: string; routes?: RouteDefinition[] }) => string;

*   `opts` a relative path to the base directory of the app and optionally in which format (esm or cjs) the manifest should be generated

Generate a server-side manifest to initialise the SvelteKit [server](/docs/kit/@sveltejs-kit#Server) with.

    getBuildDirectory: (name: string) => string;

*   `name` path to the file, relative to the build directory

Resolve a path to the `name` directory inside `outDir`, e.g. `/path/to/.svelte-kit/my-adapter`.

    getClientDirectory: () => string;

Get the fully resolved path to the directory containing client-side assets, including the contents of your `static` directory.

    getServerDirectory: () => string;

Get the fully resolved path to the directory containing server-side code.

    getAppPath: () => string;

Get the application path including any configured `base` path, e.g. `my-base-path/_app`.

    writeClient: (dest: string) => string[];

*   `dest` the destination folder
*   returns an array of files written to `dest`

Write client assets to `dest`.

    writePrerendered: (dest: string) => string[];

*   `dest` the destination folder
*   returns an array of files written to `dest`

Write prerendered files to `dest`.

    writeServer: (dest: string) => string[];

*   `dest` the destination folder
*   returns an array of files written to `dest`

Write server-side code to `dest`.

    copy: (
    	from: string,
    	to: string,
    	opts?: {
    		filter?(basename: string): boolean;
    		replace?: Record<string, string>;
    	}
    ) => string[];

*   `from` the source file or directory
*   `to` the destination file or directory
*   `opts.filter` a function to determine whether a file or directory should be copied
*   `opts.replace` a map of strings to replace
*   returns an array of files that were copied

Copy a file or directory.

    compress: (directory: string) => Promise<void>;

*   `directory` The directory containing the files to be compressed

Compress files in `directory` with gzip and brotli, where appropriate. Generates `.gz` and `.br` files alongside the originals.

ClientInit[](#ClientInit)
-------------------------

> Available since 2.10.0

The [`init`](/docs/kit/hooks#Shared-hooks-init) will be invoked once the app starts in the browser

    type ClientInit = () => MaybePromise<void>;

Config[](#Config)
-----------------

See the [configuration reference](/docs/kit/configuration) for details.

Cookies[](#Cookies)
-------------------

    interface Cookies {…}

    get: (name: string, opts?: import('cookie').CookieParseOptions) => string | undefined;

*   `name` the name of the cookie
*   `opts` the options, passed directly to `cookie.parse`. See documentation [here](https://github.com/jshttp/cookie#cookieparsestr-options)

Gets a cookie that was previously set with `cookies.set`, or from the request headers.

    getAll: (opts?: import('cookie').CookieParseOptions) => Array<{ name: string; value: string }>;

*   `opts` the options, passed directly to `cookie.parse`. See documentation [here](https://github.com/jshttp/cookie#cookieparsestr-options)

Gets all cookies that were previously set with `cookies.set`, or from the request headers.

    set: (
    	name: string,
    	value: string,
    	opts: import('cookie').CookieSerializeOptions & { path: string }
    ) => void;

*   `name` the name of the cookie
*   `value` the cookie value
*   `opts` the options, passed directly to `cookie.serialize`. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)

Sets a cookie. This will add a `set-cookie` header to the response, but also make the cookie available via `cookies.get` or `cookies.getAll` during the current request.

The `httpOnly` and `secure` options are `true` by default (except on [http://localhost](http://localhost), where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`.

You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children

    delete: (name: string, opts: import('cookie').CookieSerializeOptions & { path: string }) => void;

*   `name` the name of the cookie
*   `opts` the options, passed directly to `cookie.serialize`. The `path` must match the path of the cookie you want to delete. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)

Deletes a cookie by setting its value to an empty string and setting the expiry date in the past.

You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children

    serialize: (
    	name: string,
    	value: string,
    	opts: import('cookie').CookieSerializeOptions & { path: string }
    ) => string;

*   `name` the name of the cookie
*   `value` the cookie value
*   `opts` the options, passed directly to `cookie.serialize`. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)

Serialize a cookie name-value pair into a `Set-Cookie` header string, but don’t apply it to the response.

The `httpOnly` and `secure` options are `true` by default (except on [http://localhost](http://localhost), where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`.

You must specify a `path` for the cookie. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app. You can use relative paths, or set `path: ''` to make the cookie only available on the current path and its children

Emulator[](#Emulator)
---------------------

A collection of functions that influence the environment during dev, build and prerendering

    interface Emulator {…}

    platform?(details: { config: any; prerender: PrerenderOption }): MaybePromise<App.Platform>;

A function that is called with the current route `config` and `prerender` option and returns an `App.Platform` object

Handle[](#Handle)
-----------------

The [`handle`](/docs/kit/hooks#Server-hooks-handle) hook runs every time the SvelteKit server receives a [request](/docs/kit/web-standards#Fetch-APIs-Request) and determines the [response](/docs/kit/web-standards#Fetch-APIs-Response). It receives an `event` object representing the request and a function called `resolve`, which renders the route and generates a `Response`. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).

    type Handle = (input: {
    	event: RequestEvent;
    	resolve: (
    		event: RequestEvent,
    		opts?: ResolveOptions
    	) => MaybePromise<Response>;
    }) => MaybePromise<Response>;

HandleClientError[](#HandleClientError)
---------------------------------------

The client-side [`handleError`](/docs/kit/hooks#Shared-hooks-handleError) hook runs when an unexpected error is thrown while navigating.

If an unexpected error is thrown during loading or the following render, this function will be called with the error and the event. Make sure that this function _never_ throws an error.

    type HandleClientError = (input: {
    	error: unknown;
    	event: NavigationEvent;
    	status: number;
    	message: string;
    }) => MaybePromise<void | App.Error>;

HandleFetch[](#HandleFetch)
---------------------------

The [`handleFetch`](/docs/kit/hooks#Server-hooks-handleFetch) hook allows you to modify (or replace) the result of an [`event.fetch`](/docs/kit/load#Making-fetch-requests) call that runs on the server (or during prerendering) inside an endpoint, `load`, `action`, `handle`, `handleError` or `reroute`.

    type HandleFetch = (input: {
    	event: RequestEvent;
    	request: Request;
    	fetch: typeof fetch;
    }) => MaybePromise<Response>;

HandleServerError[](#HandleServerError)
---------------------------------------

The server-side [`handleError`](/docs/kit/hooks#Shared-hooks-handleError) hook runs when an unexpected error is thrown while responding to a request.

If an unexpected error is thrown during loading or rendering, this function will be called with the error and the event. Make sure that this function _never_ throws an error.

    type HandleServerError = (input: {
    	error: unknown;
    	event: RequestEvent;
    	status: number;
    	message: string;
    }) => MaybePromise<void | App.Error>;

HttpError[](#HttpError)
-----------------------

The object returned by the [`error`](/docs/kit/@sveltejs-kit#error) function.

    interface HttpError {…}

    status: number;

The [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses), in the range 400-599.

    body: App.Error;

The content of the error.

KitConfig[](#KitConfig)
-----------------------

See the [configuration reference](/docs/kit/configuration) for details.

LessThan[](#LessThan)
---------------------

    type LessThan<
    	TNumber extends number,
    	TArray extends any[] = []
    > = TNumber extends TArray['length']
    	? TArray[number]
    	: LessThan<TNumber, [...TArray, TArray['length']]>;

Load[](#Load)
-------------

The generic form of `PageLoad` and `LayoutLoad`. You should import those from `./$types` (see [generated types](/docs/kit/types#Generated-types)) rather than using `Load` directly.

    type Load<
    	Params extends Partial<Record<string, string>> = Partial<
    		Record<string, string>
    	>,
    	InputData extends Record<string, unknown> | null = Record<
    		string,
    		any
    	> | null,
    	ParentData extends Record<string, unknown> = Record<
    		string,
    		any
    	>,
    	OutputData extends Record<
    		string,
    		unknown
    	> | void = Record<string, any> | void,
    	RouteId extends string | null = string | null
    > = (
    	event: LoadEvent<Params, InputData, ParentData, RouteId>
    ) => MaybePromise<OutputData>;

LoadEvent[](#LoadEvent)
-----------------------

The generic form of `PageLoadEvent` and `LayoutLoadEvent`. You should import those from `./$types` (see [generated types](/docs/kit/types#Generated-types)) rather than using `LoadEvent` directly.

    interface LoadEvent<
    	Params extends Partial<Record<string, string>> = Partial<
    		Record<string, string>
    	>,
    	Data extends Record<string, unknown> | null = Record<
    		string,
    		any
    	> | null,
    	ParentData extends Record<string, unknown> = Record<
    		string,
    		any
    	>,
    	RouteId extends string | null = string | null
    > extends NavigationEvent<Params, RouteId> {…}

    fetch: typeof fetch;

`fetch` is equivalent to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch), with a few additional features:

*   It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request.
*   It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context).
*   Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
*   During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text` and `json` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](/docs/kit/hooks#Server-hooks-handle)
*   During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.

You can learn more about making credentialed requests with cookies [here](/docs/kit/load#Cookies)

    data: Data;

Contains the data returned by the route’s server `load` function (in `+layout.server.js` or `+page.server.js`), if any.

    setHeaders: (headers: Record<string, string>) => void;

If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:

src/routes/blog/+page

    export async function function load({ fetch, setHeaders }: {
        fetch: any;
        setHeaders: any;
    }): Promise<any>load({ fetch, setHeaders }) {
    
    	const const url: "https://cms.example.com/articles.json"url = `https://cms.example.com/articles.json`;
    	const const response: anyresponse = await fetch: anyfetch(const url: "https://cms.example.com/articles.json"url);
    
    	setHeaders: anysetHeaders({
    		age: anyage: const response: anyresponse.headers.get('age'),
    		'cache-control': const response: anyresponse.headers.get('cache-control')
    	});
    
    	return const response: anyresponse.json();
    }

Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once.

You cannot add a `set-cookie` header with `setHeaders` — use the [`cookies`](/docs/kit/@sveltejs-kit#Cookies) API in a server-only `load` function instead.

`setHeaders` has no effect when a `load` function runs in the browser.

    parent: () => Promise<ParentData>;

`await parent()` returns data from parent `+layout.js` `load` functions. Implicitly, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will return and forward data from parent `+layout.server.js` files.

Be careful not to introduce accidental waterfalls when using `await parent()`. If for example you only want to merge parent data into the returned output, call it _after_ fetching your other data.

    depends: (...deps: Array<`${string}:${string}`>) => void;

This function declares that the `load` function has a _dependency_ on one or more URLs or custom identifiers, which can subsequently be used with [`invalidate()`](/docs/kit/$app-navigation#invalidate) to cause `load` to rerun.

Most of the time you won’t need this, as `fetch` calls `depends` on your behalf — it’s only necessary if you’re using a custom API client that bypasses `fetch`.

URLs can be absolute or relative to the page being loaded, and must be [encoded](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).

Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the [URI specification](https://www.rfc-editor.org/rfc/rfc3986.html).

The following example shows how to use `depends` to register a dependency on a custom identifier, which is `invalidate`d after a button click, making the `load` function rerun.

src/routes/+page

    let let count: numbercount = 0;
    export async function function load({ depends }: {
        depends: any;
    }): Promise<{
        count: number;
    }>load({ depends }) {
    	depends: anydepends('increase:count');
    
    	return { count: numbercount: let count: numbercount++ };
    }

src/routes/+page

    <script>
    	import { invalidate } from '$app/navigation';
    
    	let { data } = $props();
    
    	const increase = async () => {
    		await invalidate('increase:count');
    	}
    </script>
    
    <p>{data.count}<p>
    <button on:click={increase}>Increase Count</button>

    untrack: <T>(fn: () => T) => T;

Use this function to opt out of dependency tracking for everything that is synchronously called within the callback. Example:

src/routes/+page.server

    export async function function load({ untrack, url }: {
        untrack: any;
        url: any;
    }): Promise<{
        message: string;
    } | undefined>load({ untrack, url }) {
    
    	// Untrack url.pathname so that path changes don't trigger a rerun
    	if (untrack: anyuntrack(() => url: anyurl.pathname === '/')) {
    		return { message: stringmessage: 'Welcome!' };
    	}
    }

LoadProperties[](#LoadProperties)
---------------------------------

    type LoadProperties<
    	input extends Record<string, any> | void
    > = input extends void
    	? undefined // needs to be undefined, because void will break intellisense
    	: input extends Record<string, any>
    		? input
    		: unknown;

Navigation[](#Navigation)
-------------------------

    interface Navigation {…}

    from: NavigationTarget | null;

Where navigation was triggered from

    to: NavigationTarget | null;

Where navigation is going to/has gone to

    type: Exclude<NavigationType, 'enter'>;

The type of navigation:

*   `form`: The user submitted a `<form>`
*   `leave`: The app is being left either because the tab is being closed or a navigation to a different document is occurring
*   `link`: Navigation was triggered by a link click
*   `goto`: Navigation was triggered by a `goto(...)` call or a redirect
*   `popstate`: Navigation was triggered by back/forward navigation

    willUnload: boolean;

Whether or not the navigation will result in the page being unloaded (i.e. not a client-side navigation)

    delta?: number;

In case of a history back/forward navigation, the number of steps to go back/forward

    complete: Promise<void>;

A promise that resolves once the navigation is complete, and rejects if the navigation fails or is aborted. In the case of a `willUnload` navigation, the promise will never resolve

NavigationEvent[](#NavigationEvent)
-----------------------------------

    interface NavigationEvent<
    	Params extends Partial<Record<string, string>> = Partial<
    		Record<string, string>
    	>,
    	RouteId extends string | null = string | null
    > {…}

    params: Params;

The parameters of the current page - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object

    route: {…}

Info about the current route

    id: RouteId;

The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`. It is `null` when no route is matched.

    url: URL;

The URL of the current page

NavigationTarget[](#NavigationTarget)
-------------------------------------

Information about the target of a specific navigation.

    interface NavigationTarget {…}

    params: Record<string, string> | null;

Parameters of the target page - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object. Is `null` if the target is not part of the SvelteKit app (could not be resolved to a route).

    route: {…}

Info about the target route

    id: string | null;

The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`. It is `null` when no route is matched.

    url: URL;

The URL that is navigated to

NavigationType[](#NavigationType)
---------------------------------

*   `enter`: The app has hydrated/started
*   `form`: The user submitted a `<form>` with a GET method
*   `leave`: The user is leaving the app by closing the tab or using the back/forward buttons to go to a different document
*   `link`: Navigation was triggered by a link click
*   `goto`: Navigation was triggered by a `goto(...)` call or a redirect
*   `popstate`: Navigation was triggered by back/forward navigation

    type NavigationType =
    	| 'enter'
    	| 'form'
    	| 'leave'
    	| 'link'
    	| 'goto'
    	| 'popstate';

NumericRange[](#NumericRange)
-----------------------------

    type NumericRange<
    	TStart extends number,
    	TEnd extends number
    > = Exclude<TEnd | LessThan<TEnd>, LessThan<TStart>>;

OnNavigate[](#OnNavigate)
-------------------------

The argument passed to [`onNavigate`](/docs/kit/$app-navigation#onNavigate) callbacks.

    interface OnNavigate extends Navigation {…}

    type: Exclude<NavigationType, 'enter' | 'leave'>;

The type of navigation:

*   `form`: The user submitted a `<form>`
*   `link`: Navigation was triggered by a link click
*   `goto`: Navigation was triggered by a `goto(...)` call or a redirect
*   `popstate`: Navigation was triggered by back/forward navigation

    willUnload: false;

Since `onNavigate` callbacks are called immediately before a client-side navigation, they will never be called with a navigation that unloads the page.

Page[](#Page)
-------------

The shape of the [`page`](/docs/kit/$app-state#page) reactive object and the [`$page`](/docs/kit/$app-stores) store.

    interface Page<
    	Params extends Record<string, string> = Record<
    		string,
    		string
    	>,
    	RouteId extends string | null = string | null
    > {…}

    url: URL;

The URL of the current page.

    params: Params;

The parameters of the current page - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object.

    route: {…}

Info about the current route.

    id: RouteId;

The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`. It is `null` when no route is matched.

    status: number;

HTTP status code of the current page.

    error: App.Error | null;

The error object of the current page, if any. Filled from the `handleError` hooks.

    data: App.PageData & Record<string, any>;

The merged result of all data from all `load` functions on the current page. You can type a common denominator through `App.PageData`.

    state: App.PageState;

The page state, which can be manipulated using the [`pushState`](/docs/kit/$app-navigation#pushState) and [`replaceState`](/docs/kit/$app-navigation#replaceState) functions from `$app/navigation`.

    form: any;

Filled only after a form submission. See [form actions](/docs/kit/form-actions) for more info.

ParamMatcher[](#ParamMatcher)
-----------------------------

The shape of a param matcher. See [matching](/docs/kit/advanced-routing#Matching) for more info.

    type ParamMatcher = (param: string) => boolean;

PrerenderOption[](#PrerenderOption)
-----------------------------------

    type PrerenderOption = boolean | 'auto';

Redirect[](#Redirect)
---------------------

The object returned by the [`redirect`](/docs/kit/@sveltejs-kit#redirect) function.

    interface Redirect {…}

    status: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308;

The [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages), in the range 300-308.

    location: string;

The location to redirect to.

RequestEvent[](#RequestEvent)
-----------------------------

    interface RequestEvent<
    	Params extends Partial<Record<string, string>> = Partial<
    		Record<string, string>
    	>,
    	RouteId extends string | null = string | null
    > {…}

    cookies: Cookies;

Get or set cookies related to the current request

    fetch: typeof fetch;

`fetch` is equivalent to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch), with a few additional features:

*   It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request.
*   It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context).
*   Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
*   During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text` and `json` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](/docs/kit/hooks#Server-hooks-handle)
*   During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.

You can learn more about making credentialed requests with cookies [here](/docs/kit/load#Cookies).

    getClientAddress: () => string;

The client’s IP address, set by the adapter.

    locals: App.Locals;

Contains custom data that was added to the request within the [`server handle hook`](/docs/kit/hooks#Server-hooks-handle).

    params: Params;

The parameters of the current route - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object.

    platform: Readonly<App.Platform> | undefined;

Additional data made available through the adapter.

    request: Request;

The original request object.

    route: {…}

Info about the current route.

    id: RouteId;

The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`. It is `null` when no route is matched.

    setHeaders: (headers: Record<string, string>) => void;

If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:

src/routes/blog/+page

    export async function function load({ fetch, setHeaders }: {
        fetch: any;
        setHeaders: any;
    }): Promise<any>load({ fetch, setHeaders }) {
    
    	const const url: "https://cms.example.com/articles.json"url = `https://cms.example.com/articles.json`;
    	const const response: anyresponse = await fetch: anyfetch(const url: "https://cms.example.com/articles.json"url);
    
    	setHeaders: anysetHeaders({
    		age: anyage: const response: anyresponse.headers.get('age'),
    		'cache-control': const response: anyresponse.headers.get('cache-control')
    	});
    
    	return const response: anyresponse.json();
    }

Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once.

You cannot add a `set-cookie` header with `setHeaders` — use the [`cookies`](/docs/kit/@sveltejs-kit#Cookies) API instead.

    url: URL;

The requested URL.

    isDataRequest: boolean;

`true` if the request comes from the client asking for `+page/layout.server.js` data. The `url` property will be stripped of the internal information related to the data request in this case. Use this property instead if the distinction is important to you.

    isSubRequest: boolean;

`true` for `+server.js` calls coming from SvelteKit without the overhead of actually making an HTTP request. This happens when you make same-origin `fetch` requests on the server.

RequestHandler[](#RequestHandler)
---------------------------------

A `(event: RequestEvent) => Response` function exported from a `+server.js` file that corresponds to an HTTP verb (`GET`, `PUT`, `PATCH`, etc) and handles requests with that method.

It receives `Params` as the first generic argument, which you can skip by using [generated types](/docs/kit/types#Generated-types) instead.

    type RequestHandler<
    	Params extends Partial<Record<string, string>> = Partial<
    		Record<string, string>
    	>,
    	RouteId extends string | null = string | null
    > = (
    	event: RequestEvent<Params, RouteId>
    ) => MaybePromise<Response>;

Reroute[](#Reroute)
-------------------

> Available since 2.3.0

The [`reroute`](/docs/kit/hooks#Universal-hooks-reroute) hook allows you to modify the URL before it is used to determine which route to render.

    type Reroute = (event: {
    	url: URL;
    	fetch: typeof fetch;
    }) => MaybePromise<void | string>;

ResolveOptions[](#ResolveOptions)
---------------------------------

    interface ResolveOptions {…}

    transformPageChunk?: (input: { html: string; done: boolean }) => MaybePromise<string | undefined>;

*   `input` the html chunk and the info if this is the last chunk

Applies custom transforms to HTML. If `done` is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML (they could include an element’s opening tag but not its closing tag, for example) but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components.

    filterSerializedResponseHeaders?: (name: string, value: string) => boolean;

*   `name` header name
*   `value` header value

Determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`. By default, none will be included.

    preload?: (input: { type: 'font' | 'css' | 'js' | 'asset'; path: string }) => boolean;

*   `input` the type of the file and its path

Determines what should be added to the `<head>` tag to preload it. By default, `js` and `css` files will be preloaded.

RouteDefinition[](#RouteDefinition)
-----------------------------------

    interface RouteDefinition<Config = any> {…}

    id: string;

    api: {
    	methods: Array<HttpMethod | '*'>;
    };

    page: {
    	methods: Array<Extract<HttpMethod, 'GET' | 'POST'>>;
    };

    pattern: RegExp;

    prerender: PrerenderOption;

    segments: RouteSegment[];

    methods: Array<HttpMethod | '*'>;

    config: Config;

SSRManifest[](#SSRManifest)
---------------------------

    interface SSRManifest {…}

    appDir: string;

    appPath: string;

    assets: Set<string>;

Static files from `kit.config.files.assets` and the service worker (if any).

    mimeTypes: Record<string, string>;

    _: {…}

private fields

    client: NonNullable<BuildData['client']>;

    nodes: SSRNodeLoader[];

    routes: SSRRoute[];

    prerendered_routes: Set<string>;

    matchers: () => Promise<Record<string, ParamMatcher>>;

    server_assets: Record<string, number>;

A `[file]: size` map of all assets imported by server code.

ServerInit[](#ServerInit)
-------------------------

> Available since 2.10.0

The [`init`](/docs/kit/hooks#Shared-hooks-init) will be invoked before the server responds to its first request

    type ServerInit = () => MaybePromise<void>;

ServerInitOptions[](#ServerInitOptions)
---------------------------------------

    interface ServerInitOptions {…}

    env: Record<string, string>;

A map of environment variables.

    read?: (file: string) => ReadableStream;

A function that turns an asset filename into a `ReadableStream`. Required for the `read` export from `$app/server` to work.

ServerLoad[](#ServerLoad)
-------------------------

The generic form of `PageServerLoad` and `LayoutServerLoad`. You should import those from `./$types` (see [generated types](/docs/kit/types#Generated-types)) rather than using `ServerLoad` directly.

    type ServerLoad<
    	Params extends Partial<Record<string, string>> = Partial<
    		Record<string, string>
    	>,
    	ParentData extends Record<string, any> = Record<
    		string,
    		any
    	>,
    	OutputData extends Record<string, any> | void = Record<
    		string,
    		any
    	> | void,
    	RouteId extends string | null = string | null
    > = (
    	event: ServerLoadEvent<Params, ParentData, RouteId>
    ) => MaybePromise<OutputData>;

ServerLoadEvent[](#ServerLoadEvent)
-----------------------------------

    interface ServerLoadEvent<
    	Params extends Partial<Record<string, string>> = Partial<
    		Record<string, string>
    	>,
    	ParentData extends Record<string, any> = Record<
    		string,
    		any
    	>,
    	RouteId extends string | null = string | null
    > extends RequestEvent<Params, RouteId> {…}

    parent: () => Promise<ParentData>;

`await parent()` returns data from parent `+layout.server.js` `load` functions.

Be careful not to introduce accidental waterfalls when using `await parent()`. If for example you only want to merge parent data into the returned output, call it _after_ fetching your other data.

    depends: (...deps: string[]) => void;

This function declares that the `load` function has a _dependency_ on one or more URLs or custom identifiers, which can subsequently be used with [`invalidate()`](/docs/kit/$app-navigation#invalidate) to cause `load` to rerun.

Most of the time you won’t need this, as `fetch` calls `depends` on your behalf — it’s only necessary if you’re using a custom API client that bypasses `fetch`.

URLs can be absolute or relative to the page being loaded, and must be [encoded](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).

Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the [URI specification](https://www.rfc-editor.org/rfc/rfc3986.html).

The following example shows how to use `depends` to register a dependency on a custom identifier, which is `invalidate`d after a button click, making the `load` function rerun.

src/routes/+page

    let let count: numbercount = 0;
    export async function function load({ depends }: {
        depends: any;
    }): Promise<{
        count: number;
    }>load({ depends }) {
    	depends: anydepends('increase:count');
    
    	return { count: numbercount: let count: numbercount++ };
    }

src/routes/+page

    <script>
    	import { invalidate } from '$app/navigation';
    
    	let { data } = $props();
    
    	const increase = async () => {
    		await invalidate('increase:count');
    	}
    </script>
    
    <p>{data.count}<p>
    <button on:click={increase}>Increase Count</button>

    untrack: <T>(fn: () => T) => T;

Use this function to opt out of dependency tracking for everything that is synchronously called within the callback. Example:

src/routes/+page

    export async function function load({ untrack, url }: {
        untrack: any;
        url: any;
    }): Promise<{
        message: string;
    } | undefined>load({ untrack, url }) {
    
    	// Untrack url.pathname so that path changes don't trigger a rerun
    	if (untrack: anyuntrack(() => url: anyurl.pathname === '/')) {
    		return { message: stringmessage: 'Welcome!' };
    	}
    }

Snapshot[](#Snapshot)
---------------------

The type of `export const snapshot` exported from a page or layout component.

    interface Snapshot<T = any> {…}

    capture: () => T;

    restore: (snapshot: T) => void;

SubmitFunction[](#SubmitFunction)
---------------------------------

    type SubmitFunction<
    	Success extends
    		| Record<string, unknown>
    		| undefined = Record<string, any>,
    	Failure extends
    		| Record<string, unknown>
    		| undefined = Record<string, any>
    > = (input: {
    	action: URL;
    	formData: FormData;
    	formElement: HTMLFormElement;
    	controller: AbortController;
    	submitter: HTMLElement | null;
    	cancel: () => void;
    }) => MaybePromise<
    	| void
    	| ((opts: {
    			formData: FormData;
    			formElement: HTMLFormElement;
    			action: URL;
    			result: ActionResult<Success, Failure>;
    			/**
    			 * Call this to get the default behavior of a form submission response.
    			 * @param options Set `reset: false` if you don't want the `<form>` values to be reset after a successful submission.
    			 * @param invalidateAll Set `invalidateAll: false` if you don't want the action to call `invalidateAll` after submission.
    			 */
    			update: (options?: {
    				reset?: boolean;
    				invalidateAll?: boolean;
    			}) => Promise<void>;
    	  }) => MaybePromise<void>)
    >;

Transport[](#Transport)
-----------------------

> Available since 2.11.0

The [`transport`](/docs/kit/hooks#Universal-hooks-transport) hook allows you to transport custom types across the server/client boundary.

Each transporter has a pair of `encode` and `decode` functions. On the server, `encode` determines whether a value is an instance of the custom type and, if so, returns a non-falsy encoding of the value which can be an object or an array (or `false` otherwise).

In the browser, `decode` turns the encoding back into an instance of the custom type.

    import type { type Transport = {
        [x: string]: Transporter<any, any>;
    }The transport hook allows you to transport custom types across the server/client boundary.
    Each transporter has a pair of encode and decode functions. On the server, encode determines whether a value is an instance of the custom type and, if so, returns a non-falsy encoding of the value which can be an object or an array (or false otherwise).
    In the browser, decode turns the encoding back into an instance of the custom type.
    import type { Transport } from '@sveltejs/kit';
    
    declare class MyCustomType {
    	data: any
    }
    
    // hooks.js
    export const transport: Transport = {
    	MyCustomType: {
    		encode: (value) => value instanceof MyCustomType &#x26;&#x26; [value.data],
    		decode: ([data]) => new MyCustomType(data)
    	}
    };@since2.11.0Transport } from '@sveltejs/kit';
    
    declare class class MyCustomTypeMyCustomType {
    	MyCustomType.data: anydata: any
    }
    
    // hooks.js
    export const const transport: Transporttransport: type Transport = {
        [x: string]: Transporter<any, any>;
    }The transport hook allows you to transport custom types across the server/client boundary.
    Each transporter has a pair of encode and decode functions. On the server, encode determines whether a value is an instance of the custom type and, if so, returns a non-falsy encoding of the value which can be an object or an array (or false otherwise).
    In the browser, decode turns the encoding back into an instance of the custom type.
    import type { Transport } from '@sveltejs/kit';
    
    declare class MyCustomType {
    	data: any
    }
    
    // hooks.js
    export const transport: Transport = {
    	MyCustomType: {
    		encode: (value) => value instanceof MyCustomType &#x26;&#x26; [value.data],
    		decode: ([data]) => new MyCustomType(data)
    	}
    };@since2.11.0Transport = {
    	type MyCustomType: {
        encode: (value: any) => false | any[];
        decode: ([data]: any) => MyCustomType;
    }MyCustomType: {
    		Transporter<any, any>.encode: (value: any) => anyencode: (value: anyvalue) => value: anyvalue instanceof class MyCustomTypeMyCustomType && [value: MyCustomTypevalue.MyCustomType.data: anydata],
    		Transporter<any, any>.decode: (data: any) => anydecode: ([data: anydata]) => new constructor MyCustomType(): MyCustomTypeMyCustomType(data: anydata)
    	}
    };

    type Transport = Record<string, Transporter>;

Transporter[](#Transporter)
---------------------------

A member of the [`transport`](/docs/kit/hooks#Universal-hooks-transport) hook.

    interface Transporter<
    	T = any,
    	U = Exclude<
    		any,
    		false | 0 | '' | null | undefined | typeof NaN
    	>
    > {…}

    encode: (value: T) => false | U;

    decode: (data: U) => T;

Private types[](#Private-types)
-------------------------------

The following are referenced by the public types documented above, but cannot be imported directly:

AdapterEntry[](#AdapterEntry)
-----------------------------

    interface AdapterEntry {…}

    id: string;

A string that uniquely identifies an HTTP service (e.g. serverless function) and is used for deduplication. For example, `/foo/a-[b]` and `/foo/[c]` are different routes, but would both be represented in a Netlify \_redirects file as `/foo/:param`, so they share an ID

    filter(route: RouteDefinition): boolean;

A function that compares the candidate route with the current route to determine if it should be grouped with the current route.

Use cases:

*   Fallback pages: `/foo/[c]` is a fallback for `/foo/a-[b]`, and `/[...catchall]` is a fallback for all routes
*   Grouping routes that share a common `config`: `/foo` should be deployed to the edge, `/bar` and `/baz` should be deployed to a serverless function

    complete(entry: { generateManifest(opts: { relativePath: string }): string }): MaybePromise<void>;

A function that is invoked once the entry has been created. This is where you should write the function to the filesystem and generate redirect manifests.

Csp[](#Csp)
-----------

    namespace Csp {
    	type ActionSource = 'strict-dynamic' | 'report-sample';
    	type BaseSource =
    		| 'self'
    		| 'unsafe-eval'
    		| 'unsafe-hashes'
    		| 'unsafe-inline'
    		| 'wasm-unsafe-eval'
    		| 'none';
    	type CryptoSource =
    		`${'nonce' | 'sha256' | 'sha384' | 'sha512'}-${string}`;
    	type FrameSource =
    		| HostSource
    		| SchemeSource
    		| 'self'
    		| 'none';
    	type HostNameScheme = `${string}.${string}` | 'localhost';
    	type HostSource =
    		`${HostProtocolSchemes}${HostNameScheme}${PortScheme}`;
    	type HostProtocolSchemes = `${string}://` | '';
    	type HttpDelineator = '/' | '?' | '#' | '\\';
    	type PortScheme = `:${number}` | '' | ':*';
    	type SchemeSource =
    		| 'http:'
    		| 'https:'
    		| 'data:'
    		| 'mediastream:'
    		| 'blob:'
    		| 'filesystem:';
    	type Source =
    		| HostSource
    		| SchemeSource
    		| CryptoSource
    		| BaseSource;
    	type Sources = Source[];
    }

CspDirectives[](#CspDirectives)
-------------------------------

    interface CspDirectives {…}

    'child-src'?: Csp.Sources;

    'default-src'?: Array<Csp.Source | Csp.ActionSource>;

    'frame-src'?: Csp.Sources;

    'worker-src'?: Csp.Sources;

    'connect-src'?: Csp.Sources;

    'font-src'?: Csp.Sources;

    'img-src'?: Csp.Sources;

    'manifest-src'?: Csp.Sources;

    'media-src'?: Csp.Sources;

    'object-src'?: Csp.Sources;

    'prefetch-src'?: Csp.Sources;

    'script-src'?: Array<Csp.Source | Csp.ActionSource>;

    'script-src-elem'?: Csp.Sources;

    'script-src-attr'?: Csp.Sources;

    'style-src'?: Array<Csp.Source | Csp.ActionSource>;

    'style-src-elem'?: Csp.Sources;

    'style-src-attr'?: Csp.Sources;

    'base-uri'?: Array<Csp.Source | Csp.ActionSource>;

    sandbox?: Array<
    | 'allow-downloads-without-user-activation'
    | 'allow-forms'
    | 'allow-modals'
    | 'allow-orientation-lock'
    | 'allow-pointer-lock'
    | 'allow-popups'
    | 'allow-popups-to-escape-sandbox'
    | 'allow-presentation'
    | 'allow-same-origin'
    | 'allow-scripts'
    | 'allow-storage-access-by-user-activation'
    | 'allow-top-navigation'
    | 'allow-top-navigation-by-user-activation'
    >;

    'form-action'?: Array<Csp.Source | Csp.ActionSource>;

    'frame-ancestors'?: Array<Csp.HostSource | Csp.SchemeSource | Csp.FrameSource>;

    'navigate-to'?: Array<Csp.Source | Csp.ActionSource>;

    'report-uri'?: string[];

    'report-to'?: string[];

    'require-trusted-types-for'?: Array<'script'>;

    'trusted-types'?: Array<'none' | 'allow-duplicates' | '*' | string>;

    'upgrade-insecure-requests'?: boolean;

    'require-sri-for'?: Array<'script' | 'style' | 'script style'>;

*   deprecated

    'block-all-mixed-content'?: boolean;

*   deprecated

    'plugin-types'?: Array<`${string}/${string}` | 'none'>;

*   deprecated

    referrer?: Array<
    | 'no-referrer'
    | 'no-referrer-when-downgrade'
    | 'origin'
    | 'origin-when-cross-origin'
    | 'same-origin'
    | 'strict-origin'
    | 'strict-origin-when-cross-origin'
    | 'unsafe-url'
    | 'none'
    >;

*   deprecated

HttpMethod[](#HttpMethod)
-------------------------

    type HttpMethod =
    	| 'GET'
    	| 'HEAD'
    	| 'POST'
    	| 'PUT'
    	| 'DELETE'
    	| 'PATCH'
    	| 'OPTIONS';

Logger[](#Logger)
-----------------

    interface Logger {…}

    (msg: string): void;

    success(msg: string): void;

    error(msg: string): void;

    warn(msg: string): void;

    minor(msg: string): void;

    info(msg: string): void;

MaybePromise[](#MaybePromise)
-----------------------------

    type MaybePromise<T> = T | Promise<T>;

PrerenderEntryGeneratorMismatchHandler[](#PrerenderEntryGeneratorMismatchHandler)
---------------------------------------------------------------------------------

    interface PrerenderEntryGeneratorMismatchHandler {…}

    (details: { generatedFromId: string; entry: string; matchedId: string; message: string }): void;

PrerenderEntryGeneratorMismatchHandlerValue[](#PrerenderEntryGeneratorMismatchHandlerValue)
-------------------------------------------------------------------------------------------

    type PrerenderEntryGeneratorMismatchHandlerValue =
    	| 'fail'
    	| 'warn'
    	| 'ignore'
    	| PrerenderEntryGeneratorMismatchHandler;

PrerenderHttpErrorHandler[](#PrerenderHttpErrorHandler)
-------------------------------------------------------

    interface PrerenderHttpErrorHandler {…}

    (details: {
    status: number;
    path: string;
    referrer: string | null;
    referenceType: 'linked' | 'fetched';
    message: string;
    }): void;

PrerenderHttpErrorHandlerValue[](#PrerenderHttpErrorHandlerValue)
-----------------------------------------------------------------

    type PrerenderHttpErrorHandlerValue =
    	| 'fail'
    	| 'warn'
    	| 'ignore'
    	| PrerenderHttpErrorHandler;

PrerenderMap[](#PrerenderMap)
-----------------------------

    type PrerenderMap = Map<string, PrerenderOption>;

PrerenderMissingIdHandler[](#PrerenderMissingIdHandler)
-------------------------------------------------------

    interface PrerenderMissingIdHandler {…}

    (details: { path: string; id: string; referrers: string[]; message: string }): void;

PrerenderMissingIdHandlerValue[](#PrerenderMissingIdHandlerValue)
-----------------------------------------------------------------

    type PrerenderMissingIdHandlerValue =
    	| 'fail'
    	| 'warn'
    	| 'ignore'
    	| PrerenderMissingIdHandler;

PrerenderOption[](#PrerenderOption)
-----------------------------------

    type PrerenderOption = boolean | 'auto';

Prerendered[](#Prerendered)
---------------------------

    interface Prerendered {…}

    pages: Map<
    string,
    {
    	/** The location of the .html file relative to the output directory */
    	file: string;
    }
    >;

A map of `path` to `{ file }` objects, where a path like `/foo` corresponds to `foo.html` and a path like `/bar/` corresponds to `bar/index.html`.

    assets: Map<
    string,
    {
    	/** The MIME type of the asset */
    	type: string;
    }
    >;

A map of `path` to `{ type }` objects.

    redirects: Map<
    string,
    {
    	status: number;
    	location: string;
    }
    >;

A map of redirects encountered during prerendering.

    paths: string[];

An array of prerendered paths (without trailing slashes, regardless of the trailingSlash config)

RequestOptions[](#RequestOptions)
---------------------------------

    interface RequestOptions {…}

    getClientAddress(): string;

    platform?: App.Platform;

RouteSegment[](#RouteSegment)
-----------------------------

    interface RouteSegment {…}

    content: string;

    dynamic: boolean;

    rest: boolean;

TrailingSlash[](#TrailingSlash)
-------------------------------

    type TrailingSlash = 'never' | 'always' | 'ignore';

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/10-@sveltejs-kit.md) [llms.txt](/docs/kit/@sveltejs-kit/llms.txt)

previous next

[Glossary](/docs/kit/glossary) [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

@sveltejs/kit/hooks
===================

### On this page

*   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
*   [sequence](#sequence)

    import { function sequence(...handlers: import("@sveltejs/kit").Handle[]): import("@sveltejs/kit").HandleA helper function for sequencing multiple handle calls in a middleware-like manner.
    The behavior for the handle options is as follows:
    
    transformPageChunk is applied in reverse order and merged
    preload is applied in forward order, the first option “wins” and no preload options after it are called
    filterSerializedResponseHeaders behaves the same as preload
    
    src/hooks.serverimport { sequence } from '@sveltejs/kit/hooks';
    
    /// type: import('@sveltejs/kit').Handle
    async function first({ event, resolve }) {
    	console.log('first pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			// transforms are applied in reverse order
    			console.log('first transform');
    			return html;
    		},
    		preload: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('first preload');
    			return true;
    		}
    	});
    	console.log('first post-processing');
    	return result;
    }
    
    /// type: import('@sveltejs/kit').Handle
    async function second({ event, resolve }) {
    	console.log('second pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			console.log('second transform');
    			return html;
    		},
    		preload: () => {
    			console.log('second preload');
    			return true;
    		},
    		filterSerializedResponseHeaders: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('second filterSerializedResponseHeaders');
    			return true;
    		}
    	});
    	console.log('second post-processing');
    	return result;
    }
    
    export const handle = sequence(first, second);The example above would print:
    first pre-processing
    first preload
    second pre-processing
    second filterSerializedResponseHeaders
    second transform
    first transform
    second post-processing
    first post-processing@paramhandlers The chain of handle functionssequence } from '@sveltejs/kit/hooks';

sequence[](#sequence)
---------------------

A helper function for sequencing multiple `handle` calls in a middleware-like manner. The behavior for the `handle` options is as follows:

*   `transformPageChunk` is applied in reverse order and merged
*   `preload` is applied in forward order, the first option “wins” and no `preload` options after it are called
*   `filterSerializedResponseHeaders` behaves the same as `preload`

src/hooks.server

    import { function sequence(...handlers: import("@sveltejs/kit").Handle[]): import("@sveltejs/kit").HandleA helper function for sequencing multiple handle calls in a middleware-like manner.
    The behavior for the handle options is as follows:
    
    transformPageChunk is applied in reverse order and merged
    preload is applied in forward order, the first option “wins” and no preload options after it are called
    filterSerializedResponseHeaders behaves the same as preload
    
    src/hooks.serverimport { sequence } from '@sveltejs/kit/hooks';
    
    /// type: import('@sveltejs/kit').Handle
    async function first({ event, resolve }) {
    	console.log('first pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			// transforms are applied in reverse order
    			console.log('first transform');
    			return html;
    		},
    		preload: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('first preload');
    			return true;
    		}
    	});
    	console.log('first post-processing');
    	return result;
    }
    
    /// type: import('@sveltejs/kit').Handle
    async function second({ event, resolve }) {
    	console.log('second pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			console.log('second transform');
    			return html;
    		},
    		preload: () => {
    			console.log('second preload');
    			return true;
    		},
    		filterSerializedResponseHeaders: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('second filterSerializedResponseHeaders');
    			return true;
    		}
    	});
    	console.log('second post-processing');
    	return result;
    }
    
    export const handle = sequence(first, second);The example above would print:
    first pre-processing
    first preload
    second pre-processing
    second filterSerializedResponseHeaders
    second transform
    first transform
    second post-processing
    first post-processing@paramhandlers The chain of handle functionssequence } from '@sveltejs/kit/hooks';
    
    /** @type {import('@sveltejs/kit').Handle} */
    async function function first({ event, resolve }: {
        event: any;
        resolve: any;
    }): Promise<any>@type{import('@sveltejs/kit').Handle}first({ event: anyevent, resolve: anyresolve }) {
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('first pre-processing');
    	const const result: anyresult = await resolve: anyresolve(event: anyevent, {
    		transformPageChunk: ({ html }: {
        html: any;
    }) => anytransformPageChunk: ({ html: anyhtml }) => {
    			// transforms are applied in reverse order
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('first transform');
    			return html: anyhtml;
    		},
    		preload: () => booleanpreload: () => {
    			// this one wins as it's the first defined in the chain
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('first preload');
    			return true;
    		}
    	});
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('first post-processing');
    	return const result: anyresult;
    }
    
    /** @type {import('@sveltejs/kit').Handle} */
    async function function second({ event, resolve }: {
        event: any;
        resolve: any;
    }): Promise<any>@type{import('@sveltejs/kit').Handle}second({ event: anyevent, resolve: anyresolve }) {
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second pre-processing');
    	const const result: anyresult = await resolve: anyresolve(event: anyevent, {
    		transformPageChunk: ({ html }: {
        html: any;
    }) => anytransformPageChunk: ({ html: anyhtml }) => {
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second transform');
    			return html: anyhtml;
    		},
    		preload: () => booleanpreload: () => {
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second preload');
    			return true;
    		},
    		filterSerializedResponseHeaders: () => booleanfilterSerializedResponseHeaders: () => {
    			// this one wins as it's the first defined in the chain
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second filterSerializedResponseHeaders');
    			return true;
    		}
    	});
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second post-processing');
    	return const result: anyresult;
    }
    
    export const const handle: Handlehandle = function sequence(...handlers: import("@sveltejs/kit").Handle[]): import("@sveltejs/kit").HandleA helper function for sequencing multiple handle calls in a middleware-like manner.
    The behavior for the handle options is as follows:
    
    transformPageChunk is applied in reverse order and merged
    preload is applied in forward order, the first option “wins” and no preload options after it are called
    filterSerializedResponseHeaders behaves the same as preload
    
    src/hooks.serverimport { sequence } from '@sveltejs/kit/hooks';
    
    /// type: import('@sveltejs/kit').Handle
    async function first({ event, resolve }) {
    	console.log('first pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			// transforms are applied in reverse order
    			console.log('first transform');
    			return html;
    		},
    		preload: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('first preload');
    			return true;
    		}
    	});
    	console.log('first post-processing');
    	return result;
    }
    
    /// type: import('@sveltejs/kit').Handle
    async function second({ event, resolve }) {
    	console.log('second pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			console.log('second transform');
    			return html;
    		},
    		preload: () => {
    			console.log('second preload');
    			return true;
    		},
    		filterSerializedResponseHeaders: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('second filterSerializedResponseHeaders');
    			return true;
    		}
    	});
    	console.log('second post-processing');
    	return result;
    }
    
    export const handle = sequence(first, second);The example above would print:
    first pre-processing
    first preload
    second pre-processing
    second filterSerializedResponseHeaders
    second transform
    first transform
    second post-processing
    first post-processing@paramhandlers The chain of handle functionssequence(function first({ event, resolve }: {
        event: any;
        resolve: any;
    }): Promise<any>@type{import('@sveltejs/kit').Handle}first, function second({ event, resolve }: {
        event: any;
        resolve: any;
    }): Promise<any>@type{import('@sveltejs/kit').Handle}second);

    import { function sequence(...handlers: import("@sveltejs/kit").Handle[]): import("@sveltejs/kit").HandleA helper function for sequencing multiple handle calls in a middleware-like manner.
    The behavior for the handle options is as follows:
    
    transformPageChunk is applied in reverse order and merged
    preload is applied in forward order, the first option “wins” and no preload options after it are called
    filterSerializedResponseHeaders behaves the same as preload
    
    src/hooks.serverimport { sequence } from '@sveltejs/kit/hooks';
    
    /// type: import('@sveltejs/kit').Handle
    async function first({ event, resolve }) {
    	console.log('first pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			// transforms are applied in reverse order
    			console.log('first transform');
    			return html;
    		},
    		preload: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('first preload');
    			return true;
    		}
    	});
    	console.log('first post-processing');
    	return result;
    }
    
    /// type: import('@sveltejs/kit').Handle
    async function second({ event, resolve }) {
    	console.log('second pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			console.log('second transform');
    			return html;
    		},
    		preload: () => {
    			console.log('second preload');
    			return true;
    		},
    		filterSerializedResponseHeaders: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('second filterSerializedResponseHeaders');
    			return true;
    		}
    	});
    	console.log('second post-processing');
    	return result;
    }
    
    export const handle = sequence(first, second);The example above would print:
    first pre-processing
    first preload
    second pre-processing
    second filterSerializedResponseHeaders
    second transform
    first transform
    second post-processing
    first post-processing@paramhandlers The chain of handle functionssequence } from '@sveltejs/kit/hooks';
    import type { type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle } from '@sveltejs/kit';
    
    const const first: Handlefirst: type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle = async ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) => {
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('first pre-processing');
    	const const result: Responseresult = await resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event, {
    		ResolveOptions.transformPageChunk?: ((input: {
        html: string;
        done: boolean;
    }) => MaybePromise<string | undefined>) | undefinedApplies custom transforms to HTML. If done is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML
    (they could include an element’s opening tag but not its closing tag, for example)
    but they will always be split at sensible boundaries such as %sveltekit.head% or layout/page components.
    @paraminput the html chunk and the info if this is the last chunktransformPageChunk: ({ html: stringhtml }) => {
    			// transforms are applied in reverse order
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('first transform');
    			return html: stringhtml;
    		},
    		ResolveOptions.preload?: ((input: {
        type: "font" | "css" | "js" | "asset";
        path: string;
    }) => boolean) | undefinedDetermines what should be added to the &#x3C;head> tag to preload it.
    By default, js and css files will be preloaded.
    @paraminput the type of the file and its pathpreload: () => {
    			// this one wins as it's the first defined in the chain
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('first preload');
    			return true;
    		}
    	});
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('first post-processing');
    	return const result: Responseresult;
    };
    
    const const second: Handlesecond: type Handle = (input: {
        event: RequestEvent;
        resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>;
    }) => MaybePromise<...>The handle hook runs every time the SvelteKit server receives a request and
    determines the response.
    It receives an event object representing the request and a function called resolve, which renders the route and generates a Response.
    This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).
    Handle = async ({ event: RequestEvent<Partial<Record<string, string>>, string | null>event, resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve }) => {
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second pre-processing');
    	const const result: Responseresult = await resolve: (event: RequestEvent, opts?: ResolveOptions) => MaybePromise<Response>resolve(event: RequestEvent<Partial<Record<string, string>>, string | null>event, {
    		ResolveOptions.transformPageChunk?: ((input: {
        html: string;
        done: boolean;
    }) => MaybePromise<string | undefined>) | undefinedApplies custom transforms to HTML. If done is true, it’s the final chunk. Chunks are not guaranteed to be well-formed HTML
    (they could include an element’s opening tag but not its closing tag, for example)
    but they will always be split at sensible boundaries such as %sveltekit.head% or layout/page components.
    @paraminput the html chunk and the info if this is the last chunktransformPageChunk: ({ html: stringhtml }) => {
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second transform');
    			return html: stringhtml;
    		},
    		ResolveOptions.preload?: ((input: {
        type: "font" | "css" | "js" | "asset";
        path: string;
    }) => boolean) | undefinedDetermines what should be added to the &#x3C;head> tag to preload it.
    By default, js and css files will be preloaded.
    @paraminput the type of the file and its pathpreload: () => {
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second preload');
    			return true;
    		},
    		ResolveOptions.filterSerializedResponseHeaders?: ((name: string, value: string) => boolean) | undefinedDetermines which headers should be included in serialized responses when a load function loads a resource with fetch.
    By default, none will be included.
    @paramname header name@paramvalue header valuefilterSerializedResponseHeaders: () => {
    			// this one wins as it's the first defined in the chain
    			var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second filterSerializedResponseHeaders');
    			return true;
    		}
    	});
    	var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log('second post-processing');
    	return const result: Responseresult;
    };
    
    export const const handle: Handlehandle = function sequence(...handlers: import("@sveltejs/kit").Handle[]): import("@sveltejs/kit").HandleA helper function for sequencing multiple handle calls in a middleware-like manner.
    The behavior for the handle options is as follows:
    
    transformPageChunk is applied in reverse order and merged
    preload is applied in forward order, the first option “wins” and no preload options after it are called
    filterSerializedResponseHeaders behaves the same as preload
    
    src/hooks.serverimport { sequence } from '@sveltejs/kit/hooks';
    
    /// type: import('@sveltejs/kit').Handle
    async function first({ event, resolve }) {
    	console.log('first pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			// transforms are applied in reverse order
    			console.log('first transform');
    			return html;
    		},
    		preload: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('first preload');
    			return true;
    		}
    	});
    	console.log('first post-processing');
    	return result;
    }
    
    /// type: import('@sveltejs/kit').Handle
    async function second({ event, resolve }) {
    	console.log('second pre-processing');
    	const result = await resolve(event, {
    		transformPageChunk: ({ html }) => {
    			console.log('second transform');
    			return html;
    		},
    		preload: () => {
    			console.log('second preload');
    			return true;
    		},
    		filterSerializedResponseHeaders: () => {
    			// this one wins as it's the first defined in the chain
    			console.log('second filterSerializedResponseHeaders');
    			return true;
    		}
    	});
    	console.log('second post-processing');
    	return result;
    }
    
    export const handle = sequence(first, second);The example above would print:
    first pre-processing
    first preload
    second pre-processing
    second filterSerializedResponseHeaders
    second transform
    first transform
    second post-processing
    first post-processing@paramhandlers The chain of handle functionssequence(const first: Handlefirst, const second: Handlesecond);

The example above would print:

    first pre-processing
    first preload
    second pre-processing
    second filterSerializedResponseHeaders
    second transform
    first transform
    second post-processing
    first post-processing

    function sequence(
    	...handlers: import('@sveltejs/kit').Handle[]
    ): import('@sveltejs/kit').Handle;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/15-@sveltejs-kit-hooks.md) [llms.txt](/docs/kit/@sveltejs-kit-hooks/llms.txt)

previous next

[@sveltejs/kit](/docs/kit/@sveltejs-kit) [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

@sveltejs/kit/node/polyfills
============================

### On this page

*   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
*   [installPolyfills](#installPolyfills)

    import { function installPolyfills(): voidMake various web APIs available as globals:
    
    crypto
    File
    
    installPolyfills } from '@sveltejs/kit/node/polyfills';

installPolyfills[](#installPolyfills)
-------------------------------------

Make various web APIs available as globals:

*   `crypto`
*   `File`

    function installPolyfills(): void;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/15-@sveltejs-kit-node-polyfills.md) [llms.txt](/docs/kit/@sveltejs-kit-node-polyfills/llms.txt)

previous next

[@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks) [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

@sveltejs/kit/node
==================

### On this page

*   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
*   [createReadableStream](#createReadableStream)
*   [getRequest](#getRequest)
*   [setResponse](#setResponse)

    import {
    	function createReadableStream(file: string): ReadableStreamConverts a file on disk to a readable stream
    @since2.4.0createReadableStream,
    	function getRequest({ request, base, bodySizeLimit }: {
        request: import("http").IncomingMessage;
        base: string;
        bodySizeLimit?: number;
    }): Promise<Request>getRequest,
    	function setResponse(res: import("http").ServerResponse, response: Response): Promise<void>setResponse
    } from '@sveltejs/kit/node';

createReadableStream[](#createReadableStream)
---------------------------------------------

> Available since 2.4.0

Converts a file on disk to a readable stream

    function createReadableStream(file: string): ReadableStream;

getRequest[](#getRequest)
-------------------------

    function getRequest({
    	request,
    	base,
    	bodySizeLimit
    }: {
    	request: import('http').IncomingMessage;
    	base: string;
    	bodySizeLimit?: number;
    }): Promise<Request>;

setResponse[](#setResponse)
---------------------------

    function setResponse(
    	res: import('http').ServerResponse,
    	response: Response
    ): Promise<void>;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/15-@sveltejs-kit-node.md) [llms.txt](/docs/kit/@sveltejs-kit-node/llms.txt)

previous next

[@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills) [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

@sveltejs/kit/vite
==================

### On this page

*   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
*   [sveltekit](#sveltekit)

    import { function sveltekit(): Promise<Plugin<any>[]>Returns the SvelteKit Vite plugins.
    sveltekit } from '@sveltejs/kit/vite';

sveltekit[](#sveltekit)
-----------------------

Returns the SvelteKit Vite plugins.

    function sveltekit(): Promise<import('vite').Plugin[]>;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/15-@sveltejs-kit-vite.md) [llms.txt](/docs/kit/@sveltejs-kit-vite/llms.txt)

previous next

[@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node) [$app/environment](/docs/kit/$app-environment)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$app/environment
================

### On this page

*   [$app/environment](/docs/kit/$app-environment)
*   [browser](#browser)
*   [building](#building)
*   [dev](#dev)
*   [version](#version)

    import { const browser: booleantrue if the app is running in the browser.
    browser, const building: booleanSvelteKit analyses your app during the build step by running it. During this process, building is true. This also applies during prerendering.
    building, const dev: booleanWhether the dev server is running. This is not guaranteed to correspond to NODE_ENV or MODE.
    dev, const version: stringThe value of config.kit.version.name.
    version } from '$app/environment';

browser[](#browser)
-------------------

`true` if the app is running in the browser.

    const browser: boolean;

building[](#building)
---------------------

SvelteKit analyses your app during the `build` step by running it. During this process, `building` is `true`. This also applies during prerendering.

    const building: boolean;

dev[](#dev)
-----------

Whether the dev server is running. This is not guaranteed to correspond to `NODE_ENV` or `MODE`.

    const dev: boolean;

version[](#version)
-------------------

The value of `config.kit.version.name`.

    const version: string;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/20-$app-environment.md) [llms.txt](/docs/kit/$app-environment/llms.txt)

previous next

[@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite) [$app/forms](/docs/kit/$app-forms)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$app/forms
==========

### On this page

*   [$app/forms](/docs/kit/$app-forms)
*   [applyAction](#applyAction)
*   [deserialize](#deserialize)
*   [enhance](#enhance)

    import { function applyAction<Success extends Record<string, unknown> | undefined, Failure extends Record<string, unknown> | undefined>(result: import("@sveltejs/kit").ActionResult<Success, Failure>): Promise<void>This action updates the form property of the current page with the given data and updates page.status.
    In case of an error, it redirects to the nearest error page.
    applyAction, function deserialize<Success extends Record<string, unknown> | undefined, Failure extends Record<string, unknown> | undefined>(result: string): import("@sveltejs/kit").ActionResult<Success, Failure>Use this function to deserialize the response from a form submission.
    Usage:
    import { deserialize } from '$app/forms';
    
    async function handleSubmit(event) {
      const response = await fetch('/form?/action', {
    	method: 'POST',
    	body: new FormData(event.target)
      });
    
      const result = deserialize(await response.text());
      // ...
    }deserialize, function enhance<Success extends Record<string, unknown> | undefined, Failure extends Record<string, unknown> | undefined>(form_element: HTMLFormElement, submit?: import("@sveltejs/kit").SubmitFunction<Success, Failure>): {
        destroy(): void;
    }This action enhances a &#x3C;form> element that otherwise would work without JavaScript.
    The submit function is called upon submission with the given FormData and the action that should be triggered.
    If cancel is called, the form will not be submitted.
    You can use the abort controller to cancel the submission in case another one starts.
    If a function is returned, that function is called with the response from the server.
    If nothing is returned, the fallback will be used.
    If this function or its return value isn’t set, it
    
    falls back to updating the form prop with the returned data if the action is on the same page as the form
    updates page.status
    resets the &#x3C;form> element and invalidates all data in case of successful submission with no redirect response
    redirects in case of a redirect response
    redirects to the nearest error page in case of an unexpected error
    
    If you provide a custom function with a callback and want to use the default behavior, invoke update in your callback.
    It accepts an options object
    
    reset: false if you don’t want the &#x3C;form> values to be reset after a successful submission
    invalidateAll: false if you don’t want the action to call invalidateAll after submission
    
    @paramform_element The form element@paramsubmit Submit callbackenhance } from '$app/forms';

applyAction[](#applyAction)
---------------------------

This action updates the `form` property of the current page with the given data and updates `page.status`. In case of an error, it redirects to the nearest error page.

    function applyAction<
    	Success extends Record<string, unknown> | undefined,
    	Failure extends Record<string, unknown> | undefined
    >(
    	result: import('@sveltejs/kit').ActionResult<
    		Success,
    		Failure
    	>
    ): Promise<void>;

deserialize[](#deserialize)
---------------------------

Use this function to deserialize the response from a form submission. Usage:

    import { function deserialize<Success extends Record<string, unknown> | undefined, Failure extends Record<string, unknown> | undefined>(result: string): import("@sveltejs/kit").ActionResult<Success, Failure>Use this function to deserialize the response from a form submission.
    Usage:
    import { deserialize } from '$app/forms';
    
    async function handleSubmit(event) {
      const response = await fetch('/form?/action', {
    	method: 'POST',
    	body: new FormData(event.target)
      });
    
      const result = deserialize(await response.text());
      // ...
    }deserialize } from '$app/forms';
    
    async function function handleSubmit(event: any): Promise<void>handleSubmit(event: anyevent) {
    	const const response: Responseresponse = await function fetch(input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response> (+1 overload)MDN Reference
    fetch('/form?/action', {
    		RequestInit.method?: string | undefinedA string to set request’s method.
    method: 'POST',
    		RequestInit.body?: BodyInit | null | undefinedA BodyInit object or null to set request’s body.
    body: new var FormData: new (form?: HTMLFormElement, submitter?: HTMLElement | null) => FormDataProvides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to “multipart/form-data”.
    MDN Reference
    FormData(event: anyevent.target)
    	});
    
    	const const result: ActionResult<Record<string, unknown> | undefined, Record<string, unknown> | undefined>result = deserialize<Record<string, unknown> | undefined, Record<string, unknown> | undefined>(result: string): ActionResult<Record<string, unknown> | undefined, Record<string, unknown> | undefined>Use this function to deserialize the response from a form submission.
    Usage:
    import { deserialize } from '$app/forms';
    
    async function handleSubmit(event) {
      const response = await fetch('/form?/action', {
    	method: 'POST',
    	body: new FormData(event.target)
      });
    
      const result = deserialize(await response.text());
      // ...
    }deserialize(await const response: Responseresponse.Body.text(): Promise<string>MDN Reference
    text());
    	// ...
    }

    function deserialize<
    	Success extends Record<string, unknown> | undefined,
    	Failure extends Record<string, unknown> | undefined
    >(
    	result: string
    ): import('@sveltejs/kit').ActionResult<Success, Failure>;

enhance[](#enhance)
-------------------

This action enhances a `<form>` element that otherwise would work without JavaScript.

The `submit` function is called upon submission with the given FormData and the `action` that should be triggered. If `cancel` is called, the form will not be submitted. You can use the abort `controller` to cancel the submission in case another one starts. If a function is returned, that function is called with the response from the server. If nothing is returned, the fallback will be used.

If this function or its return value isn’t set, it

*   falls back to updating the `form` prop with the returned data if the action is on the same page as the form
*   updates `page.status`
*   resets the `<form>` element and invalidates all data in case of successful submission with no redirect response
*   redirects in case of a redirect response
*   redirects to the nearest error page in case of an unexpected error

If you provide a custom function with a callback and want to use the default behavior, invoke `update` in your callback. It accepts an options object

*   `reset: false` if you don’t want the `<form>` values to be reset after a successful submission
*   `invalidateAll: false` if you don’t want the action to call `invalidateAll` after submission

    function enhance<
    	Success extends Record<string, unknown> | undefined,
    	Failure extends Record<string, unknown> | undefined
    >(
    	form_element: HTMLFormElement,
    	submit?: import('@sveltejs/kit').SubmitFunction<
    		Success,
    		Failure
    	>
    ): {
    	destroy(): void;
    };

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/20-$app-forms.md) [llms.txt](/docs/kit/$app-forms/llms.txt)

previous next

[$app/environment](/docs/kit/$app-environment) [$app/navigation](/docs/kit/$app-navigation)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$app/navigation
===============

### On this page

*   [$app/navigation](/docs/kit/$app-navigation)
*   [afterNavigate](#afterNavigate)
*   [beforeNavigate](#beforeNavigate)
*   [disableScrollHandling](#disableScrollHandling)
*   [goto](#goto)
*   [invalidate](#invalidate)
*   [invalidateAll](#invalidateAll)
*   [onNavigate](#onNavigate)
*   [preloadCode](#preloadCode)
*   [preloadData](#preloadData)
*   [pushState](#pushState)
*   [replaceState](#replaceState)

    import {
    	function afterNavigate(callback: (navigation: import("@sveltejs/kit").AfterNavigate) => void): voidA lifecycle function that runs the supplied callback when the current component mounts, and also whenever we navigate to a URL.
    afterNavigate must be called during a component initialization. It remains active as long as the component is mounted.
    afterNavigate,
    	function beforeNavigate(callback: (navigation: import("@sveltejs/kit").BeforeNavigate) => void): voidA navigation interceptor that triggers before we navigate to a URL, whether by clicking a link, calling goto(...), or using the browser back/forward controls.
    Calling cancel() will prevent the navigation from completing. If navigation.type === 'leave' — meaning the user is navigating away from the app (or closing the tab) — calling cancel will trigger the native browser unload confirmation dialog. In this case, the navigation may or may not be cancelled depending on the user’s response.
    When a navigation isn’t to a SvelteKit-owned route (and therefore controlled by SvelteKit’s client-side router), navigation.to.route.id will be null.
    If the navigation will (if not cancelled) cause the document to unload — in other words 'leave' navigations and 'link' navigations where navigation.to.route === null — navigation.willUnload is true.
    beforeNavigate must be called during a component initialization. It remains active as long as the component is mounted.
    beforeNavigate,
    	function disableScrollHandling(): voidIf called when the page is being updated following a navigation (in onMount or afterNavigate or an action, for example), this disables SvelteKit’s built-in scroll handling.
    This is generally discouraged, since it breaks user expectations.
    disableScrollHandling,
    	function goto(url: string | URL, opts?: {
        replaceState?: boolean | undefined;
        noScroll?: boolean | undefined;
        keepFocus?: boolean | undefined;
        invalidateAll?: boolean | undefined;
        invalidate?: (string | URL | ((url: URL) => boolean))[] | undefined;
        state?: App.PageState | undefined;
    } | undefined): Promise<void>Allows you to navigate programmatically to a given route, with options such as keeping the current element focused.
    Returns a Promise that resolves when SvelteKit navigates (or fails to navigate, in which case the promise rejects) to the specified url.
    For external URLs, use window.location = url instead of calling goto(url).
    @paramurl Where to navigate to. Note that if you've set config.kit.paths.base and the URL is root-relative, you need to prepend the base path if you want to navigate within the app.@paramopts Options related to the navigationgoto,
    	function invalidate(resource: string | URL | ((url: URL) => boolean)): Promise<void>Causes any load functions belonging to the currently active page to re-run if they depend on the url in question, via fetch or depends. Returns a Promise that resolves when the page is subsequently updated.
    If the argument is given as a string or URL, it must resolve to the same URL that was passed to fetch or depends (including query parameters).
    To create a custom identifier, use a string beginning with [a-z]+: (e.g. custom:state) — this is a valid URL.
    The function argument can be used define a custom predicate. It receives the full URL and causes load to rerun if true is returned.
    This can be useful if you want to invalidate based on a pattern instead of a exact match.
    // Example: Match '/path' regardless of the query parameters
    import { function invalidate(resource: string | URL | ((url: URL) => boolean)): Promise<void>Causes any load functions belonging to the currently active page to re-run if they depend on the url in question, via fetch or depends. Returns a Promise that resolves when the page is subsequently updated.
    If the argument is given as a string or URL, it must resolve to the same URL that was passed to fetch or depends (including query parameters).
    To create a custom identifier, use a string beginning with [a-z]+: (e.g. custom:state) — this is a valid URL.
    The function argument can be used define a custom predicate. It receives the full URL and causes load to rerun if true is returned.
    This can be useful if you want to invalidate based on a pattern instead of a exact match.
    // Example: Match '/path' regardless of the query parameters
    import { invalidate } from '$app/navigation';
    
    invalidate((url) => url.pathname === '/path');@paramresource The invalidated URLinvalidate } from '$app/navigation';
    
    function invalidate(resource: string | URL | ((url: URL) => boolean)): Promise<void>Causes any load functions belonging to the currently active page to re-run if they depend on the url in question, via fetch or depends. Returns a Promise that resolves when the page is subsequently updated.
    If the argument is given as a string or URL, it must resolve to the same URL that was passed to fetch or depends (including query parameters).
    To create a custom identifier, use a string beginning with [a-z]+: (e.g. custom:state) — this is a valid URL.
    The function argument can be used define a custom predicate. It receives the full URL and causes load to rerun if true is returned.
    This can be useful if you want to invalidate based on a pattern instead of a exact match.
    // Example: Match '/path' regardless of the query parameters
    import { invalidate } from '$app/navigation';
    
    invalidate((url) => url.pathname === '/path');@paramresource The invalidated URLinvalidate((url: URLurl) => url: URLurl.URL.pathname: stringMDN Reference
    pathname === '/path');@paramresource The invalidated URLinvalidate,
    	function invalidateAll(): Promise<void>Causes all load functions belonging to the currently active page to re-run. Returns a Promise that resolves when the page is subsequently updated.
    invalidateAll,
    	function onNavigate(callback: (navigation: import("@sveltejs/kit").OnNavigate) => MaybePromise<void | (() => void)>): voidA lifecycle function that runs the supplied callback immediately before we navigate to a new URL except during full-page navigations.
    If you return a Promise, SvelteKit will wait for it to resolve before completing the navigation. This allows you to — for example — use document.startViewTransition. Avoid promises that are slow to resolve, since navigation will appear stalled to the user.
    If a function (or a Promise that resolves to a function) is returned from the callback, it will be called once the DOM has updated.
    onNavigate must be called during a component initialization. It remains active as long as the component is mounted.
    onNavigate,
    	function preloadCode(pathname: string): Promise<void>Programmatically imports the code for routes that haven’t yet been fetched.
    Typically, you might call this to speed up subsequent navigation.
    You can specify routes by any matching pathname such as /about (to match src/routes/about/+page.svelte) or /blog/* (to match src/routes/blog/[slug]/+page.svelte).
    Unlike preloadData, this won’t call load functions.
    Returns a Promise that resolves when the modules have been imported.
    preloadCode,
    	function preloadData(href: string): Promise<{
        type: "loaded";
        status: number;
        data: Record<string, any>;
    } | {
        type: "redirect";
        location: string;
    }>Programmatically preloads the given page, which means
    
    ensuring that the code for the page is loaded, and
    calling the page’s load function with the appropriate options.
    
    This is the same behaviour that SvelteKit triggers when the user taps or mouses over an &#x3C;a> element with data-sveltekit-preload-data.
    If the next navigation is to href, the values returned from load will be used, making navigation instantaneous.
    Returns a Promise that resolves with the result of running the new route’s load functions once the preload is complete.
    @paramhref Page to preloadpreloadData,
    	function pushState(url: string | URL, state: App.PageState): voidProgrammatically create a new history entry with the given page.state. To use the current URL, you can pass '' as the first argument. Used for shallow routing.
    pushState,
    	function replaceState(url: string | URL, state: App.PageState): voidProgrammatically replace the current history entry with the given page.state. To use the current URL, you can pass '' as the first argument. Used for shallow routing.
    replaceState
    } from '$app/navigation';

afterNavigate[](#afterNavigate)
-------------------------------

A lifecycle function that runs the supplied `callback` when the current component mounts, and also whenever we navigate to a URL.

`afterNavigate` must be called during a component initialization. It remains active as long as the component is mounted.

    function afterNavigate(
    	callback: (
    		navigation: import('@sveltejs/kit').AfterNavigate
    	) => void
    ): void;

beforeNavigate[](#beforeNavigate)
---------------------------------

A navigation interceptor that triggers before we navigate to a URL, whether by clicking a link, calling `goto(...)`, or using the browser back/forward controls.

Calling `cancel()` will prevent the navigation from completing. If `navigation.type === 'leave'` — meaning the user is navigating away from the app (or closing the tab) — calling `cancel` will trigger the native browser unload confirmation dialog. In this case, the navigation may or may not be cancelled depending on the user’s response.

When a navigation isn’t to a SvelteKit-owned route (and therefore controlled by SvelteKit’s client-side router), `navigation.to.route.id` will be `null`.

If the navigation will (if not cancelled) cause the document to unload — in other words `'leave'` navigations and `'link'` navigations where `navigation.to.route === null` — `navigation.willUnload` is `true`.

`beforeNavigate` must be called during a component initialization. It remains active as long as the component is mounted.

    function beforeNavigate(
    	callback: (
    		navigation: import('@sveltejs/kit').BeforeNavigate
    	) => void
    ): void;

disableScrollHandling[](#disableScrollHandling)
-----------------------------------------------

If called when the page is being updated following a navigation (in `onMount` or `afterNavigate` or an action, for example), this disables SvelteKit’s built-in scroll handling. This is generally discouraged, since it breaks user expectations.

    function disableScrollHandling(): void;

goto[](#goto)
-------------

Allows you to navigate programmatically to a given route, with options such as keeping the current element focused. Returns a Promise that resolves when SvelteKit navigates (or fails to navigate, in which case the promise rejects) to the specified `url`.

For external URLs, use `window.location = url` instead of calling `goto(url)`.

    function goto(
    	url: string | URL,
    	opts?:
    		| {
    				replaceState?: boolean | undefined;
    				noScroll?: boolean | undefined;
    				keepFocus?: boolean | undefined;
    				invalidateAll?: boolean | undefined;
    				invalidate?:
    					| (string | URL | ((url: URL) => boolean))[]
    					| undefined;
    				state?: App.PageState | undefined;
    		  }
    		| undefined
    ): Promise<void>;

invalidate[](#invalidate)
-------------------------

Causes any `load` functions belonging to the currently active page to re-run if they depend on the `url` in question, via `fetch` or `depends`. Returns a `Promise` that resolves when the page is subsequently updated.

If the argument is given as a `string` or `URL`, it must resolve to the same URL that was passed to `fetch` or `depends` (including query parameters). To create a custom identifier, use a string beginning with `[a-z]+:` (e.g. `custom:state`) — this is a valid URL.

The `function` argument can be used define a custom predicate. It receives the full `URL` and causes `load` to rerun if `true` is returned. This can be useful if you want to invalidate based on a pattern instead of a exact match.

    // Example: Match '/path' regardless of the query parameters
    import { function invalidate(resource: string | URL | ((url: URL) => boolean)): Promise<void>Causes any load functions belonging to the currently active page to re-run if they depend on the url in question, via fetch or depends. Returns a Promise that resolves when the page is subsequently updated.
    If the argument is given as a string or URL, it must resolve to the same URL that was passed to fetch or depends (including query parameters).
    To create a custom identifier, use a string beginning with [a-z]+: (e.g. custom:state) — this is a valid URL.
    The function argument can be used define a custom predicate. It receives the full URL and causes load to rerun if true is returned.
    This can be useful if you want to invalidate based on a pattern instead of a exact match.
    // Example: Match '/path' regardless of the query parameters
    import { invalidate } from '$app/navigation';
    
    invalidate((url) => url.pathname === '/path');@paramresource The invalidated URLinvalidate } from '$app/navigation';
    
    function invalidate(resource: string | URL | ((url: URL) => boolean)): Promise<void>Causes any load functions belonging to the currently active page to re-run if they depend on the url in question, via fetch or depends. Returns a Promise that resolves when the page is subsequently updated.
    If the argument is given as a string or URL, it must resolve to the same URL that was passed to fetch or depends (including query parameters).
    To create a custom identifier, use a string beginning with [a-z]+: (e.g. custom:state) — this is a valid URL.
    The function argument can be used define a custom predicate. It receives the full URL and causes load to rerun if true is returned.
    This can be useful if you want to invalidate based on a pattern instead of a exact match.
    // Example: Match '/path' regardless of the query parameters
    import { invalidate } from '$app/navigation';
    
    invalidate((url) => url.pathname === '/path');@paramresource The invalidated URLinvalidate((url: URLurl) => url: URLurl.URL.pathname: stringMDN Reference
    pathname === '/path');

    function invalidate(
    	resource: string | URL | ((url: URL) => boolean)
    ): Promise<void>;

invalidateAll[](#invalidateAll)
-------------------------------

Causes all `load` functions belonging to the currently active page to re-run. Returns a `Promise` that resolves when the page is subsequently updated.

    function invalidateAll(): Promise<void>;

onNavigate[](#onNavigate)
-------------------------

A lifecycle function that runs the supplied `callback` immediately before we navigate to a new URL except during full-page navigations.

If you return a `Promise`, SvelteKit will wait for it to resolve before completing the navigation. This allows you to — for example — use `document.startViewTransition`. Avoid promises that are slow to resolve, since navigation will appear stalled to the user.

If a function (or a `Promise` that resolves to a function) is returned from the callback, it will be called once the DOM has updated.

`onNavigate` must be called during a component initialization. It remains active as long as the component is mounted.

    function onNavigate(
    	callback: (
    		navigation: import('@sveltejs/kit').OnNavigate
    	) => MaybePromise<(() => void) | void>
    ): void;

preloadCode[](#preloadCode)
---------------------------

Programmatically imports the code for routes that haven’t yet been fetched. Typically, you might call this to speed up subsequent navigation.

You can specify routes by any matching pathname such as `/about` (to match `src/routes/about/+page.svelte`) or `/blog/*` (to match `src/routes/blog/[slug]/+page.svelte`).

Unlike `preloadData`, this won’t call `load` functions. Returns a Promise that resolves when the modules have been imported.

    function preloadCode(pathname: string): Promise<void>;

preloadData[](#preloadData)
---------------------------

Programmatically preloads the given page, which means

1.  ensuring that the code for the page is loaded, and
2.  calling the page’s load function with the appropriate options.

This is the same behaviour that SvelteKit triggers when the user taps or mouses over an `<a>` element with `data-sveltekit-preload-data`. If the next navigation is to `href`, the values returned from load will be used, making navigation instantaneous. Returns a Promise that resolves with the result of running the new route’s `load` functions once the preload is complete.

    function preloadData(href: string): Promise<
    	| {
    			type: 'loaded';
    			status: number;
    			data: Record<string, any>;
    	  }
    	| {
    			type: 'redirect';
    			location: string;
    	  }
    >;

pushState[](#pushState)
-----------------------

Programmatically create a new history entry with the given `page.state`. To use the current URL, you can pass `''` as the first argument. Used for [shallow routing](/docs/kit/shallow-routing).

    function pushState(
    	url: string | URL,
    	state: App.PageState
    ): void;

replaceState[](#replaceState)
-----------------------------

Programmatically replace the current history entry with the given `page.state`. To use the current URL, you can pass `''` as the first argument. Used for [shallow routing](/docs/kit/shallow-routing).

    function replaceState(
    	url: string | URL,
    	state: App.PageState
    ): void;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/20-$app-navigation.md) [llms.txt](/docs/kit/$app-navigation/llms.txt)

previous next

[$app/forms](/docs/kit/$app-forms) [$app/paths](/docs/kit/$app-paths)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$app/paths
==========

### On this page

*   [$app/paths](/docs/kit/$app-paths)
*   [assets](#assets)
*   [base](#base)
*   [resolveRoute](#resolveRoute)

    import { let assets: "" | `https://${string}` | `http://${string}` | "/_svelte_kit_assets"An absolute path that matches config.kit.paths.assets.
     If a value for config.kit.paths.assets is specified, it will be replaced with '/_svelte_kit_assets' during vite dev or vite preview, since the assets don’t yet live at their eventual URL.
    assets, let base: "" | `/${string}`A string that matches config.kit.paths.base.
    Example usage: &#x3C;a href="{base}/your-page">Link&#x3C;/a>
    base, function resolveRoute(id: string, params: Record<string, string | undefined>): stringPopulate a route ID with params to resolve a pathname.
    @examplejs import { resolveRoute } from '$app/paths';  resolveRoute(   `/blog/[slug]/[...somethingElse]`,   {     slug: 'hello-world',     somethingElse: 'something/else'   } ); // `/blog/hello-world/something/else` resolveRoute } from '$app/paths';

assets[](#assets)
-----------------

An absolute path that matches [`config.kit.paths.assets`](/docs/kit/configuration#paths).

> If a value for `config.kit.paths.assets` is specified, it will be replaced with `'/_svelte_kit_assets'` during `vite dev` or `vite preview`, since the assets don’t yet live at their eventual URL.

    let assets:
    	| ''
    	| `https://${string}`
    	| `http://${string}`
    	| '/_svelte_kit_assets';

base[](#base)
-------------

A string that matches [`config.kit.paths.base`](/docs/kit/configuration#paths).

Example usage: `<a href="{base}/your-page">Link</a>`

    let base: '' | `/${string}`;

resolveRoute[](#resolveRoute)
-----------------------------

Populate a route ID with params to resolve a pathname.

    import { function resolveRoute(id: string, params: Record<string, string | undefined>): stringPopulate a route ID with params to resolve a pathname.
    @examplejs import { resolveRoute } from '$app/paths';  resolveRoute(   `/blog/[slug]/[...somethingElse]`,   {     slug: 'hello-world',     somethingElse: 'something/else'   } ); // `/blog/hello-world/something/else` resolveRoute } from '$app/paths';
    
    function resolveRoute(id: string, params: Record<string, string | undefined>): stringPopulate a route ID with params to resolve a pathname.
    @examplejs import { resolveRoute } from '$app/paths';  resolveRoute(   `/blog/[slug]/[...somethingElse]`,   {     slug: 'hello-world',     somethingElse: 'something/else'   } ); // `/blog/hello-world/something/else` resolveRoute(
    	`/blog/[slug]/[...somethingElse]`,
    	{
    		slug: stringslug: 'hello-world',
    		somethingElse: stringsomethingElse: 'something/else'
    	}
    ); // `/blog/hello-world/something/else`

    function resolveRoute(
    	id: string,
    	params: Record<string, string | undefined>
    ): string;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/20-$app-paths.md) [llms.txt](/docs/kit/$app-paths/llms.txt)

previous next

[$app/navigation](/docs/kit/$app-navigation) [$app/server](/docs/kit/$app-server)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$app/server
===========

### On this page

*   [$app/server](/docs/kit/$app-server)
*   [getRequestEvent](#getRequestEvent)
*   [read](#read)

    import { function getRequestEvent(): RequestEvent<Partial<Record<string, string>>, string | null>Returns the current RequestEvent. Can be used inside handle, load and actions (and functions called by them).
    In environments without AsyncLocalStorage, this must be called synchronously (i.e. not after an await).
    @since2.20.0getRequestEvent, function read(asset: string): ResponseRead the contents of an imported asset from the filesystem
    @examplejs import { read } from '$app/server'; import somefile from './somefile.txt';  const asset = read(somefile); const text = await asset.text(); @since2.4.0read } from '$app/server';

getRequestEvent[](#getRequestEvent)
-----------------------------------

> Available since 2.20.0

Returns the current `RequestEvent`. Can be used inside server hooks, server `load` functions, actions, and endpoints (and functions called by them).

In environments without [`AsyncLocalStorage`](https://nodejs.org/api/async_context.html#class-asynclocalstorage), this must be called synchronously (i.e. not after an `await`).

    function getRequestEvent(): RequestEvent<
    	Partial<Record<string, string>>,
    	string | null
    >;

read[](#read)
-------------

> Available since 2.4.0

Read the contents of an imported asset from the filesystem

    import { function read(asset: string): ResponseRead the contents of an imported asset from the filesystem
    @examplejs import { read } from '$app/server'; import somefile from './somefile.txt';  const asset = read(somefile); const text = await asset.text(); @since2.4.0read } from '$app/server';
    import const somefile: stringsomefile from './somefile.txt';
    
    const const asset: Responseasset = function read(asset: string): ResponseRead the contents of an imported asset from the filesystem
    @examplejs import { read } from '$app/server'; import somefile from './somefile.txt';  const asset = read(somefile); const text = await asset.text(); @since2.4.0read(const somefile: stringsomefile);
    const const text: stringtext = await const asset: Responseasset.Body.text(): Promise<string>MDN Reference
    text();

    function read(asset: string): Response;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/20-$app-server.md) [llms.txt](/docs/kit/$app-server/llms.txt)

previous next

[$app/paths](/docs/kit/$app-paths) [$app/state](/docs/kit/$app-state)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$app/state
==========

### On this page

*   [$app/state](/docs/kit/$app-state)
*   [navigating](#navigating)
*   [page](#page)
*   [updated](#updated)

SvelteKit makes three read-only state objects available via the `$app/state` module — `page`, `navigating` and `updated`.

> This module was added in 2.12. If you’re using an earlier version of SvelteKit, use [`$app/stores`]($app-stores) instead.

    import { const navigating: Navigation | {
        from: null;
        to: null;
        type: null;
        willUnload: null;
        delta: null;
        complete: null;
    }A read-only object representing an in-progress navigation, with from, to, type and (if type === 'popstate') delta properties.
    Values are null when no navigation is occurring, or during server rendering.
    navigating, const page: Page<Record<string, string>, string | null>A read-only reactive object with information about the current page, serving several use cases:
    
    retrieving the combined data of all pages/layouts anywhere in your component tree (also see loading data)
    retrieving the current value of the form prop anywhere in your component tree (also see form actions)
    retrieving the page state that was set through goto, pushState or replaceState (also see goto and shallow routing)
    retrieving metadata such as the URL you’re on, the current route and its parameters, and whether or not there was an error
    
    &#x3C;! file: +layout.svelte >
    &#x3C;script>
    	import { page } from '$app/state';
    &#x3C;/script>
    
    &#x3C;p>Currently at {page.url.pathname}&#x3C;/p>
    
    {#if page.error}
    	&#x3C;span class="red">Problem detected&#x3C;/span>
    {:else}
    	&#x3C;span class="small">All systems operational&#x3C;/span>
    {/if}Changes to page are available exclusively with runes. (The legacy reactivity syntax will not reflect any changes)
    &#x3C;! file: +page.svelte >
    &#x3C;script>
    	import { page } from '$app/state';
    	const id = $derived(page.params.id); // This will correctly update id for usage on this page
    	$: badId = page.params.id; // Do not use; will never update after initial load
    &#x3C;/script>On the server, values can only be read during rendering (in other words not in e.g. load functions). In the browser, the values can be read at any time.
    page, const updated: {
        readonly current: boolean;
        check(): Promise<boolean>;
    }A read-only reactive value that’s initially false. If version.pollInterval is a non-zero value, SvelteKit will poll for new versions of the app and update current to true when it detects one. updated.check() will force an immediate check, regardless of polling.
    updated } from '$app/state';

navigating[](#navigating)
-------------------------

A read-only object representing an in-progress navigation, with `from`, `to`, `type` and (if `type === 'popstate'`) `delta` properties. Values are `null` when no navigation is occurring, or during server rendering.

    const navigating:
    	| import('@sveltejs/kit').Navigation
    	| {
    			from: null;
    			to: null;
    			type: null;
    			willUnload: null;
    			delta: null;
    			complete: null;
    	  };

page[](#page)
-------------

A read-only reactive object with information about the current page, serving several use cases:

*   retrieving the combined `data` of all pages/layouts anywhere in your component tree (also see [loading data](/docs/kit/load))
*   retrieving the current value of the `form` prop anywhere in your component tree (also see [form actions](/docs/kit/form-actions))
*   retrieving the page state that was set through `goto`, `pushState` or `replaceState` (also see [goto](/docs/kit/$app-navigation#goto) and [shallow routing](/docs/kit/shallow-routing))
*   retrieving metadata such as the URL you’re on, the current route and its parameters, and whether or not there was an error

+layout

    <script>
    	import { page } from '$app/state';
    </script>
    
    <p>Currently at {page.url.pathname}</p>
    
    {#if page.error}
    	<span class="red">Problem detected</span>
    {:else}
    	<span class="small">All systems operational</span>
    {/if}

    <script lang="ts">
    	import { page } from '$app/state';
    </script>
    
    <p>Currently at {page.url.pathname}</p>
    
    {#if page.error}
    	<span class="red">Problem detected</span>
    {:else}
    	<span class="small">All systems operational</span>
    {/if}

Changes to `page` are available exclusively with runes. (The legacy reactivity syntax will not reflect any changes)

+page

    <script>
    	import { page } from '$app/state';
    	const id = $derived(page.params.id); // This will correctly update id for usage on this page
    	$: badId = page.params.id; // Do not use; will never update after initial load
    </script>

    <script lang="ts">
    	import { page } from '$app/state';
    	const id = $derived(page.params.id); // This will correctly update id for usage on this page
    	$: badId = page.params.id; // Do not use; will never update after initial load
    </script>

On the server, values can only be read during rendering (in other words _not_ in e.g. `load` functions). In the browser, the values can be read at any time.

    const page: import('@sveltejs/kit').Page;

updated[](#updated)
-------------------

A read-only reactive value that’s initially `false`. If [`version.pollInterval`](/docs/kit/configuration#version) is a non-zero value, SvelteKit will poll for new versions of the app and update `current` to `true` when it detects one. `updated.check()` will force an immediate check, regardless of polling.

    const updated: {
    	get current(): boolean;
    	check(): Promise<boolean>;
    };

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/20-$app-state.md) [llms.txt](/docs/kit/$app-state/llms.txt)

previous next

[$app/server](/docs/kit/$app-server) [$app/stores](/docs/kit/$app-stores)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$app/stores
===========

### On this page

*   [$app/stores](/docs/kit/$app-stores)
*   [getStores](#getStores)
*   [navigating](#navigating)
*   [page](#page)
*   [updated](#updated)

This module contains store-based equivalents of the exports from [`$app/state`]($app-state). If you’re using SvelteKit 2.12 or later, use that module instead.

    import { function getStores(): {
        page: typeof page;
        navigating: typeof navigating;
        updated: typeof updated;
    }getStores, const navigating: Readable<Navigation | null>A readable store.
    When navigating starts, its value is a Navigation object with from, to, type and (if type === 'popstate') delta properties.
    When navigating finishes, its value reverts to null.
    On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.
    @deprecatedUse navigating from $app/state instead (requires Svelte 5, see docs for more info)navigating, const page: Readable<Page<Record<string, string>, string | null>>A readable store whose value contains page data.
    On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.
    @deprecatedUse page from $app/state instead (requires Svelte 5, see docs for more info)page, const updated: Readable<boolean> & {
        check(): Promise<boolean>;
    }A readable store whose initial value is false. If version.pollInterval is a non-zero value, SvelteKit will poll for new versions of the app and update the store value to true when it detects one. updated.check() will force an immediate check, regardless of polling.
    On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.
    @deprecatedUse updated from $app/state instead (requires Svelte 5, see docs for more info)updated } from '$app/stores';

getStores[](#getStores)
-----------------------

    function getStores(): {
    	page: typeof page;
    
    	navigating: typeof navigating;
    
    	updated: typeof updated;
    };

navigating[](#navigating)
-------------------------

> Use `navigating` from `$app/state` instead (requires Svelte 5, [see docs for more info](/docs/kit/migrating-to-sveltekit-2#SvelteKit-2.12:-$app-stores-deprecated))

A readable store. When navigating starts, its value is a `Navigation` object with `from`, `to`, `type` and (if `type === 'popstate'`) `delta` properties. When navigating finishes, its value reverts to `null`.

On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.

    const navigating: import('svelte/store').Readable<
    	import('@sveltejs/kit').Navigation | null
    >;

page[](#page)
-------------

> Use `page` from `$app/state` instead (requires Svelte 5, [see docs for more info](/docs/kit/migrating-to-sveltekit-2#SvelteKit-2.12:-$app-stores-deprecated))

A readable store whose value contains page data.

On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.

    const page: import('svelte/store').Readable<
    	import('@sveltejs/kit').Page
    >;

updated[](#updated)
-------------------

> Use `updated` from `$app/state` instead (requires Svelte 5, [see docs for more info](/docs/kit/migrating-to-sveltekit-2#SvelteKit-2.12:-$app-stores-deprecated))

A readable store whose initial value is `false`. If [`version.pollInterval`](/docs/kit/configuration#version) is a non-zero value, SvelteKit will poll for new versions of the app and update the store value to `true` when it detects one. `updated.check()` will force an immediate check, regardless of polling.

On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.

    const updated: import('svelte/store').Readable<boolean> & {
    	check(): Promise<boolean>;
    };

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/20-$app-stores.md) [llms.txt](/docs/kit/$app-stores/llms.txt)

previous next

[$app/state](/docs/kit/$app-state) [$env/dynamic/private](/docs/kit/$env-dynamic-private)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$env/dynamic/private
====================

### On this page

*   [$env/dynamic/private](/docs/kit/$env-dynamic-private)

This module provides access to runtime environment variables, as defined by the platform you’re running on. For example if you’re using [`adapter-node`](https://github.com/sveltejs/kit/tree/main/packages/adapter-node) (or running [`vite preview`](/docs/kit/cli)), this is equivalent to `process.env`. This module only includes variables that _do not_ begin with [`config.kit.env.publicPrefix`](/docs/kit/configuration#env) _and do_ start with [`config.kit.env.privatePrefix`](/docs/kit/configuration#env) (if configured).

This module cannot be imported into client-side code.

Dynamic environment variables cannot be used during prerendering.

    import { import envenv } from '$env/dynamic/private';
    var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(import envenv.DEPLOYMENT_SPECIFIC_VARIABLE);

> In `dev`, `$env/dynamic` always includes environment variables from `.env`. In `prod`, this behavior will depend on your adapter.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/25-$env-dynamic-private.md) [llms.txt](/docs/kit/$env-dynamic-private/llms.txt)

previous next

[$app/stores](/docs/kit/$app-stores) [$env/dynamic/public](/docs/kit/$env-dynamic-public)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$env/dynamic/public
===================

### On this page

*   [$env/dynamic/public](/docs/kit/$env-dynamic-public)

Similar to [`$env/dynamic/private`](/docs/kit/$env-dynamic-private), but only includes variables that begin with [`config.kit.env.publicPrefix`](/docs/kit/configuration#env) (which defaults to `PUBLIC_`), and can therefore safely be exposed to client-side code.

Note that public dynamic environment variables must all be sent from the server to the client, causing larger network requests — when possible, use `$env/static/public` instead.

Dynamic environment variables cannot be used during prerendering.

    import { import envenv } from '$env/dynamic/public';
    var console: ConsoleThe console module provides a simple debugging console that is similar to the
    JavaScript console mechanism provided by web browsers.
    The module exports two specific components:
    
    A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
    A global console instance configured to write to process.stdout and
    process.stderr. The global console can be used without calling require('console').
    
    Warning: The global console object’s methods are neither consistently
    synchronous like the browser APIs they resemble, nor are they consistently
    asynchronous like all other Node.js streams. See the note on process I/O for
    more information.
    Example using the global console:
    console.log('hello world');
    // Prints: hello world, to stdout
    console.log('hello %s', 'world');
    // Prints: hello world, to stdout
    console.error(new Error('Whoops, something bad happened'));
    // Prints error message and stack trace to stderr:
    //   Error: Whoops, something bad happened
    //     at [eval]:5:15
    //     at Script.runInThisContext (node:vm:132:18)
    //     at Object.runInThisContext (node:vm:309:38)
    //     at node:internal/process/execution:77:19
    //     at [eval]-wrapper:6:22
    //     at evalScript (node:internal/process/execution:76:60)
    //     at node:internal/main/eval_string:23:3
    
    const name = 'Will Robinson';
    console.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to stderrExample using the Console class:
    const out = getStreamSomehow();
    const err = getStreamSomehow();
    const myConsole = new console.Console(out, err);
    
    myConsole.log('hello world');
    // Prints: hello world, to out
    myConsole.log('hello %s', 'world');
    // Prints: hello world, to out
    myConsole.error(new Error('Whoops, something bad happened'));
    // Prints: [Error: Whoops, something bad happened], to err
    
    const name = 'Will Robinson';
    myConsole.warn(`Danger ${name}! Danger!`);
    // Prints: Danger Will Robinson! Danger!, to err@seesourceconsole.Console.log(message?: any, ...optionalParams: any[]): void (+1 overload)Prints to stdout with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to printf(3)
    (the arguments are all passed to util.format()).
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdoutSee util.format() for more information.
    @sincev0.1.100log(import envenv.PUBLIC_DEPLOYMENT_SPECIFIC_VARIABLE);

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/25-$env-dynamic-public.md) [llms.txt](/docs/kit/$env-dynamic-public/llms.txt)

previous next

[$env/dynamic/private](/docs/kit/$env-dynamic-private) [$env/static/private](/docs/kit/$env-static-private)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$env/static/private
===================

### On this page

*   [$env/static/private](/docs/kit/$env-static-private)

Environment variables [loaded by Vite](https://vitejs.dev/guide/env-and-mode.html#env-files) from `.env` files and `process.env`. Like [`$env/dynamic/private`](/docs/kit/$env-dynamic-private), this module cannot be imported into client-side code. This module only includes variables that _do not_ begin with [`config.kit.env.publicPrefix`](/docs/kit/configuration#env) _and do_ start with [`config.kit.env.privatePrefix`](/docs/kit/configuration#env) (if configured).

_Unlike_ [`$env/dynamic/private`](/docs/kit/$env-dynamic-private), the values exported from this module are statically injected into your bundle at build time, enabling optimisations like dead code elimination.

    import { import API_KEYAPI_KEY } from '$env/static/private';

Note that all environment variables referenced in your code should be declared (for example in an `.env` file), even if they don’t have a value until the app is deployed:

    MY_FEATURE_FLAG=""

You can override `.env` values from the command line like so:

    MY_FEATURE_FLAG="enabled" npm run dev

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/25-$env-static-private.md) [llms.txt](/docs/kit/$env-static-private/llms.txt)

previous next

[$env/dynamic/public](/docs/kit/$env-dynamic-public) [$env/static/public](/docs/kit/$env-static-public)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$env/static/public
==================

### On this page

*   [$env/static/public](/docs/kit/$env-static-public)

Similar to [`$env/static/private`](/docs/kit/$env-static-private), except that it only includes environment variables that begin with [`config.kit.env.publicPrefix`](/docs/kit/configuration#env) (which defaults to `PUBLIC_`), and can therefore safely be exposed to client-side code.

Values are replaced statically at build time.

    import { import PUBLIC_BASE_URLPUBLIC_BASE_URL } from '$env/static/public';

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/25-$env-static-public.md) [llms.txt](/docs/kit/$env-static-public/llms.txt)

previous next

[$env/static/private](/docs/kit/$env-static-private) [$lib](/docs/kit/$lib)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$lib
====

### On this page

*   [$lib](/docs/kit/$lib)

SvelteKit automatically makes files under `src/lib` available using the `$lib` import alias. You can change which directory this alias points to in your [config file](configuration#files).

src/lib/Component

    A reusable component

src/routes/+page

    <script>
    	import Component from '$lib/Component.svelte';
    </script>
    
    <Component />

    <script lang="ts">
    	import Component from '$lib/Component.svelte';
    </script>
    
    <Component />

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/26-$lib.md) [llms.txt](/docs/kit/$lib/llms.txt)

previous next

[$env/static/public](/docs/kit/$env-static-public) [$service-worker](/docs/kit/$service-worker)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

$service-worker
===============

### On this page

*   [$service-worker](/docs/kit/$service-worker)
*   [base](#base)
*   [build](#build)
*   [files](#files)
*   [prerendered](#prerendered)
*   [version](#version)

    import { const base: stringThe base path of the deployment. Typically this is equivalent to config.kit.paths.base, but it is calculated from location.pathname meaning that it will continue to work correctly if the site is deployed to a subdirectory.
    Note that there is a base but no assets, since service workers cannot be used if config.kit.paths.assets is specified.
    base, const build: string[]An array of URL strings representing the files generated by Vite, suitable for caching with cache.addAll(build).
    During development, this is an empty array.
    build, const files: string[]An array of URL strings representing the files in your static directory, or whatever directory is specified by config.kit.files.assets. You can customize which files are included from static directory using config.kit.serviceWorker.files
    files, const prerendered: string[]An array of pathnames corresponding to prerendered pages and endpoints.
    During development, this is an empty array.
    prerendered, const version: stringSee config.kit.version. It’s useful for generating unique cache names inside your service worker, so that a later deployment of your app can invalidate old caches.
    version } from '$service-worker';

This module is only available to [service workers](/docs/kit/service-workers).

base[](#base)
-------------

The `base` path of the deployment. Typically this is equivalent to `config.kit.paths.base`, but it is calculated from `location.pathname` meaning that it will continue to work correctly if the site is deployed to a subdirectory. Note that there is a `base` but no `assets`, since service workers cannot be used if `config.kit.paths.assets` is specified.

    const base: string;

build[](#build)
---------------

An array of URL strings representing the files generated by Vite, suitable for caching with `cache.addAll(build)`. During development, this is an empty array.

    const build: string[];

files[](#files)
---------------

An array of URL strings representing the files in your static directory, or whatever directory is specified by `config.kit.files.assets`. You can customize which files are included from `static` directory using [`config.kit.serviceWorker.files`](/docs/kit/configuration)

    const files: string[];

prerendered[](#prerendered)
---------------------------

An array of pathnames corresponding to prerendered pages and endpoints. During development, this is an empty array.

    const prerendered: string[];

version[](#version)
-------------------

See [`config.kit.version`](/docs/kit/configuration#version). It’s useful for generating unique cache names inside your service worker, so that a later deployment of your app can invalidate old caches.

    const version: string;

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/27-$service-worker.md) [llms.txt](/docs/kit/$service-worker/llms.txt)

previous next

[$lib](/docs/kit/$lib) [Configuration](/docs/kit/configuration)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

Configuration
=============

### On this page

*   [Configuration](/docs/kit/configuration)
*   [Config](#Config)
*   [KitConfig](#KitConfig)
*   [adapter](#adapter)
*   [alias](#alias)
*   [appDir](#appDir)
*   [csp](#csp)
*   [csrf](#csrf)
*   [embedded](#embedded)
*   [env](#env)
*   [files](#files)
*   [inlineStyleThreshold](#inlineStyleThreshold)
*   [moduleExtensions](#moduleExtensions)
*   [outDir](#outDir)
*   [output](#output)
*   [paths](#paths)
*   [prerender](#prerender)
*   [router](#router)
*   [serviceWorker](#serviceWorker)
*   [typescript](#typescript)
*   [version](#version)

Your project’s configuration lives in a `svelte.config.js` file at the root of your project. As well as SvelteKit, this config object is used by other tooling that integrates with Svelte such as editor extensions.

svelte.config

    import const adapter: () => import("@sveltejs/kit").Adapteradapter from '@sveltejs/adapter-auto';
    
    /** @type {import('@sveltejs/kit').Config} */
    const const config: Config@type{import('@sveltejs/kit').Config}config = {
    	Config.kit?: KitConfig | undefinedSvelteKit options
    kit: {
    		KitConfig.adapter?: Adapter | undefinedYour adapter is run when executing vite build. It determines how the output is converted for different platforms.
    @defaultundefinedadapter: function adapter(): import("@sveltejs/kit").Adapteradapter()
    	}
    };
    
    export default const config: Config@type{import('@sveltejs/kit').Config}config;

Config[](#Config)
-----------------

    interface Config {…}

    compilerOptions?: CompileOptions;

*   default `{}`

Options passed to [`svelte.compile`](/docs/svelte/svelte-compiler#CompileOptions).

    extensions?: string[];

*   default `[".svelte"]`

List of file extensions that should be treated as Svelte files.

    kit?: KitConfig;

SvelteKit options

    preprocess?: any;

Preprocessor options, if any. Preprocessing can alternatively also be done through Vite’s preprocessor capabilities.

    vitePlugin?: PluginOptions;

`vite-plugin-svelte` plugin options.

    [key: string]: any;

Any additional options required by tooling that integrates with Svelte.

KitConfig[](#KitConfig)
-----------------------

The `kit` property configures SvelteKit, and can have the following properties:

adapter[](#adapter)
-------------------

*   default `undefined`

Your [adapter](/docs/kit/adapters) is run when executing `vite build`. It determines how the output is converted for different platforms.

alias[](#alias)
---------------

*   default `{}`

An object containing zero or more aliases used to replace values in `import` statements. These aliases are automatically passed to Vite and TypeScript.

svelte.config

    /** @type {import('@sveltejs/kit').Config} */
    const const config: {
        kit: {
            alias: {
     'my-file': string;
     'my-directory': string;
                'my-directory/*': string;
            };
        };
    }@type{import('@sveltejs/kit').Config}config = {
    	kit: {
        alias: {
            'my-file': string;
            'my-directory': string;
            'my-directory/*': string;
        };
    }kit: {
    		alias: {
        'my-file': string;
        'my-directory': string;
        'my-directory/*': string;
    }alias: {
    			// this will match a file
    			'my-file': 'path/to/my-file.js',
    
    			// this will match a directory and its contents
    			// (`my-directory/x` resolves to `path/to/my-directory/x`)
    			'my-directory': 'path/to/my-directory',
    
    			// an alias ending /* will only match
    			// the contents of a directory, not the directory itself
    			'my-directory/*': 'path/to/my-directory/*'
    		}
    	}
    };

> The built-in `$lib` alias is controlled by `config.kit.files.lib` as it is used for packaging.

> You will need to run `npm run dev` to have SvelteKit automatically generate the required alias configuration in `jsconfig.json` or `tsconfig.json`.

appDir[](#appDir)
-----------------

*   default `"_app"`

The directory where SvelteKit keeps its stuff, including static assets (such as JS and CSS) and internally-used routes.

If `paths.assets` is specified, there will be two app directories — `${paths.assets}/${appDir}` and `${paths.base}/${appDir}`.

csp[](#csp)
-----------

[Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) configuration. CSP helps to protect your users against cross-site scripting (XSS) attacks, by limiting the places resources can be loaded from. For example, a configuration like this...

svelte.config

    /** @type {import('@sveltejs/kit').Config} */
    const const config: {
        kit: {
            csp: {
     directives: {
       'script-src': string[];
     };
     reportOnly: {
       'script-src': string[];
       'report-uri': string[];
     };
            };
        };
    }@type{import('@sveltejs/kit').Config}config = {
    	kit: {
        csp: {
            directives: {
     'script-src': string[];
            };
            reportOnly: {
     'script-src': string[];
     'report-uri': string[];
            };
        };
    }kit: {
    		csp: {
        directives: {
            'script-src': string[];
        };
        reportOnly: {
            'script-src': string[];
            'report-uri': string[];
        };
    }csp: {
    			directives: {
        'script-src': string[];
    }directives: {
    				'script-src': ['self']
    			},
    			// must be specified with either the `report-uri` or `report-to` directives, or both
    			reportOnly: {
        'script-src': string[];
        'report-uri': string[];
    }reportOnly: {
    				'script-src': ['self'],
    				'report-uri': ['/']
    			}
    		}
    	}
    };
    
    export default const config: {
        kit: {
            csp: {
     directives: {
       'script-src': string[];
     };
     reportOnly: {
       'script-src': string[];
       'report-uri': string[];
                };
            };
        };
    }@type{import('@sveltejs/kit').Config}config;

...would prevent scripts loading from external sites. SvelteKit will augment the specified directives with nonces or hashes (depending on `mode`) for any inline styles and scripts it generates.

To add a nonce for scripts and links manually included in `src/app.html`, you may use the placeholder `%sveltekit.nonce%` (for example `<script nonce="%sveltekit.nonce%">`).

When pages are prerendered, the CSP header is added via a `<meta http-equiv>` tag (note that in this case, `frame-ancestors`, `report-uri` and `sandbox` directives will be ignored).

> When `mode` is `'auto'`, SvelteKit will use nonces for dynamically rendered pages and hashes for prerendered pages. Using nonces with prerendered pages is insecure and therefore forbidden.

> Note that most [Svelte transitions](/tutorial/svelte/transition) work by creating an inline `<style>` element. If you use these in your app, you must either leave the `style-src` directive unspecified or add `unsafe-inline`.

If this level of configuration is insufficient and you have more dynamic requirements, you can use the [`handle` hook](/docs/kit/hooks#Server-hooks-handle) to roll your own CSP.

    mode?: 'hash' | 'nonce' | 'auto';

Whether to use hashes or nonces to restrict `<script>` and `<style>` elements. `'auto'` will use hashes for prerendered pages, and nonces for dynamically rendered pages.

    directives?: CspDirectives;

Directives that will be added to `Content-Security-Policy` headers.

    reportOnly?: CspDirectives;

Directives that will be added to `Content-Security-Policy-Report-Only` headers.

csrf[](#csrf)
-------------

Protection against [cross-site request forgery (CSRF)](https://owasp.org/www-community/attacks/csrf) attacks.

    checkOrigin?: boolean;

*   default `true`

Whether to check the incoming `origin` header for `POST`, `PUT`, `PATCH`, or `DELETE` form submissions and verify that it matches the server’s origin.

To allow people to make `POST`, `PUT`, `PATCH`, or `DELETE` requests with a `Content-Type` of `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain` to your app from other origins, you will need to disable this option. Be careful!

embedded[](#embedded)
---------------------

*   default `false`

Whether or not the app is embedded inside a larger app. If `true`, SvelteKit will add its event listeners related to navigation etc on the parent of `%sveltekit.body%` instead of `window`, and will pass `params` from the server rather than inferring them from `location.pathname`. Note that it is generally not supported to embed multiple SvelteKit apps on the same page and use client-side SvelteKit features within them (things such as pushing to the history state assume a single instance).

env[](#env)
-----------

Environment variable configuration

    dir?: string;

*   default `"."`

The directory to search for `.env` files.

    publicPrefix?: string;

*   default `"PUBLIC_"`

A prefix that signals that an environment variable is safe to expose to client-side code. See [`$env/static/public`](/docs/kit/$env-static-public) and [`$env/dynamic/public`](/docs/kit/$env-dynamic-public). Note that Vite’s [`envPrefix`](https://vitejs.dev/config/shared-options.html#envprefix) must be set separately if you are using Vite’s environment variable handling - though use of that feature should generally be unnecessary.

    privatePrefix?: string;

*   default `""`
*   available since v1.21.0

A prefix that signals that an environment variable is unsafe to expose to client-side code. Environment variables matching neither the public nor the private prefix will be discarded completely. See [`$env/static/private`](/docs/kit/$env-static-private) and [`$env/dynamic/private`](/docs/kit/$env-dynamic-private).

files[](#files)
---------------

Where to find various files within your project.

    assets?: string;

*   default `"static"`

a place to put static files that should have stable URLs and undergo no processing, such as `favicon.ico` or `manifest.json`

    hooks?: {…}

    client?: string;

*   default `"src/hooks.client"`

The location of your client [hooks](/docs/kit/hooks).

    server?: string;

*   default `"src/hooks.server"`

The location of your server [hooks](/docs/kit/hooks).

    universal?: string;

*   default `"src/hooks"`
*   available since v2.3.0

The location of your universal [hooks](/docs/kit/hooks).

    lib?: string;

*   default `"src/lib"`

your app’s internal library, accessible throughout the codebase as `$lib`

    params?: string;

*   default `"src/params"`

a directory containing [parameter matchers](/docs/kit/advanced-routing#Matching)

    routes?: string;

*   default `"src/routes"`

the files that define the structure of your app (see [Routing](/docs/kit/routing))

    serviceWorker?: string;

*   default `"src/service-worker"`

the location of your service worker’s entry point (see [Service workers](/docs/kit/service-workers))

    appTemplate?: string;

*   default `"src/app.html"`

the location of the template for HTML responses

    errorTemplate?: string;

*   default `"src/error.html"`

the location of the template for fallback error responses

inlineStyleThreshold[](#inlineStyleThreshold)
---------------------------------------------

*   default `0`

Inline CSS inside a `<style>` block at the head of the HTML. This option is a number that specifies the maximum length of a CSS file in UTF-16 code units, as specified by the [String.length](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length) property, to be inlined. All CSS files needed for the page and smaller than this value are merged and inlined in a `<style>` block.

> This results in fewer initial requests and can improve your [First Contentful Paint](https://web.dev/first-contentful-paint) score. However, it generates larger HTML output and reduces the effectiveness of browser caches. Use it advisedly.

moduleExtensions[](#moduleExtensions)
-------------------------------------

*   default `[".js", ".ts"]`

An array of file extensions that SvelteKit will treat as modules. Files with extensions that match neither `config.extensions` nor `config.kit.moduleExtensions` will be ignored by the router.

outDir[](#outDir)
-----------------

*   default `".svelte-kit"`

The directory that SvelteKit writes files to during `dev` and `build`. You should exclude this directory from version control.

output[](#output)
-----------------

Options related to the build output format

    preloadStrategy?: 'modulepreload' | 'preload-js' | 'preload-mjs';

*   default `"modulepreload"`
*   available since v1.8.4

SvelteKit will preload the JavaScript modules needed for the initial page to avoid import ‘waterfalls’, resulting in faster application startup. There are three strategies with different trade-offs:

*   `modulepreload` - uses `<link rel="modulepreload">`. This delivers the best results in Chromium-based browsers, in Firefox 115+, and Safari 17+. It is ignored in older browsers.
*   `preload-js` - uses `<link rel="preload">`. Prevents waterfalls in Chromium and Safari, but Chromium will parse each module twice (once as a script, once as a module). Causes modules to be requested twice in Firefox. This is a good setting if you want to maximise performance for users on iOS devices at the cost of a very slight degradation for Chromium users.
*   `preload-mjs` - uses `<link rel="preload">` but with the `.mjs` extension which prevents double-parsing in Chromium. Some static webservers will fail to serve .mjs files with a `Content-Type: application/javascript` header, which will cause your application to break. If that doesn’t apply to you, this is the option that will deliver the best performance for the largest number of users, until `modulepreload` is more widely supported.

    bundleStrategy?: 'split' | 'single' | 'inline';

*   default `'split'`
*   available since v2.13.0

The bundle strategy option affects how your app’s JavaScript and CSS files are loaded.

*   If `'split'`, splits the app up into multiple .js/.css files so that they are loaded lazily as the user navigates around the app. This is the default, and is recommended for most scenarios.
*   If `'single'`, creates just one .js bundle and one .css file containing code for the entire app.
*   If `'inline'`, inlines all JavaScript and CSS of the entire app into the HTML. The result is usable without a server (i.e. you can just open the file in your browser).

When using `'split'`, you can also adjust the bundling behaviour by setting [`output.experimentalMinChunkSize`](https://rollupjs.org/configuration-options/#output-experimentalminchunksize) and [`output.manualChunks`](https://rollupjs.org/configuration-options/#output-manualchunks) inside your Vite config’s [`build.rollupOptions`](https://vite.dev/config/build-options.html#build-rollupoptions).

If you want to inline your assets, you’ll need to set Vite’s [`build.assetsInlineLimit`](https://vite.dev/config/build-options.html#build-assetsinlinelimit) option to an appropriate size then import your assets through Vite.

vite.config

    import { function sveltekit(): Promise<Plugin<any>[]>Returns the SvelteKit Vite plugins.
    sveltekit } from '@sveltejs/kit/vite';
    import { function defineConfig(config: UserConfig): UserConfig (+3 overloads)Type helper to make it easier to use vite.config.ts
    accepts a direct 
    {@link 
    UserConfig
    }
     object, or a function that returns it.
    The function receives a 
    {@link 
    ConfigEnv
    }
     object.
    defineConfig } from 'vite';
    
    export default function defineConfig(config: UserConfig): UserConfig (+3 overloads)Type helper to make it easier to use vite.config.ts
    accepts a direct 
    {@link 
    UserConfig
    }
     object, or a function that returns it.
    The function receives a 
    {@link 
    ConfigEnv
    }
     object.
    defineConfig({
    	UserConfig.plugins?: PluginOption[] | undefinedArray of vite plugins to use.
    plugins: [function sveltekit(): Promise<Plugin<any>[]>Returns the SvelteKit Vite plugins.
    sveltekit()],
    	UserConfig.build?: BuildOptions | undefinedBuild specific options
    build: {
    		// inline all imported assets
    		BuildOptions.assetsInlineLimit?: number | ((filePath: string, content: Buffer) => boolean | undefined) | undefinedStatic asset files smaller than this number (in bytes) will be inlined as
    base64 strings. Default limit is 4096 (4 KiB). Set to 0 to disable.
    @default4096assetsInlineLimit: var Infinity: numberInfinity
    	}
    });

src/routes/+layout

    <script>
    	// import the asset through Vite
    	import favicon from './favicon.png';
    </script>
    
    <svelte:head>
    	<!-- this asset will be inlined as a base64 URL -->
    	<link rel="icon" href={favicon} />
    </svelte:head>

    <script lang="ts">
    	// import the asset through Vite
    	import favicon from './favicon.png';
    </script>
    
    <svelte:head>
    	<!-- this asset will be inlined as a base64 URL -->
    	<link rel="icon" href={favicon} />
    </svelte:head>

paths[](#paths)
---------------

    assets?: '' | `http://${string}` | `https://${string}`;

*   default `""`

An absolute path that your app’s files are served from. This is useful if your files are served from a storage bucket of some kind.

    base?: '' | `/${string}`;

*   default `""`

A root-relative path that must start, but not end with `/` (e.g. `/base-path`), unless it is the empty string. This specifies where your app is served from and allows the app to live on a non-root path. Note that you need to prepend all your root-relative links with the base value or they will point to the root of your domain, not your `base` (this is how the browser works). You can use [`base` from `$app/paths`](/docs/kit/$app-paths#base) for that: `<a href="{base}/your-page">Link</a>`. If you find yourself writing this often, it may make sense to extract this into a reusable component.

    relative?: boolean;

*   default `true`
*   available since v1.9.0

Whether to use relative asset paths.

If `true`, `base` and `assets` imported from `$app/paths` will be replaced with relative asset paths during server-side rendering, resulting in more portable HTML. If `false`, `%sveltekit.assets%` and references to build artifacts will always be root-relative paths, unless `paths.assets` is an external URL

[Single-page app](/docs/kit/single-page-apps) fallback pages will always use absolute paths, regardless of this setting.

If your app uses a `<base>` element, you should set this to `false`, otherwise asset URLs will incorrectly be resolved against the `<base>` URL rather than the current page.

In 1.0, `undefined` was a valid value, which was set by default. In that case, if `paths.assets` was not external, SvelteKit would replace `%sveltekit.assets%` with a relative path and use relative paths to reference build artifacts, but `base` and `assets` imported from `$app/paths` would be as specified in your config.

prerender[](#prerender)
-----------------------

See [Prerendering](/docs/kit/page-options#prerender).

    concurrency?: number;

*   default `1`

How many pages can be prerendered simultaneously. JS is single-threaded, but in cases where prerendering performance is network-bound (for example loading content from a remote CMS) this can speed things up by processing other tasks while waiting on the network response.

    crawl?: boolean;

*   default `true`

Whether SvelteKit should find pages to prerender by following links from `entries`.

    entries?: var Array: ArrayConstructorArray<'*' | `/${string}`>;

*   default `["*"]`

An array of pages to prerender, or start crawling from (if `crawl: true`). The `*` string includes all routes containing no required `[parameters]` with optional parameters included as being empty (since SvelteKit doesn’t know what value any parameters should have).

    handleHttpError?: PrerenderHttpErrorHandlerValue;

*   default `"fail"`
*   available since v1.15.7

How to respond to HTTP errors encountered while prerendering the app.

*   `'fail'` — fail the build
*   `'ignore'` - silently ignore the failure and continue
*   `'warn'` — continue, but print a warning
*   `(details) => void` — a custom error handler that takes a `details` object with `status`, `path`, `referrer`, `referenceType` and `message` properties. If you `throw` from this function, the build will fail

svelte.config

    /** @type {import('@sveltejs/kit').Config} */
    const const config: {
        kit: {
            prerender: {
     handleHttpError: ({ path, referrer, message }: {
       path: any;
       referrer: any;
         message: any;
     }) => void;
            };
        };
    }@type{import('@sveltejs/kit').Config}config = {
    	kit: {
        prerender: {
            handleHttpError: ({ path, referrer, message }: {
     path: any;
     referrer: any;
     message: any;
            }) => void;
        };
    }kit: {
    		prerender: {
        handleHttpError: ({ path, referrer, message }: {
            path: any;
            referrer: any;
            message: any;
        }) => void;
    }prerender: {
    			handleHttpError: ({ path, referrer, message }: {
        path: any;
        referrer: any;
        message: any;
    }) => voidhandleHttpError: ({ path: anypath, referrer: anyreferrer, message: anymessage }) => {
    				// ignore deliberate link to shiny 404 page
    				if (path: anypath === '/not-found' && referrer: anyreferrer === '/blog/how-we-built-our-404-page') {
    					return;
    				}
    
    				// otherwise fail the build
    				throw new var Error: ErrorConstructor
    new (message?: string, options?: ErrorOptions) => Error (+1 overload)Error(message: anymessage);
    			}
    		}
    	}
    };

    handleMissingId?: PrerenderMissingIdHandlerValue;

*   default `"fail"`
*   available since v1.15.7

How to respond when hash links from one prerendered page to another don’t correspond to an `id` on the destination page.

*   `'fail'` — fail the build
*   `'ignore'` - silently ignore the failure and continue
*   `'warn'` — continue, but print a warning
*   `(details) => void` — a custom error handler that takes a `details` object with `path`, `id`, `referrers` and `message` properties. If you `throw` from this function, the build will fail

    handleEntryGeneratorMismatch?: PrerenderEntryGeneratorMismatchHandlerValue;

*   default `"fail"`
*   available since v1.16.0

How to respond when an entry generated by the `entries` export doesn’t match the route it was generated from.

*   `'fail'` — fail the build
*   `'ignore'` - silently ignore the failure and continue
*   `'warn'` — continue, but print a warning
*   `(details) => void` — a custom error handler that takes a `details` object with `generatedFromId`, `entry`, `matchedId` and `message` properties. If you `throw` from this function, the build will fail

    var origin: stringMDN Reference
    origin?: string;

*   default `"http://sveltekit-prerender"`

The value of `url.origin` during prerendering; useful if it is included in rendered content.

router[](#router)
-----------------

    type?: 'pathname' | 'hash';

*   default `"pathname"`
*   available since v2.14.0

What type of client-side router to use.

*   `'pathname'` is the default and means the current URL pathname determines the route
*   `'hash'` means the route is determined by `location.hash`. In this case, SSR and prerendering are disabled. This is only recommended if `pathname` is not an option, for example because you don’t control the webserver where your app is deployed. It comes with some caveats: you can’t use server-side rendering (or indeed any server logic), and you have to make sure that the links in your app all start with #/, or they won’t work. Beyond that, everything works exactly like a normal SvelteKit app.

    resolution?: 'client' | 'server';

*   default `"client"`
*   available since v2.17.0

How to determine which route to load when navigating to a new page.

By default, SvelteKit will serve a route manifest to the browser. When navigating, this manifest is used (along with the `reroute` hook, if it exists) to determine which components to load and which `load` functions to run. Because everything happens on the client, this decision can be made immediately. The drawback is that the manifest needs to be loaded and parsed before the first navigation can happen, which may have an impact if your app contains many routes.

Alternatively, SvelteKit can determine the route on the server. This means that for every navigation to a path that has not yet been visited, the server will be asked to determine the route. This has several advantages:

*   The client does not need to load the routing manifest upfront, which can lead to faster initial page loads
*   The list of routes is hidden from public view
*   The server has an opportunity to intercept each navigation (for example through a middleware), enabling (for example) A/B testing opaque to SvelteKit

The drawback is that for unvisited paths, resolution will take slightly longer (though this is mitigated by [preloading](/docs/kit/link-options#data-sveltekit-preload-data)).

> When using server-side route resolution and prerendering, the resolution is prerendered along with the route itself.

serviceWorker[](#serviceWorker)
-------------------------------

    register?: boolean;

*   default `true`

Whether to automatically register the service worker, if it exists.

    files?(filepath: stringfilepath: string): boolean;

*   default `(filename) => !/\.DS_Store/.test(filename)`

Determine which files in your `static` directory will be available in `$service-worker.files`.

typescript[](#typescript)
-------------------------

    config?: (config: Record<string, any>config: type Record<K extends keyof any, T> = { [P in K]: T; }Construct a type with a set of properties K of type T
    Record<string, any>) => Record<string, any> | void;

*   default `(config) => config`
*   available since v1.3.0

A function that allows you to edit the generated `tsconfig.json`. You can mutate the config (recommended) or return a new one. This is useful for extending a shared `tsconfig.json` in a monorepo root, for example.

version[](#version)
-------------------

Client-side navigation can be buggy if you deploy a new version of your app while people are using it. If the code for the new page is already loaded, it may have stale content; if it isn’t, the app’s route manifest may point to a JavaScript file that no longer exists. SvelteKit helps you solve this problem through version management. If SvelteKit encounters an error while loading the page and detects that a new version has been deployed (using the `name` specified here, which defaults to a timestamp of the build) it will fall back to traditional full-page navigation. Not all navigations will result in an error though, for example if the JavaScript for the next page is already loaded. If you still want to force a full-page navigation in these cases, use techniques such as setting the `pollInterval` and then using `beforeNavigate`:

+layout

    <script>
    	import { beforeNavigate } from '$app/navigation';
    	import { updated } from '$app/state';
    
    	beforeNavigate(({ willUnload, to }) => {
    		if (updated.current && !willUnload && to?.url) {
    			location.href = to.url.href;
    		}
    	});
    </script>

If you set `pollInterval` to a non-zero value, SvelteKit will poll for new versions in the background and set the value of [`updated.current`](/docs/kit/$app-state#updated) `true` when it detects one.

    const name: void@deprecatedname?: string;

The current app version string. If specified, this must be deterministic (e.g. a commit ref rather than `Math.random()` or `Date.now().toString()`), otherwise defaults to a timestamp of the build.

For example, to use the current commit hash, you could do use `git rev-parse HEAD`:

svelte.config

    import * as module "node:child_process"child_process from 'node:child_process';
    
    export default {
    	kit: {
        version: {
            name: string;
        };
    }kit: {
    		version: {
        name: string;
    }version: {
    			name: stringname: module "node:child_process"child_process.function execSync(command: string): Buffer (+3 overloads)The child_process.execSync() method is generally identical to 
    {@link 
    exec
    }
     with the exception that the method will not return
    until the child process has fully closed. When a timeout has been encountered
    and killSignal is sent, the method won’t return until the process has
    completely exited. If the child process intercepts and handles the SIGTERM signal and doesn’t exit, the parent process will wait until the child process
    has exited.
    If the process times out or has a non-zero exit code, this method will throw.
    The Error object will contain the entire result from 
    {@link 
    spawnSync
    }
    .
    Never pass unsanitized user input to this function. Any input containing shell
    metacharacters may be used to trigger arbitrary command execution.
    @sincev0.11.12@paramcommand The command to run.@returnThe stdout from the command.execSync('git rev-parse HEAD').Buffer.toString(encoding?: BufferEncoding, start?: number, end?: number): stringDecodes buf to a string according to the specified character encoding inencoding. start and end may be passed to decode only a subset of buf.
    If encoding is 'utf8' and a byte sequence in the input is not valid UTF-8,
    then each invalid byte is replaced with the replacement character U+FFFD.
    The maximum length of a string instance (in UTF-16 code units) is available
    as 
    {@link 
    constants.MAX_STRING_LENGTH
    }
    .
    import { Buffer } from 'node:buffer';
    
    const buf1 = Buffer.allocUnsafe(26);
    
    for (let i = 0; i &#x3C; 26; i++) {
      // 97 is the decimal ASCII value for 'a'.
      buf1[i] = i + 97;
    }
    
    console.log(buf1.toString('utf8'));
    // Prints: abcdefghijklmnopqrstuvwxyz
    console.log(buf1.toString('utf8', 0, 5));
    // Prints: abcde
    
    const buf2 = Buffer.from('tést');
    
    console.log(buf2.toString('hex'));
    // Prints: 74c3a97374
    console.log(buf2.toString('utf8', 0, 3));
    // Prints: té
    console.log(buf2.toString(undefined, 0, 3));
    // Prints: té@sincev0.1.90@paramencoding The character encoding to use.@paramstart The byte offset to start decoding at.@paramend The byte offset to stop decoding at (not inclusive).toString().String.trim(): stringRemoves the leading and trailing white space and line terminator characters from a string.
    trim()
    		}
    	}
    };

    pollInterval?: number;

*   default `0`

The interval in milliseconds to poll for version changes. If this is `0`, no polling occurs.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/50-configuration.md) [llms.txt](/docs/kit/configuration/llms.txt)

previous next

[$service-worker](/docs/kit/$service-worker) [Command Line Interface](/docs/kit/cli)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

Command Line Interface
======================

### On this page

*   [Command Line Interface](/docs/kit/cli)
*   [svelte-kit sync](#svelte-kit-sync)

SvelteKit projects use [Vite](https://vitejs.dev), meaning you’ll mostly use its CLI (albeit via `npm run dev/build/preview` scripts):

*   `vite dev` — start a development server
*   `vite build` — build a production version of your app
*   `vite preview` — run the production version locally

However SvelteKit includes its own CLI for initialising your project:

svelte-kit sync[](#svelte-kit-sync)
-----------------------------------

`svelte-kit sync` creates the `tsconfig.json` and all generated types (which you can import as `./$types` inside routing files) for your project. When you create a new project, it is listed as the `prepare` script and will be run automatically as part of the npm lifecycle, so you should not ordinarily have to run this command.

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/52-cli.md) [llms.txt](/docs/kit/cli/llms.txt)

previous next

[Configuration](/docs/kit/configuration) [Types](/docs/kit/types)

*   ### Getting started
    
    *   [Introduction](/docs/kit/introduction)
    *   [Creating a project](/docs/kit/creating-a-project)
    *   [Project types](/docs/kit/project-types)
    *   [Project structure](/docs/kit/project-structure)
    *   [Web standards](/docs/kit/web-standards)
*   ### Core concepts
    
    *   [Routing](/docs/kit/routing)
    *   [Loading data](/docs/kit/load)
    *   [Form actions](/docs/kit/form-actions)
    *   [Page options](/docs/kit/page-options)
    *   [State management](/docs/kit/state-management)
*   ### Build and deploy
    
    *   [Building your app](/docs/kit/building-your-app)
    *   [Adapters](/docs/kit/adapters)
    *   [Zero-config deployments](/docs/kit/adapter-auto)
    *   [Node servers](/docs/kit/adapter-node)
    *   [Static site generation](/docs/kit/adapter-static)
    *   [Single-page apps](/docs/kit/single-page-apps)
    *   [Cloudflare](/docs/kit/adapter-cloudflare)
    *   [Cloudflare Workers](/docs/kit/adapter-cloudflare-workers)
    *   [Netlify](/docs/kit/adapter-netlify)
    *   [Vercel](/docs/kit/adapter-vercel)
    *   [Writing adapters](/docs/kit/writing-adapters)
*   ### Advanced
    
    *   [Advanced routing](/docs/kit/advanced-routing)
    *   [Hooks](/docs/kit/hooks)
    *   [Errors](/docs/kit/errors)
    *   [Link options](/docs/kit/link-options)
    *   [Service workers](/docs/kit/service-workers)
    *   [Server-only modules](/docs/kit/server-only-modules)
    *   [Snapshots](/docs/kit/snapshots)
    *   [Shallow routing](/docs/kit/shallow-routing)
    *   [Packaging](/docs/kit/packaging)
*   ### Best practices
    
    *   [Auth](/docs/kit/auth)
    *   [Performance](/docs/kit/performance)
    *   [Icons](/docs/kit/icons)
    *   [Images](/docs/kit/images)
    *   [Accessibility](/docs/kit/accessibility)
    *   [SEO](/docs/kit/seo)
*   ### Appendix
    
    *   [Frequently asked questions](/docs/kit/faq)
    *   [Integrations](/docs/kit/integrations)
    *   [Breakpoint Debugging](/docs/kit/debugging)
    *   [Migrating to SvelteKit v2](/docs/kit/migrating-to-sveltekit-2)
    *   [Migrating from Sapper](/docs/kit/migrating)
    *   [Additional resources](/docs/kit/additional-resources)
    *   [Glossary](/docs/kit/glossary)
*   ### Reference
    
    *   [@sveltejs/kit](/docs/kit/@sveltejs-kit)
    *   [@sveltejs/kit/hooks](/docs/kit/@sveltejs-kit-hooks)
    *   [@sveltejs/kit/node/polyfills](/docs/kit/@sveltejs-kit-node-polyfills)
    *   [@sveltejs/kit/node](/docs/kit/@sveltejs-kit-node)
    *   [@sveltejs/kit/vite](/docs/kit/@sveltejs-kit-vite)
    *   [$app/environment](/docs/kit/$app-environment)
    *   [$app/forms](/docs/kit/$app-forms)
    *   [$app/navigation](/docs/kit/$app-navigation)
    *   [$app/paths](/docs/kit/$app-paths)
    *   [$app/server](/docs/kit/$app-server)
    *   [$app/state](/docs/kit/$app-state)
    *   [$app/stores](/docs/kit/$app-stores)
    *   [$env/dynamic/private](/docs/kit/$env-dynamic-private)
    *   [$env/dynamic/public](/docs/kit/$env-dynamic-public)
    *   [$env/static/private](/docs/kit/$env-static-private)
    *   [$env/static/public](/docs/kit/$env-static-public)
    *   [$lib](/docs/kit/$lib)
    *   [$service-worker](/docs/kit/$service-worker)
    *   [Configuration](/docs/kit/configuration)
    *   [Command Line Interface](/docs/kit/cli)
    *   [Types](/docs/kit/types)

SvelteKitReference

Types
=====

### On this page

*   [Types](/docs/kit/types)
*   [Generated types](#Generated-types)
*   [$lib](#$lib)
*   [app.d.ts](#app.d.ts)
*   [Error](#Error)
*   [Locals](#Locals)
*   [PageData](#PageData)
*   [PageState](#PageState)
*   [Platform](#Platform)

Generated types[](#Generated-types)
-----------------------------------

The `RequestHandler` and `Load` types both accept a `Params` argument allowing you to type the `params` object. For example this endpoint expects `foo`, `bar` and `baz` params:

src/routes/\[foo\]/\[bar\]/\[baz\]/+server

    /** @type {import('@sveltejs/kit').RequestHandler<{
    	foo: string;
    	bar: string;
    	baz: string
      }>} */
    export async function function GET({ params }: {
        params: any;
    }): Promise<void>@type{import('@sveltejs/kit').RequestHandler<{
    	foo: string;
    	bar: string;
    	baz: string
      }>}GET({ params: anyparams }) {
    	// ...
    }

    import type { type RequestHandler<Params extends Partial<Record<string, string>> = Partial<Record<string, string>>, RouteId extends string | null = string | null> = (event: RequestEvent<Params, RouteId>) => MaybePromise<Response>A (event: RequestEvent) => Response function exported from a +server.js file that corresponds to an HTTP verb (GET, PUT, PATCH, etc) and handles requests with that method.
    It receives Params as the first generic argument, which you can skip by using generated types instead.
    RequestHandler } from '@sveltejs/kit';
    export const const GET: RequestHandler<{
        foo: string;
        bar: string;
        baz: string;
    }>GET: type RequestHandler<Params extends Partial<Record<string, string>> = Partial<Record<string, string>>, RouteId extends string | null = string | null> = (event: RequestEvent<Params, RouteId>) => MaybePromise<Response>A (event: RequestEvent) => Response function exported from a +server.js file that corresponds to an HTTP verb (GET, PUT, PATCH, etc) and handles requests with that method.
    It receives Params as the first generic argument, which you can skip by using generated types instead.
    RequestHandler<{
    	foo: stringfoo: string;
    	bar: stringbar: string;
    	baz: stringbaz: string
      }> = async ({ params: {
        foo: string;
        bar: string;
        baz: string;
    }The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) => {
    	// ...
    };

Needless to say, this is cumbersome to write out, and less portable (if you were to rename the `[foo]` directory to `[qux]`, the type would no longer reflect reality).

To solve this problem, SvelteKit generates `.d.ts` files for each of your endpoints and pages:

.svelte-kit/types/src/routes/\[foo\]/\[bar\]/\[baz\]/$types.d

    import type * as module "@sveltejs/kit"Kit from '@sveltejs/kit';
    
    type type RouteParams = {
        foo: string;
        bar: string;
        baz: string;
    }RouteParams = {
    	foo: stringfoo: string;
    	bar: stringbar: string;
    	baz: stringbaz: string;
    };
    
    export type type RequestHandler = (event: Kit.RequestEvent<RouteParams, string | null>) => MaybePromise<Response>RequestHandler = module "@sveltejs/kit"Kit.type RequestHandler<Params extends Partial<Record<string, string>> = Partial<Record<string, string>>, RouteId extends string | null = string | null> = (event: Kit.RequestEvent<Params, RouteId>) => MaybePromise<Response>A (event: RequestEvent) => Response function exported from a +server.js file that corresponds to an HTTP verb (GET, PUT, PATCH, etc) and handles requests with that method.
    It receives Params as the first generic argument, which you can skip by using generated types instead.
    RequestHandler<type RouteParams = {
        foo: string;
        bar: string;
        baz: string;
    }RouteParams>;
    export type type PageLoad = (event: Kit.LoadEvent<RouteParams, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = module "@sveltejs/kit"Kit.type Load<Params extends Partial<Record<string, string>> = Partial<Record<string, string>>, InputData extends Record<string, unknown> | null = Record<string, any> | null, ParentData extends Record<string, unknown> = Record<...>, OutputData extends Record<string, unknown> | void = void | Record<...>, RouteId extends string | null = string | null> = (event: Kit.LoadEvent<Params, InputData, ParentData, RouteId>) => MaybePromise<OutputData>The generic form of PageLoad and LayoutLoad. You should import those from ./$types (see generated types)
    rather than using Load directly.
    Load<type RouteParams = {
        foo: string;
        bar: string;
        baz: string;
    }RouteParams>;

These files can be imported into your endpoints and pages as siblings, thanks to the [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs) option in your TypeScript configuration:

src/routes/\[foo\]/\[bar\]/\[baz\]/+server

    /** @type {import('./$types').RequestHandler} */
    export async function GET({ params: RouteParamsThe parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) {
    	// ...
    }

    import type { type RequestHandler = (event: RequestEvent<RouteParams, string | null>) => MaybePromise<Response>RequestHandler } from './$types';
    
    export const GET: type RequestHandler = (event: RequestEvent<RouteParams, string | null>) => MaybePromise<Response>RequestHandler = async ({ params: RouteParamsThe parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.
    params }) => {
    	// ...
    };

src/routes/\[foo\]/\[bar\]/\[baz\]/+page

    /** @type {import('./$types').PageLoad} */
    export async function function load(event: LoadEvent<RouteParams, Record<string, any> | null, Record<string, any>, string | null>): MaybePromise<void | Record<string, any>>@type{import('./$types').PageLoad}load({ params: RouteParamsThe parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params, fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here
    fetch }) {
    	// ...
    }

    import type { type PageLoad = (event: LoadEvent<RouteParams, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad } from './$types';
    
    export const const load: PageLoadload: type PageLoad = (event: LoadEvent<RouteParams, Record<string, any> | null, Record<string, any>, string | null>) => MaybePromise<void | Record<string, any>>PageLoad = async ({ params: RouteParamsThe parameters of the current page - e.g. for a route like /blog/[slug], a { slug: string } object
    params, fetch: {
        (input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
        (input: string | URL | globalThis.Request, init?: RequestInit): Promise<Response>;
    }fetch is equivalent to the native fetch web API, with a few additional features:
    
    It can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers for the page request.
    It can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context).
    Internal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.
    During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the text and json methods of the Response object. Note that headers will not be serialized, unless explicitly included via filterSerializedResponseHeaders
    During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request.
    
    You can learn more about making credentialed requests with cookies here
    fetch }) => {
    	// ...
    };

The return types of the load functions are then available through the `$types` module as `PageData` and `LayoutData` respectively, while the union of the return values of all `Actions` is available as `ActionData`.

Starting with version 2.16.0, two additional helper types are provided: `PageProps` defines `data: PageData`, as well as `form: ActionData`, when there are actions defined, while `LayoutProps` defines `data: LayoutData`, as well as `children: Snippet`.

src/routes/+page

    <script>
    	/** @type {import('./$types').PageProps} */
    	let { data, form } = $props();
    </script>

    <script lang="ts">
    	import type { PageProps } from './$types';
    
    	let { data, form }: PageProps = $props();
    </script>

> Legacy mode
> 
> Before 2.16.0:
> 
> src/routes/+page
> 
>     <script>
>     	/** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */
>     	let { data, form } = $props();
>     </script>
> 
>     <script lang="ts">
>     	import type { PageData, ActionData } from './$types';
>     
>     	let { data, form }: { data: PageData, form: ActionData } = $props();
>     </script>
> 
> Using Svelte 4:
> 
> src/routes/+page
> 
>     <script>
>       /** @type {import('./$types').PageData} */
>       export let data;
>       /** @type {import('./$types').ActionData} */
>       export let form;
>     </script>
> 
>     <script lang="ts">
>     	import type { PageData, ActionData } from './$types';
>     
>       
>       export let data: PageData;
>       
>       export let form: ActionData;
>     </script>

> For this to work, your own `tsconfig.json` or `jsconfig.json` should extend from the generated `.svelte-kit/tsconfig.json` (where `.svelte-kit` is your [`outDir`](configuration#outDir)):
> 
> `{ "extends": "./.svelte-kit/tsconfig.json" }`

### Default tsconfig.json[](#Generated-types-Default-tsconfig.json)

The generated `.svelte-kit/tsconfig.json` file contains a mixture of options. Some are generated programmatically based on your project configuration, and should generally not be overridden without good reason:

.svelte-kit/tsconfig

    {
    	"compilerOptions": {
    		"paths": {
    			"$lib": ["../src/lib"],
    			"$lib/*": ["../src/lib/*"]
    		},
    		"rootDirs": ["..", "./types"]
    	},
    	"include": [
    		"ambient.d.ts",
    		"non-ambient.d.ts",
    		"./types/**/$types.d.ts",
    		"../vite.config.js",
    		"../vite.config.ts",
    		"../src/**/*.js",
    		"../src/**/*.ts",
    		"../src/**/*.svelte",
    		"../tests/**/*.js",
    		"../tests/**/*.ts",
    		"../tests/**/*.svelte"
    	],
    	"exclude": [
    		"../node_modules/**",
    		"../src/service-worker.js",
    		"../src/service-worker/**/*.js",
    		"../src/service-worker.ts",
    		"../src/service-worker/**/*.ts",
    		"../src/service-worker.d.ts",
    		"../src/service-worker/**/*.d.ts"
    	]
    }

Others are required for SvelteKit to work properly, and should also be left untouched unless you know what you’re doing:

.svelte-kit/tsconfig

    {
    	"compilerOptions": {
    		// this ensures that types are explicitly
    		// imported with `import type`, which is
    		// necessary as Svelte/Vite cannot
    		// otherwise compile components correctly
    		"verbatimModuleSyntax": true,
    
    		// Vite compiles one TypeScript module
    		// at a time, rather than compiling
    		// the entire module graph
    		"isolatedModules": true,
    
    		// Tell TS it's used only for type-checking
    		"noEmit": true,
    
    		// This ensures both `vite build`
    		// and `svelte-package` work correctly
    		"lib": ["esnext", "DOM", "DOM.Iterable"],
    		"moduleResolution": "bundler",
    		"module": "esnext",
    		"target": "esnext"
    	}
    }

$lib[](#$lib)
-------------

This is a simple alias to `src/lib`, or whatever directory is specified as [`config.kit.files.lib`](configuration#files). It allows you to access common components and utility modules without `../../../../` nonsense.

### $lib/server[](#$lib-$lib-server)

A subdirectory of `$lib`. SvelteKit will prevent you from importing any modules in `$lib/server` into client-side code. See [server-only modules](server-only-modules).

app.d.ts[](#app.d.ts)
---------------------

The `app.d.ts` file is home to the ambient types of your apps, i.e. types that are available without explicitly importing them.

Always part of this file is the `App` namespace. This namespace contains several types that influence the shape of certain SvelteKit features you interact with.

Error[](#Error)
---------------

Defines the common shape of expected and unexpected errors. Expected errors are thrown using the `error` function. Unexpected errors are handled by the `handleError` hooks which should return this shape.

    interface Error {…}

    message: string;

Locals[](#Locals)
-----------------

The interface that defines `event.locals`, which can be accessed in server [hooks](/docs/kit/hooks) (`handle`, and `handleError`), server-only `load` functions, and `+server.js` files.

    interface Locals {}

PageData[](#PageData)
---------------------

Defines the common shape of the [page.data state](/docs/kit/$app-state#page) and [$page.data store](/docs/kit/$app-stores#page) - that is, the data that is shared between all pages. The `Load` and `ServerLoad` functions in `./$types` will be narrowed accordingly. Use optional properties for data that is only present on specific pages. Do not add an index signature (`[key: string]: any`).

    interface PageData {}

PageState[](#PageState)
-----------------------

The shape of the `page.state` object, which can be manipulated using the [`pushState`](/docs/kit/$app-navigation#pushState) and [`replaceState`](/docs/kit/$app-navigation#replaceState) functions from `$app/navigation`.

    interface PageState {}

Platform[](#Platform)
---------------------

If your adapter provides [platform-specific context](/docs/kit/adapters#Platform-specific-context) via `event.platform`, you can specify it here.

    interface Platform {}

[Edit this page on GitHub](https://github.com/sveltejs/kit/edit/main/documentation/docs/98-reference/54-types.md) [llms.txt](/docs/kit/types/llms.txt)

previous next

[Command Line Interface](/docs/kit/cli)