[](#react-router-home)React Router Home
=======================================

React Router is a multi-strategy router for React bridging the gap from React 18 to React 19. You can use it maximally as a React framework or as minimally as you want.

[](#getting-started)Getting Started
-----------------------------------

There are three primary ways, or "modes", to use it in your app, so there are three guides to get you started.

*   [Declarative](./start/declarative/installation)
*   [Data](./start/data/custom)
*   [Framework](./start/framework/installation)

Learn which mode is right for you in [Picking a Mode](./start/modes).

[](#using-these-guides)Using These Guides
-----------------------------------------

Across the docs you'll see the following icons:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

These icons indicate which mode the content is relevant to.

Additional auto-generated reference documentation is available:

[Autogenerated Reference Docs ↗](https://api.reactrouter.com/v7/modules/react_router.html)

[](#upgrading)Upgrading
-----------------------

If you are caught up on future flags, upgrading from React Router v6 or Remix v2 is generally non-breaking. Remix v2 apps are encouraged to upgrade to React Router v7.

*   [Upgrade from v6](./upgrading/v6)
*   [Upgrade from Remix](./upgrading/remix)

[](#react-router-home)React Router Home
=======================================

React Router is a multi-strategy router for React bridging the gap from React 18 to React 19. You can use it maximally as a React framework or as minimally as you want.

[](#getting-started)Getting Started
-----------------------------------

There are three primary ways, or "modes", to use it in your app, so there are three guides to get you started.

*   [Declarative](./start/declarative/installation)
*   [Data](./start/data/custom)
*   [Framework](./start/framework/installation)

Learn which mode is right for you in [Picking a Mode](./start/modes).

[](#using-these-guides)Using These Guides
-----------------------------------------

Across the docs you'll see the following icons:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

These icons indicate which mode the content is relevant to.

Additional auto-generated reference documentation is available:

[Autogenerated Reference Docs ↗](https://api.reactrouter.com/v7/modules/react_router.html)

[](#upgrading)Upgrading
-----------------------

If you are caught up on future flags, upgrading from React Router v6 or Remix v2 is generally non-breaking. Remix v2 apps are encouraged to upgrade to React Router v7.

*   [Upgrade from v6](./upgrading/v6)
*   [Upgrade from Remix](./upgrading/remix)

[](#react-router-home)React Router Home
=======================================

React Router is a multi-strategy router for React bridging the gap from React 18 to React 19. You can use it maximally as a React framework or as minimally as you want.

[](#getting-started)Getting Started
-----------------------------------

There are three primary ways, or "modes", to use it in your app, so there are three guides to get you started.

*   [Declarative](./start/declarative/installation)
*   [Data](./start/data/custom)
*   [Framework](./start/framework/installation)

Learn which mode is right for you in [Picking a Mode](./start/modes).

[](#using-these-guides)Using These Guides
-----------------------------------------

Across the docs you'll see the following icons:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

These icons indicate which mode the content is relevant to.

Additional auto-generated reference documentation is available:

[Autogenerated Reference Docs ↗](https://api.reactrouter.com/v7/modules/react_router.html)

[](#upgrading)Upgrading
-----------------------

If you are caught up on future flags, upgrading from React Router v6 or Remix v2 is generally non-breaking. Remix v2 apps are encouraged to upgrade to React Router v7.

*   [Upgrade from v6](./upgrading/v6)
*   [Upgrade from Remix](./upgrading/remix)

[](#react-router-home)React Router Home
=======================================

React Router is a multi-strategy router for React bridging the gap from React 18 to React 19. You can use it maximally as a React framework or as minimally as you want.

[](#getting-started)Getting Started
-----------------------------------

There are three primary ways, or "modes", to use it in your app, so there are three guides to get you started.

*   [Declarative](./start/declarative/installation)
*   [Data](./start/data/custom)
*   [Framework](./start/framework/installation)

Learn which mode is right for you in [Picking a Mode](./start/modes).

[](#using-these-guides)Using These Guides
-----------------------------------------

Across the docs you'll see the following icons:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

These icons indicate which mode the content is relevant to.

Additional auto-generated reference documentation is available:

[Autogenerated Reference Docs ↗](https://api.reactrouter.com/v7/modules/react_router.html)

[](#upgrading)Upgrading
-----------------------

If you are caught up on future flags, upgrading from React Router v6 or Remix v2 is generally non-breaking. Remix v2 apps are encouraged to upgrade to React Router v7.

*   [Upgrade from v6](./upgrading/v6)
*   [Upgrade from Remix](./upgrading/remix)

6.30.1 is not found or the page is under construction.v5.reactrouter.com is not found or the page is under construction.v7 is not found or the page is under construction.

[](#react-router-releases)React Router Releases
===============================================

This page lists all releases/release notes for React Router back to `v6.0.0`. For releases prior to v6, please refer to the [Github Releases Page](https://github.com/remix-run/react-router/releases).

We manage release notes in this file instead of the paginated Github Releases Page for 2 reasons:

*   Pagination in the Github UI means that you cannot easily search release notes for a large span of releases at once
*   The paginated Github interface also cuts off longer releases notes without indication in list view, and you need to click into the detail view to see the full set of release notes

Table of Contents

*   [React Router Releases](#react-router-releases)
    *   [v7.6.0](#v760)
        *   [What's Changed](#whats-changed)
            *   [`routeDiscovery` Config Option](#routediscovery-config-option)
            *   [Automatic Types for Future Flags](#automatic-types-for-future-flags)
        *   [Minor Changes](#minor-changes)
        *   [Patch Changes](#patch-changes)
        *   [Unstable Changes](#unstable-changes)
        *   [Changes by Package](#changes-by-package)
    *   [v7.5.3](#v753)
        *   [Patch Changes](#patch-changes-1)
    *   [v7.5.2](#v752)
        *   [Security Notice](#security-notice)
        *   [Patch Changes](#patch-changes-2)
    *   [v7.5.1](#v751)
        *   [Patch Changes](#patch-changes-3)
        *   [Unstable Changes](#unstable-changes-1)
    *   [v7.5.0](#v750)
        *   [What's Changed](#whats-changed-1)
            *   [`route.lazy` Object API](#routelazy-object-api)
        *   [Minor Changes](#minor-changes-1)
        *   [Patch Changes](#patch-changes-4)
        *   [Unstable Changes](#unstable-changes-2)
        *   [Changes by Package](#changes-by-package-1)
    *   [v7.4.1](#v741)
        *   [Security Notice](#security-notice-1)
        *   [Patch Changes](#patch-changes-5)
        *   [Unstable Changes](#unstable-changes-3)
    *   [v7.4.0](#v740)
        *   [Minor Changes](#minor-changes-2)
        *   [Patch Changes](#patch-changes-6)
        *   [Unstable Changes](#unstable-changes-4)
        *   [Changes by Package](#changes-by-package-2)
    *   [v7.3.0](#v730)
        *   [Minor Changes](#minor-changes-3)
        *   [Patch Changes](#patch-changes-7)
        *   [Unstable Changes](#unstable-changes-5)
            *   [Client-side `context` (unstable)](#client-side-context-unstable)
            *   [Middleware (unstable)](#middleware-unstable)
                *   [Middleware `context` parameter](#middleware-context-parameter)
            *   [`unstable_SerializesTo`](#unstable_serializesto)
        *   [Changes by Package](#changes-by-package-3)
    *   [v7.2.0](#v720)
        *   [What's Changed](#whats-changed-2)
            *   [Type-safe `href` utility](#type-safe-href-utility)
            *   [Prerendering with a SPA Fallback](#prerendering-with-a-spa-fallback)
            *   [Allow a root `loader` in SPA Mode](#allow-a-root-loader-in-spa-mode)
        *   [Minor Changes](#minor-changes-4)
        *   [Patch Changes](#patch-changes-8)
        *   [Unstable Changes](#unstable-changes-6)
            *   [Split Route Modules (unstable)](#split-route-modules-unstable)
        *   [Changes by Package](#changes-by-package-4)
    *   [v7.1.5](#v715)
        *   [Patch Changes](#patch-changes-9)
    *   [v7.1.4](#v714)
        *   [Patch Changes](#patch-changes-10)
    *   [v7.1.3](#v713)
        *   [Patch Changes](#patch-changes-11)
    *   [v7.1.2](#v712)
        *   [Patch Changes](#patch-changes-12)
    *   [v7.1.1](#v711)
        *   [Patch Changes](#patch-changes-13)
    *   [v7.1.0](#v710)
        *   [Minor Changes](#minor-changes-5)
        *   [Patch Changes](#patch-changes-14)
        *   [Changes by Package](#changes-by-package-5)
    *   [v7.0.2](#v702)
        *   [Patch Changes](#patch-changes-15)
    *   [v7.0.1](#v701)
        *   [Patch Changes](#patch-changes-16)
    *   [v7.0.0](#v700)
        *   [Breaking Changes](#breaking-changes)
            *   [Package Restructuring](#package-restructuring)
            *   [Removed Adapter Re-exports](#removed-adapter-re-exports)
            *   [Removed APIs](#removed-apis)
            *   [Minimum Versions](#minimum-versions)
            *   [Adopted Future Flag Behaviors](#adopted-future-flag-behaviors)
            *   [Vite Compiler](#vite-compiler)
            *   [Exposed Router Promises](#exposed-router-promises)
        *   [Other Notable Changes](#other-notable-changes)
            *   [`routes.ts`](#routests)
            *   [Typesafety improvements](#typesafety-improvements)
            *   [Prerendering](#prerendering)
        *   [Major Changes (`react-router`)](#major-changes-react-router)
        *   [Major Changes (`@react-router/*`)](#major-changes-react-router-1)
        *   [Minor Changes](#minor-changes-6)
        *   [Patch Changes](#patch-changes-17)
        *   [Changes by Package](#changes-by-package-6)
*   [React Router v6 Releases](#react-router-v6-releases)
    *   [v6.30.1](#v6301)
        *   [Patch Changes](#patch-changes-18)
    *   [v6.30.0](#v6300)
        *   [Minor Changes](#minor-changes-7)
        *   [Patch Changes](#patch-changes-19)
    *   [v6.29.0](#v6290)
        *   [Minor Changes](#minor-changes-8)
        *   [Patch Changes](#patch-changes-20)
    *   [v6.28.2](#v6282)
        *   [Patch Changes](#patch-changes-21)
    *   [v6.28.1](#v6281)
        *   [Patch Changes](#patch-changes-22)
    *   [v6.28.0](#v6280)
        *   [What's Changed](#whats-changed-3)
        *   [Minor Changes](#minor-changes-9)
        *   [Patch Changes](#patch-changes-23)
    *   [v6.27.0](#v6270)
        *   [What's Changed](#whats-changed-4)
            *   [Stabilized APIs](#stabilized-apis)
        *   [Minor Changes](#minor-changes-10)
        *   [Patch Changes](#patch-changes-24)
    *   [v6.26.2](#v6262)
        *   [Patch Changes](#patch-changes-25)
    *   [v6.26.1](#v6261)
        *   [Patch Changes](#patch-changes-26)
    *   [v6.26.0](#v6260)
        *   [Minor Changes](#minor-changes-11)
        *   [Patch Changes](#patch-changes-27)
    *   [v6.25.1](#v6251)
        *   [Patch Changes](#patch-changes-28)
    *   [v6.25.0](#v6250)
        *   [What's Changed](#whats-changed-5)
            *   [Stabilized `v7_skipActionErrorRevalidation`](#stabilized-v7_skipactionerrorrevalidation)
        *   [Minor Changes](#minor-changes-12)
        *   [Patch Changes](#patch-changes-29)
    *   [v6.24.1](#v6241)
        *   [Patch Changes](#patch-changes-30)
    *   [v6.24.0](#v6240)
        *   [What's Changed](#whats-changed-6)
            *   [Lazy Route Discovery (a.k.a. "Fog of War")](#lazy-route-discovery-aka-fog-of-war)
        *   [Minor Changes](#minor-changes-13)
        *   [Patch Changes](#patch-changes-31)
    *   [v6.23.1](#v6231)
        *   [Patch Changes](#patch-changes-32)
    *   [v6.23.0](#v6230)
        *   [What's Changed](#whats-changed-7)
            *   [Data Strategy (unstable)](#data-strategy-unstable)
            *   [Skip Action Error Revalidation (unstable)](#skip-action-error-revalidation-unstable)
        *   [Minor Changes](#minor-changes-14)
    *   [v6.22.3](#v6223)
        *   [Patch Changes](#patch-changes-33)
    *   [v6.22.2](#v6222)
        *   [Patch Changes](#patch-changes-34)
    *   [v6.22.1](#v6221)
        *   [Patch Changes](#patch-changes-35)
    *   [v6.22.0](#v6220)
        *   [What's Changed](#whats-changed-8)
            *   [Core Web Vitals Technology Report Flag](#core-web-vitals-technology-report-flag)
        *   [Minor Changes](#minor-changes-15)
        *   [Patch Changes](#patch-changes-36)
    *   [v6.21.3](#v6213)
        *   [Patch Changes](#patch-changes-37)
    *   [v6.21.2](#v6212)
        *   [Patch Changes](#patch-changes-38)
    *   [v6.21.1](#v6211)
        *   [Patch Changes](#patch-changes-39)
    *   [v6.21.0](#v6210)
        *   [What's Changed](#whats-changed-9)
            *   [`future.v7_relativeSplatPath`](#futurev7_relativesplatpath)
            *   [Partial Hydration](#partial-hydration)
        *   [Minor Changes](#minor-changes-16)
        *   [Patch Changes](#patch-changes-40)
    *   [v6.20.1](#v6201)
        *   [Patch Changes](#patch-changes-41)
    *   [v6.20.0](#v6200)
        *   [Minor Changes](#minor-changes-17)
        *   [Patch Changes](#patch-changes-42)
    *   [v6.19.0](#v6190)
        *   [What's Changed](#whats-changed-10)
            *   [`unstable_flushSync` API](#unstable_flushsync-api)
        *   [Minor Changes](#minor-changes-18)
        *   [Patch Changes](#patch-changes-43)
    *   [v6.18.0](#v6180)
        *   [What's Changed](#whats-changed-11)
            *   [New Fetcher APIs](#new-fetcher-apis)
            *   [Persistence Future Flag (`future.v7_fetcherPersist`)](#persistence-future-flag-futurev7_fetcherpersist)
        *   [Minor Changes](#minor-changes-19)
        *   [Patch Changes](#patch-changes-44)
    *   [v6.17.0](#v6170)
        *   [What's Changed](#whats-changed-12)
            *   [View Transitions 🚀](#view-transitions-)
        *   [Minor Changes](#minor-changes-20)
        *   [Patch Changes](#patch-changes-45)
    *   [v6.16.0](#v6160)
        *   [Minor Changes](#minor-changes-21)
        *   [Patch Changes](#patch-changes-46)
    *   [v6.15.0](#v6150)
        *   [Minor Changes](#minor-changes-22)
        *   [Patch Changes](#patch-changes-47)
    *   [v6.14.2](#v6142)
        *   [Patch Changes](#patch-changes-48)
    *   [v6.14.1](#v6141)
        *   [Patch Changes](#patch-changes-49)
    *   [v6.14.0](#v6140)
        *   [What's Changed](#whats-changed-13)
            *   [JSON/Text Submissions](#jsontext-submissions)
        *   [Minor Changes](#minor-changes-23)
        *   [Patch Changes](#patch-changes-50)
    *   [v6.13.0](#v6130)
        *   [What's Changed](#whats-changed-14)
            *   [`future.v7_startTransition`](#futurev7_starttransition)
        *   [Minor Changes](#minor-changes-24)
        *   [Patch Changes](#patch-changes-51)
    *   [v6.12.1](#v6121)
        *   [Patch Changes](#patch-changes-52)
    *   [v6.12.0](#v6120)
        *   [What's Changed](#whats-changed-15)
            *   [`React.startTransition` support](#reactstarttransition-support)
        *   [Minor Changes](#minor-changes-25)
        *   [Patch Changes](#patch-changes-53)
    *   [v6.11.2](#v6112)
        *   [Patch Changes](#patch-changes-54)
    *   [v6.11.1](#v6111)
        *   [Patch Changes](#patch-changes-55)
    *   [v6.11.0](#v6110)
        *   [Minor Changes](#minor-changes-26)
        *   [Patch Changes](#patch-changes-56)
    *   [v6.10.0](#v6100)
        *   [What's Changed](#whats-changed-16)
        *   [Minor Changes](#minor-changes-27)
            *   [`future.v7_normalizeFormMethod`](#futurev7_normalizeformmethod)
        *   [Patch Changes](#patch-changes-57)
    *   [v6.9.0](#v690)
        *   [What's Changed](#whats-changed-17)
            *   [`Component`/`ErrorBoundary` route properties](#componenterrorboundary-route-properties)
            *   [Introducing Lazy Route Modules](#introducing-lazy-route-modules)
        *   [Minor Changes](#minor-changes-28)
        *   [Patch Changes](#patch-changes-58)
    *   [v6.8.2](#v682)
        *   [Patch Changes](#patch-changes-59)
    *   [v6.8.1](#v681)
        *   [Patch Changes](#patch-changes-60)
    *   [v6.8.0](#v680)
        *   [Minor Changes](#minor-changes-29)
        *   [Patch Changes](#patch-changes-61)
    *   [v6.7.0](#v670)
        *   [Minor Changes](#minor-changes-30)
        *   [Patch Changes](#patch-changes-62)
    *   [v6.6.2](#v662)
        *   [Patch Changes](#patch-changes-63)
    *   [v6.6.1](#v661)
        *   [Patch Changes](#patch-changes-64)
    *   [v6.6.0](#v660)
        *   [What's Changed](#whats-changed-18)
        *   [Minor Changes](#minor-changes-31)
        *   [Patch Changes](#patch-changes-65)
    *   [v6.5.0](#v650)
        *   [What's Changed](#whats-changed-19)
        *   [Minor Changes](#minor-changes-32)
        *   [Patch Changes](#patch-changes-66)
    *   [v6.4.5](#v645)
        *   [Patch Changes](#patch-changes-67)
    *   [v6.4.4](#v644)
        *   [Patch Changes](#patch-changes-68)
    *   [v6.4.3](#v643)
        *   [Patch Changes](#patch-changes-69)
    *   [v6.4.2](#v642)
        *   [Patch Changes](#patch-changes-70)
    *   [v6.4.1](#v641)
        *   [Patch Changes](#patch-changes-71)
    *   [v6.4.0](#v640)
        *   [What's Changed](#whats-changed-20)
            *   [Remix Data APIs](#remix-data-apis)
        *   [Patch Changes](#patch-changes-72)
    *   [v6.3.0](#v630)
        *   [Minor Changes](#minor-changes-33)
    *   [v6.2.2](#v622)
        *   [Patch Changes](#patch-changes-73)
    *   [v6.2.1](#v621)
        *   [Patch Changes](#patch-changes-74)
    *   [v6.2.0](#v620)
        *   [Minor Changes](#minor-changes-34)
        *   [Patch Changes](#patch-changes-75)
    *   [v6.1.1](#v611)
        *   [Patch Changes](#patch-changes-76)
    *   [v6.1.0](#v610)
        *   [Minor Changes](#minor-changes-35)
        *   [Patch Changes](#patch-changes-77)
    *   [v6.0.2](#v602)
        *   [Patch Changes](#patch-changes-78)
    *   [v6.0.1](#v601)
        *   [Patch Changes](#patch-changes-79)
    *   [v6.0.0](#v600)

[](#v760)v7.6.0
---------------

Date: 2025-05-08

### [](#whats-changed)What's Changed

#### [](#routediscovery-config-option)`routeDiscovery` Config Option

We've added a new config option in `7.6.0` which grants you more control over the Lazy Route Discovery feature. You can now configure the `/__manifest` path if you're running multiple RR applications on the same server, or you can also disable the feature entirely if your application is small enough and the feature isn't necessary.

    // react-router.config.ts
    
    export default {
      // You can modify the manifest path used:
      routeDiscovery: { mode: "lazy", manifestPath: "/custom-manifest" }
    
      // Or you can disable this feature entirely and include all routes in the
      // manifest on initial document load:
      routeDiscovery: { mode: "initial" }
    
      // If you don't specify anything, the default config is as follows, which enables
      // Lazy Route Discovery and makes manifest requests to the `/__manifest` path:
      // routeDiscovery: { mode: "lazy", manifestPath: "/__manifest" }
    } satisfies Config;
    

#### [](#automatic-types-for-future-flags)Automatic Types for Future Flags

Some future flags alter the way types should work in React Router. Previously, you had to remember to manually opt-in to the new types. For example, for `future.unstable_middleware`:

    // react-router.config.ts
    
    // Step 1: Enable middleware
    export default {
      future: {
        unstable_middleware: true,
      },
    };
    
    // Step 2: Enable middleware types
    declare module "react-router" {
      interface Future {
        unstable_middleware: true; // 👈 Enable middleware types
      }
    }
    

It was up to you to keep the runtime future flags synced with the types for those flags. This was confusing and error-prone.

Now, React Router will automatically enable types for future flags. That means you only need to specify the runtime future flag:

    // react-router.config.ts
    
    // Step 1: Enable middleware
    export default {
      future: {
        unstable_middleware: true,
      },
    };
    
    // No step 2! That's it!
    

Behind the scenes, React Router will generate the corresponding `declare module` into `.react-router/types`. Currently this is done in `.react-router/types/+register.ts` but this is an implementation detail that may change in the future.

### [](#minor-changes)Minor Changes

*   `react-router` - Added a new `routeDiscovery` option in `react-router.config.ts` to configure Lazy Route Discovery behavior ([#13451](https://github.com/remix-run/react-router/pull/13451))
    
*   `react-router` - Add support for route component props in `createRoutesStub` ([#13528](https://github.com/remix-run/react-router/pull/13528))
    
    *   This allows you to unit test your route components using the props instead of the hooks:
        
            let RoutesStub = createRoutesStub([
              {
                path: "/",
                Component({ loaderData }) {
                  let data = loaderData as { message: string };
                  return <pre data-testid="data">Message: {data.message}</pre>;
                },
                loader() {
                  return { message: "hello" };
                },
              },
            ]);
            
            render(<RoutesStub />);
            
            await waitFor(() => screen.findByText("Message: hello"));
            
        
*   `@react-router/dev` - Automatic types for future flags ([#13506](https://github.com/remix-run/react-router/pull/13506))
    

### [](#patch-changes)Patch Changes

You may notice this list is a bit larger than usual! The team ate their vegetables last week and spent the week [squashing bugs](https://x.com/BrooksLybrand/status/1918406062920589731) to work on lowering the issue count that had ballooned a bit since the v7 release.

*   `react-router` - Fix `react-router` module augmentation for `NodeNext` ([#13498](https://github.com/remix-run/react-router/pull/13498))
*   `react-router` - Don't bundle `react-router` in `react-router/dom` CJS export ([#13497](https://github.com/remix-run/react-router/pull/13497))
*   `react-router` - Fix bug where a submitting `fetcher` would get stuck in a `loading` state if a revalidating `loader` redirected ([#12873](https://github.com/remix-run/react-router/pull/12873))
*   `react-router` - Fix hydration error if a server `loader` returned `undefined` ([#13496](https://github.com/remix-run/react-router/pull/13496))
*   `react-router` - Fix initial load 404 scenarios in data mode ([#13500](https://github.com/remix-run/react-router/pull/13500))
*   `react-router` - Stabilize `useRevalidator`'s `revalidate` function ([#13542](https://github.com/remix-run/react-router/pull/13542))
*   `react-router` - Preserve status code if a `clientAction` throws a `data()` result in framework mode ([#13522](https://github.com/remix-run/react-router/pull/13522))
*   `react-router` - Be defensive against leading double slashes in paths to avoid `Invalid URL` errors from the URL constructor ([#13510](https://github.com/remix-run/react-router/pull/13510))
    *   Note we do not sanitize/normalize these paths - we only detect them so we can avoid the error that would be thrown by `new URL("//", window.location.origin)`
*   `react-router` - Remove `Navigator` declaration for `navigator.connection.saveData` to avoid messing with any other types beyond `saveData` in user land ([#13512](https://github.com/remix-run/react-router/pull/13512))
*   `react-router` - Fix `handleError` `params` values on `.data` requests for routes with a dynamic param as the last URL segment ([#13481](https://github.com/remix-run/react-router/pull/13481))
*   `react-router` - Don't trigger an `ErrorBoundary` UI before the reload when we detect a manifest version mismatch in Lazy Route Discovery ([#13480](https://github.com/remix-run/react-router/pull/13480))
*   `react-router` - Inline `turbo-stream@2.4.1` dependency and fix decoding ordering of `Map`/`Set` instances ([#13518](https://github.com/remix-run/react-router/pull/13518))
*   `react-router` - Only render dev warnings during dev ([#13461](https://github.com/remix-run/react-router/pull/13461))
*   `react-router` - Short circuit post-processing on aborted `dataStrategy` requests ([#13521](https://github.com/remix-run/react-router/pull/13521))
    *   This resolves non-user-facing console errors of the form `Cannot read properties of undefined (reading 'result')`
*   `@react-router/dev` - Support project root directories without a `package.json` if it exists in a parent directory ([#13472](https://github.com/remix-run/react-router/pull/13472))
*   `@react-router/dev` - When providing a custom Vite config path via the CLI `--config`/`-c` flag, default the project root directory to the directory containing the Vite config when not explicitly provided ([#13472](https://github.com/remix-run/react-router/pull/13472))
*   `@react-router/dev` - In a `routes.ts` context, ensure the `--mode` flag is respected for `import.meta.env.MODE` ([#13485](https://github.com/remix-run/react-router/pull/13485))
    *   Previously, `import.meta.env.MODE` within a `routes.ts` context was always `"development"` for the `dev` and `typegen --watch` commands, but otherwise resolved to `"production"`. These defaults are still in place, but if a `--mode` flag is provided, this will now take precedence.
*   `@react-router/dev` - Ensure consistent project root directory resolution logic in CLI commands ([#13472](https://github.com/remix-run/react-router/pull/13472))
*   `@react-router/dev` - When executing `react-router.config.ts` and `routes.ts` with `vite-node`, ensure that PostCSS config files are ignored ([#13489](https://github.com/remix-run/react-router/pull/13489))
*   `@react-router/dev` - When extracting critical CSS during development, ensure it's loaded from the client environment to avoid issues with plugins that handle the SSR environment differently ([#13503](https://github.com/remix-run/react-router/pull/13503))
*   `@react-router/dev` - Fix "Status message is not supported by HTTP/2" error during dev when using HTTPS ([#13460](https://github.com/remix-run/react-router/pull/13460))
*   `@react-router/dev` - Update config when `react-router.config.ts` is created or deleted during development ([#12319](https://github.com/remix-run/react-router/pull/12319))
*   `@react-router/dev` - Skip unnecessary `routes.ts` evaluation before Vite build is started ([#13513](https://github.com/remix-run/react-router/pull/13513))
*   `@react-router/dev` - Fix `TS2300: Duplicate identifier` errors caused by generated types ([#13499](https://github.com/remix-run/react-router/pull/13499))
*   Previously, routes that had the same full path would cause duplicate entries in the generated types for `href` (`.react-router/types/+register.ts`), causing type checking errors

### [](#unstable-changes)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Fix a few bugs with error bubbling in middleware use-cases ([#13538](https://github.com/remix-run/react-router/pull/13538))
*   `@react-router/dev` - When `future.unstable_viteEnvironmentApi` is enabled, ensure that `build.assetsDir` in Vite config is respected when `environments.client.build.assetsDir` is not configured ([#13491](https://github.com/remix-run/react-router/pull/13491))

### [](#changes-by-package)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/create-react-router/CHANGELOG.md#760)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router/CHANGELOG.md#760)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-architect/CHANGELOG.md#760)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-cloudflare/CHANGELOG.md#760)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-dev/CHANGELOG.md#760)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-express/CHANGELOG.md#760)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-fs-routes/CHANGELOG.md#760)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-node/CHANGELOG.md#760)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#760)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-serve/CHANGELOG.md#760)

**Full Changelog**: [`v7.5.3...v7.6.0`](https://github.com/remix-run/react-router/compare/react-router@7.5.3...react-router@7.6.0)

[](#v753)v7.5.3
---------------

Date: 2025-04-28

### [](#patch-changes-1)Patch Changes

*   `react-router` - Fix bug where bubbled action errors would result in `loaderData` being cleared at the handling `ErrorBoundary` route ([#13476](https://github.com/remix-run/react-router/pull/13476))
*   `react-router` - Handle redirects from `clientLoader.hydrate` initial load executions ([#13477](https://github.com/remix-run/react-router/pull/13477))

**Full Changelog**: [`v7.5.2...v7.5.3`](https://github.com/remix-run/react-router/compare/react-router@7.5.2...react-router@7.5.3)

[](#v752)v7.5.2
---------------

Date: 2025-04-24

### [](#security-notice)Security Notice

Fixed 2 security vulnerabilities that could result in cache-poisoning attacks by sending specific headers intended for build-time usage for SPA Mode and Pre-rendering ([GHSA-f46r-rw29-r322](https://github.com/remix-run/react-router/security/advisories/GHSA-f46r-rw29-r322), [GHSA-cpj6-fhp6-mr6j](https://github.com/remix-run/react-router/security/advisories/GHSA-cpj6-fhp6-mr6j)).

### [](#patch-changes-2)Patch Changes

*   `react-router` - Adjust approach for Pre-rendering/SPA Mode via headers ([#13453](https://github.com/remix-run/react-router/pull/13453))
*   `react-router` - Update Single Fetch to also handle the 204 redirects used in `?_data` requests in Remix v2 ([#13364](https://github.com/remix-run/react-router/pull/13364))
    *   This allows applications to trigger a redirect on `.data` requests from outside the scope of React Router (i.e., an `express`/`hono` middleware) the same way they did in Remix v2 before Single Fetch was implemented
    *   This is a bit of an escape hatch - the recommended way to handle this is redirecting from a root route middleware
    *   To use this functionality, you may return from a `.data` request wih a response as follows:
        *   Set a 204 status code
        *   Set an `X-Remix-Redirect: <new-location>` header
        *   Optionally, set `X-Remix-Replace: true` or `X-Remix-Reload-Document: true` headers to replicate `replace()`/`redirectDocument()` functionality
    *   ⚠️ Please note that these responses rely on implementation details that are subject to change without a SemVer major release, and it is recommended you set up integration tests for your application to confirm this functionality is working correctly with each future React Router upgrade

**Full Changelog**: [`v7.5.1...v7.5.2`](https://github.com/remix-run/react-router/compare/react-router@7.5.1...react-router@7.5.2)

[](#v751)v7.5.1
---------------

Date: 2025-04-17

### [](#patch-changes-3)Patch Changes

*   `react-router` - When using the object-based `route.lazy` API, the `HydrateFallback` and `hydrateFallbackElement` properties are now skipped when lazy loading routes after hydration ([#13376](https://github.com/remix-run/react-router/pull/13376))
    
    *   If you move the code for these properties into a separate file, since the hydrate properties were unused already (if the route wasn't present during hydration), you can avoid downloading them at all. For example:
        
            createBrowserRouter([
              {
                path: "/show/:showId",
                lazy: {
                  loader: async () => (await import("./show.loader.js")).loader,
                  Component: async () =>
                    (await import("./show.component.js")).Component,
                  HydrateFallback: async () =>
                    (await import("./show.hydrate-fallback.js")).HydrateFallback,
                },
              },
            ]);
            
        
*   `react-router` - Fix single fetch bug where no revalidation request would be made when navigating upwards to a reused parent route ([#13253](https://github.com/remix-run/react-router/pull/13253))
    
*   `react-router` - Properly revalidate pre-rendered paths when param values change when using `ssr:false` + `prerender` configs ([#13380](https://github.com/remix-run/react-router/pull/13380))
    
*   `react-router` - Fix pre-rendering when a loader returns a redirect ([#13365](https://github.com/remix-run/react-router/pull/13365))
    
*   `react-router` - Do not automatically add `null` to `staticHandler.query()` `context.loaderData` if routes do not have loaders ([#13223](https://github.com/remix-run/react-router/pull/13223))
    
    *   This was a Remix v2 implementation detail inadvertently left in for React Router v7
    *   Now that we allow returning `undefined` from loaders, our prior check of `loaderData[routeId] !== undefined` was no longer sufficient and was changed to a `routeId in loaderData` check - these `null` values can cause issues for this new check
    *   ⚠️ This could be a "breaking bug fix" for you if you are doing manual SSR with `createStaticHandler()`/`<StaticRouterProvider>`, and using `context.loaderData` to control `<RouterProvider>` hydration behavior on the client

### [](#unstable-changes-1)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Add better error messaging when `getLoadContext` is not updated to return a `Map` ([#13242](https://github.com/remix-run/react-router/pull/13242))
*   `react-router` - Update context type for `LoaderFunctionArgs`/`ActionFunctionArgs` when middleware is enabled ([#13381](https://github.com/remix-run/react-router/pull/13381))
*   `react-router` - Add a new `unstable_runClientMiddleware` argument to `dataStrategy` to enable middleware execution in custom `dataStrategy` implementations ([#13395](https://github.com/remix-run/react-router/pull/13395))
*   `react-router` - Add support for the new `unstable_shouldCallHandler`/`unstable_shouldRevalidateArgs` APIs in `dataStrategy` ([#13253](https://github.com/remix-run/react-router/pull/13253))

**Full Changelog**: [`v7.5.0...v7.5.1`](https://github.com/remix-run/react-router/compare/react-router@7.5.0...react-router@7.5.1)

[](#v750)v7.5.0
---------------

Date: 2025-04-04

### [](#whats-changed-1)What's Changed

#### [](#routelazy-object-api)`route.lazy` Object API

We've introduced a new `route.lazy` API which gives you more granular control over the lazy loading of route properties that you could not achieve with the `route.lazy()` function signature. This is useful for Framework mode and performance-critical library mode applications.

    createBrowserRouter([
      {
        path: "/show/:showId",
        lazy: {
          loader: async () => (await import("./show.loader.js")).loader,
          action: async () => (await import("./show.action.js")).action,
          Component: async () => (await import("./show.component.js")).Component,
        },
      },
    ]);
    

⚠️ This is a breaking change if you have adopted the `route.unstable_lazyMiddleware` API which has been removed in favor of `route.lazy.unstable_middleware`. See the `Unstable Changes` section below for more information.

### [](#minor-changes-1)Minor Changes

*   `react-router` - Add granular object-based API for `route.lazy` to support lazy loading of individual route properties ([#13294](https://github.com/remix-run/react-router/pull/13294))

### [](#patch-changes-4)Patch Changes

*   `@react-router/dev` - Update optional `wrangler` peer dependency range to support `wrangler` v4 ([#13258](https://github.com/remix-run/react-router/pull/13258))
*   `@react-router/dev` - Reinstate dependency optimization in the child compiler to fix `depsOptimizer is required in dev mode` errors when using `vite-plugin-cloudflare` and importing Node.js builtins ([#13317](https://github.com/remix-run/react-router/pull/13317))

### [](#unstable-changes-2)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Introduce `future.unstable_subResourceIntegrity` flag that enables generation of an `importmap` with `integrity` for the scripts that will be loaded by the browser ([#13163](https://github.com/remix-run/react-router/pull/13163))
*   `react-router` - Remove support for the `route.unstable_lazyMiddleware` property ([#13294](https://github.com/remix-run/react-router/pull/13294))
    *   In order to lazily load middleware, you can use the new object-based `route.lazy.unstable_middleware` API
*   `@react-router/dev` - When `future.unstable_viteEnvironmentApi` is enabled, ensure critical CSS in development works when using a custom Vite `base` has been configured ([#13305](https://github.com/remix-run/react-router/pull/13305))

### [](#changes-by-package-1)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/create-react-router/CHANGELOG.md#750)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router/CHANGELOG.md#750)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-architect/CHANGELOG.md#750)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-cloudflare/CHANGELOG.md#750)
*   [`@react-router/dev`](http://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-dev/CHANGELOG.md#750)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-express/CHANGELOG.md#750)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-fs-routes/CHANGELOG.md#750)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-node/CHANGELOG.md#750)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#750)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-serve/CHANGELOG.md#750)

**Full Changelog**: [`v7.4.1...v7.5.0`](https://github.com/remix-run/react-router/compare/react-router@7.4.1...react-router@7.5.0)

[](#v741)v7.4.1
---------------

Date: 2025-03-28

### [](#security-notice-1)Security Notice

Fixed a security vulnerability that allowed URL manipulation and potential cache pollution via the `Host` and `X-Forwarded-Host` headers due to inadequate port sanitization ([GHSA-4q56-crqp-v477/CVE-2025-31137](https://github.com/remix-run/react-router/security/advisories/GHSA-4q56-crqp-v477)).

### [](#patch-changes-5)Patch Changes

*   `react-router` - Dedupe calls to `route.lazy` functions ([#13260](https://github.com/remix-run/react-router/pull/13260))
*   `@react-router/dev` - Fix path in prerender error messages ([#13257](https://github.com/remix-run/react-router/pull/13257))
*   `@react-router/dev` - Fix typegen for virtual modules when `moduleDetection` is set to `force` ([#13267](https://github.com/remix-run/react-router/pull/13267))
*   `@react-router/express` - Better validation of `x-forwarded-host` header to prevent potential security issues ([#13309](https://github.com/remix-run/react-router/pull/13309))

### [](#unstable-changes-3)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Fix types on `unstable_MiddlewareFunction` to avoid type errors when a middleware doesn't return a value ([#13311](https://github.com/remix-run/react-router/pull/13311))
*   `react-router` - Add support for `route.unstable_lazyMiddleware` function to allow lazy loading of middleware logic ([#13210](https://github.com/remix-run/react-router/pull/13210))
    *   ⚠️ We do not recommend adoption of this API currently as we are likely going to change it prior to the stable release of middleware
    *   ⚠️ This may be a breaking change if your app is currently returning `unstable_middleware` from `route.lazy`
    *   The `route.unstable_middleware` property is no longer supported in the return value from `route.lazy`
    *   If you want to lazily load middleware, you must use `route.unstable_lazyMiddleware`
*   `@react-router/dev` - When both `future.unstable_middleware` and `future.unstable_splitRouteModules` are enabled, split `unstable_clientMiddleware` route exports into separate chunks when possible ([#13210](https://github.com/remix-run/react-router/pull/13210))
*   `@react-router/dev` - Improve performance of `future.unstable_middleware` by ensuring that route modules are only blocking during the middleware phase when the `unstable_clientMiddleware` has been defined ([#13210](https://github.com/remix-run/react-router/pull/13210))

**Full Changelog**: [`v7.4.0...v7.4.1`](https://github.com/remix-run/react-router/compare/react-router@7.4.0...react-router@7.4.1)

[](#v740)v7.4.0
---------------

Date: 2025-03-19

### [](#minor-changes-2)Minor Changes

*   `@react-router/dev` - Generate types for `virtual:react-router/server-build` module ([#13152](https://github.com/remix-run/react-router/pull/13152))

### [](#patch-changes-6)Patch Changes

*   `react-router` - Fix root loader data on initial load redirects in SPA mode ([#13222](https://github.com/remix-run/react-router/pull/13222))
*   `react-router` - Load ancestor pathless/index routes in lazy route discovery for upwards non-eager-discovery routing ([#13203](https://github.com/remix-run/react-router/pull/13203))
*   `react-router` - Fix `shouldRevalidate` behavior for `clientLoader`\-only routes in `ssr:true` apps ([#13221](https://github.com/remix-run/react-router/pull/13221))
*   `@react-router/dev` - Fix conflicts with other Vite plugins that use the `configureServer` and/or `configurePreviewServer` hooks ([#13184](https://github.com/remix-run/react-router/pull/13184))

### [](#unstable-changes-4)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - If a middleware throws an error, ensure we only bubble the error itself via `next()` and are no longer leaking the `MiddlewareError` implementation detail ([#13180](https://github.com/remix-run/react-router/pull/13180))
    *   ⚠️ This may be a breaking change if you are `catch`\-ing errors thrown by the `next()` function in your middlewares
*   `react-router` - Fix `RequestHandler` `loadContext` parameter type when middleware is enabled ([#13204](https://github.com/remix-run/react-router/pull/13204))
*   `react-router` - Update `Route.unstable_MiddlewareFunction` to have a return value of `Response | undefined` instead of `Response | void` ([#13199](https://github.com/remix-run/react-router/pull/13199))
*   `@react-router/dev` - When `future.unstable_splitRouteModules` is set to `"enforce"`, allow both splittable and unsplittable root route exports since it's always in a single chunk ([#13238](https://github.com/remix-run/react-router/pull/13238))
*   `@react-router/dev` - When `future.unstable_viteEnvironmentApi` is enabled, allow plugins that override the default SSR environment (such as `@cloudflare/vite-plugin`) to be placed before or after the React Router plugin ([#13183](https://github.com/remix-run/react-router/pull/13183))

### [](#changes-by-package-2)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/create-react-router/CHANGELOG.md#740)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router/CHANGELOG.md#740)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-architect/CHANGELOG.md#740)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-cloudflare/CHANGELOG.md#740)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-dev/CHANGELOG.md#740)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-express/CHANGELOG.md#740)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-fs-routes/CHANGELOG.md#740)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-node/CHANGELOG.md#740)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#740)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-serve/CHANGELOG.md#740)

**Full Changelog**: [`v7.3.0...v7.4.0`](https://github.com/remix-run/react-router/compare/react-router@7.3.0...react-router@7.4.0)

[](#v730)v7.3.0
---------------

Date: 2025-03-06

### [](#minor-changes-3)Minor Changes

*   Add `fetcherKey` as a parameter to `patchRoutesOnNavigation` ([#13061](https://github.com/remix-run/react-router/pull/13061))

### [](#patch-changes-7)Patch Changes

*   `react-router` - Detect and handle manifest-skew issues on new deploys during active sessions ([#13061](https://github.com/remix-run/react-router/pull/13061))
    *   In framework mode, Lazy Route Discovery will now detect manifest version mismatches in active sessions after a new deploy
    *   On navigations to undiscovered routes, this mismatch will trigger a document reload of the destination path
    *   On `fetcher` calls to undiscovered routes, this mismatch will trigger a document reload of the current path
*   `react-router` - Skip resource route flow in dev server in SPA mode ([#13113](https://github.com/remix-run/react-router/pull/13113))
*   `react-router` - Fix single fetch `_root.data` requests when a `basename` is used ([#12898](https://github.com/remix-run/react-router/pull/12898))
*   `react-router` - Fix types for `loaderData` and `actionData` that contained `Record`s ([#13139](https://github.com/remix-run/react-router/pull/13139))
    *   ⚠️ This is a breaking change for users who have already adopted `unstable_SerializesTo` - see the note in the `Unstable Changes` section below for more information
*   `@react-router/dev` - Fix support for custom client `build.rollupOptions.output.entryFileNames` ([#13098](https://github.com/remix-run/react-router/pull/13098))
*   `@react-router/dev` - Fix usage of `prerender` option when `serverBundles` option has been configured or provided by a preset, e.g. `vercelPreset` from `@vercel/react-router` ([#13082](https://github.com/remix-run/react-router/pull/13082))
*   `@react-router/dev` - Fix support for custom `build.assetsDir` ([#13077](https://github.com/remix-run/react-router/pull/13077))
*   `@react-router/dev` - Remove unused dependencies ([#13134](https://github.com/remix-run/react-router/pull/13134))
*   `@react-router/dev` - Stub all routes except root in "SPA Mode" server builds to avoid issues when route modules or their dependencies import non-SSR-friendly modules ([#13023](https://github.com/remix-run/react-router/pull/13023))
*   `@react-router/dev` - Remove unused Vite file system watcher ([#13133](https://github.com/remix-run/react-router/pull/13133))
*   `@react-router/dev` - Fix support for custom SSR build input when `serverBundles` option has been configured ([#13107](https://github.com/remix-run/react-router/pull/13107))
    *   ⚠️ Note that for consumers using the `future.unstable_viteEnvironmentApi` and `serverBundles` options together, hyphens are no longer supported in server bundle IDs since they also need to be valid Vite environment names.
*   `@react-router/dev` - Fix dev server when using HTTPS by stripping HTTP/2 pseudo headers from dev server requests ([#12830](https://github.com/remix-run/react-router/pull/12830))
*   `@react-router/dev` - Lazy load Cloudflare platform proxy on first dev server request when using the `cloudflareDevProxy` Vite plugin to avoid creating unnecessary `workerd` processes ([#13016](https://github.com/remix-run/react-router/pull/13016))
*   `@react-router/dev` - Fix duplicated entries in typegen for layout routes and their corresponding index route ([#13140](https://github.com/remix-run/react-router/pull/13140))
*   `@react-router/express` - Update `express` `peerDependency` to include v5 ([https://github.com/remix-run/react-router/pull/13064](https://github.com/remix-run/react-router/pull/13064)) ([#12961](https://github.com/remix-run/react-router/pull/12961))

### [](#unstable-changes-5)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Add `context` support to client side data routers (unstable) ([#12941](https://github.com/remix-run/react-router/pull/12941))
*   `react-router` - Support middleware on routes (unstable) ([#12941](https://github.com/remix-run/react-router/pull/12941))
*   `@react-router/dev` - Fix errors with `future.unstable_viteEnvironmentApi` when the `ssr` environment has been configured by another plugin to be a custom `Vite.DevEnvironment` rather than the default `Vite.RunnableDevEnvironment` ([#13008](https://github.com/remix-run/react-router/pull/13008))
*   `@react-router/dev` - When `future.unstable_viteEnvironmentApi` is enabled and the `ssr` environment has `optimizeDeps.noDiscovery` disabled, define `optimizeDeps.entries` and `optimizeDeps.include` ([#13007](https://github.com/remix-run/react-router/pull/13007))

#### [](#client-side-context-unstable)Client-side `context` (unstable)

Your application `clientLoader`/`clientAction` functions (or `loader`/`action` in library mode) will now receive a `context` parameter on the client. This is an instance of `unstable_RouterContextProvider` that you use with type-safe contexts (similar to `React.createContext`) and is most useful with the corresponding `unstable_clientMiddleware` API:

    import { unstable_createContext } from "react-router";
    
    type User = {
      /*...*/
    };
    
    const userContext = unstable_createContext<User>();
    
    const sessionMiddleware: Route.unstable_ClientMiddlewareFunction = async ({
      context,
    }) => {
      let user = await getUser();
      context.set(userContext, user);
    };
    
    export const unstable_clientMiddleware = [sessionMiddleware];
    
    export function clientLoader({ context }: Route.ClientLoaderArgs) {
      let user = context.get(userContext);
      let profile = await getProfile(user.id);
      return { profile };
    }
    

Similar to server-side requests, a fresh `context` will be created per navigation (or `fetcher` call). If you have initial data you'd like to populate in the context for every request, you can provide an `unstable_getContext` function at the root of your app:

*   Library mode - `createBrowserRouter(routes, { unstable_getContext })`
*   Framework mode - `<HydratedRouter unstable_getContext>`

This function should return an value of type `unstable_InitialContext` which is a `Map<unstable_RouterContext, unknown>` of context's and initial values:

    const loggerContext = unstable_createContext<(...args: unknown[]) => void>();
    
    function logger(...args: unknown[]) {
      console.log(new Date.toISOString(), ...args);
    }
    
    function unstable_getContext() {
      let map = new Map();
      map.set(loggerContext, logger);
      return map;
    }
    

#### [](#middleware-unstable)Middleware (unstable)

Middleware is implemented behind a `future.unstable_middleware` flag. To enable, you must enable the flag and the types in your `react-router.config.ts` file:

    import type { Config } from "@react-router/dev/config";
    import type { Future } from "react-router";
    
    declare module "react-router" {
      interface Future {
        unstable_middleware: true; // 👈 Enable middleware types
      }
    }
    
    export default {
      future: {
        unstable_middleware: true, // 👈 Enable middleware
      },
    } satisfies Config;
    

⚠️ Middleware is unstable and should not be adopted in production. There is at least one known de-optimization in route module loading for `clientMiddleware` that we will be addressing this before a stable release.

⚠️ Enabling middleware contains a breaking change to the `context` parameter passed to your `loader`/`action` functions - see below for more information.

Once enabled, routes can define an array of middleware functions that will run sequentially before route handlers run. These functions accept the same parameters as `loader`/`action` plus an additional `next` parameter to run the remaining data pipeline. This allows middlewares to perform logic before and after handlers execute.

    // Framework mode
    export const unstable_middleware = [serverLogger, serverAuth]; // server
    export const unstable_clientMiddleware = [clientLogger]; // client
    
    // Library mode
    const routes = [
      {
        path: "/",
        // Middlewares are client-side for library mode SPA's
        unstable_middleware: [clientLogger, clientAuth],
        loader: rootLoader,
        Component: Root,
      },
    ];
    

Here's a simple example of a client-side logging middleware that can be placed on the root route:

    const clientLogger: Route.unstable_ClientMiddlewareFunction = async (
      { request },
      next
    ) => {
      let start = performance.now();
    
      // Run the remaining middlewares and all route loaders
      await next();
    
      let duration = performance.now() - start;
      console.log(`Navigated to ${request.url} (${duration}ms)`);
    };
    

Note that in the above example, the `next`/`middleware` functions don't return anything. This is by design as on the client there is no "response" to send over the network like there would be for middlewares running on the server. The data is all handled behind the scenes by the stateful `router`.

For a server-side middleware, the `next` function will return the HTTP `Response` that React Router will be sending across the wire, thus giving you a chance to make changes as needed. You may throw a new response to short circuit and respond immediately, or you may return a new or altered response to override the default returned by `next()`.

    const serverLogger: Route.unstable_MiddlewareFunction = async (
      { request, params, context },
      next
    ) => {
      let start = performance.now();
    
      // 👇 Grab the response here
      let res = await next();
    
      let duration = performance.now() - start;
      console.log(`Navigated to ${request.url} (${duration}ms)`);
    
      // 👇 And return it here (optional if you don't modify the response)
      return res;
    };
    

You can throw a `redirect` from a middleware to short circuit any remaining processing:

    import { sessionContext } from "../context";
    const serverAuth: Route.unstable_MiddlewareFunction = (
      { request, params, context },
      next
    ) => {
      let session = context.get(sessionContext);
      let user = session.get("user");
      if (!user) {
        session.set("returnTo", request.url);
        throw redirect("/login", 302);
      }
    };
    

_Note that in cases like this where you don't need to do any post-processing you don't need to call the `next` function or return a `Response`._

Here's another example of using a server middleware to detect 404s and check the CMS for a redirect:

    const redirects: Route.unstable_MiddlewareFunction = async ({
      request,
      next,
    }) => {
      // attempt to handle the request
      let res = await next();
    
      // if it's a 404, check the CMS for a redirect, do it last
      // because it's expensive
      if (res.status === 404) {
        let cmsRedirect = await checkCMSRedirects(request.url);
        if (cmsRedirect) {
          throw redirect(cmsRedirect, 302);
        }
      }
    
      return res;
    };
    

For more information on the `middleware` API/design, please see the [decision doc](https://github.com/remix-run/react-router/blob/release-next/decisions/0014-context-middleware.md).

##### [](#middleware-context-parameter)Middleware `context` parameter

When middleware is enabled, your application will use a different type of `context` parameter in your loaders and actions to provide better type safety. Instead of `AppLoadContext`, `context` will now be an instance of `ContextProvider` that you can use with type-safe contexts (similar to `React.createContext`):

    import { unstable_createContext } from "react-router";
    import { Route } from "./+types/root";
    import type { Session } from "./sessions.server";
    import { getSession } from "./sessions.server";
    
    let sessionContext = unstable_createContext<Session>();
    
    const sessionMiddleware: Route.unstable_MiddlewareFunction = ({
      context,
      request,
    }) => {
      let session = await getSession(request);
      context.set(sessionContext, session);
      //                          ^ must be of type Session
    };
    
    // ... then in some downstream middleware
    const loggerMiddleware: Route.unstable_MiddlewareFunction = ({
      context,
      request,
    }) => {
      let session = context.get(sessionContext);
      //  ^ typeof Session
      console.log(session.get("userId"), request.method, request.url);
    };
    
    // ... or some downstream loader
    export function loader({ context }: Route.LoaderArgs) {
      let session = context.get(sessionContext);
      let profile = await getProfile(session.get("userId"));
      return { profile };
    }
    

If you are using a custom server with a `getLoadContext` function, the return value for initial context values passed from the server adapter layer is no longer an object and should now return an `unstable_InitialContext` (`Map<RouterContext, unknown>`):

    let adapterContext = unstable_createContext<MyAdapterContext>();
    
    function getLoadContext(req, res): unstable_InitialContext {
      let map = new Map();
      map.set(adapterContext, getAdapterContext(req));
      return map;
    }
    

#### [](#unstable_serializesto)`unstable_SerializesTo`

`unstable_SerializesTo` added a way to register custom serialization types in Single Fetch for other library and framework authors like Apollo. It was implemented with branded type whose branded property that was made optional so that casting arbitrary values was easy:

    // without the brand being marked as optional
    let x1 = 42 as unknown as unstable_SerializesTo<number>;
    //          ^^^^^^^^^^
    
    // with the brand being marked as optional
    let x2 = 42 as unstable_SerializesTo<number>;
    

However, this broke type inference in `loaderData` and `actionData` for any `Record` types as those would now (incorrectly) match `unstable_SerializesTo`. This affected all users, not just those that depended on `unstable_SerializesTo`. To fix this, the branded property of `unstable_SerializesTo` is marked as required instead of optional.

For library and framework authors using `unstable_SerializesTo`, you may need to add `as unknown` casts before casting to `unstable_SerializesTo`.

### [](#changes-by-package-3)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/create-react-router/CHANGELOG.md#730)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router/CHANGELOG.md#730)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-architect/CHANGELOG.md#730)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-cloudflare/CHANGELOG.md#730)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-dev/CHANGELOG.md#730)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-express/CHANGELOG.md#730)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-fs-routes/CHANGELOG.md#730)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-node/CHANGELOG.md#730)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#730)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-serve/CHANGELOG.md#730)

**Full Changelog**: [`v7.2.0...v7.3.0`](https://github.com/remix-run/react-router/compare/react-router@7.2.0...react-router@7.3.0)

[](#v720)v7.2.0
---------------

Date: 2025-02-18

### [](#whats-changed-2)What's Changed

#### [](#type-safe-href-utility)Type-safe `href` utility

In framework mode, we now provide you with a fully type-safe `href` utility to give you all the warm and fuzzy feelings of path auto-completion and param validation for links in your application:

    import { href } from "react-router";
    
    export default function Component() {
      const link = href("/blog/:slug", { slug: "my-first-post" });
      //                ^ type-safe!     ^ Also type-safe!
    
      return (
        <main>
          <Link to={href("/products/:id", { id: "asdf" })} />
          <NavLink to={href("/:lang?/about", { lang: "en" })} />
        </main>
      );
    }
    

You'll now get type errors if you pass a bad path value or a bad param value:

    const badPath = href("/not/a/valid/path");
    //                   ^ Error!
    
    const badParam = href("/blog/:slug", { oops: "bad param" });
    //                                     ^ Error!
    

#### [](#prerendering-with-a-spa-fallback)Prerendering with a SPA Fallback

This release enhances the ability to use a combination of pre-rendered paths alongside other paths that operate in "SPA Mode" when pre-rendering with `ssr:false`.

*   If you specify `ssr:false` without a `prerender` config, this is considered "SPA Mode" and the generated `index.html` file will only render down to the root route and will be able to hydrate for any valid application path
*   If you specify `ssr:false` with a `prerender` config but _do not_ include the `/` path (i.e., `prerender: ['/blog/post']`), then we still generate a "SPA Mode" `index.html` file that can hydrate for any path in the application
*   If you specify `ssr:false` and include the `/` path in your `prerender` config, the generated `index.html` file will be specific to the root index route, so we will now also generate a separate "SPA Mode" file in `__spa-fallback.html` that you can serve/hydrate for non-prerendered paths

For more info, see the [Pre-rendering](https://reactrouter.com/dev/how-to/pre-rendering#pre-rendering-with-a-spa-fallback) docs for more info.

#### [](#allow-a-root-loader-in-spa-mode)Allow a root `loader` in SPA Mode

SPA Mode used to prohibit the use of loaders in all routes so that we could hydrate for any path in the application. However, because the root route is always rendered at build time, we can lift this restriction for the root route.

In order to use your build-time loader data during pre-rendering, we now also expose the `loaderData` as an optional prop for the `HydrateFallback` component on routes:

*   This will be defined so long as the `HydrateFallback` is rendering because _children_ routes are loading
*   This will be `undefined` if the `HydrateFallback` is rendering because the route itself has it's own hydrating `clientLoader`
    *   In SPA mode, this will allow you to render loader root data into the SPA Mode HTML file

### [](#minor-changes-4)Minor Changes

*   `react-router` - New type-safe `href` utility that guarantees links point to actual paths in your app ([#13012](https://github.com/remix-run/react-router/pull/13012))
*   `@react-router/dev` - Generate a "SPA fallback" HTML file when pre-rendering the `/` route with `ssr:false` ([#12948](https://github.com/remix-run/react-router/pull/12948))
*   `@react-router/dev` - Allow a `loader` in the root route in SPA mode because it can be called/server-rendered at build time ([#12948](https://github.com/remix-run/react-router/pull/12948))
    *   `Route.HydrateFallbackProps` now also receives `loaderData`

### [](#patch-changes-8)Patch Changes

*   `react-router` - Disable Lazy Route Discovery for all `ssr:false` apps and not just "SPA Mode" because there is no runtime server to serve the search-param-configured `__manifest` requests ([#12894](https://github.com/remix-run/react-router/pull/12894))
    *   We previously only disabled this for "SPA Mode" but we realized it should apply to all `ssr:false` apps
    *   In those `prerender` scenarios we would pre-render the `/__manifest` file but that makes some unnecessary assumptions about the static file server behaviors
*   `react-router` - Don't apply Single Fetch revalidation de-optimization when in SPA mode since there is no server HTTP request ([#12948](https://github.com/remix-run/react-router/pull/12948))
*   `react-router` - Properly handle revalidations to across a pre-render/SPA boundary ([#13021](https://github.com/remix-run/react-router/pull/13021))
    *   In "hybrid" applications where some routes are pre-rendered and some are served from a SPA fallback, we need to avoid making `.data` requests if the path wasn't pre-rendered because the request will 404
    *   We don't know all the pre-rendered paths client-side, however:
        *   All `loader` data in `ssr:false` mode is static because it's generated at build time
        *   A route must use a `clientLoader` to do anything dynamic
        *   Therefore, if a route only has a `loader` and not a `clientLoader`, we disable revalidation by default because there is no new data to retrieve
        *   We short circuit and skip single fetch `.data` request logic if there are no server loaders with `shouldLoad=true` in our single fetch `dataStrategy`
        *   This ensures that the route doesn't cause a `.data` request that would 404 after a submission
*   `react-router` - Align dev server behavior with static file server behavior when `ssr:false` is set ([#12948](https://github.com/remix-run/react-router/pull/12948))
    *   When no `prerender` config exists, only SSR down to the root `HydrateFallback` (SPA Mode)
    *   When a `prerender` config exists but the current path is not pre-rendered, only SSR down to the root `HydrateFallback` (SPA Fallback)
    *   Return a 404 on `.data` requests to non-pre-rendered paths
*   `react-router` - Improve prefetch performance of CSS side effects in framework mode ([#12889](https://github.com/remix-run/react-router/pull/12889))
*   `react-router` - Properly handle interrupted manifest requests in lazy route discovery ([#12915](https://github.com/remix-run/react-router/pull/12915))
*   `@react-router/dev` - Handle custom `envDir` in Vite config ([#12969](https://github.com/remix-run/react-router/pull/12969))
*   `@react-router/dev` - Fix CLI parsing to allow argument-less `npx react-router` usage ([#12925](https://github.com/remix-run/react-router/pull/12925))
*   `@react-router/dev` - Skip action-only resource routes when using `prerender:true` ([#13004](https://github.com/remix-run/react-router/pull/13004))
*   `@react-router/dev` - Enhance invalid export detection when using `ssr:false` ([#12948](https://github.com/remix-run/react-router/pull/12948))
    *   `headers`/`action` functions are prohibited in all routes with `ssr:false` because there will be no runtime server on which to run them
    *   `loader` functions are more nuanced and depend on whether a given route is prerendered
        *   When using `ssr:false` without a `prerender` config, only the `root` route can have a `loader`
        *   When using `ssr:false` with a `prerender` config, only routes matched by a `prerender` path can have a `loader`
*   `@react-router/dev` - Error at build time in `ssr:false` + `prerender` apps for the edge case scenario of: ([#13021](https://github.com/remix-run/react-router/pull/13021))
    *   A parent route has only a `loader` (does not have a `clientLoader`)
    *   The parent route is pre-rendered
    *   The parent route has children routes which are not prerendered
    *   This means that when the child paths are loaded via the SPA fallback, the parent won't have any `loaderData` because there is no server on which to run the `loader`
    *   This can be resolved by either adding a parent `clientLoader` or pre-rendering the child paths
    *   If you add a `clientLoader`, calling the `serverLoader()` on non-prerendered paths will throw a 404
*   `@react-router/dev` - Limit prerendered resource route `.data` files to only the target route ([#13004](https://github.com/remix-run/react-router/pull/13004))
*   `@react-router/dev` - Fix pre-rendering of binary files ([#13039](https://github.com/remix-run/react-router/pull/13039))
*   `@react-router/dev` - Fix typegen for repeated params ([#13012](https://github.com/remix-run/react-router/pull/13012))
    *   In React Router, path parameters are keyed by their name, so for a path pattern like `/a/:id/b/:id?/c/:id`, the last `:id` will set the value for `id` in `useParams` and the `params` prop
        *   For example, `/a/1/b/2/c/3` will result in the value `{ id: 3 }` at runtime
    *   Previously, generated types for params incorrectly modeled repeated params with an array
        *   For example, `/a/1/b/2/c/3` generated a type like `{ id: [1,2,3] }`.
    *   To be consistent with runtime behavior, the generated types now correctly model the "last one wins" semantics of path parameters.
        *   For example, `/a/1/b/2/c/3` now generates a type like `{ id: 3 }`.
*   `@react-router/dev` - Fix path to load `package.json` for `react-router --version` ([#13012](https://github.com/remix-run/react-router/pull/13012))

### [](#unstable-changes-6)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Add `unstable_SerializesTo` brand type for library authors to register types serializable by React Router's streaming format (`turbo-stream`) ([#12264](https://github.com/remix-run/react-router/pull/12264))
*   `@react-router/dev` - Add unstable support for splitting route modules in framework mode via `future.unstable_splitRouteModules` ([#11871](https://github.com/remix-run/react-router/pull/11871))
*   `@react-router/dev` - Add `future.unstable_viteEnvironmentApi` flag to enable experimental Vite Environment API support ([#12936](https://github.com/remix-run/react-router/pull/12936))

#### [](#split-route-modules-unstable)Split Route Modules (unstable)

> ⚠️ This feature is currently [unstable](https://reactrouter.com/community/api-development-strategy#unstable-flags), enabled by the `future.unstable_splitRouteModules` flag. We’d love any interested users to play with it locally and provide feedback, but we do not recommend using it in production yet.
> 
> If you do choose to adopt this flag in production, please ensure you do sufficient testing against your production build to ensure that the optimization is working as expected.

One of the conveniences of the [Route Module API](https://reactrouter.com/start/framework/route-module) is that everything a route needs is in a single file. Unfortunately this comes with a performance cost in some cases when using the `clientLoader`, `clientAction`, and `HydrateFallback` APIs.

As a basic example, consider this route module:

    import { MassiveComponent } from "~/components";
    
    export async function clientLoader() {
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    
    export default function Component({ loaderData }) {
      return <MassiveComponent data={loaderData} />;
    }
    

In this example we have a minimal `clientLoader` export that makes a basic fetch call, whereas the default component export is much larger. This is a problem for performance because it means that if we want to navigate to this route client-side, the entire route module must be downloaded before the client loader can start running.

To visualize this as a timeline:

In the following timeline diagrams, different characters are used within the Route Module bars to denote the different Route Module APIs being exported.

    Get Route Module:  |--=======|
    Run clientLoader:            |-----|
    Render:                            |-|
    

Instead, we want to optimize this to the following:

    Get clientLoader:  |--|
    Get Component:     |=======|
    Run clientLoader:     |-----|
    Render:                     |-|
    

To achieve this optimization, React Router will split the route module into multiple smaller modules during the production build process. In this case, we'll end up with two separate [virtual modules](https://vite.dev/guide/api-plugin#virtual-modules-convention) — one for the client loader and one for the component and its dependencies.

    export async function clientLoader() {
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    

    import { MassiveComponent } from "~/components";
    
    export default function Component({ loaderData }) {
      return <MassiveComponent data={loaderData} />;
    }
    

> 💡 This optimization is automatically applied in framework mode, but you can also implement it in library mode via `route.lazy` and authoring your route in multiple files as covered in our blog post on [lazy loading route modules.](https://remix.run/blog/lazy-loading-routes#advanced-usage-and-optimizations)

Now that these are available as separate modules, the client loader and the component can be downloaded in parallel. This means that the client loader can be executed as soon as it's ready without having to wait for the component.

This optimization is even more pronounced when more Route Module APIs are used. For example, when using `clientLoader`, `clientAction` and `HydrateFallback`, the timeline for a single route module during a client-side navigation might look like this:

    Get Route Module:     |--~~++++=======|
    Run clientLoader:                     |-----|
    Render:                                     |-|
    

This would instead be optimized to the following:

    Get clientLoader:     |--|
    Get clientAction:     |~~|
    Get HydrateFallback:  SKIPPED
    Get Component:        |=======|
    Run clientLoader:        |-----|
    Render:                        |-|
    

Note that this optimization only works when the Route Module APIs being split don't share code within the same file. For example, the following route module can't be split:

    import { MassiveComponent } from "~/components";
    
    const shared = () => console.log("hello");
    
    export async function clientLoader() {
      shared();
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    
    export default function Component({ loaderData }) {
      shared();
      return <MassiveComponent data={loaderData} />;
    }
    

This route will still work, but since both the client loader and the component depend on the `shared` function defined within the same file, it will be de-optimized into a single route module.

To avoid this, you can extract any code shared between exports into a separate file. For example:

    export const shared = () => console.log("hello");
    

You can then import this shared code in your route module without triggering the de-optimization:

    import { MassiveComponent } from "~/components";
    import { shared } from "./shared";
    
    export async function clientLoader() {
      shared();
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    
    export default function Component({ loaderData }) {
      shared();
      return <MassiveComponent data={loaderData} />;
    }
    

Since the shared code is in its own module, React Router is now able to split this route module into two separate virtual modules:

    import { shared } from "./shared";
    
    export async function clientLoader() {
      shared();
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    

    import { MassiveComponent } from "~/components";
    import { shared } from "./shared";
    
    export default function Component({ loaderData }) {
      shared();
      return <MassiveComponent data={loaderData} />;
    }
    

If your project is particularly performance sensitive, you can set the `unstable_splitRouteModules` future flag to `"enforce"`:

    export default {
      future: {
        unstable_splitRouteModules: "enforce",
      },
    };
    

This setting will raise an error if any route modules can't be split:

    Error splitting route module: routes/example/route.tsx
    
    - clientLoader
    
    This export could not be split into its own chunk because it shares code with other exports. You should extract any shared code into its own module and then import it within the route module.
    

### [](#changes-by-package-4)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/create-react-router/CHANGELOG.md#720)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router/CHANGELOG.md#720)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-architect/CHANGELOG.md#720)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-cloudflare/CHANGELOG.md#720)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-dev/CHANGELOG.md#720)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-express/CHANGELOG.md#720)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-fs-routes/CHANGELOG.md#720)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-node/CHANGELOG.md#720)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#720)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-serve/CHANGELOG.md#720)

**Full Changelog**: [`v7.1.5...v7.2.0`](https://github.com/remix-run/react-router/compare/react-router@7.1.5...react-router@7.2.0)

[](#v715)v7.1.5
---------------

Date: 2025-01-31

### [](#patch-changes-9)Patch Changes

*   `react-router` - Fix regression introduced in `7.1.4` via [#12800](https://github.com/remix-run/react-router/pull/12800) that caused issues navigating to hash routes inside splat routes for applications using Lazy Route Discovery (`patchRoutesOnNavigation`) ([#12927](https://github.com/remix-run/react-router/pull/12927))

**Full Changelog**: [`v7.1.4...v7.1.5`](https://github.com/remix-run/react-router/compare/react-router@7.1.4...react-router@7.1.5)

[](#v714)v7.1.4
---------------

Date: 2025-01-30

### [](#patch-changes-10)Patch Changes

*   `@react-router/dev` - Properly resolve Windows file paths to scan for Vite's dependency optimization when using the `unstable_optimizeDeps` future flag ([#12637](https://github.com/remix-run/react-router/pull/12637))
*   `@react-router/dev` - Fix prerendering when using a custom server - previously we ended up trying to import the users custom server when we actually want to import the virtual server build module ([#12759](https://github.com/remix-run/react-router/pull/12759))
*   `react-router` - Properly handle status codes that cannot have a body in single fetch responses (204, etc.) ([#12760](https://github.com/remix-run/react-router/pull/12760))
*   `react-router` - Properly bubble headers as `errorHeaders` when throwing a `data()` result ([#12846](https://github.com/remix-run/react-router/pull/12846))
    *   Avoid duplication of `Set-Cookie` headers if also returned from `headers`
*   `react-router` - Stop erroring on resource routes that return raw strings/objects and instead serialize them as `text/plain` or `application/json` responses ([#12848](https://github.com/remix-run/react-router/pull/12848))
    *   This only applies when accessed as a resource route without the `.data` extension
    *   When accessed from a Single Fetch `.data` request, they will still be encoded via `turbo-stream`
*   `react-router` - Optimize Lazy Route Discovery path discovery to favor a single `querySelectorAll` call at the `body` level instead of many calls at the sub-tree level ([#12731](https://github.com/remix-run/react-router/pull/12731))
*   `react-router` - Optimize route matching by skipping redundant `matchRoutes` calls when possible ([#12800](https://github.com/remix-run/react-router/pull/12800), [#12882](https://github.com/remix-run/react-router/pull/12882))
*   `react-router` - Internal reorg to clean up some duplicated route module types ([#12799](https://github.com/remix-run/react-router/pull/12799))

**Full Changelog**: [`v7.1.3...v7.1.4`](https://github.com/remix-run/react-router/compare/react-router@7.1.3...react-router@7.1.4)

[](#v713)v7.1.3
---------------

Date: 2025-01-17

### [](#patch-changes-11)Patch Changes

*   `@react-router/dev` - Fix `reveal` and `routes` CLI commands ([#12745](https://github.com/remix-run/react-router/pull/12745))

**Full Changelog**: [`v7.1.2...v7.1.3`](https://github.com/remix-run/react-router/compare/react-router@7.1.2...react-router@7.1.3)

[](#v712)v7.1.2
---------------

Date: 2025-01-16

### [](#patch-changes-12)Patch Changes

*   `react-router` - Fix issue with fetcher data cleanup in the data layer on fetcher unmount ([#12681](https://github.com/remix-run/react-router/pull/12681))
*   `react-router` - Do not rely on `symbol` for filtering out `redirect` responses from loader data ([#12694](https://github.com/remix-run/react-router/pull/12694))
    *   Previously, some projects were getting type checking errors like:
        
            error TS4058: Return type of exported function has or is using name 'redirectSymbol' from external module "node_modules/..." but cannot be named.
            
        
    *   Now that `symbol`s are not used for the `redirect` response type, these errors should no longer be present
*   `@react-router/dev` - Fix default external conditions in Vite v6 ([#12644](https://github.com/remix-run/react-router/pull/12644))
    *   This fixes resolution issues with certain npm packages
*   `@react-router/dev` - Fix mismatch in prerendering html/data files when path is missing a leading slash ([#12684](https://github.com/remix-run/react-router/pull/12684))
*   `@react-router/dev` - Use `module-sync` server condition when enabled in the runtime. This fixes React context mismatches (e.g. `useHref() may be used only in the context of a <Router> component.`) during development on Node 22.10.0+ when using libraries that have a peer dependency on React Router ([#12729](https://github.com/remix-run/react-router/pull/12729))
*   `@react-router/dev` - Fix `react-refresh` source maps ([#12686](https://github.com/remix-run/react-router/pull/12686))

**Full Changelog**: [`v7.1.1...v7.1.2`](https://github.com/remix-run/react-router/compare/react-router@7.1.1...react-router@7.1.2)

[](#v711)v7.1.1
---------------

Date: 2024-12-23

### [](#patch-changes-13)Patch Changes

*   `@react-router/dev` - Fix for a crash when optional args are passed to the CLI ([#12609](https://github.com/remix-run/react-router/pull/12609))

**Full Changelog**: [`v7.1.0...v7.1.1`](https://github.com/remix-run/react-router/compare/react-router@7.1.0...react-router@7.1.1)

[](#v710)v7.1.0
---------------

Date: 2024-12-20

### [](#minor-changes-5)Minor Changes

*   Add support for Vite v6 ([#12469](https://github.com/remix-run/react-router/pull/12469))

### [](#patch-changes-14)Patch Changes

*   `react-router` - Throw unwrapped Single Fetch `redirect` to align with pre-Single Fetch behavior ([#12506](https://github.com/remix-run/react-router/pull/12506))
*   `react-router` - Ignore redirects when inferring loader data types ([#12527](https://github.com/remix-run/react-router/pull/12527))
*   `react-router` - Remove `<Link prefetch>` warning which suffers from false positives in a lazy route discovery world ([#12485](https://github.com/remix-run/react-router/pull/12485))
*   `create-react-router` - Fix missing `fs-extra` dependency ([#12556](https://github.com/remix-run/react-router/pull/12556))
*   `@react-router/dev`/`@react-router/serve` - Properly initialize `NODE_ENV` if not already set for compatibility with React 19 ([#12578](https://github.com/remix-run/react-router/pull/12578))
*   `@react-router/dev` - Remove the leftover/unused `abortDelay` prop from `ServerRouter` and update the default `entry.server.tsx` to use the new `streamTimeout` value for Single Fetch ([#12478](https://github.com/remix-run/react-router/pull/12478))
    *   The `abortDelay` functionality was removed in v7 as it was coupled to the `defer` implementation from Remix v2, but this removal of this prop was missed
    *   If you were still using this prop in your `entry.server` file, it's likely your app is not aborting streams as you would expect and you will need to adopt the new [`streamTimeout`](https://reactrouter.com/explanation/special-files#streamtimeout) value introduced with Single Fetch
*   `@react-router/fs-routes` - Throw error in `flatRoutes` if routes directory is missing ([#12407](https://github.com/remix-run/react-router/pull/12407))

### [](#changes-by-package-5)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/create-react-router/CHANGELOG.md#710)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router/CHANGELOG.md#710)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-architect/CHANGELOG.md#710)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-cloudflare/CHANGELOG.md#710)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-dev/CHANGELOG.md#710)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-express/CHANGELOG.md#710)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-fs-routes/CHANGELOG.md#710)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-node/CHANGELOG.md#710)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#710)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-serve/CHANGELOG.md#710)

**Full Changelog**: [`v7.0.2...v7.1.0`](https://github.com/remix-run/react-router/compare/react-router@7.0.2...react-router@7.1.0)

[](#v702)v7.0.2
---------------

Date: 2024-12-02

### [](#patch-changes-15)Patch Changes

*   `react-router` - Temporarily only use one build in export map so packages can have a peer dependency on react router ([#12437](https://github.com/remix-run/react-router/pull/12437))
*   `@react-router/dev` - Support `moduleResolution` `Node16` and `NodeNext` ([#12440](https://github.com/remix-run/react-router/pull/12440))
*   `@react-router/dev` - Generate wide `matches` and `params` types for child routes ([#12397](https://github.com/remix-run/react-router/pull/12397))
    *   At runtime, `matches` includes child route matches and `params` include child route path parameters
    *   But previously, we only generated types for parent routes and the current route in `matches` and `params`
    *   To align our generated types more closely to the runtime behavior, we now generate more permissive, wider types when accessing child route information

**Full Changelog**: [`v7.0.1...v7.0.2`](https://github.com/remix-run/react-router/compare/react-router@7.0.1...react-router@7.0.2)

[](#v701)v7.0.1
---------------

Date: 2024-11-22

### [](#patch-changes-16)Patch Changes

*   `@react-router/dev` - Ensure typegen file watcher is cleaned up when Vite dev server restarts ([#12331](https://github.com/remix-run/react-router/pull/12331))
*   `@react-router/dev` - Pass route `error` to `ErrorBoundary` as a prop ([#12338](https://github.com/remix-run/react-router/pull/12338))

**Full Changelog**: [`v7.0.0...v7.0.1`](https://github.com/remix-run/react-router/compare/react-router@7.0.0...react-router@7.0.1)

[](#v700)v7.0.0
---------------

Date: 2024-11-21

### [](#breaking-changes)Breaking Changes

#### [](#package-restructuring)Package Restructuring

*   The `react-router-dom`, `@remix-run/react`, `@remix-run/server-runtime`, and `@remix-run/router` have been collapsed into the `react-router` package
    *   To ease migration, `react-router-dom` is still published in v7 as a re-export of everything from `react-router`
*   The `@remix-run/cloudflare-pages` and `@remix-run/cloudflare-workers` have been collapsed into `@react-router/cloudflare` package\`
*   The `react-router-dom-v5-compat` and `react-router-native` packages are removed starting with v7

#### [](#removed-adapter-re-exports)Removed Adapter Re-exports

Remix v2 used to re-export all common `@remix-run/server-runtime` APIs through the various runtime packages (`node`, `cloudflare`, `deno`) so that you wouldn't need an additional `@remix-run/server-runtime` dependency in your `package.json`. With the collapsing of packages into `react-router`, these common APIs are now no longer re-exported through the runtime adapters. You should import all common APIs from `react-router`, and only import runtime-specific APIs from the runtime packages:

    // Runtime-specific APIs
    import { createFileSessionStorage } from "@react-router/node";
    // Runtime-agnostic APIs
    import { redirect, useLoaderData } from "react-router";
    

#### [](#removed-apis)Removed APIs

The following APIs have been removed in React Router v7:

*   `json`
*   `defer`
*   `unstable_composeUploadHandlers`
*   `unstable_createMemoryUploadHandler`
*   `unstable_parseMultipartFormData`

#### [](#minimum-versions)Minimum Versions

React Router v7 requires the following minimum versions:

*   `node@20`
    *   React Router no longer provides an `installGlobals` method to [polyfill](https://reactrouter.com/dev/guides/deploying/custom-node#polyfilling-fetch) the `fetch` API
*   `react@18`, `react-dom@18`

#### [](#adopted-future-flag-behaviors)Adopted Future Flag Behaviors

Remix and React Router follow an [API Development Strategy](https://reactrouter.com/en/main/guides/api-development-strategy) leveraging "Future Flags" to avoid introducing a slew of breaking changes in a major release. Instead, breaking changes are introduced in minor releases behind a flag, allowing users to opt-in at their convenience. In the next major release, all future flag behaviors become the default behavior.

The following previously flagged behaviors are now the default in React Router v7:

*   [React Router v6 flags](https://reactrouter.com/en/v6/upgrading/future)
    *   `future.v7_relativeSplatPath`
    *   `future.v7_startTransition`
    *   `future.v7_fetcherPersist`
    *   `future.v7_normalizeFormMethod`
    *   `future.v7_partialHydration`
    *   `future.v7_skipActionStatusRevalidation`
*   [Remix v2 flags](https://remix.run/docs/en/v2/start/future-flags)
    *   `future.v3_fetcherPersist`
    *   `future.v3_relativeSplatPath`
    *   `future.v3_throwAbortReason`
    *   `future.v3_singleFetch`
    *   `future.v3_lazyRouteDiscovery`
    *   `future.v3_optimizeDeps`

#### [](#vite-compiler)Vite Compiler

The [Remix Vite plugin](https://remix.run/docs/en/2.12.1/start/future-flags#vite-plugin) is the proper way to build full-stack SSR apps using React Router v7. The former `esbuild`\-based compiler is no longer available.

**Renamed `vitePlugin` and `cloudflareDevProxyVitePlugin`**

For Remix consumers migrating to React Router, the `vitePlugin` and `cloudflareDevProxyVitePlugin` exports have been renamed and moved ([#11904](https://github.com/remix-run/react-router/pull/11904))

    -import {
    -  vitePlugin as remix,
    -  cloudflareDevProxyVitePlugin,
    -} from "@remix/dev";
    
    +import { reactRouter } from "@react-router/dev/vite";
    +import { cloudflareDevProxy } from "@react-router/dev/vite/cloudflare";
    

**Removed `manifest` option**

For Remix consumers migrating to React Router, the Vite plugin's `manifest` option has been removed. The `manifest` option been superseded by the more powerful `buildEnd` hook since it's passed the `buildManifest` argument. You can still write the build manifest to disk if needed, but you'll most likely find it more convenient to write any logic depending on the build manifest within the `buildEnd` hook itself. ([#11573](https://github.com/remix-run/react-router/pull/11573))

If you were using the `manifest` option, you can replace it with a `buildEnd` hook that writes the manifest to disk like this:

    // react-router.config.ts
    import { type Config } from "@react-router/dev/config";
    import { writeFile } from "node:fs/promises";
    
    export default {
      async buildEnd({ buildManifest }) {
        await writeFile(
          "build/manifest.json",
          JSON.stringify(buildManifest, null, 2),
          "utf-8"
        );
      },
    } satisfies Config;
    

#### [](#exposed-router-promises)Exposed Router Promises

Because React 19 will have first-class support for handling promises in the render pass (via `React.use` and `useAction`), we are now comfortable exposing the promises for the APIs that previously returned `undefined`:

*   `useNavigate()`
*   `useSubmit()`
*   `useFetcher().load`
*   `useFetcher().submit`
*   `useRevalidator().revalidate()`

### [](#other-notable-changes)Other Notable Changes

#### [](#routests)`routes.ts`

When using the React Router Vite plugin, routes are defined in `app/routes.ts`. Route config is exported via the `routes` export, conforming to the `RouteConfig` type. Route helper functions `route`, `index`, and `layout` are provided to make declarative type-safe route definitions easier.

    // app/routes.ts
    import {
      type RouteConfig,
      route,
      index,
      layout,
    } from "@react-router/dev/routes";
    
    export const routes: RouteConfig = [
      index("./home.tsx"),
      route("about", "./about.tsx"),
    
      layout("./auth/layout.tsx", [
        route("login", "./auth/login.tsx"),
        route("register", "./auth/register.tsx"),
      ]),
    
      route("concerts", [
        index("./concerts/home.tsx"),
        route(":city", "./concerts/city.tsx"),
        route("trending", "./concerts/trending.tsx"),
      ]),
    ];
    

For Remix consumers migrating to React Router, you can still configure file system routing within `routes.ts` using the `@react-router/fs-routes` package. A minimal route config that reproduces the default Remix setup looks like this:

    // app/routes.ts
    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export const routes: RouteConfig = flatRoutes();
    

If you want to migrate from file system routing to config-based routes, you can mix and match approaches by spreading the results of the async `flatRoutes` function into the array of config-based routes.

    // app/routes.ts
    import { type RouteConfig, route } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export const routes: RouteConfig = [
      // Example config-based route:
      route("/hello", "./routes/hello.tsx"),
    
      // File system routes scoped to a different directory:
      ...(await flatRoutes({
        rootDirectory: "fs-routes",
      })),
    ];
    

If you were using Remix's `routes` option to use alternative file system routing conventions, you can adapt these to the new `RouteConfig` format using `@react-router/remix-config-routes-adapter`.

For example, if you were using [Remix v1 route conventions](https://remix.run/docs/en/1.19.3/file-conventions/routes-files) in Remix v2, you can combine `@react-router/remix-config-routes-adapter` with `@remix-run/v1-route-convention` to adapt this to React Router:

    // app/routes.ts
    import { type RouteConfig } from "@react-router/dev/routes";
    import { remixConfigRoutes } from "@react-router/remix-config-routes-adapter";
    import { createRoutesFromFolders } from "@remix-run/v1-route-convention";
    
    export const routes: RouteConfig = remixConfigRoutes(async (defineRoutes) => {
      return createRoutesFromFolders(defineRoutes, {
        ignoredFilePatterns: ["**/.*", "**/*.css"],
      });
    });
    

Also note that, if you were using Remix's `routes` option to define config-based routes, you can also adapt these to the new `RouteConfig` format using `@react-router/remix-config-routes-adapter` with minimal code changes. While this makes for a fast migration path, we recommend migrating any config-based routes from Remix to the new `RouteConfig` format since it's a fairly straightforward migration.

    // app/routes.ts
    -import { type RouteConfig } from "@react-router/dev/routes";
    +import { type RouteConfig, route } from "@react-router/dev/routes";
    -import { remixConfigRoutes } from "@react-router/remix-config-routes-adapter";
    
    -export const routes: RouteConfig = remixConfigRoutes(async (defineRoutes) => {
    -  defineRoutes((route) => {
    -    route("/parent", "./routes/parent.tsx", () => [
    -      route("/child", "./routes/child.tsx"),
    -    ]);
    -  });
    -});
    +export const routes: RouteConfig = [
    +  route("/parent", "./routes/parent.tsx", [
    +    route("/child", "./routes/child.tsx"),
    +  ]),
    +];
    

#### [](#typesafety-improvements)Typesafety improvements

React Router now generates types for each of your route modules and passes typed props to route module component exports ([#11961](https://github.com/remix-run/react-router/pull/11961), [#12019](https://github.com/remix-run/react-router/pull/12019)). You can access those types by importing them from `./+types/<route filename without extension>`.

See [_How To > Route Module Type Safety_](https://reactrouter.com/dev/how-to/route-module-type-safety) and [_Explanations > Type Safety_](https://reactrouter.com/dev/explanation/type-safety) for more details.

#### [](#prerendering)Prerendering

React Router v7 includes a new `prerender` config in the vite plugin to support SSG use-cases. This will pre-render your `.html` and `.data` files at build time and so you can serve them statically at runtime from a running server or a CDN ([#11539](https://github.com/remix-run/react-router/pull/11539))

    export default defineConfig({
      plugins: [
        reactRouter({
          async prerender({ getStaticPaths }) {
            let slugs = await fakeGetSlugsFromCms();
            return [
              ...getStaticPaths(),
              ...slugs.map((slug) => `/product/${slug}`),
            ];
          },
        }),
        tsconfigPaths(),
      ],
    });
    
    async function fakeGetSlugsFromCms() {
      await new Promise((r) => setTimeout(r, 1000));
      return ["shirt", "hat"];
    }
    

### [](#major-changes-react-router)Major Changes (`react-router`)

*   Remove the original `defer` implementation in favor of using raw promises via single fetch and `turbo-stream` ([#11744](https://github.com/remix-run/react-router/pull/11744))
    *   This removes these exports from React Router:
        *   `defer`
        *   `AbortedDeferredError`
        *   `type TypedDeferredData`
        *   `UNSAFE_DeferredData`
        *   `UNSAFE_DEFERRED_SYMBOL`
*   Collapse packages into `react-router`([#11505](https://github.com/remix-run/react-router/pull/11505))
    *   `@remix-run/router`
    *   `react-router-dom`
    *   `@remix-run/server-runtime`
    *   `@remix-run/testing`
    *   As a note, the `react-router-dom` package is maintained to ease adoption but it simply re-exports all APIs from `react-router`
*   Drop support for Node 16, React Router SSR now requires Node 18 or higher ([#11391](https://github.com/remix-run/react-router/pull/11391), [#11690](https://github.com/remix-run/react-router/pull/11690))
*   Remove `future.v7_startTransition` flag ([#11696](https://github.com/remix-run/react-router/pull/11696))
*   Expose the underlying router promises from the following APIs for composition in React 19 APIs: ([#11521](https://github.com/remix-run/react-router/pull/11521))
*   Remove `future.v7_normalizeFormMethod` future flag ([#11697](https://github.com/remix-run/react-router/pull/11697))
*   Imports/Exports cleanup ([#11840](https://github.com/remix-run/react-router/pull/11840))
    *   Removed the following exports that were previously public API from `@remix-run/router`
        *   types
            *   `AgnosticDataIndexRouteObject`
            *   `AgnosticDataNonIndexRouteObject`
            *   `AgnosticDataRouteMatch`
            *   `AgnosticDataRouteObject`
            *   `AgnosticIndexRouteObject`
            *   `AgnosticNonIndexRouteObject`
            *   `AgnosticRouteMatch`
            *   `AgnosticRouteObject`
            *   `TrackedPromise`
            *   `unstable_AgnosticPatchRoutesOnMissFunction`
            *   `Action` -> exported as `NavigationType` via `react-router`
            *   `Router` exported as `RemixRouter` to differentiate from RR's `<Router>`
        *   API
            *   `getToPathname` (`@private`)
            *   `joinPaths` (`@private`)
            *   `normalizePathname` (`@private`)
            *   `resolveTo` (`@private`)
            *   `stripBasename` (`@private`)
            *   `createBrowserHistory` -> in favor of `createBrowserRouter`
            *   `createHashHistory` -> in favor of `createHashRouter`
            *   `createMemoryHistory` -> in favor of `createMemoryRouter`
            *   `createRouter`
            *   `createStaticHandler` -> in favor of wrapper `createStaticHandler` in RR Dom
            *   `getStaticContextFromError`
    *   Removed the following exports that were previously public API from `react-router`
        *   `Hash`
        *   `Pathname`
        *   `Search`
*   Remove `future.v7_prependBasename` from the internalized `@remix-run/router` package ([#11726](https://github.com/remix-run/react-router/pull/11726))
*   Remove `future.v7_throwAbortReason` from internalized `@remix-run/router` package ([#11728](https://github.com/remix-run/react-router/pull/11728))
*   Add `exports` field to all packages ([#11675](https://github.com/remix-run/react-router/pull/11675))
*   Renamed `RemixContext` to `FrameworkContext` ([#11705](https://github.com/remix-run/react-router/pull/11705))
*   Update the minimum React version to 18 ([#11689](https://github.com/remix-run/react-router/pull/11689))
*   `PrefetchPageDescriptor` replaced by `PageLinkDescriptor` ([#11960](https://github.com/remix-run/react-router/pull/11960))
*   Remove the `future.v7_partialHydration` flag ([#11725](https://github.com/remix-run/react-router/pull/11725))
    *   This also removes the `<RouterProvider fallbackElement>` prop
        *   To migrate, move the `fallbackElement` to a `hydrateFallbackElement`/`HydrateFallback` on your root route
    *   Also worth nothing there is a related breaking changer with this future flag:
        *   Without `future.v7_partialHydration` (when using `fallbackElement`), `state.navigation` was populated during the initial load
        *   With `future.v7_partialHydration`, `state.navigation` remains in an `"idle"` state during the initial load
*   Remove `future.v7_relativeSplatPath` future flag ([#11695](https://github.com/remix-run/react-router/pull/11695))
*   Remove remaining future flags ([#11820](https://github.com/remix-run/react-router/pull/11820))
    *   React Router `v7_skipActionErrorRevalidation`
    *   Remix `v3_fetcherPersist`, `v3_relativeSplatPath`, `v3_throwAbortReason`
*   Rename `createRemixStub` to `createRoutesStub` ([#11692](https://github.com/remix-run/react-router/pull/11692))
*   Remove `@remix-run/router` deprecated `detectErrorBoundary` option in favor of `mapRouteProperties` ([#11751](https://github.com/remix-run/react-router/pull/11751))
*   Add `react-router/dom` subpath export to properly enable `react-dom` as an optional `peerDependency` ([#11851](https://github.com/remix-run/react-router/pull/11851))
    *   This ensures that we don't blindly `import ReactDOM from "react-dom"` in `<RouterProvider>` in order to access `ReactDOM.flushSync()`, since that would break `createMemoryRouter` use cases in non-DOM environments
    *   DOM environments should import from `react-router/dom` to get the proper component that makes `ReactDOM.flushSync()` available:
        *   If you are using the Vite plugin, use this in your `entry.client.tsx`:
            *   `import { HydratedRouter } from 'react-router/dom'`
        *   If you are not using the Vite plugin and are manually calling `createBrowserRouter`/`createHashRouter`:
            *   `import { RouterProvider } from "react-router/dom"`
*   Remove `future.v7_fetcherPersist` flag ([#11731](https://github.com/remix-run/react-router/pull/11731))
*   Allow returning `undefined` from loaders and actions ([#11680](https://github.com/remix-run/react-router/pull/11680), [#12057](%5Bhttps://github.com/remix-run/react-router/pull/1205))
*   Use `createRemixRouter`/`RouterProvider` in `entry.client` instead of `RemixBrowser` ([#11469](https://github.com/remix-run/react-router/pull/11469))
*   Remove the deprecated `json` utility ([#12146](https://github.com/remix-run/react-router/pull/12146))
    *   You can use [`Response.json`](https://developer.mozilla.org/en-US/docs/Web/API/Response/json_static) if you still need to construct JSON responses in your app

### [](#major-changes-react-router-1)Major Changes (`@react-router/*`)

*   Remove `future.v3_singleFetch` flag ([#11522](https://github.com/remix-run/react-router/pull/11522))
*   Drop support for Node 16 and 18, update minimum Node version to 20 ([#11690](https://github.com/remix-run/react-router/pull/11690), [#12171](https://github.com/remix-run/react-router/pull/12171))
    *   Remove `installGlobals()` as this should no longer be necessary
*   Add `exports` field to all packages ([#11675](https://github.com/remix-run/react-router/pull/11675))
*   No longer re-export APIs from `react-router` through different runtime/adapter packages ([#11702](https://github.com/remix-run/react-router/pull/11702))
*   For Remix consumers migrating to React Router, the `crypto` global from the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) is now required when using cookie and session APIs
    *   This means that the following APIs are provided from `react-router` rather than platform-specific packages: ([#11837](https://github.com/remix-run/react-router/pull/11837))
        *   `createCookie`
        *   `createCookieSessionStorage`
        *   `createMemorySessionStorage`
        *   `createSessionStorage`
    *   For consumers running older versions of Node, the `installGlobals` function from `@remix-run/node` has been updated to define `globalThis.crypto`, using [Node's `require('node:crypto').webcrypto` implementation](https://nodejs.org/api/webcrypto.html)
    *   Since platform-specific packages no longer need to implement this API, the following low-level APIs have been removed:
        *   `createCookieFactory`
        *   `createSessionStorageFactory`
        *   `createCookieSessionStorageFactory`
        *   `createMemorySessionStorageFactory`
*   Consolidate types previously duplicated across `@remix-run/router`, `@remix-run/server-runtime`, and `@remix-run/react` now that they all live in `react-router` ([#12177](https://github.com/remix-run/react-router/pull/12177))
    *   Examples: `LoaderFunction`, `LoaderFunctionArgs`, `ActionFunction`, `ActionFunctionArgs`, `DataFunctionArgs`, `RouteManifest`, `LinksFunction`, `Route`, `EntryRoute`
    *   The `RouteManifest` type used by the "remix" code is now slightly stricter because it is using the former `@remix-run/router` `RouteManifest`
        *   `Record<string, Route> -> Record<string, Route | undefined>`
    *   Removed `AppData` type in favor of inlining `unknown` in the few locations it was used
    *   Removed `ServerRuntimeMeta*` types in favor of the `Meta*` types they were duplicated from
*   Migrate Remix v2 type generics to React Router ([#12180](https://github.com/remix-run/react-router/pull/12180))
    *   These generics are provided for Remix v2 migration purposes
    *   These generics and the APIs they exist on should be considered informally deprecated in favor of the new `Route.*` types
    *   Anyone migrating from React Router v6 should probably not leverage these new generics and should migrate straight to the `Route.*` types
    *   For React Router v6 users, these generics are new and should not impact your app, with one exception
        *   `useFetcher` previously had an optional generic (used primarily by Remix v2) that expected the data type
        *   This has been updated in v7 to expect the type of the function that generates the data (i.e., `typeof loader`/`typeof action`)
        *   Therefore, you should update your usages:
            *   ❌ `useFetcher<LoaderData>()`
            *   ✅ `useFetcher<typeof loader>()`
*   Update `cookie` dependency to `^1.0.1` - please see the [release notes](https://github.com/jshttp/cookie/releases) for any breaking changes ([#12172](https://github.com/remix-run/react-router/pull/12172))
*   `@react-router/cloudflare` - For Remix consumers migrating to React Router, all exports from `@remix-run/cloudflare-pages` are now provided for React Router consumers in the `@react-router/cloudflare` package. There is no longer a separate package for Cloudflare Pages. ([#11801](https://github.com/remix-run/react-router/pull/11801))
*   `@react-router/cloudflare` - The `@remix-run/cloudflare-workers` package has been deprecated. Remix consumers migrating to React Router should use the `@react-router/cloudflare` package directly. For guidance on how to use `@react-router/cloudflare` within a Cloudflare Workers context, refer to the Cloudflare Workers template. ([#11801](https://github.com/remix-run/react-router/pull/11801))
*   `@react-router/dev` - For Remix consumers migrating to React Router, the `vitePlugin` and `cloudflareDevProxyVitePlugin` exports have been renamed and moved. ([#11904](https://github.com/remix-run/react-router/pull/11904))
*   `@react-router/dev` - For Remix consumers migrating to React Router who used the Vite plugin's `buildEnd` hook, the resolved `reactRouterConfig` object no longer contains a `publicPath` property since this belongs to Vite, not React Router ([#11575](https://github.com/remix-run/react-router/pull/11575))
*   `@react-router/dev` - For Remix consumers migrating to React Router, the Vite plugin's `manifest` option has been removed ([#11573](https://github.com/remix-run/react-router/pull/11573))
*   `@react-router/dev` - Update default `isbot` version to v5 and drop support for `isbot@3` ([#11770](https://github.com/remix-run/react-router/pull/11770))
    *   If you have `isbot@4` or `isbot@5` in your `package.json`:
        *   You do not need to make any changes
    *   If you have `isbot@3` in your `package.json` and you have your own `entry.server.tsx` file in your repo
        *   You do not need to make any changes
        *   You can upgrade to `isbot@5` independent of the React Router v7 upgrade
    *   If you have `isbot@3` in your `package.json` and you do not have your own `entry.server.tsx` file in your repo
        *   You are using the internal default entry provided by React Router v7 and you will need to upgrade to `isbot@5` in your `package.json`
*   `@react-router/dev` - For Remix consumers migrating to React Router, Vite manifests (i.e. `.vite/manifest.json`) are now written within each build subdirectory, e.g. `build/client/.vite/manifest.json` and `build/server/.vite/manifest.json` instead of `build/.vite/client-manifest.json` and `build/.vite/server-manifest.json`. This means that the build output is now much closer to what you'd expect from a typical Vite project. ([#11573](https://github.com/remix-run/react-router/pull/11573))
    *   Originally the Remix Vite plugin moved all Vite manifests to a root-level `build/.vite` directory to avoid accidentally serving them in production, particularly from the client build. This was later improved with additional logic that deleted these Vite manifest files at the end of the build process unless Vite's `build.manifest` had been enabled within the app's Vite config. This greatly reduced the risk of accidentally serving the Vite manifests in production since they're only present when explicitly asked for. As a result, we can now assume that consumers will know that they need to manage these additional files themselves, and React Router can safely generate a more standard Vite build output.

### [](#minor-changes-6)Minor Changes

*   `react-router` - Params, loader data, and action data as props for route component exports ([#11961](https://github.com/remix-run/react-router/pull/11961))
*   `react-router` - Add route module type generation ([#12019](https://github.com/remix-run/react-router/pull/12019))
*   `react-router` - Remove duplicate `RouterProvider` implementations ([#11679](https://github.com/remix-run/react-router/pull/11679))
*   `react-router` - Stabilize `unstable_dataStrategy` ([#11969](https://github.com/remix-run/react-router/pull/11969))
*   `react-router` - Stabilize `unstable_patchRoutesOnNavigation` ([#11970](https://github.com/remix-run/react-router/pull/11970))
*   `react-router` - Add prefetching support to `Link`/`NavLink` when using Remix SSR ([#11402](https://github.com/remix-run/react-router/pull/11402))
*   `react-router` - Enhance `ScrollRestoration` so it can restore properly on an SSR'd document load ([#11401](https://github.com/remix-run/react-router/pull/11401))
*   `@react-router/dev` - Add support for the `prerender` config in the React Router vite plugin, to support existing SSG use-cases ([#11539](https://github.com/remix-run/react-router/pull/11539))
*   `@react-router/dev` - Remove internal `entry.server.spa.tsx` implementation which was not compatible with the Single Fetch async hydration approach ([#11681](https://github.com/remix-run/react-router/pull/11681))
*   `@react-router/serve`: Update `express.static` configurations to support new `prerender` API ([#11547](https://github.com/remix-run/react-router/pull/11547))
    *   Assets in the `build/client/assets` folder are served as before, with a 1-year immutable `Cache-Control` header
    *   Static files outside of assets, such as pre-rendered `.html` and `.data` files are not served with a specific `Cache-Control` header
    *   `.data` files are served with `Content-Type: text/x-turbo`
        *   For some reason, when adding this via `express.static`, it seems to also add a `Cache-Control: public, max-age=0` to `.data` files

### [](#patch-changes-17)Patch Changes

*   Replace `substr` with `substring` ([#12080](https://github.com/remix-run/react-router/pull/12080))
*   `react-router` - Fix redirects returned from loaders/actions using `data()` ([#12021](https://github.com/remix-run/react-router/pull/12021))
*   `@react-router/dev` - Enable prerendering for resource routes ([#12200](https://github.com/remix-run/react-router/pull/12200))
*   `@react-router/dev` - resolve config directory relative to flat output file structure ([#12187](https://github.com/remix-run/react-router/pull/12187))

### [](#changes-by-package-6)Changes by Package

*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router/CHANGELOG.md#700)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-architect/CHANGELOG.md#700)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-cloudflare/CHANGELOG.md#700)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-dev/CHANGELOG.md#700)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-express/CHANGELOG.md#700)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-fs-routes/CHANGELOG.md#700)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-node/CHANGELOG.md#700)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#700)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-serve/CHANGELOG.md#700)

**Full Changelog**: [`v6.28.0...v7.0.0`](https://github.com/remix-run/react-router/compare/react-router@6.28.0...react-router@7.0.0)

[](#react-router-v6-releases)React Router v6 Releases
=====================================================

[](#v6301)v6.30.1
-----------------

Date: 2025-05-20

### [](#patch-changes-18)Patch Changes

*   Partially revert optimization added in `6.29.0` to reduce calls to `matchRoutes` because it surfaced other issues ([#13623](https://github.com/remix-run/react-router/pull/13623))
*   Stop logging invalid warning when `v7_relativeSplatPath` is set to `false` ([#13502](https://github.com/remix-run/react-router/pull/13502))

**Full Changelog**: [`v6.30.0...v6.30.1`](https://github.com/remix-run/react-router/compare/react-router@6.30.0...react-router@6.30.1)

[](#v6300)v6.30.0
-----------------

Date: 2025-02-27

### [](#minor-changes-7)Minor Changes

*   Add `fetcherKey` as a parameter to `patchRoutesOnNavigation` ([#13109](https://github.com/remix-run/react-router/pull/13109))

### [](#patch-changes-19)Patch Changes

*   Fix regression introduced in `6.29.0` via [#12169](https://github.com/remix-run/react-router/pull/12169) that caused issues navigating to hash routes inside splat routes for applications using Lazy Route Discovery (`patchRoutesOnNavigation`) ([#13108](https://github.com/remix-run/react-router/pull/13108))

**Full Changelog**: [`v6.29.0...v6.30.0`](https://github.com/remix-run/react-router/compare/react-router@6.29.0...react-router@6.30.0)

[](#v6290)v6.29.0
-----------------

Date: 2025-01-30

### [](#minor-changes-8)Minor Changes

*   Provide the request `signal` as a parameter to `patchRoutesOnNavigation` ([#12900](https://github.com/remix-run/react-router/pull/12900))
    *   This can be used to abort any manifest fetches if the in-flight navigation/fetcher is aborted

### [](#patch-changes-20)Patch Changes

*   Do not log v7 deprecation warnings in production builds ([#12794](https://github.com/remix-run/react-router/pull/12794))
*   Properly bubble headers when throwing a `data()` result ([#12845](https://github.com/remix-run/react-router/pull/12845))
*   Optimize route matching by skipping redundant `matchRoutes` calls when possible ([#12169](https://github.com/remix-run/react-router/pull/12169))
*   Strip search parameters from `patchRoutesOnNavigation` `path` param for fetcher calls ([#12899](https://github.com/remix-run/react-router/pull/12899))

**Full Changelog**: [`v6.28.2...v6.29.0`](https://github.com/remix-run/react-router/compare/react-router@6.28.2...react-router@6.29.0)

[](#v6282)v6.28.2
-----------------

Date: 2025-01-16

### [](#patch-changes-21)Patch Changes

*   Fix manual fetcher `key` usage when not opted into `future.v7_fetcherPersist` ([#12674](https://github.com/remix-run/react-router/pull/12674))
*   Fix issue with fetcher data cleanup in the data layer on fetcher unmount ([#12674](https://github.com/remix-run/react-router/pull/12674))

**Full Changelog**: [`v6.28.1...v6.28.2`](https://github.com/remix-run/react-router/compare/react-router@6.28.1...react-router@6.28.2)

[](#v6281)v6.28.1
-----------------

Date: 2024-12-20

### [](#patch-changes-22)Patch Changes

*   Allow users to opt out of v7 deprecation warnings by setting flags to `false` ([#12441](https://github.com/remix-run/react-router/pull/12441))

**Full Changelog**: [`v6.28.0...v6.28.1`](https://github.com/remix-run/react-router/compare/react-router@6.28.0...react-router@6.28.1)

[](#v6280)v6.28.0
-----------------

Date: 2024-11-06

### [](#whats-changed-3)What's Changed

*   In preparation for v7 we've added deprecation warnings for any future flags that you have not yet opted into. Please use the flags to better prepare for eventually upgrading to v7.

### [](#minor-changes-9)Minor Changes

*   Log deprecation warnings for v7 flags ([#11750](https://github.com/remix-run/react-router/pull/11750))
    *   Add deprecation warnings to `json`/`defer` in favor of returning raw objects
        *   These methods will be removed in React Router v7

### [](#patch-changes-23)Patch Changes

*   Update JSDoc URLs for new website structure (add /v6/ segment) ([#12141](https://github.com/remix-run/react-router/pull/12141))

**Full Changelog**: [`v6.27.0...v6.28.0`](https://github.com/remix-run/react-router/compare/react-router@6.27.0...react-router@6.28.0)

[](#v6270)v6.27.0
-----------------

Date: 2024-10-11

### [](#whats-changed-4)What's Changed

#### [](#stabilized-apis)Stabilized APIs

This release stabilizes a handful of "unstable" APIs in preparation for the [pending](https://x.com/remix_run/status/1841926034868077009) React Router v7 release (see [these](https://remix.run/blog/merging-remix-and-react-router) [posts](https://remix.run/blog/incremental-path-to-react-19) for more info):

*   `unstable_dataStrategy` → `dataStrategy` (`createBrowserRouter` and friends) ([Docs](https://reactrouter.com/v6/routers/create-browser-router#optsdatastrategy))
*   `unstable_patchRoutesOnNavigation` → `patchRoutesOnNavigation` (`createBrowserRouter` and friends) ([Docs](https://reactrouter.com/v6/routers/create-browser-router#optspatchroutesonnavigation))
*   `unstable_flushSync` → `flushSync` (`useSubmit`, `fetcher.load`, `fetcher.submit`) ([Docs](https://reactrouter.com/v6/hooks/use-submit#optionsflushsync))
*   `unstable_viewTransition` → `viewTransition` (`<Link>`, `<Form>`, `useNavigate`, `useSubmit`) ([Docs](https://reactrouter.com/v6/components/link#viewtransition))

### [](#minor-changes-10)Minor Changes

*   Stabilize the `unstable_flushSync` option for navigations and fetchers ([#11989](https://github.com/remix-run/react-router/pull/11989))
*   Stabilize the `unstable_viewTransition` option for navigations and the corresponding `unstable_useViewTransitionState` hook ([#11989](https://github.com/remix-run/react-router/pull/11989))
*   Stabilize `unstable_dataStrategy` ([#11974](https://github.com/remix-run/react-router/pull/11974))
*   Stabilize `unstable_patchRoutesOnNavigation` ([#11973](https://github.com/remix-run/react-router/pull/11973))
    *   Add new `PatchRoutesOnNavigationFunctionArgs` type for convenience ([#11967](https://github.com/remix-run/react-router/pull/11967))

### [](#patch-changes-24)Patch Changes

*   Fix bug when submitting to the current contextual route (parent route with an index child) when an `?index` param already exists from a prior submission ([#12003](https://github.com/remix-run/react-router/pull/12003))
*   Fix `useFormAction` bug - when removing `?index` param it would not keep other non-Remix `index` params ([#12003](https://github.com/remix-run/react-router/pull/12003))
*   Fix bug with fetchers not persisting `preventScrollReset` through redirects during concurrent fetches ([#11999](https://github.com/remix-run/react-router/pull/11999))
*   Avoid unnecessary `console.error` on fetcher abort due to back-to-back revalidation calls ([#12050](https://github.com/remix-run/react-router/pull/12050))
*   Fix bugs with `partialHydration` when hydrating with errors ([#12070](https://github.com/remix-run/react-router/pull/12070))
*   Remove internal cache to fix issues with interrupted `patchRoutesOnNavigation` calls ([#12055](https://github.com/remix-run/react-router/pull/12055))
    *   ⚠️ This may be a breaking change if you were relying on this behavior in the `unstable_` API
    *   We used to cache in-progress calls to `patchRoutesOnNavigation` internally so that multiple navigations with the same start/end would only execute the function once and use the same promise
    *   However, this approach was at odds with `patch` short circuiting if a navigation was interrupted (and the `request.signal` aborted) since the first invocation's `patch` would no-op
    *   This cache also made some assumptions as to what a valid cache key might be - and is oblivious to any other application-state changes that may have occurred
    *   So, the cache has been removed because in _most_ cases, repeated calls to something like `import()` for async routes will already be cached automatically - and if not it's easy enough for users to implement this cache in userland
*   Remove internal `discoveredRoutes` FIFO queue from `unstable_patchRoutesOnNavigation` ([#11977](https://github.com/remix-run/react-router/pull/11977))
    *   ⚠️ This may be a breaking change if you were relying on this behavior in the `unstable_` API
    *   This was originally implemented as an optimization but it proved to be a bit too limiting
    *   If you need this optimization you can implement your own cache inside `patchRoutesOnNavigation`
*   Fix types for `RouteObject` within `PatchRoutesOnNavigationFunction`'s `patch` method so it doesn't expect agnostic route objects passed to `patch` ([#11967](https://github.com/remix-run/react-router/pull/11967))
*   Expose errors thrown from `patchRoutesOnNavigation` directly to `useRouteError` instead of wrapping them in a 400 `ErrorResponse` instance ([#12111](https://github.com/remix-run/react-router/pull/12111))

**Full Changelog**: [`v6.26.2...v6.27.0`](https://github.com/remix-run/react-router/compare/react-router@6.26.2...react-router@6.27.0)

[](#v6262)v6.26.2
-----------------

Date: 2024-09-09

### [](#patch-changes-25)Patch Changes

*   Update the `unstable_dataStrategy` API to allow for more advanced implementations ([#11943](https://github.com/remix-run/react-router/pull/11943))
    *   ⚠️ If you have already adopted `unstable_dataStrategy`, please review carefully as this includes breaking changes to this API
    *   Rename `unstable_HandlerResult` to `unstable_DataStrategyResult`
    *   Change the return signature of `unstable_dataStrategy` from a parallel array of `unstable_DataStrategyResult[]` (parallel to `matches`) to a key/value object of `routeId => unstable_DataStrategyResult`
        *   This allows more advanced control over revalidation behavior because you can opt-into or out-of revalidating data that may not have been revalidated by default (via `match.shouldLoad`)
    *   You should now return/throw a result from your `handlerOverride` instead of returning a `DataStrategyResult`
        *   The return value (or thrown error) from your `handlerOverride` will be wrapped up into a `DataStrategyResult` and returned fromm `match.resolve`
        *   Therefore, if you are aggregating the results of `match.resolve()` into a final results object you should not need to think about the `DataStrategyResult` type
        *   If you are manually filling your results object from within your `handlerOverride`, then you will need to assign a `DataStrategyResult` as the value so React Router knows if it's a successful execution or an error (see examples in the documentation for details)
    *   Added a new `fetcherKey` parameter to `unstable_dataStrategy` to allow differentiation from navigational and fetcher calls
*   Preserve opted-in view transitions through redirects ([#11925](https://github.com/remix-run/react-router/pull/11925))
*   Preserve pending view transitions through a router revalidation call ([#11917](https://github.com/remix-run/react-router/pull/11917))
*   Fix blocker usage when `blocker.proceed` is called quickly/synchronously ([#11930](https://github.com/remix-run/react-router/pull/11930))

**Full Changelog**: [`v6.26.1...v6.26.2`](https://github.com/remix-run/react-router/compare/react-router@6.26.1...react-router@6.26.2)

[](#v6261)v6.26.1
-----------------

Date: 2024-08-15

### [](#patch-changes-26)Patch Changes

*   Rename `unstable_patchRoutesOnMiss` to `unstable_patchRoutesOnNavigation` to match new behavior ([#11888](https://github.com/remix-run/react-router/pull/11888))
*   Update `unstable_patchRoutesOnNavigation` logic so that we call the method when we match routes with dynamic param or splat segments in case there exists a higher-scoring static route that we've not yet discovered ([#11883](https://github.com/remix-run/react-router/pull/11883))
    *   We also now leverage an internal FIFO queue of previous paths we've already called `unstable_patchRoutesOnNavigation` against so that we don't re-call on subsequent navigations to the same path

**Full Changelog**: [`v6.26.0...v6.26.1`](https://github.com/remix-run/react-router/compare/react-router@6.26.0...react-router@6.26.1)

[](#v6260)v6.26.0
-----------------

Date: 2024-08-01

### [](#minor-changes-11)Minor Changes

*   Add a new `replace(url, init?)` alternative to `redirect(url, init?)` that performs a `history.replaceState` instead of a `history.pushState` on client-side navigation redirects ([#11811](https://github.com/remix-run/react-router/pull/11811))
*   Add a new `unstable_data()` API for usage with Remix Single Fetch ([#11836](https://github.com/remix-run/react-router/pull/11836))
    *   This API is not intended for direct usage in React Router SPA applications
    *   It is primarily intended for usage with `createStaticHandler.query()` to allow loaders/actions to return arbitrary data along with custom `status`/`headers` without forcing the serialization of data into a `Response` instance
    *   This allows for more advanced serialization tactics via `unstable_dataStrategy` such as serializing via `turbo-stream` in Remix Single Fetch
    *   ⚠️ This removes the `status` field from `HandlerResult`
        *   If you need to return a specific `status` from `unstable_dataStrategy` you should instead do so via `unstable_data()`

### [](#patch-changes-27)Patch Changes

*   Fix internal cleanup of interrupted fetchers to avoid invalid revalidations on navigations ([#11839](https://github.com/remix-run/react-router/pull/11839))
*   Fix initial hydration behavior when using `future.v7_partialHydration` along with `unstable_patchRoutesOnMiss` ([#11838](https://github.com/remix-run/react-router/pull/11838))
    *   During initial hydration, `router.state.matches` will now include any partial matches so that we can render ancestor `HydrateFallback` components

**Full Changelog**: [`v6.25.1...v6.26.0`](https://github.com/remix-run/react-router/compare/react-router@6.25.1...react-router@6.26.0)

[](#v6251)v6.25.1
-----------------

Date: 2024-07-17

### [](#patch-changes-28)Patch Changes

*   Memoize some `RouterProvider` internals to reduce unnecessary re-renders ([#11803](https://github.com/remix-run/react-router/pull/11803))

**Full Changelog**: [`v6.25.0...v6.25.1`](https://github.com/remix-run/react-router/compare/react-router@6.25.0...react-router@6.25.1)

[](#v6250)v6.25.0
-----------------

Date: 2024-07-16

### [](#whats-changed-5)What's Changed

#### [](#stabilized-v7_skipactionerrorrevalidation)Stabilized `v7_skipActionErrorRevalidation`

This release stabilizes the `future.unstable_skipActionErrorRevalidation` flag into [`future.v7_skipActionErrorRevalidation`](https://reactrouter.com/v6/upgrading/future#v7_skipactionstatusrevalidation) in preparation for the upcoming React Router v7 release.

*   When this flag is enabled, actions that return/throw a `4xx/5xx` `Response` will not trigger a revalidation by default
*   This also stabilizes `shouldRevalidate`'s `unstable_actionStatus` parameter to `actionStatus`

### [](#minor-changes-12)Minor Changes

*   Stabilize `future.unstable_skipActionErrorRevalidation` as `future.v7_skipActionErrorRevalidation` ([#11769](https://github.com/remix-run/react-router/pull/11769))

### [](#patch-changes-29)Patch Changes

*   Fix regression and properly decode paths inside `useMatch` so matches/params reflect decoded params ([#11789](https://github.com/remix-run/react-router/pull/11789))
*   Fix bubbling of errors thrown from `unstable_patchRoutesOnMiss` ([#11786](https://github.com/remix-run/react-router/pull/11786))
*   Fix hydration in SSR apps using `unstable_patchRoutesOnMiss` that matched a splat route on the server ([#11790](https://github.com/remix-run/react-router/pull/11790))

**Full Changelog**: [`v6.24.1...v6.25.0`](https://github.com/remix-run/react-router/compare/react-router@6.24.1...react-router@6.25.0)

[](#v6241)v6.24.1
-----------------

Date: 2024-07-03

### [](#patch-changes-30)Patch Changes

*   Remove `polyfill.io` reference from warning message because the domain was sold and has since been determined to serve malware ([#11741](https://github.com/remix-run/react-router/pull/11741))
    *   See [https://sansec.io/research/polyfill-supply-chain-attack](https://sansec.io/research/polyfill-supply-chain-attack)
*   Export `NavLinkRenderProps` type for easier typing of custom `NavLink` callback ([#11553](https://github.com/remix-run/react-router/pull/11553))
*   When using `future.v7_relativeSplatPath`, properly resolve relative paths in splat routes that are children of pathless routes ([#11633](https://github.com/remix-run/react-router/pull/11633))
*   Fog of War (unstable): Trigger a new `router.routes` identity/reflow during route patching ([#11740](https://github.com/remix-run/react-router/pull/11740))
*   Fog of War (unstable): Fix initial matching when a splat route matches ([#11759](https://github.com/remix-run/react-router/pull/11759))

**Full Changelog**: [`v6.24.0...v6.24.1`](https://github.com/remix-run/react-router/compare/react-router@6.24.0...react-router@6.24.1)

[](#v6240)v6.24.0
-----------------

Date: 2024-06-24

### [](#whats-changed-6)What's Changed

#### [](#lazy-route-discovery-aka-fog-of-war)Lazy Route Discovery (a.k.a. "Fog of War")

We're really excited to release our new API for "Lazy Route Discovery" in `v6.24.0`! For some background information, please check out the original [RFC](https://github.com/remix-run/react-router/discussions/11113). The **tl;dr;** is that ever since we introduced the Data APIs in v6.4 via `<RouterProvider>`, we've been a little bummed that one of the tradeoffs was the lack of a compelling code-splitting story mirroring what we had in the `<BrowserRouter>`/`<Routes>` apps. We took a baby-step towards improving that story with `route.lazy` in `v6.9.0`, but with `v6.24.0` we've gone the rest of the way.

With "Fog of War", you can now load portions of the route tree lazily via the new `unstable_patchRoutesOnMiss` option passed to `createBrowserRouter` (and it's memory/hash counterparts). This gives you a way to hook into spots where React Router is unable to match a given path and patch new routes into the route tree during the navigation (or fetcher call).

Here's a very small example, but please refer to the [documentation](https://reactrouter.com/v6/routers/create-browser-router#optsunstable_patchroutesonmiss) for more information and use cases:

    const router = createBrowserRouter(
      [
        {
          id: "root",
          path: "/",
          Component: RootComponent,
        },
      ],
      {
        async unstable_patchRoutesOnMiss({ path, patch }) {
          if (path === "/a") {
            // Load the `a` route (`{ path: 'a', Component: A }`)
            let route = await getARoute();
            // Patch the `a` route in as a new child of the `root` route
            patch("root", [route]);
          }
        },
      }
    );
    

### [](#minor-changes-13)Minor Changes

*   Add support for Lazy Route Discovery (a.k.a. "Fog of War") ([#11626](https://github.com/remix-run/react-router/pull/11626))

### [](#patch-changes-31)Patch Changes

*   Fix `fetcher.submit` types - remove incorrect `navigate`/`fetcherKey`/`unstable_viewTransition` options because they are only relevant for `useSubmit` ([#11631](https://github.com/remix-run/react-router/pull/11631))
*   Allow falsy `location.state` values passed to `<StaticRouter>` ([#11495](https://github.com/remix-run/react-router/pull/11495))

**Full Changelog**: [`v6.23.1...v6.24.0`](https://github.com/remix-run/react-router/compare/react-router@6.23.1...react-router@6.24.0)

[](#v6231)v6.23.1
-----------------

Date: 2024-05-10

### [](#patch-changes-32)Patch Changes

*   Allow `undefined` to be resolved through `<Await>` ([#11513](https://github.com/remix-run/react-router/pull/11513))
*   Add defensive `document` check when checking for `document.startViewTransition` availability ([#11544](https://github.com/remix-run/react-router/pull/11544))
*   Change the `react-router-dom/server` import back to `react-router-dom` instead of `index.ts` ([#11514](https://github.com/remix-run/react-router/pull/11514))
*   `@remix-run/router` - Support `unstable_dataStrategy` on `staticHandler.queryRoute` ([#11515](https://github.com/remix-run/react-router/pull/11515))

**Full Changelog**: [`v6.23.0...v6.23.1`](https://github.com/remix-run/react-router/compare/react-router@6.23.0...react-router@6.23.1)

[](#v6230)v6.23.0
-----------------

Date: 2024-04-23

### [](#whats-changed-7)What's Changed

#### [](#data-strategy-unstable)Data Strategy (unstable)

The new `unstable_dataStrategy` API is a low-level API designed for advanced use-cases where you need to take control over the data strategy for your `loader`/`action` functions. The default implementation is today's behavior, to fetch all loaders in parallel, but this option allows users to implement more advanced data flows including Remix ["Single Fetch"](https://remix.run/docs/guides/single-fetch), user-land middleware/context APIs, automatic loader caching, and more. Please see the [docs](https://reactrouter.com/v6/routers/create-browser-router#unstable_datastrategy) for more information.

**Note:** This is a low-level API intended for advanced use-cases. This overrides React Router's internal handling of `loader`/`action` execution, and if done incorrectly will break your app code. Please use with caution and perform the appropriate testing.

#### [](#skip-action-error-revalidation-unstable)Skip Action Error Revalidation (unstable)

Currently, all active `loader`'s revalidate after any `action` submission, regardless of the `action` result. However, in the majority of cases a `4xx`/`5xx` response from an `action` means that no data was actually changed and the revalidation is unnecessary. We've introduced a new `future.unstable_skipActionErrorRevalidation` flag that changes the behavior here, and we plan to make this the default in future version of React Router.

With this flag enabled, `action`'s that return/throw a `4xx`/`5xx` response status will no longer automatically revalidate. If you need to revalidate after a `4xx`/`5xx` result with this flag enabled, you can still do that via returning `true` from `shouldRevalidate` - which now also receives a new `unstable_actionStatus` argument alongside `actionResult` so you can make decision based on the status of the `action` response without having to encode it into the action data.

### [](#minor-changes-14)Minor Changes

*   Add a new `unstable_dataStrategy` configuration option ([#11098](https://github.com/remix-run/react-router/pull/11098), [#11377](https://github.com/remix-run/react-router/pull/11377))
*   `@remix-run/router` - Add a new `future.unstable_skipActionRevalidation` future flag ([#11098](https://github.com/remix-run/react-router/pull/11098))
*   `@remix-run/router` - SSR: Added a new `skipLoaderErrorBubbling` options to the `staticHandler.query` method to disable error bubbling by the static handler for use in Remix's Single Fetch implementation ([#11098](https://github.com/remix-run/react-router/pull/11098), ([#11377](https://github.com/remix-run/react-router/pull/11377)))

**Full Changelog**: [`v6.22.3...v6.23.0`](https://github.com/remix-run/react-router/compare/react-router@6.22.3...react-router@6.23.0)

[](#v6223)v6.22.3
-----------------

Date: 2024-03-07

### [](#patch-changes-33)Patch Changes

*   Fix a `future.v7_partialHydration` bug that would re-run loaders below the boundary on hydration if SSR loader errors bubbled to a parent boundary ([#11324](https://github.com/remix-run/react-router/pull/11324))
*   Fix a `future.v7_partialHydration` bug that would consider the router uninitialized if a route did not have a loader ([#11325](https://github.com/remix-run/react-router/pull/11325))

**Full Changelog**: [`v6.22.2...v6.22.3`](https://github.com/remix-run/react-router/compare/react-router@6.22.2...react-router@6.22.3)

[](#v6222)v6.22.2
-----------------

Date: 2024-02-28

### [](#patch-changes-34)Patch Changes

*   Preserve hydrated errors during partial hydration runs ([#11305](https://github.com/remix-run/react-router/pull/11305))

**Full Changelog**: [`v6.22.1...v6.22.2`](https://github.com/remix-run/react-router/compare/react-router@6.22.1...react-router@6.22.2)

[](#v6221)v6.22.1
-----------------

Date: 2024-02-16

### [](#patch-changes-35)Patch Changes

*   Fix encoding/decoding issues with pre-encoded dynamic parameter values ([#11199](https://github.com/remix-run/react-router/pull/11199))

**Full Changelog**: [`v6.22.0...v6.22.1`](https://github.com/remix-run/react-router/compare/react-router@6.22.0...react-router@6.22.1)

[](#v6220)v6.22.0
-----------------

Date: 2024-02-01

### [](#whats-changed-8)What's Changed

#### [](#core-web-vitals-technology-report-flag)Core Web Vitals Technology Report Flag

In 2021, the HTTP Archive launched the [Core Web Vitals Technology Report dashboard](https://discuss.httparchive.org/t/new-dashboard-the-core-web-vitals-technology-report/2178):

> By combining the powers of real-user experiences in the Chrome UX Report 26 (CrUX) dataset with web technology detections in HTTP Archive 30, we can get a glimpse into how architectural decisions like choices of CMS platform or JavaScript framework play a role in sites’ CWV performance.

They use a tool called [`wappalyzer`](https://github.com/HTTPArchive/wappalyzer) to identify what technologies a given website is using by looking for certain scripts, global JS variables, or other identifying characteristics. For example, for Remix applications, they [look for the global `__remixContext`](https://github.com/HTTPArchive/wappalyzer/blob/c2a24ee7c2d07bf9c521f02584ae2dcf603ac0b7/src/technologies/r.json#L1328) variable to identify that a website is using Remix.

It was brought to our attention that React Router was unable to be reliably identified because there are no identifying global aspects. They are currently [looking for external scripts with `react-router`](https://github.com/HTTPArchive/wappalyzer/blob/c2a24ee7c2d07bf9c521f02584ae2dcf603ac0b7/src/technologies/r.json#L637) in the name. This will identify sites using React Router from a CDN such as `unpkg` - but it will miss the **vast** majority of sites that are installing React Router from the npm registry and bundling it into their JS files. This results in [drastically under-reporting](https://lookerstudio.google.com/s/pixHkNmGbN4) the usage of React Router on the web.

Starting with version `6.22.0`, sites using `react-router-dom` will begin adding a `window.__reactRouterVersion` variable that will be set to a string value of the SemVer major version number (i.e., `window.__reactRouterVersion = "6";`) so that they can be properly identified.

### [](#minor-changes-15)Minor Changes

*   Include a `window.__reactRouterVersion` for CWV Report detection ([#11222](https://github.com/remix-run/react-router/pull/11222))
*   Add a `createStaticHandler` `future.v7_throwAbortReason` flag to throw `request.signal.reason` (defaults to a `DOMException`) when a request is aborted instead of an `Error` such as `new Error("query() call aborted: GET /path")` ([#11104](https://github.com/remix-run/react-router/pull/11104))
    *   Please note that `DOMException` was added in Node v17 so you will not get a `DOMException` on Node 16 and below.

### [](#patch-changes-36)Patch Changes

*   Respect the `ErrorResponse` status code if passed to `getStaticContextFormError` ([#11213](https://github.com/remix-run/react-router/pull/11213))

**Full Changelog**: [`v6.21.3...v6.22.0`](https://github.com/remix-run/react-router/compare/react-router@6.21.3...react-router@6.22.0)

[](#v6213)v6.21.3
-----------------

Date: 2024-01-18

### [](#patch-changes-37)Patch Changes

*   Fix `NavLink` `isPending` when a `basename` is used ([#11195](https://github.com/remix-run/react-router/pull/11195))
*   Remove leftover `unstable_` prefix from `Blocker`/`BlockerFunction` types ([#11187](https://github.com/remix-run/react-router/pull/11187))

**Full Changelog**: [`v6.21.2...v6.21.3`](https://github.com/remix-run/react-router/compare/react-router@6.21.2...react-router@6.21.3)

[](#v6212)v6.21.2
-----------------

Date: 2024-01-11

### [](#patch-changes-38)Patch Changes

*   Leverage `useId` for internal fetcher keys when available ([#11166](https://github.com/remix-run/react-router/pull/11166))
*   Fix bug where dashes were not picked up in dynamic parameter names ([#11160](https://github.com/remix-run/react-router/pull/11160))
*   Do not attempt to deserialize empty JSON responses ([#11164](https://github.com/remix-run/react-router/pull/11164))

**Full Changelog**: [`v6.21.1...v6.21.2`](https://github.com/remix-run/react-router/compare/react-router@6.21.1...react-router@6.21.2)

[](#v6211)v6.21.1
-----------------

Date: 2023-12-21

### [](#patch-changes-39)Patch Changes

*   Fix bug with `route.lazy` not working correctly on initial SPA load when `v7_partialHydration` is specified ([#11121](https://github.com/remix-run/react-router/pull/11121))
*   Fix bug preventing revalidation from occurring for persisted fetchers unmounted during the `submitting` phase ([#11102](https://github.com/remix-run/react-router/pull/11102))
*   De-dup relative path logic in `resolveTo` ([#11097](https://github.com/remix-run/react-router/pull/11097))

**Full Changelog**: [`v6.21.0...v6.21.1`](https://github.com/remix-run/react-router/compare/react-router@6.21.0...react-router@6.21.1)

[](#v6210)v6.21.0
-----------------

Date: 2023-12-13

### [](#whats-changed-9)What's Changed

#### [](#futurev7_relativesplatpath)`future.v7_relativeSplatPath`

We fixed a splat route path-resolution bug in `6.19.0`, but later determined a large number of applications were relying on the buggy behavior, so we reverted the fix in `6.20.1` (see [#10983](https://github.com/remix-run/react-router/issues/10983), [#11052](https://github.com/remix-run/react-router/issues/11052), [#11078](https://github.com/remix-run/react-router/issues/11078)).

The buggy behavior is that the default behavior when resolving relative paths inside a splat route would _ignore_ any splat (`*`) portion of the current route path. When the future flag is enabled, splat portions are included in relative path logic within splat routes.

For more information, please refer to the [`useResolvedPath` docs](https://reactrouter.com/v6/hooks/use-resolved-path#splat-paths) and/or the [detailed changelog entry](https://github.com/remix-run/react-router/blob/main/packages/react-router-dom/CHANGELOG.md#6210).

#### [](#partial-hydration)Partial Hydration

We added a new `future.v7_partialHydration` future flag for the `@remix-run/router` that enables partial hydration of a data router when Server-Side Rendering. This allows you to provide `hydrationData.loaderData` that has values for _some_ initially matched route loaders, but not all. When this flag is enabled, the router will call `loader` functions for routes that do not have hydration loader data during `router.initialize()`, and it will render down to the deepest provided `HydrateFallback` (up to the first route without hydration data) while it executes the unhydrated routes. ([#11033](https://github.com/remix-run/react-router/pull/11033))

### [](#minor-changes-16)Minor Changes

*   Add a new `future.v7_relativeSplatPath` flag to implement a breaking bug fix to relative routing when inside a splat route. ([#11087](https://github.com/remix-run/react-router/pull/11087))
*   Add a new `future.v7_partialHydration` future flag that enables partial hydration of a data router when Server-Side Rendering ([#11033](https://github.com/remix-run/react-router/pull/11033))

### [](#patch-changes-40)Patch Changes

*   Properly handle falsy error values in `ErrorBoundary`'s ([#11071](https://github.com/remix-run/react-router/pull/11071))
*   Catch and bubble errors thrown when trying to unwrap responses from `loader`/`action` functions ([#11061](https://github.com/remix-run/react-router/pull/11061))
*   Fix `relative="path"` issue when rendering `Link`/`NavLink` outside of matched routes ([#11062](https://github.com/remix-run/react-router/pull/11062))

**Full Changelog**: [`v6.20.1...v6.21.0`](https://github.com/remix-run/react-router/compare/react-router@6.20.1...react-router@6.21.0)

[](#v6201)v6.20.1
-----------------

Date: 2023-12-01

### [](#patch-changes-41)Patch Changes

*   Revert the `useResolvedPath` fix for splat routes due to a large number of applications that were relying on the buggy behavior (see [#11052](https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329)) ([#11078](https://github.com/remix-run/react-router/pull/11078))
    *   We plan to re-introduce this fix behind a future flag in the next minor version (see [this comment](https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329))
    *   This fix was included in versions `6.19.0` and `6.20.0`. If you are upgrading from `6.18.0` or earlier, you would not have been impacted by this fix.

**Full Changelog**: [`v6.20.0...v6.20.1`](https://github.com/remix-run/react-router/compare/react-router@6.20.0...react-router@6.20.1)

[](#v6200)v6.20.0
-----------------

Date: 2023-11-22

> \[!WARNING\] Please use version `6.20.1` or later instead of `6.20.0`. We discovered that a large number of apps were relying on buggy behavior that was fixed in this release ([#11045](https://github.com/remix-run/react-router/pull/11045)). We reverted the fix in `6.20.1` and will be re-introducing it behind a future flag in a subsequent release. See [#11052](https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329) for more details.

### [](#minor-changes-17)Minor Changes

*   Export the `PathParam` type from the public API ([#10719](https://github.com/remix-run/react-router/pull/10719))

### [](#patch-changes-42)Patch Changes

*   Do not revalidate unmounted fetchers when `v7_fetcherPersist` is enabled ([#11044](https://github.com/remix-run/react-router/pull/11044))
*   Fix bug with `resolveTo` path resolution in splat routes ([#11045](https://github.com/remix-run/react-router/pull/11045))
    *   This is a follow up to [#10983](https://github.com/remix-run/react-router/pull/10983) to handle the few other code paths using `getPathContributingMatches`
    *   This removes the `UNSAFE_getPathContributingMatches` export from `@remix-run/router` since we no longer need this in the `react-router`/`react-router-dom` layers

**Full Changelog**: [`v6.19.0...v6.20.0`](https://github.com/remix-run/react-router/compare/react-router@6.19.0...react-router@6.20.0)

[](#v6190)v6.19.0
-----------------

Date: 2023-11-16

> \[!WARNING\] Please use version `6.20.1` or later instead of `6.19.0`. We discovered that a large number of apps were relying on buggy behavior that was fixed in this release ([#10983](https://github.com/remix-run/react-router/pull/10983)). We reverted the fix in `6.20.1` and will be re-introducing it behind a future flag in a subsequent release. See [#11052](https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329) for more details.

### [](#whats-changed-10)What's Changed

#### [](#unstable_flushsync-api)`unstable_flushSync` API

This release brings a new `unstable_flushSync` option to the imperative APIs (`useSubmit`, `useNavigate`, `fetcher.submit`, `fetcher.load`) to let users opt-into synchronous DOM updates for pending/optimistic UI.

    function handleClick() {
      submit(data, { flushSync: true });
      // Everything is flushed to the DOM so you can focus/scroll to your pending/optimistic UI
      setFocusAndOrScrollToNewlyAddedThing();
    }
    

### [](#minor-changes-18)Minor Changes

*   Add `unstable_flushSync` option to `useNavigate`/`useSubmit`/`fetcher.load`/`fetcher.submit` to opt-out of `React.startTransition` and into `ReactDOM.flushSync` for state updates ([#11005](https://github.com/remix-run/react-router/pull/11005))
*   Remove the `unstable_` prefix from the [`useBlocker`](https://reactrouter.com/v6/hooks/use-blocker) hook as it's been in use for enough time that we are confident in the API ([#10991](https://github.com/remix-run/react-router/pull/10991))
    *   We do not plan to remove the prefix from `unstable_usePrompt` due to differences in how browsers handle `window.confirm` that prevent React Router from guaranteeing consistent/correct behavior

### [](#patch-changes-43)Patch Changes

*   Fix `useActionData` so it returns proper contextual action data and not _any_ action data in the tree ([#11023](https://github.com/remix-run/react-router/pull/11023))
    
*   Fix bug in `useResolvedPath` that would cause `useResolvedPath(".")` in a splat route to lose the splat portion of the URL path. ([#10983](https://github.com/remix-run/react-router/pull/10983))
    
    *   ⚠️ This fixes a quite long-standing bug specifically for `"."` paths inside a splat route which incorrectly dropped the splat portion of the URL. If you are relative routing via `"."` inside a splat route in your application you should double check that your logic is not relying on this buggy behavior and update accordingly.
*   Fix issue where a changing fetcher `key` in a `useFetcher` that remains mounted wasn't getting picked up ([#11009](https://github.com/remix-run/react-router/pull/11009))
    
*   Fix `useFormAction` which was incorrectly inheriting the `?index` query param from child route `action` submissions ([#11025](https://github.com/remix-run/react-router/pull/11025))
    
*   Fix `NavLink` `active` logic when `to` location has a trailing slash ([#10734](https://github.com/remix-run/react-router/pull/10734))
    
*   Fix types so `unstable_usePrompt` can accept a `BlockerFunction` in addition to a `boolean` ([#10991](https://github.com/remix-run/react-router/pull/10991))
    
*   Fix `relative="path"` bug where relative path calculations started from the full location pathname, instead of from the current contextual route pathname. ([#11006](https://github.com/remix-run/react-router/pull/11006))
    
        <Route path="/a">
          <Route path="/b" element={<Component />}>
            <Route path="/c" />
          </Route>
        </Route>;
        
        function Component() {
          return (
            <>
              {/* This is now correctly relative to /a/b, not /a/b/c */}
              <Link to=".." relative="path" />
              <Outlet />
            </>
          );
        }
        
    

**Full Changelog**: [`6.18.0...6.19.0`](https://github.com/remix-run/react-router/compare/react-router@6.18.0...react-router@6.19.0)

[](#v6180)v6.18.0
-----------------

Date: 2023-10-31

### [](#whats-changed-11)What's Changed

#### [](#new-fetcher-apis)New Fetcher APIs

Per this [RFC](https://github.com/remix-run/remix/discussions/7698), we've introduced some new APIs that give you more granular control over your fetcher behaviors.

*   You may now specify your own fetcher identifier via `useFetcher({ key: string })`, which allows you to access the same fetcher instance from different components in your application without prop-drilling
*   Fetcher keys are now exposed on the fetchers returned from `useFetchers` so that they can be looked up by `key`
*   `Form` and `useSubmit` now support optional `navigate`/`fetcherKey` props/params to allow kicking off a fetcher submission under the hood with an optionally user-specified `key`
    *   `<Form method="post" navigate={false} fetcherKey="my-key">`
    *   `submit(data, { method: "post", navigate: false, fetcherKey: "my-key" })`
    *   Invoking a fetcher in this way is ephemeral and stateless
    *   If you need to access the state of one of these fetchers, you will need to leverage `useFetchers()` or `useFetcher({ key })` to look it up elsewhere

#### [](#persistence-future-flag-futurev7_fetcherpersist)Persistence Future Flag (`future.v7_fetcherPersist`)

Per the same [RFC](https://github.com/remix-run/remix/discussions/7698) as above, we've introduced a new `future.v7_fetcherPersist` flag that allows you to opt-into the new fetcher persistence/cleanup behavior. Instead of being immediately cleaned up on unmount, fetchers will persist until they return to an `idle` state. This makes pending/optimistic UI _much_ easier in scenarios where the originating fetcher needs to unmount.

*   This is sort of a long-standing bug fix as the `useFetchers()` API was always supposed to only reflect **in-flight** fetcher information for pending/optimistic UI -- it was not intended to reflect fetcher data or hang onto fetchers after they returned to an `idle` state
*   Keep an eye out for the following specific behavioral changes when opting into this flag and check your app for compatibility:
    *   Fetchers that complete _while still mounted_ will no longer appear in `useFetchers()` after completion - they served no purpose in there since you can access the data via `useFetcher().data`
    *   Fetchers that previously unmounted _while in-flight_ will not be immediately aborted and will instead be cleaned up once they return to an `idle` state
        *   They will remain exposed via `useFetchers` while in-flight so you can still access pending/optimistic data after unmount
        *   If a fetcher is no longer mounted when it completes, then it's result will not be post processed - e.g., redirects will not be followed and errors will not bubble up in the UI
        *   However, if a fetcher was re-mounted elsewhere in the tree using the same `key`, then it's result will be processed, even if the originating fetcher was unmounted

### [](#minor-changes-19)Minor Changes

*   Add fetcher `key` APIs and `navigate=false` options ([#10960](https://github.com/remix-run/react-router/pull/10960))
*   Add `future.v7_fetcherPersist` flag ([#10962](https://github.com/remix-run/react-router/pull/10962))
*   Add support for optional path segments in `matchPath` ([#10768](https://github.com/remix-run/react-router/pull/10768))

### [](#patch-changes-44)Patch Changes

*   Fix the `future` prop on `BrowserRouter`, `HashRouter` and `MemoryRouter` so that it accepts a `Partial<FutureConfig>` instead of requiring all flags to be included ([#10962](https://github.com/remix-run/react-router/pull/10962))
*   Fix `router.getFetcher`/`router.deleteFetcher` type definitions which incorrectly specified `key` as an optional parameter ([#10960](https://github.com/remix-run/react-router/pull/10960))

**Full Changelog**: [`6.17.0...6.18.0`](https://github.com/remix-run/react-router/compare/react-router@6.17.0...react-router@6.18.0)

[](#v6170)v6.17.0
-----------------

Date: 2023-10-16

### [](#whats-changed-12)What's Changed

#### [](#view-transitions-)View Transitions 🚀

We're excited to release experimental support for the [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition) in React Router! You can now trigger navigational DOM updates to be wrapped in `document.startViewTransition` to enable CSS animated transitions on SPA navigations in your application.

The simplest approach to enabling a View Transition in your React Router app is via the new [`<Link unstable_viewTransition>`](https://reactrouter.com/v6/components/link#unstable_viewtransition) prop. This will cause the navigation DOM update to be wrapped in `document.startViewTransition` which will enable transitions for the DOM update. Without any additional CSS styles, you'll get a basic cross-fade animation for your page.

If you need to apply more fine-grained styles for your animations, you can leverage the [`unstable_useViewTransitionState`](https://reactrouter.com/v6/hooks/use-view-transition-state) hook which will tell you when a transition is in progress and you can use that to apply classes or styles:

    function ImageLink(to, src, alt) {
      const isTransitioning = unstable_useViewTransitionState(to);
      return (
        <Link to={to} unstable_viewTransition>
          <img
            src={src}
            alt={alt}
            style={{
              viewTransitionName: isTransitioning ? "image-expand" : "",
            }}
          />
        </Link>
      );
    }
    

You can also use the [`<NavLink unstable_viewTransition>`](https://reactrouter.com/v6/components/nav-link#unstable_viewtransition) shorthand which will manage the hook usage for you and automatically add a `transitioning` class to the `<a>` during the transition:

    a.transitioning img {
      view-transition-name: "image-expand";
    }
    

    <NavLink to={to} unstable_viewTransition>
      <img src={src} alt={alt} />
    </NavLink>
    

For an example usage of View Transitions, check out [our fork](https://github.com/brophdawg11/react-router-records) of the awesome [Astro Records](https://github.com/Charca/astro-records) demo.

For more information on using the View Transitions API, please refer to the [Smooth and simple transitions with the View Transitions API](https://developer.chrome.com/docs/web-platform/view-transitions/) guide from the Google Chrome team.

### [](#minor-changes-20)Minor Changes

*   Add support for view transitions ([#10916](https://github.com/remix-run/react-router/pull/10916))

### [](#patch-changes-45)Patch Changes

*   Log a warning and fail gracefully in `ScrollRestoration` when `sessionStorage` is unavailable ([#10848](https://github.com/remix-run/react-router/pull/10848))
*   Fix `RouterProvider` `future` prop type to be a `Partial<FutureConfig>` so that not all flags must be specified ([#10900](https://github.com/remix-run/react-router/pull/10900))
*   Allow 404 detection to leverage root route error boundary if path contains a URL segment ([#10852](https://github.com/remix-run/react-router/pull/10852))
*   Fix `ErrorResponse` type to avoid leaking internal field ([#10876](https://github.com/remix-run/react-router/pull/10876))

**Full Changelog**: [`6.16.0...6.17.0`](https://github.com/remix-run/react-router/compare/react-router@6.16.0...react-router@6.17.0)

[](#v6160)v6.16.0
-----------------

Date: 2023-09-13

### [](#minor-changes-21)Minor Changes

*   In order to move towards stricter TypeScript support in the future, we're aiming to replace current usages of `any` with `unknown` on exposed typings for user-provided data. To do this in Remix v2 without introducing breaking changes in React Router v6, we have added generics to a number of shared types. These continue to default to `any` in React Router and are overridden with `unknown` in Remix. In React Router v7 we plan to move these to `unknown` as a breaking change. ([#10843](https://github.com/remix-run/react-router/pull/10843))
    *   `Location` now accepts a generic for the `location.state` value
    *   `ActionFunctionArgs`/`ActionFunction`/`LoaderFunctionArgs`/`LoaderFunction` now accept a generic for the `context` parameter (only used in SSR usages via `createStaticHandler`)
    *   The return type of `useMatches` (now exported as `UIMatch`) accepts generics for `match.data` and `match.handle` - both of which were already set to `unknown`
*   Move the `@private` class export `ErrorResponse` to an `UNSAFE_ErrorResponseImpl` export since it is an implementation detail and there should be no construction of `ErrorResponse` instances in userland. This frees us up to export a `type ErrorResponse` which correlates to an instance of the class via `InstanceType`. Userland code should only ever be using `ErrorResponse` as a type and should be type-narrowing via `isRouteErrorResponse`. ([#10811](https://github.com/remix-run/react-router/pull/10811))
*   Export `ShouldRevalidateFunctionArgs` interface ([#10797](https://github.com/remix-run/react-router/pull/10797))
*   Removed private/internal APIs only required for the Remix v1 backwards compatibility layer and no longer needed in Remix v2 (`_isFetchActionRedirect`, `_hasFetcherDoneAnything`) ([#10715](https://github.com/remix-run/react-router/pull/10715))

### [](#patch-changes-46)Patch Changes

*   Properly encode rendered URIs in server rendering to avoid hydration errors ([#10769](https://github.com/remix-run/react-router/pull/10769))
*   Add method/url to error message on aborted `query`/`queryRoute` calls ([#10793](https://github.com/remix-run/react-router/pull/10793))
*   Fix a race-condition with loader/action-thrown errors on `route.lazy` routes ([#10778](https://github.com/remix-run/react-router/pull/10778))
*   Fix type for `actionResult` on the arguments object passed to `shouldRevalidate` ([#10779](https://github.com/remix-run/react-router/pull/10779))

**Full Changelog**: [`v6.15.0...v6.16.0`](https://github.com/remix-run/react-router/compare/react-router@6.15.0...react-router@6.16.0)

[](#v6150)v6.15.0
-----------------

Date: 2023-08-10

### [](#minor-changes-22)Minor Changes

*   Add's a new `redirectDocument()` function which allows users to specify that a redirect from a `loader`/`action` should trigger a document reload (via `window.location`) instead of attempting to navigate to the redirected location via React Router ([#10705](https://github.com/remix-run/react-router/pull/10705))

### [](#patch-changes-47)Patch Changes

*   Ensure `useRevalidator` is referentially stable across re-renders if revalidations are not actively occurring ([#10707](https://github.com/remix-run/react-router/pull/10707))
*   Ensure hash history always includes a leading slash on hash pathnames ([#10753](https://github.com/remix-run/react-router/pull/10753))
*   Fixes an edge-case affecting web extensions in Firefox that use `URLSearchParams` and the `useSearchParams` hook ([#10620](https://github.com/remix-run/react-router/pull/10620))
*   Reorder effects in `unstable_usePrompt` to avoid throwing an exception if the prompt is unblocked and a navigation is performed synchronously ([#10687](https://github.com/remix-run/react-router/pull/10687), [#10718](https://github.com/remix-run/react-router/pull/10718))
*   SSR: Do not include hash in `useFormAction()` for unspecified actions since it cannot be determined on the server and causes hydration issues ([#10758](https://github.com/remix-run/react-router/pull/10758))
*   SSR: Fix an issue in `queryRoute` that was not always identifying thrown `Response` instances ([#10717](https://github.com/remix-run/react-router/pull/10717))
*   `react-router-native`: Update `@ungap/url-search-params` dependency from `^0.1.4` to `^0.2.2` ([#10590](https://github.com/remix-run/react-router/pull/10590))

**Full Changelog**: [`v6.14.2...v6.15.0`](https://github.com/remix-run/react-router/compare/react-router@6.14.2...react-router@6.15.0)

[](#v6142)v6.14.2
-----------------

Date: 2023-07-17

### [](#patch-changes-48)Patch Changes

*   Add missing `<Form state>` prop to populate `history.state` on submission navigations ([#10630](https://github.com/remix-run/react-router/pull/10630))
*   Trigger an error if a `defer` promise resolves/rejects with `undefined` in order to match the behavior of loaders and actions which must return a value or `null` ([#10690](https://github.com/remix-run/react-router/pull/10690))
*   Properly handle fetcher redirects interrupted by normal navigations ([#10674](https://github.com/remix-run/react-router/pull/10674))
*   Initial-load fetchers should not automatically revalidate on GET navigations ([#10688](https://github.com/remix-run/react-router/pull/10688))
*   Properly decode element id when emulating hash scrolling via `<ScrollRestoration>` ([#10682](https://github.com/remix-run/react-router/pull/10682))
*   Typescript: Enhance the return type of `Route.lazy` to prohibit returning an empty object ([#10634](https://github.com/remix-run/react-router/pull/10634))
*   SSR: Support proper hydration of `Error` subclasses such as `ReferenceError`/`TypeError` ([#10633](https://github.com/remix-run/react-router/pull/10633))

**Full Changelog**: [`v6.14.1...v6.14.2`](https://github.com/remix-run/react-router/compare/react-router@6.14.1...react-router@6.14.2)

[](#v6141)v6.14.1
-----------------

Date: 2023-06-30

### [](#patch-changes-49)Patch Changes

*   Fix loop in `unstable_useBlocker` when used with an unstable blocker function ([#10652](https://github.com/remix-run/react-router/pull/10652))
*   Fix issues with reused blockers on subsequent navigations ([#10656](https://github.com/remix-run/react-router/pull/10656))
*   Updated dependencies:
    *   `@remix-run/router@1.7.1`

**Full Changelog**: [`v6.14.0...v6.14.1`](https://github.com/remix-run/react-router/compare/react-router@6.14.0...react-router@6.14.1)

[](#v6140)v6.14.0
-----------------

Date: 2023-06-23

### [](#whats-changed-13)What's Changed

#### [](#jsontext-submissions)JSON/Text Submissions

`6.14.0` adds support for JSON and Text submissions via `useSubmit`/`fetcher.submit` since it's not always convenient to have to serialize into `FormData` if you're working in a client-side SPA. To opt-into these encodings you just need to specify the proper `formEncType`:

**Opt-into `application/json` encoding:**

    function Component() {
      let navigation = useNavigation();
      let submit = useSubmit();
      submit({ key: "value" }, { method: "post", encType: "application/json" });
      // navigation.formEncType => "application/json"
      // navigation.json        => { key: "value" }
    }
    
    async function action({ request }) {
      // request.headers.get("Content-Type") => "application/json"
      // await request.json()                => { key: "value" }
    }
    

**Opt-into `text/plain` encoding:**

    function Component() {
      let navigation = useNavigation();
      let submit = useSubmit();
      submit("Text submission", { method: "post", encType: "text/plain" });
      // navigation.formEncType => "text/plain"
      // navigation.text        => "Text submission"
    }
    
    async function action({ request }) {
      // request.headers.get("Content-Type") => "text/plain"
      // await request.text()                => "Text submission"
    }
    

**⚠️ Default Behavior Will Change in v7**

Please note that to avoid a breaking change, the default behavior will still encode a simple key/value JSON object into a `FormData` instance:

    function Component() {
      let navigation = useNavigation();
      let submit = useSubmit();
      submit({ key: "value" }, { method: "post" });
      // navigation.formEncType => "application/x-www-form-urlencoded"
      // navigation.formData    => FormData instance
    }
    
    async function action({ request }) {
      // request.headers.get("Content-Type") => "application/x-www-form-urlencoded"
      // await request.formData()            => FormData instance
    }
    

This behavior will likely change in v7 so it's best to make any JSON object submissions explicit with `formEncType: "application/x-www-form-urlencoded"` or `formEncType: "application/json"` to ease your eventual v7 migration path.

### [](#minor-changes-23)Minor Changes

*   Add support for `application/json` and `text/plain` encodings for `useSubmit`/`fetcher.submit`. To reflect these additional types, `useNavigation`/`useFetcher` now also contain `navigation.json`/`navigation.text` and `fetcher.json`/`fetcher.text` which include the json/text submission if applicable. ([#10413](https://github.com/remix-run/react-router/pull/10413))

### [](#patch-changes-50)Patch Changes

*   When submitting a form from a `submitter` element, prefer the built-in `new FormData(form, submitter)` instead of the previous manual approach in modern browsers (those that support the new `submitter` parameter) ([#9865](https://github.com/remix-run/react-router/pull/9865))
    *   For browsers that don't support it, we continue to just append the submit button's entry to the end, and we also add rudimentary support for `type="image"` buttons
    *   If developers want full spec-compliant support for legacy browsers, they can use the `formdata-submitter-polyfill`
*   Call `window.history.pushState/replaceState` _before_ updating React Router state (instead of after) so that `window.location` matches `useLocation` during synchronous React 17 rendering ([#10448](https://github.com/remix-run/react-router/pull/10448))
    *   ⚠️ Note: generally apps should not be relying on `window.location` and should always reference `useLocation` when possible, as `window.location` will not be in sync 100% of the time (due to `popstate` events, concurrent mode, etc.)
*   Avoid calling `shouldRevalidate` for fetchers that have not yet completed a data load ([#10623](https://github.com/remix-run/react-router/pull/10623))
*   Strip `basename` from the `location` provided to `<ScrollRestoration getKey>` to match the `useLocation` behavior ([#10550](https://github.com/remix-run/react-router/pull/10550))
*   Strip `basename` from locations provided to `unstable_useBlocker` functions to match the `useLocation` behavior ([#10573](https://github.com/remix-run/react-router/pull/10573))
*   Fix `unstable_useBlocker` key issues in `StrictMode` ([#10573](https://github.com/remix-run/react-router/pull/10573))
*   Fix `generatePath` when passed a numeric `0` value parameter ([#10612](https://github.com/remix-run/react-router/pull/10612))
*   Fix `tsc --skipLibCheck:false` issues on React 17 ([#10622](https://github.com/remix-run/react-router/pull/10622))
*   Upgrade `typescript` to 5.1 ([#10581](https://github.com/remix-run/react-router/pull/10581))

**Full Changelog**: [`v6.13.0...v6.14.0`](https://github.com/remix-run/react-router/compare/react-router@6.13.0...react-router@6.14.0)

[](#v6130)v6.13.0
-----------------

Date: 2023-06-14

### [](#whats-changed-14)What's Changed

`6.13.0` is really a patch release in spirit but comes with a SemVer minor bump since we added a new future flag.

#### [](#futurev7_starttransition)`future.v7_startTransition`

The **tl;dr;** is that `6.13.0` is the same as [`6.12.0`](https://github.com/remix-run/react-router/releases/tag/react-router%406.12.0) bue we've moved the usage of `React.startTransition` behind an opt-in `future.v7_startTransition` [future flag](https://reactrouter.com/v6/guides/api-development-strategy) because we found that there are applications in the wild that are currently using `Suspense` in ways that are incompatible with `React.startTransition`.

Therefore, in `6.13.0` the default behavior will no longer leverage `React.startTransition`:

    <BrowserRouter>
      <Routes>{/*...*/}</Routes>
    </BrowserRouter>
    
    <RouterProvider router={router} />
    

If you wish to enable `React.startTransition`, pass the future flag to your router component:

    <BrowserRouter future={{ v7_startTransition: true }}>
      <Routes>{/*...*/}</Routes>
    </BrowserRouter>
    
    <RouterProvider router={router} future={{ v7_startTransition: true }}/>
    

We recommend folks adopt this flag sooner rather than later to be better compatible with React concurrent mode, but if you run into issues you can continue without the use of `React.startTransition` until v7. Issues usually boil down to creating net-new promises during the render cycle, so if you run into issues when opting into `React.startTransition`, you should either lift your promise creation out of the render cycle or put it behind a `useMemo`.

### [](#minor-changes-24)Minor Changes

*   Move `React.startTransition` usage behinds a future flag ([#10596](https://github.com/remix-run/react-router/pull/10596))

### [](#patch-changes-51)Patch Changes

*   Work around webpack/terser `React.startTransition` minification bug in production mode ([#10588](https://github.com/remix-run/react-router/pull/10588))

**Full Changelog**: [`v6.12.1...v6.13.0`](https://github.com/remix-run/react-router/compare/react-router@6.12.1...react-router@6.13.0)

[](#v6121)v6.12.1
-----------------

Date: 2023-06-08

> \[!WARNING\] Please use version `6.13.0` or later instead of `6.12.0`/`6.12.1`. These versions suffered from some Webpack build/minification issues resulting failed builds or invalid minified code in your production bundles. See [#10569](https://github.com/remix-run/react-router/pull/10569) and [#10579](https://github.com/remix-run/react-router/issues/10579) for more details.

### [](#patch-changes-52)Patch Changes

*   Adjust feature detection of `React.startTransition` to fix webpack + react 17 compilation error ([#10569](https://github.com/remix-run/react-router/pull/10569))

**Full Changelog**: [`v6.12.0...v6.12.1`](https://github.com/remix-run/react-router/compare/react-router@6.12.0...react-router@6.12.1)

[](#v6120)v6.12.0
-----------------

Date: 2023-06-06

> \[!WARNING\] Please use version `6.13.0` or later instead of `6.12.0`/`6.12.1`. These versions suffered from some Webpack build/minification issues resulting failed builds or invalid minified code in your production bundles. See [#10569](https://github.com/remix-run/react-router/pull/10569) and [#10579](https://github.com/remix-run/react-router/issues/10579) for more details.

### [](#whats-changed-15)What's Changed

#### [](#reactstarttransition-support)`React.startTransition` support

With `6.12.0` we've added better support for suspending components by wrapping the internal router state updates in [`React.startTransition`](https://react.dev/reference/react/startTransition). This means that, for example, if one of your components in a destination route suspends and you have not provided a [`Suspense`](https://react.dev/reference/react/Suspense) boundary to show a fallback, React will delay the rendering of the new UI and show the old UI until that asynchronous operation resolves. This could be useful for waiting for things such as waiting for images or CSS files to load (and technically, yes, you could use it for data loading but we'd still recommend using loaders for that 😀). For a quick overview of this usage, check out [Ryan's demo on Twitter](https://twitter.com/remix_run/status/1658976420767604736).

### [](#minor-changes-25)Minor Changes

*   Wrap internal router state updates with `React.startTransition` ([#10438](https://github.com/remix-run/react-router/pull/10438))

### [](#patch-changes-53)Patch Changes

*   Allow fetcher revalidations to complete if submitting fetcher is deleted ([#10535](https://github.com/remix-run/react-router/pull/10535))
*   Re-throw `DOMException` (`DataCloneError`) when attempting to perform a `PUSH` navigation with non-serializable state. ([#10427](https://github.com/remix-run/react-router/pull/10427))
*   Ensure revalidations happen when hash is present ([#10516](https://github.com/remix-run/react-router/pull/10516))
*   Upgrade `jest` and `jsdom` ([#10453](https://github.com/remix-run/react-router/pull/10453))
*   Updated dependencies:
    *   `@remix-run/router@1.6.3` ([Changelog](https://github.com/remix-run/react-router/blob/main/packages/router/CHANGELOG.md#163))

**Full Changelog**: [`v6.11.2...v6.12.0`](https://github.com/remix-run/react-router/compare/react-router@6.11.2...react-router@6.12.0)

[](#v6112)v6.11.2
-----------------

Date: 2023-05-17

### [](#patch-changes-54)Patch Changes

*   Fix `basename` duplication in descendant `<Routes>` inside a `<RouterProvider>` ([#10492](https://github.com/remix-run/react-router/pull/10492))
*   Fix bug where initial data load would not kick off when hash is present ([#10493](https://github.com/remix-run/react-router/pull/10493))
*   Export `SetURLSearchParams` type ([#10444](https://github.com/remix-run/react-router/pull/10444))
*   Fix Remix HMR-driven error boundaries by properly reconstructing new routes and `manifest` in `_internalSetRoutes` ([#10437](https://github.com/remix-run/react-router/pull/10437))

**Full Changelog**: [`v6.11.1...v6.11.2`](https://github.com/remix-run/react-router/compare/react-router@6.11.1...react-router@6.11.2)

[](#v6111)v6.11.1
-----------------

Date: 2023-05-03

### [](#patch-changes-55)Patch Changes

*   Fix usage of `Component` API within descendant `<Routes>` ([#10434](https://github.com/remix-run/react-router/pull/10434))
*   Fix bug when calling `useNavigate` from `<Routes>` inside a `<RouterProvider>` ([#10432](https://github.com/remix-run/react-router/pull/10432))
*   Fix usage of `<Navigate>` in strict mode when using a data router ([#10435](https://github.com/remix-run/react-router/pull/10435))
*   Fix `basename` handling when navigating without a path ([#10433](https://github.com/remix-run/react-router/pull/10433))
*   "Same hash" navigations no longer re-run loaders to match browser behavior (i.e. `/path#hash -> /path#hash`) ([#10408](https://github.com/remix-run/react-router/pull/10408))

**Full Changelog**: [`v6.11.0...v6.11.1`](https://github.com/remix-run/react-router/compare/react-router@6.11.0...react-router@6.11.1)

[](#v6110)v6.11.0
-----------------

Date: 2023-04-28

### [](#minor-changes-26)Minor Changes

*   Enable `basename` support in `useFetcher` ([#10336](https://github.com/remix-run/react-router/pull/10336))
    *   If you were previously working around this issue by manually prepending the `basename` then you will need to remove the manually prepended `basename` from your `fetcher` calls (`fetcher.load('/basename/route') -> fetcher.load('/route')`)
*   Updated dependencies:
    *   `@remix-run/router@1.6.0` ([Changelog](https://github.com/remix-run/react-router/blob/main/packages/router/CHANGELOG.md#160))

### [](#patch-changes-56)Patch Changes

*   When using a `RouterProvider`, `useNavigate`/`useSubmit`/`fetcher.submit` are now stable across location changes, since we can handle relative routing via the `@remix-run/router` instance and get rid of our dependence on `useLocation()` ([#10336](https://github.com/remix-run/react-router/pull/10336))
    *   When using `BrowserRouter`, these hooks remain unstable across location changes because they still rely on `useLocation()`
*   Fetchers should no longer revalidate on search params changes or routing to the same URL, and will only revalidate on `action` submissions or `router.revalidate` calls ([#10344](https://github.com/remix-run/react-router/pull/10344))
*   Fix inadvertent re-renders when using `Component` instead of `element` on a route definition ([#10287](https://github.com/remix-run/react-router/pull/10287))
*   Fail gracefully on `<Link to="//">` and other invalid URL values ([#10367](https://github.com/remix-run/react-router/pull/10367))
*   Switched from `useSyncExternalStore` to `useState` for internal `@remix-run/router` router state syncing in `<RouterProvider>`. We found some [subtle bugs](https://codesandbox.io/s/use-sync-external-store-loop-9g7b81) where router state updates got propagated _before_ other normal `useState` updates, which could lead to foot guns in `useEffect` calls. ([#10377](https://github.com/remix-run/react-router/pull/10377), [#10409](https://github.com/remix-run/react-router/pull/10409))
*   Log loader/action errors caught by the default error boundary to the console in dev for easier stack trace evaluation ([#10286](https://github.com/remix-run/react-router/pull/10286))
*   Fix bug preventing rendering of descendant `<Routes>` when `RouterProvider` errors existed ([#10374](https://github.com/remix-run/react-router/pull/10374))
*   Fix detection of `useNavigate` in the render cycle by setting the `activeRef` in a layout effect, allowing the `navigate` function to be passed to child components and called in a `useEffect` there ([#10394](https://github.com/remix-run/react-router/pull/10394))
*   Allow `useRevalidator()` to resolve a loader-driven error boundary scenario ([#10369](https://github.com/remix-run/react-router/pull/10369))
*   Enhance `LoaderFunction`/`ActionFunction` return type to prevent `undefined` from being a valid return value ([#10267](https://github.com/remix-run/react-router/pull/10267))
*   Ensure proper 404 error on `fetcher.load` call to a route without a `loader` ([#10345](https://github.com/remix-run/react-router/pull/10345))
*   Decouple `AbortController` usage between revalidating fetchers and the thing that triggered them such that the unmount/deletion of a revalidating fetcher doesn't impact the ongoing triggering navigation/revalidation ([#10271](https://github.com/remix-run/react-router/pull/10271))

**Full Changelog**: [`v6.10.0...v6.11.0`](https://github.com/remix-run/react-router/compare/react-router@6.10.0...react-router@6.11.0)

[](#v6100)v6.10.0
-----------------

Date: 2023-03-29

### [](#whats-changed-16)What's Changed

We recently published a post over on the Remix Blog titled ["Future Proofing Your Remix App"](https://remix.run/blog/future-flags) that goes through our strategy to ensure smooth upgrades for your Remix and React Router apps going forward. React Router `6.10.0` adds support for these flags (for data routers) which you can specify when you create your router:

    const router = createBrowserRouter(routes, {
      future: {
        // specify future flags here
      },
    });
    

You can also check out the docs [here](https://reactrouter.com/en/dev/guides/api-development-strategy) and [here](https://reactrouter.com/en/dev/routers/create-browser-router#future).

### [](#minor-changes-27)Minor Changes

#### [](#futurev7_normalizeformmethod)`future.v7_normalizeFormMethod`

The first future flag being introduced is `future.v7_normalizeFormMethod` which will normalize the exposed `useNavigation()/useFetcher()` `formMethod` fields as uppercase HTTP methods to align with the `fetch()` (and some Remix) behavior. ([#10207](https://github.com/remix-run/react-router/pull/10207))

*   When `future.v7_normalizeFormMethod` is unspecified or set to `false` (default v6 behavior),
    *   `useNavigation().formMethod` is lowercase
    *   `useFetcher().formMethod` is lowercase
*   When `future.v7_normalizeFormMethod === true`:
    *   `useNavigation().formMethod` is UPPERCASE
    *   `useFetcher().formMethod` is UPPERCASE

### [](#patch-changes-57)Patch Changes

*   Fix `createStaticHandler` to also check for `ErrorBoundary` on routes in addition to `errorElement` ([#10190](https://github.com/remix-run/react-router/pull/10190))
*   Fix route ID generation when using Fragments in `createRoutesFromElements` ([#10193](https://github.com/remix-run/react-router/pull/10193))
*   Provide fetcher submission to `shouldRevalidate` if the fetcher action redirects ([#10208](https://github.com/remix-run/react-router/pull/10208))
*   Properly handle `lazy()` errors during router initialization ([#10201](https://github.com/remix-run/react-router/pull/10201))
*   Remove `instanceof` check for `DeferredData` to be resilient to ESM/CJS boundaries in SSR bundling scenarios ([#10247](https://github.com/remix-run/react-router/pull/10247))
*   Update to latest `@remix-run/web-fetch@4.3.3` ([#10216](https://github.com/remix-run/react-router/pull/10216))

**Full Changelog**: [`v6.9.0...v6.10.0`](https://github.com/remix-run/react-router/compare/react-router@6.9.0...react-router@6.10.0)

[](#v690)v6.9.0
---------------

Date: 2023-03-10

### [](#whats-changed-17)What's Changed

#### [](#componenterrorboundary-route-properties)`Component`/`ErrorBoundary` route properties

React Router now supports an alternative way to define your route `element` and `errorElement` fields as React Components instead of React Elements. You can instead pass a React Component to the new `Component` and `ErrorBoundary` fields if you choose. There is no functional difference between the two, so use whichever approach you prefer 😀. You shouldn't be defining both, but if you do `Component`/`ErrorBoundary` will "win"

**Example JSON Syntax**

    // Both of these work the same:
    const elementRoutes = [{
      path: '/',
      element: <Home />,
      errorElement: <HomeError />,
    }]
    
    const componentRoutes = [{
      path: '/',
      Component: Home,
      ErrorBoundary: HomeError,
    }]
    
    function Home() { ... }
    function HomeError() { ... }
    

**Example JSX Syntax**

    // Both of these work the same:
    const elementRoutes = createRoutesFromElements(
      <Route path='/' element={<Home />} errorElement={<HomeError /> } />
    );
    
    const componentRoutes = createRoutesFromElements(
      <Route path='/' Component={Home} ErrorBoundary={HomeError} />
    );
    
    function Home() { ... }
    function HomeError() { ... }
    

#### [](#introducing-lazy-route-modules)Introducing Lazy Route Modules

In order to keep your application bundles small and support code-splitting of your routes, we've introduced a new `lazy()` route property. This is an async function that resolves the non-route-matching portions of your route definition (`loader`, `action`, `element`/`Component`, `errorElement`/`ErrorBoundary`, `shouldRevalidate`, `handle`).

Lazy routes are resolved on initial load and during the `loading` or `submitting` phase of a navigation or fetcher call. You cannot lazily define route-matching properties (`path`, `index`, `children`) since we only execute your lazy route functions after we've matched known routes.

Your `lazy` functions will typically return the result of a dynamic import.

    // In this example, we assume most folks land on the homepage so we include that
    // in our critical-path bundle, but then we lazily load modules for /a and /b so
    // they don't load until the user navigates to those routes
    let routes = createRoutesFromElements(
      <Route path="/" element={<Layout />}>
        <Route index element={<Home />} />
        <Route path="a" lazy={() => import("./a")} />
        <Route path="b" lazy={() => import("./b")} />
      </Route>
    );
    

Then in your lazy route modules, export the properties you want defined for the route:

    export async function loader({ request }) {
      let data = await fetchData(request);
      return json(data);
    }
    
    // Export a `Component` directly instead of needing to create a React Element from it
    export function Component() {
      let data = useLoaderData();
    
      return (
        <>
          <h1>You made it!</h1>
          <p>{data}</p>
        </>
      );
    }
    
    // Export an `ErrorBoundary` directly instead of needing to create a React Element from it
    export function ErrorBoundary() {
      let error = useRouteError();
      return isRouteErrorResponse(error) ? (
        <h1>
          {error.status} {error.statusText}
        </h1>
      ) : (
        <h1>{error.message || error}</h1>
      );
    }
    

An example of this in action can be found in the [`examples/lazy-loading-router-provider`](https://github.com/remix-run/react-router/tree/main/examples/lazy-loading-router-provider) directory of the repository. For more info, check out the [`lazy` docs](https://reactrouter.com/v6/route/lazy).

🙌 Huge thanks to @rossipedia for the [Initial Proposal](https://github.com/remix-run/react-router/discussions/9826) and [POC Implementation](https://github.com/remix-run/react-router/pull/9830).

### [](#minor-changes-28)Minor Changes

*   Add support for `route.Component`/`route.ErrorBoundary` properties ([#10045](https://github.com/remix-run/react-router/pull/10045))
*   Add support for `route.lazy` ([#10045](https://github.com/remix-run/react-router/pull/10045))

### [](#patch-changes-58)Patch Changes

*   Improve memoization for context providers to avoid unnecessary re-renders ([#9983](https://github.com/remix-run/react-router/pull/9983))
*   Fix `generatePath` incorrectly applying parameters in some cases ([#10078](https://github.com/remix-run/react-router/pull/10078))
*   `[react-router-dom-v5-compat]` Add missed data router API re-exports ([#10171](https://github.com/remix-run/react-router/pull/10171))

**Full Changelog**: [`v6.8.2...v6.9.0`](https://github.com/remix-run/react-router/compare/react-router@6.8.2...react-router@6.9.0)

[](#v682)v6.8.2
---------------

Date: 2023-02-27

### [](#patch-changes-59)Patch Changes

*   Treat same-origin absolute URLs in `<Link to>` as external if they are outside of the router `basename` ([#10135](https://github.com/remix-run/react-router/pull/10135))
*   Correctly perform a hard redirect for same-origin absolute URLs outside of the router `basename` ([#10076](https://github.com/remix-run/react-router/pull/10076))
*   Fix SSR of absolute `<Link to>` urls ([#10112](https://github.com/remix-run/react-router/pull/10112))
*   Properly escape HTML characters in `StaticRouterProvider` serialized hydration data ([#10068](https://github.com/remix-run/react-router/pull/10068))
*   Fix `useBlocker` to return `IDLE_BLOCKER` during SSR ([#10046](https://github.com/remix-run/react-router/pull/10046))
*   Ensure status code and headers are maintained for `defer` loader responses in `createStaticHandler`'s `query()` method ([#10077](https://github.com/remix-run/react-router/pull/10077))
*   Change `invariant` to an `UNSAFE_invariant` export since it's only intended for internal use ([#10066](https://github.com/remix-run/react-router/pull/10066))

**Full Changelog**: [`v6.8.1...v6.8.2`](https://github.com/remix-run/react-router/compare/react-router@6.8.1...react-router@6.8.2)

[](#v681)v6.8.1
---------------

Date: 2023-02-06

### [](#patch-changes-60)Patch Changes

*   Remove inaccurate console warning for POP navigations and update active blocker logic ([#10030](https://github.com/remix-run/react-router/pull/10030))
*   Only check for differing origin on absolute URL redirects ([#10033](https://github.com/remix-run/react-router/pull/10033))
*   Improved absolute url detection in `Link` component (now also supports `mailto:` urls) ([#9994](https://github.com/remix-run/react-router/pull/9994))
*   Fix partial object (search or hash only) pathnames losing current path value ([#10029](https://github.com/remix-run/react-router/pull/10029))

**Full Changelog**: [`v6.8.0...v6.8.1`](https://github.com/remix-run/react-router/compare/react-router@6.8.0...react-router@6.8.1)

[](#v680)v6.8.0
---------------

Date: 2023-01-26

### [](#minor-changes-29)Minor Changes

Support absolute URLs in `<Link to>`. If the URL is for the current origin, it will still do a client-side navigation. If the URL is for a different origin then it will do a fresh document request for the new origin. ([#9900](https://github.com/remix-run/react-router/pull/9900))

    <Link to="https://neworigin.com/some/path">    {/* Document request */}
    <Link to="//neworigin.com/some/path">          {/* Document request */}
    <Link to="https://www.currentorigin.com/path"> {/* Client-side navigation */}
    

### [](#patch-changes-61)Patch Changes

*   Fixes 2 separate issues for revalidating fetcher `shouldRevalidate` calls ([#9948](https://github.com/remix-run/react-router/pull/9948))
    *   The `shouldRevalidate` function was only being called for _explicit_ revalidation scenarios (after a mutation, manual `useRevalidator` call, or an `X-Remix-Revalidate` header used for cookie setting in Remix). It was not properly being called on _implicit_ revalidation scenarios that also apply to navigation `loader` revalidation, such as a change in search params or clicking a link for the page we're already on. It's now correctly called in those additional scenarios.
    *   The parameters being passed were incorrect and inconsistent with one another since the `current*`/`next*` parameters reflected the static `fetcher.load` URL (and thus were identical). Instead, they should have reflected the navigation that triggered the revalidation (as the `form*` parameters did). These parameters now correctly reflect the triggering navigation.
*   Fix bug with search params removal via `useSearchParams` ([#9969](https://github.com/remix-run/react-router/pull/9969))
*   Respect `preventScrollReset` on `<fetcher.Form>` ([#9963](https://github.com/remix-run/react-router/pull/9963))
*   Fix navigation for hash routers on manual URL changes ([#9980](https://github.com/remix-run/react-router/pull/9980))
*   Use `pagehide` instead of `beforeunload` for `<ScrollRestoration>`. This has better cross-browser support, specifically on Mobile Safari. ([#9945](https://github.com/remix-run/react-router/pull/9945))
*   Do not short circuit on hash change only mutation submissions ([#9944](https://github.com/remix-run/react-router/pull/9944))
*   Remove `instanceof` check from `isRouteErrorResponse` to avoid bundling issues on the server ([#9930](https://github.com/remix-run/react-router/pull/9930))
*   Detect when a `defer` call only contains critical data and remove the `AbortController` ([#9965](https://github.com/remix-run/react-router/pull/9965))
*   Send the name as the value when url-encoding `File` `FormData` entries ([#9867](https://github.com/remix-run/react-router/pull/9867))
*   `react-router-dom-v5-compat` - Fix SSR `useLayoutEffect` `console.error` when using `CompatRouter` ([#9820](https://github.com/remix-run/react-router/pull/9820))

**Full Changelog**: [`v6.7.0...v6.8.0`](https://github.com/remix-run/react-router/compare/react-router@6.7.0...react-router@6.8.0)

[](#v670)v6.7.0
---------------

Date: 2023-01-18

### [](#minor-changes-30)Minor Changes

*   Add `unstable_useBlocker`/`unstable_usePrompt` hooks for blocking navigations within the app's location origin ([#9709](https://github.com/remix-run/react-router/pull/9709), [#9932](https://github.com/remix-run/react-router/pull/9932))
*   Add `preventScrollReset` prop to `<Form>` ([#9886](https://github.com/remix-run/react-router/pull/9886))

### [](#patch-changes-62)Patch Changes

*   Added pass-through event listener options argument to `useBeforeUnload` ([#9709](https://github.com/remix-run/react-router/pull/9709))
*   Fix `generatePath` when optional params are present ([#9764](https://github.com/remix-run/react-router/pull/9764))
*   Update `<Await>` to accept `ReactNode` as children function return result ([#9896](https://github.com/remix-run/react-router/pull/9896))
*   Improved absolute redirect url detection in actions/loaders ([#9829](https://github.com/remix-run/react-router/pull/9829))
*   Fix URL creation with memory histories ([#9814](https://github.com/remix-run/react-router/pull/9814))
*   Fix scroll reset if a submission redirects ([#9886](https://github.com/remix-run/react-router/pull/9886))
*   Fix 404 bug with same-origin absolute redirects ([#9913](https://github.com/remix-run/react-router/pull/9913))
*   Streamline `jsdom` bug workaround in tests ([#9824](https://github.com/remix-run/react-router/pull/9824))

**Full Changelog**: [`v6.6.2...v6.7.0`](https://github.com/remix-run/react-router/compare/react-router@6.6.2...react-router@6.7.0)

[](#v662)v6.6.2
---------------

Date: 2023-01-09

### [](#patch-changes-63)Patch Changes

*   Ensure `useId` consistency during SSR ([#9805](https://github.com/remix-run/react-router/pull/9805))

**Full Changelog**: [`v6.6.1...v6.6.2`](https://github.com/remix-run/react-router/compare/react-router@6.6.1...react-router@6.6.2)

[](#v661)v6.6.1
---------------

Date: 2022-12-23

### [](#patch-changes-64)Patch Changes

*   Include submission info in `shouldRevalidate` on action redirects ([#9777](https://github.com/remix-run/react-router/pull/9777), [#9782](https://github.com/remix-run/react-router/pull/9782))
*   Reset `actionData` on action redirect to current location ([#9772](https://github.com/remix-run/react-router/pull/9772))

**Full Changelog**: [`v6.6.0...v6.6.1`](https://github.com/remix-run/react-router/compare/react-router@6.6.0...react-router@6.6.1)

[](#v660)v6.6.0
---------------

Date: 2022-12-21

### [](#whats-changed-18)What's Changed

This minor release is primarily to stabilize our SSR APIs for Data Routers now that we've wired up the new `RouterProvider` in Remix as part of the [React Router-ing Remix](https://remix.run/blog/react-routering-remix) work.

### [](#minor-changes-31)Minor Changes

*   Remove `unstable_` prefix from `createStaticHandler`/`createStaticRouter`/`StaticRouterProvider` ([#9738](https://github.com/remix-run/react-router/pull/9738))
*   Add `useBeforeUnload()` hook ([#9664](https://github.com/remix-run/react-router/pull/9664))

### [](#patch-changes-65)Patch Changes

*   Support uppercase `<Form method>` and `useSubmit` method values ([#9664](https://github.com/remix-run/react-router/pull/9664))
*   Fix `<button formmethod>` form submission overriddes ([#9664](https://github.com/remix-run/react-router/pull/9664))
*   Fix explicit `replace` on submissions and `PUSH` on submission to new paths ([#9734](https://github.com/remix-run/react-router/pull/9734))
*   Prevent `useLoaderData` usage in `errorElement` ([#9735](https://github.com/remix-run/react-router/pull/9735))
*   Proper hydration of `Error` objects from `StaticRouterProvider` ([#9664](https://github.com/remix-run/react-router/pull/9664))
*   Skip initial scroll restoration for SSR apps with `hydrationData` ([#9664](https://github.com/remix-run/react-router/pull/9664))
*   Fix a few bugs where loader/action data wasn't properly cleared on errors ([#9735](https://github.com/remix-run/react-router/pull/9735))

**Full Changelog**: [`v6.5.0...v6.6.0`](https://github.com/remix-run/react-router/compare/react-router@6.5.0...react-router@6.6.0)

[](#v650)v6.5.0
---------------

Date: 2022-12-16

### [](#whats-changed-19)What's Changed

This release introduces support for [Optional Route Segments](https://github.com/remix-run/react-router/issues/9546). Now, adding a `?` to the end of any path segment will make that entire segment optional. This works for both static segments and dynamic parameters.

**Optional Params Examples**

*   `<Route path=":lang?/about>` will match:
    *   `/:lang/about`
    *   `/about`
*   `<Route path="/multistep/:widget1?/widget2?/widget3?">` will match:
    *   `/multistep`
    *   `/multistep/:widget1`
    *   `/multistep/:widget1/:widget2`
    *   `/multistep/:widget1/:widget2/:widget3`

**Optional Static Segment Example**

*   `<Route path="/home?">` will match:
    *   `/`
    *   `/home`
*   `<Route path="/fr?/about">` will match:
    *   `/about`
    *   `/fr/about`

### [](#minor-changes-32)Minor Changes

*   Allows optional routes and optional static segments ([#9650](https://github.com/remix-run/react-router/pull/9650))

### [](#patch-changes-66)Patch Changes

*   Stop incorrectly matching on partial named parameters, i.e. `<Route path="prefix-:param">`, to align with how splat parameters work. If you were previously relying on this behavior then it's recommended to extract the static portion of the path at the `useParams` call site: ([#9506](https://github.com/remix-run/react-router/pull/9506))

    // Old behavior at URL /prefix-123
    <Route path="prefix-:id" element={<Comp /> }>
    
    function Comp() {
      let params = useParams(); // { id: '123' }
      let id = params.id; // "123"
      ...
    }
    
    // New behavior at URL /prefix-123
    <Route path=":id" element={<Comp /> }>
    
    function Comp() {
      let params = useParams(); // { id: 'prefix-123' }
      let id = params.id.replace(/^prefix-/, ''); // "123"
      ...
    }
    

*   Persist `headers` on `loader` `request`'s after SSR document `action` request ([#9721](https://github.com/remix-run/react-router/pull/9721))
*   Fix requests sent to revalidating loaders so they reflect a GET request ([#9660](https://github.com/remix-run/react-router/pull/9660))
*   Fix issue with deeply nested optional segments ([#9727](https://github.com/remix-run/react-router/pull/9727))
*   GET forms now expose a submission on the loading navigation ([#9695](https://github.com/remix-run/react-router/pull/9695))
*   Fix error boundary tracking for multiple errors bubbling to the same boundary ([#9702](https://github.com/remix-run/react-router/pull/9702))

**Full Changelog**: [`v6.4.5...v6.5.0`](https://github.com/remix-run/react-router/compare/react-router@6.4.5...react-router@6.5.0)

[](#v645)v6.4.5
---------------

Date: 2022-12-07

### [](#patch-changes-67)Patch Changes

*   Fix requests sent to revalidating loaders so they reflect a `GET` request ([#9680](https://github.com/remix-run/react-router/pull/9680))
*   Remove `instanceof Response` checks in favor of `isResponse` ([#9690](https://github.com/remix-run/react-router/pull/9690))
*   Fix `URL` creation in Cloudflare Pages or other non-browser-environments ([#9682](https://github.com/remix-run/react-router/pull/9682), [#9689](https://github.com/remix-run/react-router/pull/9689))
*   Add `requestContext` support to static handler `query`/`queryRoute` ([#9696](https://github.com/remix-run/react-router/pull/9696))
    *   Note that the unstable API of `queryRoute(path, routeId)` has been changed to `queryRoute(path, { routeId, requestContext })`

**Full Changelog**: [`v6.4.4...v6.4.5`](https://github.com/remix-run/react-router/compare/react-router@6.4.4...react-router@6.4.5)

[](#v644)v6.4.4
---------------

Date: 2022-11-30

### [](#patch-changes-68)Patch Changes

*   Throw an error if an `action`/`loader` function returns `undefined` as revalidations need to know whether the loader has previously been executed. `undefined` also causes issues during SSR stringification for hydration. You should always ensure your `loader`/`action` returns a value, and you may return `null` if you don't wish to return anything. ([#9511](https://github.com/remix-run/react-router/pull/9511))
*   Properly handle redirects to external domains ([#9590](https://github.com/remix-run/react-router/pull/9590), [#9654](https://github.com/remix-run/react-router/pull/9654))
*   Preserve the HTTP method on 307/308 redirects ([#9597](https://github.com/remix-run/react-router/pull/9597))
*   Support `basename` in static data routers ([#9591](https://github.com/remix-run/react-router/pull/9591))
*   Enhanced `ErrorResponse` bodies to contain more descriptive text in internal 403/404/405 scenarios
*   Fix issues with encoded characters in `NavLink` and descendant `<Routes>` ([#9589](https://github.com/remix-run/react-router/pull/9589), [#9647](https://github.com/remix-run/react-router/pull/9647))
*   Properly serialize/deserialize `ErrorResponse` instances when using built-in hydration ([#9593](https://github.com/remix-run/react-router/pull/9593))
*   Support `basename` in static data routers ([#9591](https://github.com/remix-run/react-router/pull/9591))
*   Updated dependencies:
    *   `@remix-run/router@1.0.4`
    *   `react-router@6.4.4`

**Full Changelog**: [`v6.4.3...v6.4.4`](https://github.com/remix-run/react-router/compare/react-router-dom@6.4.3...react-router-dom@6.4.4)

[](#v643)v6.4.3
---------------

Date: 2022-11-01

### [](#patch-changes-69)Patch Changes

*   Generate correct `<a href>` values when using `createHashRouter` ([#9409](https://github.com/remix-run/react-router/pull/9409))
*   Better handle encoding/matching with special characters in URLs and route paths ([#9477](https://github.com/remix-run/react-router/pull/9477), [#9496](https://github.com/remix-run/react-router/pull/9496))
*   Generate correct `formAction` pathnames when an `index` route also has a `path` ([#9486](https://github.com/remix-run/react-router/pull/9486))
*   Respect `relative=path` prop on `NavLink` ([#9453](https://github.com/remix-run/react-router/pull/9453))
*   Fix `NavLink` behavior for root urls ([#9497](https://github.com/remix-run/react-router/pull/9497))
*   `useRoutes` should be able to return `null` when passing `locationArg` ([#9485](https://github.com/remix-run/react-router/pull/9485))
*   Fix `initialEntries` type in `createMemoryRouter` ([#9498](https://github.com/remix-run/react-router/pull/9498))
*   Support `basename` and relative routing in `loader`/`action` redirects ([#9447](https://github.com/remix-run/react-router/pull/9447))
*   Ignore pathless layout routes when looking for proper submission `action` function ([#9455](https://github.com/remix-run/react-router/pull/9455))
*   Add UMD build for `@remix-run/router` ([#9446](https://github.com/remix-run/react-router/pull/9446))
*   Fix `createURL` in local file execution in Firefox ([#9464](https://github.com/remix-run/react-router/pull/9464))

**Full Changelog**: [`v6.4.2...v6.4.3`](https://github.com/remix-run/react-router/compare/react-router@6.4.2...react-router@6.4.3)

[](#v642)v6.4.2
---------------

Date: 2022-10-06

### [](#patch-changes-70)Patch Changes

*   Respect `basename` in `useFormAction` ([#9352](https://github.com/remix-run/react-router/pull/9352))
*   Fix `IndexRouteObject` and `NonIndexRouteObject` types to make `hasErrorElement` optional ([#9394](https://github.com/remix-run/react-router/pull/9394))
*   Enhance console error messages for invalid usage of data router hooks ([#9311](https://github.com/remix-run/react-router/pull/9311))
*   If an index route has children, it will result in a runtime error. We have strengthened our `RouteObject`/`RouteProps` types to surface the error in TypeScript. ([#9366](https://github.com/remix-run/react-router/pull/9366))

**Full Changelog**: [`v6.4.1...v6.4.2`](https://github.com/remix-run/react-router/compare/react-router@6.4.1...react-router@6.4.2)

[](#v641)v6.4.1
---------------

Date: 2022-09-22

### [](#patch-changes-71)Patch Changes

*   Preserve state from `initialEntries` ([#9288](https://github.com/remix-run/react-router/pull/9288))
*   Preserve `?index` for fetcher get submissions to index routes ([#9312](https://github.com/remix-run/react-router/pull/9312))

**Full Changelog**: [`v6.4.0...v6.4.1`](https://github.com/remix-run/react-router/compare/react-router@6.4.0...react-router@6.4.1)

[](#v640)v6.4.0
---------------

Date: 2022-09-13

### [](#whats-changed-20)What's Changed

#### [](#remix-data-apis)Remix Data APIs

Whoa this is a big one! `6.4.0` brings all the data loading and mutation APIs over from Remix. Here's a quick high level overview, but it's recommended you go check out the [docs](https://reactrouter.com/), especially the [feature overview](https://reactrouter.com/en/6.4.0/start/overview) and the [tutorial](https://reactrouter.com/en/6.4.0/start/tutorial).

**New `react-router` APIs**

*   Create your router with `createMemoryRouter`
*   Render your router with `<RouterProvider>`
*   Load data with a Route `loader` and mutate with a Route `action`
*   Handle errors with Route `errorElement`
*   Defer non-critical data with `defer` and `Await`

**New `react-router-dom` APIs**

*   Create your router with `createBrowserRouter`/`createHashRouter`
*   Submit data with the new `<Form>` component
*   Perform in-page data loads and mutations with `useFetcher()`
*   Defer non-critical data with `defer` and `Await`
*   Manage scroll position with `<ScrollRestoration>`
*   Perform path-relative navigations with `<Link relative="path">` ([#9160](https://github.com/remix-run/react-router/pull/9160))

### [](#patch-changes-72)Patch Changes

*   Path resolution is now trailing slash agnostic ([#8861](https://github.com/remix-run/react-router/pull/8861))
*   `useLocation` returns the scoped location inside a `<Routes location>` component ([#9094](https://github.com/remix-run/react-router/pull/9094))
*   Respect the `<Link replace>` prop if it is defined ([#8779](https://github.com/remix-run/react-router/pull/8779))

**Full Changelog**: [`v6.3.0...v6.4.0`](https://github.com/remix-run/react-router/compare/v6.3.0...react-router%406.4.0)

[](#v630)v6.3.0
---------------

Date: 2022-03-31

### [](#minor-changes-33)Minor Changes

*   Added the v5 to v6 backwards compatibility package 💜 ([#8752](https://github.com/remix-run/react-router/pull/8752)). The official guide can be found [in this discussion](https://github.com/remix-run/react-router/discussions/8753)

**Full Changelog**: [`v6.2.2...v6.3.0`](https://github.com/remix-run/react-router/compare/v6.2.2...v6.3.0)

[](#v622)v6.2.2
---------------

Date: 2022-02-28

### [](#patch-changes-73)Patch Changes

*   Fixed nested splat routes that begin with special URL-safe characters ([#8563](https://github.com/remix-run/react-router/pull/8563))
*   Fixed a bug where index routes were missing route context in some cases ([#8497](https://github.com/remix-run/react-router/pull/8497))

**Full Changelog**: [`v6.2.1...v6.2.2`](https://github.com/remix-run/react-router/compare/v6.2.1...v6.2.2)

[](#v621)v6.2.1
---------------

Date: 2021-12-17

### [](#patch-changes-74)Patch Changes

*   This release updates the internal `history` dependency to `5.2.0`.

**Full Changelog**: [`v6.2.0...v6.2.1`](https://github.com/remix-run/react-router/compare/v6.2.0...v6.2.1)

[](#v620)v6.2.0
---------------

Date: 2021-12-17

### [](#minor-changes-34)Minor Changes

*   We now use statically analyzable CJS exports. This enables named imports in Node ESM scripts ([See the commit](https://github.com/remix-run/react-router/commit/29c7fc8b5f853b0b06ecd0f5682a9bbe6eca0715)).

### [](#patch-changes-75)Patch Changes

*   Fixed the `RouteProps` `element` type, which should be a `ReactNode` ([#8473](https://github.com/remix-run/react-router/pull/8473))
*   Fixed a bug with `useOutlet` for top-level routes ([#8483](https://github.com/remix-run/react-router/pull/8483))

**Full Changelog**: [`v6.1.1...v6.2.0`](https://github.com/remix-run/react-router/compare/v6.1.1...v6.2.0)

[](#v611)v6.1.1
---------------

Date: 2021-12-11

### [](#patch-changes-76)Patch Changes

*   In v6.1.0 we inadvertently shipped a new, undocumented API that will likely introduce bugs ([#7586](https://github.com/remix-run/react-router/pull/7586)). We have flagged `HistoryRouter` as `unstable_HistoryRouter`, as this API will likely need to change before a new major release.

**Full Changelog**: [`v6.1.0...v6.1.1`](https://github.com/remix-run/react-router/compare/v6.1.0...v6.1.1)

[](#v610)v6.1.0
---------------

Date: 2021-12-10

### [](#minor-changes-35)Minor Changes

*   `<Outlet>` can now receive a `context` prop. This value is passed to child routes and is accessible via the new `useOutletContext` hook. See [the API docs](https://reactrouter.com/docs/en/v6/api#useoutletcontext) for details. ([#8461](https://github.com/remix-run/react-router/pull/8461))
*   `<NavLink>` can now receive a child function for access to its props. ([#8164](https://github.com/remix-run/react-router/pull/8164))
*   Improved TypeScript signature for `useMatch` and `matchPath`. For example, when you call `useMatch("foo/:bar/:baz")`, the path is parsed and the return type will be `PathMatch<"bar" | "baz">`. ([#8030](https://github.com/remix-run/react-router/pull/8030))

### [](#patch-changes-77)Patch Changes

*   Fixed a bug that broke support for base64 encoded IDs on nested routes ([#8291](https://github.com/remix-run/react-router/pull/8291))
*   A few error message improvements ([#8202](https://github.com/remix-run/react-router/pull/8202))

**Full Changelog**: [`v6.0.2...v6.1.0`](https://github.com/remix-run/react-router/compare/v6.0.2...v6.1.0)

[](#v602)v6.0.2
---------------

Date: 2021-11-09

### [](#patch-changes-78)Patch Changes

*   Added the `reloadDocument` prop to `<Link>`. This allows `<Link>` to function like a normal anchor tag by reloading the document after navigation while maintaining the relative `to` resolution ([#8283](https://github.com/remix-run/react-router/pull/8283))

**Full Changelog**: [`v6.0.1...v6.0.2`](https://github.com/remix-run/react-router/compare/v6.0.1...v6.0.2)

[](#v601)v6.0.1
---------------

Date: 2021-11-05

### [](#patch-changes-79)Patch Changes

*   Add a default `<StaticRouter location>` value ([#8243](https://github.com/remix-run/react-router/pull/8243))
*   Add invariant for using `<Route>` inside `<Routes>` to help people make the change ([#8238](https://github.com/remix-run/react-router/pull/8238))

**Full Changelog**: [`v6.0.0...v6.0.1`](https://github.com/remix-run/react-router/compare/v6.0.0...v6.0.1)

[](#v600)v6.0.0
---------------

Date: 2021-11-03

React Router v6 is here!

Please go read [our blog post for more information on all the great stuff in v6](https://remix.run/blog/react-router-v6) including [notes about how to upgrade from React Router v5](https://remix.run/blog/react-router-v6#upgrading-to-react-router-v6) and Reach Router.

[](#picking-a-mode)Picking a Mode
=================================

React Router is a multi-strategy router for React. There are three primary ways, or "modes", to use it in your app. Across the docs you'll see these icons indicating which mode the content is relevant to:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

The features available in each mode are additive, so moving from Declarative to Data to Framework simply adds more features at the cost of architectural control. So pick your mode based on how much control or how much help you want from React Router.

The mode depends on which "top level" router API you're using:

**Declarative**

Declarative mode enables basic routing features like matching URLs to components, navigating around the app, and providing active states with APIs like `<Link>`, `useNavigate`, and `useLocation`.

    import { BrowserRouter } from "react-router";
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    

**Data**

By moving route configuration outside of React rendering, Data Mode adds data loading, actions, pending states and more with APIs like `loader`, `action`, and `useFetcher`.

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    
    let router = createBrowserRouter([
      {
        path: "/",
        Component: Root,
        loader: loadRootData,
      },
    ]);
    
    ReactDOM.createRoot(root).render(
      <RouterProvider router={router} />
    );
    

**Framework**

Framework Mode wraps Data Mode with a Vite plugin to add the full React Router experience with:

*   typesafe `href`
*   typesafe Route Module API
*   intelligent code splitting
*   SPA, SSR, and static rendering strategies
*   and more

    import { index, route } from "@react-router/dev/routes";
    
    export default [
      index("./home.tsx"),
      route("products/:pid", "./product.tsx"),
    ];
    

You'll then have access to the Route Module API with typesafe params, loaderData, code splitting, SPA/SSR/SSG strategies, and more.

    import { Route } from "+./types/product.tsx";
    
    export async function loader({ params }: Route.LoaderArgs) {
      let product = await getProduct(params.pid);
      return { product };
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      return <div>{loaderData.product.name}</div>;
    }
    

[](#decision-advice)Decision Advice
-----------------------------------

Every mode supports any architecture and deployment target, so the question isn't really about if you want SSR, SPA, etc. It's about how much you want to do yourself.

**Use Framework Mode if you:**

*   are too new to have an opinion
*   are considering Next.js, Solid Start, SvelteKit, Astro, TanStack Start, etc. and want to compare
*   just want to build something with React
*   might want to server render, might not
*   are coming from Remix (React Router v7 is the "next version" after Remix v2)
*   are migrating from Next.js

[→ Get Started with Framework Mode](./framework/installation).

**Use Data Mode if you:**

*   want data features but also want to have control over bundling, data, and server abstractions
*   started a data router in v6.4 and are happy with it

[→ Get Started with Data Mode](./data/custom).

**Use Declarative Mode if you:**

*   want to use React Router as simply as possible
*   are coming from v6 and are happy with the `<BrowserRouter>`
*   have a data layer that either skips pending states (like local first, background data replication/sync) or has its own abstractions for them
*   are coming from Create React App (you may want to consider framework mode though)

[→ Get Started with Declarative Mode](./declarative/installation).

[](#api--mode-availability-table)API + Mode Availability Table
--------------------------------------------------------------

This is mostly for the LLMs, but knock yourself out:

API

Framework

Data

Declarative

Await

✅

✅

Form

✅

✅

Link

✅

✅

✅

`<Link discover>`

✅

`<Link prefetch>`

✅

`<Link preventScrollReset>`

✅

✅

Links

✅

Meta

✅

NavLink

✅

✅

✅

`<NavLink discover>`

✅

`<NavLink prefetch>`

✅

`<NavLink preventScrollReset>`

✅

✅

NavLink `isPending`

✅

✅

Navigate

✅

✅

✅

Outlet

✅

✅

✅

PrefetchPageLinks

✅

Route

✅

✅

✅

Routes

✅

✅

✅

Scripts

✅

ScrollRestoration

✅

✅

ServerRouter

✅

usePrompt

✅

✅

✅

useActionData

✅

✅

useAsyncError

✅

✅

useAsyncValue

✅

✅

useBeforeUnload

✅

✅

✅

useBlocker

✅

✅

useFetcher

✅

✅

useFetchers

✅

✅

useFormAction

✅

✅

useHref

✅

✅

✅

useInRouterContext

✅

✅

✅

useLinkClickHandler

✅

✅

✅

useLoaderData

✅

✅

useLocation

✅

✅

✅

useMatch

✅

✅

✅

useMatches

✅

✅

useNavigate

✅

✅

✅

useNavigation

✅

✅

useNavigationType

✅

✅

✅

useOutlet

✅

✅

✅

useOutletContext

✅

✅

✅

useParams

✅

✅

✅

useResolvedPath

✅

✅

✅

useRevalidator

✅

✅

useRouteError

✅

✅

useRouteLoaderData

✅

✅

useRoutes

✅

✅

✅

useSearchParams

✅

✅

✅

useSubmit

✅

✅

useViewTransitionState

✅

✅

isCookieFunction

✅

✅

isSessionFunction

✅

✅

createCookie

✅

✅

createCookieSessionStorage

✅

✅

createMemorySessionStorage

✅

✅

createPath

✅

✅

✅

createRoutesStub

✅

✅

createSearchParams

✅

✅

✅

data

✅

✅

generatePath

✅

✅

✅

href

✅

isCookie

✅

✅

isRouteErrorResponse

✅

✅

isSession

✅

✅

matchPath

✅

✅

✅

matchRoutes

✅

✅

✅

parsePath

✅

✅

✅

redirect

✅

✅

redirectDocument

✅

✅

renderMatches

✅

✅

✅

replace

✅

✅

resolvePath

✅

✅

✅

[](#installation)Installation
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Most projects start with a template. Let's use a basic template maintained by React Router:

    npx create-react-router@latest my-react-router-app
    

Now change into the new directory and start the app

    cd my-react-router-app
    npm i
    npm run dev
    

You can now open your browser to `http://localhost:5173`

You can [view the template on GitHub](https://github.com/remix-run/react-router-templates/tree/main/default) to see how to manually set up your project.

We also have a number of [ready to deploy templates](https://github.com/remix-run/react-router-templates) available for you to get started with:

    npx create-react-router@latest --template remix-run/react-router-templates/<template-name>
    

* * *

Next: [Routing](./routing)

[](#routing)Routing
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#configuring-routes)Configuring Routes
-----------------------------------------

Routes are configured in `app/routes.ts`. Each route has two required parts: a URL pattern to match the URL, and a file path to the route module that defines its behavior.

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("some/path", "./some/file.tsx"),
      // pattern ^           ^ module file
    ] satisfies RouteConfig;
    

Here is a larger sample route config:

    import {
      type RouteConfig,
      route,
      index,
      layout,
      prefix,
    } from "@react-router/dev/routes";
    
    export default [
      index("./home.tsx"),
      route("about", "./about.tsx"),
    
      layout("./auth/layout.tsx", [
        route("login", "./auth/login.tsx"),
        route("register", "./auth/register.tsx"),
      ]),
    
      ...prefix("concerts", [
        index("./concerts/home.tsx"),
        route(":city", "./concerts/city.tsx"),
        route("trending", "./concerts/trending.tsx"),
      ]),
    ] satisfies RouteConfig;
    

If you prefer to define your routes via file naming conventions rather than configuration, the `@react-router/fs-routes` package provides a [file system routing convention](../../how-to/file-route-conventions). You can even combine different routing conventions if you like:

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default [
      route("/", "./home.tsx"),
    
      ...(await flatRoutes()),
    ] satisfies RouteConfig;
    

[](#route-modules)Route Modules
-------------------------------

The files referenced in `routes.ts` define each route's behavior:

    route("teams/:teamId", "./team.tsx"),
    //           route module ^^^^^^^^
    

Here's a sample route module:

    // provides type safety/inference
    import type { Route } from "./+types/team";
    
    // provides `loaderData` to the component
    export async function loader({ params }: Route.LoaderArgs) {
      let team = await fetchTeam(params.teamId);
      return { name: team.name };
    }
    
    // renders after the loader is done
    export default function Component({
      loaderData,
    }: Route.ComponentProps) {
      return <h1>{loaderData.name}</h1>;
    }
    

Route modules have more features like actions, headers, and error boundaries, but they will be covered in the next guide: [Route Modules](./route-module)

[](#nested-routes)Nested Routes
-------------------------------

Routes can be nested inside parent routes.

    import {
      type RouteConfig,
      route,
      index,
    } from "@react-router/dev/routes";
    
    export default [
      // parent route
      route("dashboard", "./dashboard.tsx", [
        // child routes
        index("./home.tsx"),
        route("settings", "./settings.tsx"),
      ]),
    ] satisfies RouteConfig;
    

The path of the parent is automatically included in the child, so this config creates both `"/dashboard"` and `"/dashboard/settings"` URLs.

Child routes are rendered through the `<Outlet/>` in the parent route.

    import { Outlet } from "react-router";
    
    export default function Dashboard() {
      return (
        <div>
          <h1>Dashboard</h1>
          {/* will either be home.tsx or settings.tsx */}
          <Outlet />
        </div>
      );
    }
    

[](#root-route)Root Route
-------------------------

Every route in `routes.ts` is nested inside the special `app/root.tsx` module.

[](#layout-routes)Layout Routes
-------------------------------

Using `layout`, layout routes create new nesting for their children, but they don't add any segments to the URL. It's like the root route but they can be added at any level.

    import {
      type RouteConfig,
      route,
      layout,
      index,
      prefix,
    } from "@react-router/dev/routes";
    
    export default [
      layout("./marketing/layout.tsx", [
        index("./marketing/home.tsx"),
        route("contact", "./marketing/contact.tsx"),
      ]),
      ...prefix("projects", [
        index("./projects/home.tsx"),
        layout("./projects/project-layout.tsx", [
          route(":pid", "./projects/project.tsx"),
          route(":pid/edit", "./projects/edit-project.tsx"),
        ]),
      ]),
    ] satisfies RouteConfig;
    

Note that:

*   `home.tsx` and `contact.tsx` will be rendered into the `marketing/layout.tsx` outlet without creating any new URL paths
*   `project.tsx` and `edit-project.tsx` will be rendered into the `projects/project-layout.tsx` outlet at `/projects/:pid` and `/projects/:pid/edit` while `projects/home.tsx` will not.

[](#index-routes)Index Routes
-----------------------------

    index(componentFile),
    

Index routes render into their parent's [Outlet](https://api.reactrouter.com/v7/functions/react_router.Outlet.html) at their parent's URL (like a default child route).

    import {
      type RouteConfig,
      route,
      index,
    } from "@react-router/dev/routes";
    
    export default [
      // renders into the root.tsx Outlet at /
      index("./home.tsx"),
      route("dashboard", "./dashboard.tsx", [
        // renders into the dashboard.tsx Outlet at /dashboard
        index("./dashboard-home.tsx"),
        route("settings", "./dashboard-settings.tsx"),
      ]),
    ] satisfies RouteConfig;
    

Note that index routes can't have children.

[](#route-prefixes)Route Prefixes
---------------------------------

Using `prefix`, you can add a path prefix to a set of routes without needing to introduce a parent route file.

    import {
      type RouteConfig,
      route,
      layout,
      index,
      prefix,
    } from "@react-router/dev/routes";
    
    export default [
      layout("./marketing/layout.tsx", [
        index("./marketing/home.tsx"),
        route("contact", "./marketing/contact.tsx"),
      ]),
      ...prefix("projects", [
        index("./projects/home.tsx"),
        layout("./projects/project-layout.tsx", [
          route(":pid", "./projects/project.tsx"),
          route(":pid/edit", "./projects/edit-project.tsx"),
        ]),
      ]),
    ] satisfies RouteConfig;
    

[](#dynamic-segments)Dynamic Segments
-------------------------------------

If a path segment starts with `:` then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as `params` to other router APIs.

    route("teams/:teamId", "./team.tsx"),
    

    import type { Route } from "./+types/team";
    
    export async function loader({ params }: Route.LoaderArgs) {
      //                           ^? { teamId: string }
    }
    
    export default function Component({
      params,
    }: Route.ComponentProps) {
      params.teamId;
      //        ^ string
    }
    

You can have multiple dynamic segments in one route path:

    route("c/:categoryId/p/:productId", "./product.tsx"),
    

    import type { Route } from "./+types/product";
    
    async function loader({ params }: LoaderArgs) {
      //                    ^? { categoryId: string; productId: string }
    }
    

[](#optional-segments)Optional Segments
---------------------------------------

You can make a route segment optional by adding a `?` to the end of the segment.

    route(":lang?/categories", "./categories.tsx"),
    

You can have optional static segments, too:

    route("users/:userId/edit?", "./user.tsx");
    

[](#splats)Splats
-----------------

Also known as "catchall" and "star" segments. If a route path pattern ends with `/*` then it will match any characters following the `/`, including other `/` characters.

    route("files/*", "./files.tsx"),
    

    export async function loader({ params }: Route.LoaderArgs) {
      // params["*"] will contain the remaining URL after files/
    }
    

You can destructure the `*`, you just have to assign it a new name. A common name is `splat`:

    const { "*": splat } = params;
    

[](#component-routes)Component Routes
-------------------------------------

You can also use components that match the URL to elements anywhere in the component tree:

    import { Routes, Route } from "react-router";
    
    function Wizard() {
      return (
        <div>
          <h1>Some Wizard with Steps</h1>
          <Routes>
            <Route index element={<StepOne />} />
            <Route path="step-2" element={<StepTwo />} />
            <Route path="step-3" element={<StepThree />} />
          </Routes>
        </div>
      );
    }
    

Note that these routes do not participate in data loading, actions, code splitting, or any other route module features, so their use cases are more limited than those of the route module.

* * *

Next: [Route Module](./route-module)

[](#route-module)Route Module
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

The files referenced in `routes.ts` are called Route Modules.

    route("teams/:teamId", "./team.tsx"),
    //           route module ^^^^^^^^
    

Route modules are the foundation of React Router's framework features, they define:

*   automatic code-splitting
*   data loading
*   actions
*   revalidation
*   error boundaries
*   and more

This guide is a quick overview of every route module feature. The rest of the getting started guides will cover these features in more detail.

[](#component-default)Component (`default`)
-------------------------------------------

The `default` export in a route module defines the component that will render when the route matches.

    export default function MyRouteComponent() {
      return (
        <div>
          <h1>Look ma!</h1>
          <p>
            I'm still using React Router after like 10 years.
          </p>
        </div>
      );
    }
    

### [](#props-passed-to-the-component)Props passed to the Component

When the component is rendered, it is provided the props defined in `Route.ComponentProps` that React Router will automatically generate for you. These props include:

1.  `loaderData`: The data returned from the `loader` function in this route module
2.  `actionData`: The data returned from the `action` function in this route module
3.  `params`: An object containing the route parameters (if any).
4.  `matches`: An array of all the matches in the current route tree.

You can use these props in place of hooks like `useLoaderData` or `useParams`. This may be preferrable because they will be automatically typed correctly for the route.

### [](#using-props)Using props

    import type { Route } from "./+types/route-name";
    
    export default function MyRouteComponent({
      loaderData,
      actionData,
      params,
      matches,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>Welcome to My Route with Props!</h1>
          <p>Loader Data: {JSON.stringify(loaderData)}</p>
          <p>Action Data: {JSON.stringify(actionData)}</p>
          <p>Route Parameters: {JSON.stringify(params)}</p>
          <p>Matched Routes: {JSON.stringify(matches)}</p>
        </div>
      );
    }
    

[](#loader)`loader`
-------------------

Route loaders provide data to route components before they are rendered. They are only called on the server when server rendering or during the build with pre-rendering.

    export async function loader() {
      return { message: "Hello, world!" };
    }
    
    export default function MyRoute({ loaderData }) {
      return <h1>{loaderData.message}</h1>;
    }
    

See also:

*   [`loader` params](https://api.reactrouter.com/v7/interfaces/react_router.LoaderFunctionArgs)

[](#clientloader)`clientLoader`
-------------------------------

Called only in the browser, route client loaders provide data to route components in addition to, or in place of, route loaders.

    export async function clientLoader({ serverLoader }) {
      // call the server loader
      const serverData = await serverLoader();
      // And/or fetch data on the client
      const data = getDataFromClient();
      // Return the data to expose through useLoaderData()
      return data;
    }
    

Client loaders can participate in initial page load hydration of server rendered pages by setting the `hydrate` property on the function:

    export async function clientLoader() {
      // ...
    }
    clientLoader.hydrate = true as const;
    

By using `as const`, TypeScript will infer that the type for `clientLoader.hydrate` is `true` instead of `boolean`. That way, React Router can derive types for `loaderData` based on the value of `clientLoader.hydrate`.

See also:

*   [`clientLoader` params](https://api.reactrouter.com/v7/types/react_router.ClientLoaderFunctionArgs)

[](#action)`action`
-------------------

Route actions allow server-side data mutations with automatic revalidation of all loader data on the page when called from `<Form>`, `useFetcher`, and `useSubmit`.

    // route("/list", "./list.tsx")
    import { Form } from "react-router";
    import { TodoList } from "~/components/TodoList";
    
    // this data will be loaded after the action completes...
    export async function loader() {
      const items = await fakeDb.getItems();
      return { items };
    }
    
    // ...so that the list here is updated automatically
    export default function Items({ loaderData }) {
      return (
        <div>
          <List items={loaderData.items} />
          <Form method="post" navigate={false} action="/list">
            <input type="text" name="title" />
            <button type="submit">Create Todo</button>
          </Form>
        </div>
      );
    }
    
    export async function action({ request }) {
      const data = await request.formData();
      const todo = await fakeDb.addItem({
        title: data.get("title"),
      });
      return { ok: true };
    }
    

[](#clientaction)`clientAction`
-------------------------------

Like route actions but only called in the browser.

    export async function clientAction({ serverAction }) {
      fakeInvalidateClientSideCache();
      // can still call the server action if needed
      const data = await serverAction();
      return data;
    }
    

See also:

*   [`clientAction` params](https://api.reactrouter.com/v7/types/react_router.ClientActionFunctionArgs)

[](#errorboundary)`ErrorBoundary`
---------------------------------

When other route module APIs throw, the route module `ErrorBoundary` will render instead of the route component.

    import {
      isRouteErrorResponse,
      useRouteError,
    } from "react-router";
    
    export function ErrorBoundary() {
      const error = useRouteError();
    
      if (isRouteErrorResponse(error)) {
        return (
          <div>
            <h1>
              {error.status} {error.statusText}
            </h1>
            <p>{error.data}</p>
          </div>
        );
      } else if (error instanceof Error) {
        return (
          <div>
            <h1>Error</h1>
            <p>{error.message}</p>
            <p>The stack trace is:</p>
            <pre>{error.stack}</pre>
          </div>
        );
      } else {
        return <h1>Unknown Error</h1>;
      }
    }
    

[](#hydratefallback)`HydrateFallback`
-------------------------------------

On initial page load, the route component renders only after the client loader is finished. If exported, a `HydrateFallback` can render immediately in place of the route component.

    export async function clientLoader() {
      const data = await fakeLoadLocalGameData();
      return data;
    }
    
    export function HydrateFallback() {
      return <p>Loading Game...</p>;
    }
    
    export default function Component({ loaderData }) {
      return <Game data={loaderData} />;
    }
    

[](#headers)`headers`
---------------------

Route headers define HTTP headers to be sent with the response when server rendering.

    export function headers() {
      return {
        "X-Stretchy-Pants": "its for fun",
        "Cache-Control": "max-age=300, s-maxage=3600",
      };
    }
    

[](#handle)`handle`
-------------------

Route handle allows apps to add anything to a route match in `useMatches` to create abstractions (like breadcrumbs, etc.).

    export const handle = {
      its: "all yours",
    };
    

[](#links)`links`
-----------------

Route links define [`<link>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link)s to be rendered in the document `<head>`.

    export function links() {
      return [
        {
          rel: "icon",
          href: "/favicon.png",
          type: "image/png",
        },
        {
          rel: "stylesheet",
          href: "https://example.com/some/styles.css",
        },
        {
          rel: "preload",
          href: "/images/banner.jpg",
          as: "image",
        },
      ];
    }
    

All routes links will be aggregated and rendered through the `<Links />` component, usually rendered in your app root:

    import { Links } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head>
            <Links />
          </head>
    
          <body />
        </html>
      );
    }
    

[](#meta)`meta`
---------------

Route meta defines meta tags to be rendered in the `<Meta />` component, usually placed in the `<head>`.

    export function meta() {
      return [
        { title: "Very cool app" },
        {
          property: "og:title",
          content: "Very cool app",
        },
        {
          name: "description",
          content: "This app is the best",
        },
      ];
    }
    

    import { Meta } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head>
            <Meta />
          </head>
    
          <body />
        </html>
      );
    }
    

The meta of the last matching route is used, allowing you to override parent routes' meta. It's important to note that the entire meta descriptor array is replaced, not merged. This gives you the flexibility to build your own meta composition logic across pages at different levels.

**See also**

*   [`meta` params](https://api.reactrouter.com/v7/interfaces/react_router.MetaArgs)

[](#shouldrevalidate)`shouldRevalidate`
---------------------------------------

In framework mode, route loaders are automatically revalidated after all navigations and form submissions (this is different from [Data Mode](../data/route-object#shouldrevalidate)). This enables middleware and loaders to share a request context and optimize in different ways than then they would be in Data Mode.

Defining this function allows you to opt out of revalidation for a route loader for navigations and form submissions.

    import type { ShouldRevalidateFunctionArgs } from "react-router";
    
    export function shouldRevalidate(
      arg: ShouldRevalidateFunctionArgs
    ) {
      return true;
    }
    

[`ShouldRevalidateFunctionArgs` Reference Documentation ↗](https://api.reactrouter.com/v7/interfaces/react_router.ShouldRevalidateFunctionArgs.html)

* * *

Next: [Rendering Strategies](./rendering)

[](#rendering-strategies)Rendering Strategies
=============================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

There are three rendering strategies in React Router:

*   Client Side Rendering
*   Server Side Rendering
*   Static Pre-rendering

[](#client-side-rendering)Client Side Rendering
-----------------------------------------------

Routes are always client side rendered as the user navigates around the app. If you're looking to build a Single Page App, disable server rendering:

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
    } satisfies Config;
    

[](#server-side-rendering)Server Side Rendering
-----------------------------------------------

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: true,
    } satisfies Config;
    

Server side rendering requires a deployment that supports it. Though it's a global setting, individual routes can still be statically pre-rendered. Routes can also use client data loading with `clientLoader` to avoid server rendering/fetching for their portion of the UI.

[](#static-pre-rendering)Static Pre-rendering
---------------------------------------------

    import type { Config } from "@react-router/dev/config";
    
    export default {
      // return a list of URLs to prerender at build time
      async prerender() {
        return ["/", "/about", "/contact"];
      },
    } satisfies Config;
    

Pre-rendering is a build-time operation that generates static HTML and client navigation data payloads for a list of URLs. This is useful for SEO and performance, especially for deployments without server rendering. When pre-rendering, route module loaders are used to fetch data at build time.

* * *

Next: [Data Loading](./data-loading)

[](#data-loading)Data Loading
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Data is provided to the route component from `loader` and `clientLoader`.

Loader data is automatically serialized from loaders and deserialized in components. In addition to primitive values like strings and numbers, loaders can return promises, maps, sets, dates and more.

The type for the `loaderData` prop is [automatically generated](../../explanation/type-safety).

[](#client-data-loading)Client Data Loading
-------------------------------------------

`clientLoader` is used to fetch data on the client. This is useful for pages or full projects that you'd prefer to fetch data from the browser only.

    // route("products/:pid", "./product.tsx");
    import type { Route } from "./+types/product";
    
    export async function clientLoader({
      params,
    }: Route.ClientLoaderArgs) {
      const res = await fetch(`/api/products/${params.pid}`);
      const product = await res.json();
      return product;
    }
    
    // HydrateFallback is rendered while the client loader is running
    export function HydrateFallback() {
      return <div>Loading...</div>;
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      const { name, description } = loaderData;
      return (
        <div>
          <h1>{name}</h1>
          <p>{description}</p>
        </div>
      );
    }
    

[](#server-data-loading)Server Data Loading
-------------------------------------------

When server rendering, `loader` is used for both initial page loads and client navigations. Client navigations call the loader through an automatic `fetch` by React Router from the browser to your server.

    // route("products/:pid", "./product.tsx");
    import type { Route } from "./+types/product";
    import { fakeDb } from "../db";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const product = await fakeDb.getProduct(params.pid);
      return product;
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      const { name, description } = loaderData;
      return (
        <div>
          <h1>{name}</h1>
          <p>{description}</p>
        </div>
      );
    }
    

Note that the `loader` function is removed from client bundles so you can use server only APIs without worrying about them being included in the browser.

[](#static-data-loading)Static Data Loading
-------------------------------------------

When pre-rendering, loaders are used to fetch data during the production build.

    // route("products/:pid", "./product.tsx");
    import type { Route } from "./+types/product";
    
    export async function loader({ params }: Route.LoaderArgs) {
      let product = await getProductFromCSVFile(params.pid);
      return product;
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      const { name, description } = loaderData;
      return (
        <div>
          <h1>{name}</h1>
          <p>{description}</p>
        </div>
      );
    }
    

The URLs to pre-render are specified in react-router.config.ts:

    import type { Config } from "@react-router/dev/config";
    
    export default {
      async prerender() {
        let products = await readProductsFromCSVFile();
        return products.map(
          (product) => `/products/${product.id}`
        );
      },
    } satisfies Config;
    

Note that when server rendering, any URLs that aren't pre-rendered will be server rendered as usual, allowing you to pre-render some data at a single route while still server rendering the rest.

[](#using-both-loaders)Using Both Loaders
-----------------------------------------

`loader` and `clientLoader` can be used together. The `loader` will be used on the server for initial SSR (or pre-rendering) and the `clientLoader` will be used on subsequent client-side navigations.

    // route("products/:pid", "./product.tsx");
    import type { Route } from "./+types/product";
    import { fakeDb } from "../db";
    
    export async function loader({ params }: Route.LoaderArgs) {
      return fakeDb.getProduct(params.pid);
    }
    
    export async function clientLoader({
      serverLoader,
      params,
    }: Route.ClientLoaderArgs) {
      const res = await fetch(`/api/products/${params.pid}`);
      const serverData = await serverLoader();
      return { ...serverData, ...res.json() };
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      const { name, description } = loaderData;
    
      return (
        <div>
          <h1>{name}</h1>
          <p>{description}</p>
        </div>
      );
    }
    

You can also force the client loader to run during hydration and before the page renders by setting the `hydrate` property on the function. In this situation you will want to render a `HydrateFallback` component to show a fallback UI while the client loader runs.

    export async function loader() {
      /* ... */
    }
    
    export async function clientLoader() {
      /* ... */
    }
    
    // force the client loader to run during hydration
    clientLoader.hydrate = true as const; // `as const` for type inference
    
    export function HydrateFallback() {
      return <div>Loading...</div>;
    }
    
    export default function Product() {
      /* ... */
    }
    

* * *

Next: [Actions](./actions)

See also:

*   [Streaming with Suspense](../../how-to/suspense)
*   [Client Data](../../how-to/client-data)
*   [Using Fetchers](../../how-to/fetchers#loading-data)

[](#actions)Actions
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Data mutations are done through Route actions. When the action completes, all loader data on the page is revalidated to keep your UI in sync with the data without writing any code to do it.

Route actions defined with `action` are only called on the server while actions defined with `clientAction` are run in the browser.

[](#client-actions)Client Actions
---------------------------------

Client actions only run in the browser and take priority over a server action when both are defined.

    // route('/projects/:projectId', './project.tsx')
    import type { Route } from "./+types/project";
    import { Form } from "react-router";
    import { someApi } from "./api";
    
    export async function clientAction({
      request,
    }: Route.ClientActionArgs) {
      let formData = await request.formData();
      let title = formData.get("title");
      let project = await someApi.updateProject({ title });
      return project;
    }
    
    export default function Project({
      actionData,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>Project</h1>
          <Form method="post">
            <input type="text" name="title" />
            <button type="submit">Submit</button>
          </Form>
          {actionData ? (
            <p>{actionData.title} updated</p>
          ) : null}
        </div>
      );
    }
    

[](#server-actions)Server Actions
---------------------------------

Server actions only run on the server and are removed from client bundles.

    // route('/projects/:projectId', './project.tsx')
    import type { Route } from "./+types/project";
    import { Form } from "react-router";
    import { fakeDb } from "../db";
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      let formData = await request.formData();
      let title = formData.get("title");
      let project = await fakeDb.updateProject({ title });
      return project;
    }
    
    export default function Project({
      actionData,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>Project</h1>
          <Form method="post">
            <input type="text" name="title" />
            <button type="submit">Submit</button>
          </Form>
          {actionData ? (
            <p>{actionData.title} updated</p>
          ) : null}
        </div>
      );
    }
    

[](#calling-actions)Calling Actions
-----------------------------------

Actions are called declaratively through `<Form>` and imperatively through `useSubmit` (or `<fetcher.Form>` and `fetcher.submit`) by referencing the route's path and a "post" method.

### [](#calling-actions-with-a-form)Calling actions with a Form

    import { Form } from "react-router";
    
    function SomeComponent() {
      return (
        <Form action="/projects/123" method="post">
          <input type="text" name="title" />
          <button type="submit">Submit</button>
        </Form>
      );
    }
    

This will cause a navigation and a new entry will be added to the browser history.

### [](#calling-actions-with-usesubmit)Calling actions with useSubmit

You can submit form data to an action imperatively with `useSubmit`.

    import { useCallback } from "react";
    import { useSubmit } from "react-router";
    import { useFakeTimer } from "fake-lib";
    
    function useQuizTimer() {
      let submit = useSubmit();
    
      let cb = useCallback(() => {
        submit(
          { quizTimedOut: true },
          { action: "/end-quiz", method: "post" }
        );
      }, []);
    
      let tenMinutes = 10 * 60 * 1000;
      useFakeTimer(tenMinutes, cb);
    }
    

This will cause a navigation and a new entry will be added to the browser history.

### [](#calling-actions-with-a-fetcher)Calling actions with a fetcher

Fetchers allow you to submit data to actions (and loaders) without causing a navigation (no new entries in the browser history).

    import { useFetcher } from "react-router";
    
    function Task() {
      let fetcher = useFetcher();
      let busy = fetcher.state !== "idle";
    
      return (
        <fetcher.Form method="post" action="/update-task/123">
          <input type="text" name="title" />
          <button type="submit">
            {busy ? "Saving..." : "Save"}
          </button>
        </fetcher.Form>
      );
    }
    

They also have the imperative `submit` method.

    fetcher.submit(
      { title: "New Title" },
      { action: "/update-task/123", method: "post" }
    );
    

See the [Using Fetchers](../../how-to/fetchers) guide for more information.

* * *

Next: [Navigating](./navigating)

[](#navigating)Navigating
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Users navigate your application with `<Link>`, `<NavLink>`, `<Form>`, `redirect`, and `useNavigate`.

[](#navlink)NavLink
-------------------

This component is for navigation links that need to render active and pending states.

    import { NavLink } from "react-router";
    
    export function MyAppNav() {
      return (
        <nav>
          <NavLink to="/" end>
            Home
          </NavLink>
          <NavLink to="/trending" end>
            Trending Concerts
          </NavLink>
          <NavLink to="/concerts">All Concerts</NavLink>
          <NavLink to="/account">Account</NavLink>
        </nav>
      );
    }
    

`NavLink` renders default class names for different states for easy styling with CSS:

    a.active {
      color: red;
    }
    
    a.pending {
      animate: pulse 1s infinite;
    }
    
    a.transitioning {
      /* css transition is running */
    }
    

It also has callback props on `className`, `style`, and `children` with the states for inline styling or conditional rendering:

    // className
    <NavLink
      to="/messages"
      className={({ isActive, isPending, isTransitioning }) =>
        [
          isPending ? "pending" : "",
          isActive ? "active" : "",
          isTransitioning ? "transitioning" : "",
        ].join(" ")
      }
    >
      Messages
    </NavLink>
    

    // style
    <NavLink
      to="/messages"
      style={({ isActive, isPending, isTransitioning }) => {
        return {
          fontWeight: isActive ? "bold" : "",
          color: isPending ? "red" : "black",
          viewTransitionName: isTransitioning ? "slide" : "",
        };
      }}
    >
      Messages
    </NavLink>
    

    // children
    <NavLink to="/tasks">
      {({ isActive, isPending, isTransitioning }) => (
        <span className={isActive ? "active" : ""}>Tasks</span>
      )}
    </NavLink>
    

[](#link)Link
-------------

Use `<Link>` when the link doesn't need active styling:

    import { Link } from "react-router";
    
    export function LoggedOutMessage() {
      return (
        <p>
          You've been logged out.{" "}
          <Link to="/login">Login again</Link>
        </p>
      );
    }
    

[](#form)Form
-------------

The form component can be used to navigate with `URLSearchParams` provided by the user.

    <Form action="/search">
      <input type="text" name="q" />
    </Form>
    

If the user enters "journey" into the input and submits it, they will navigate to:

    /search?q=journey
    

Forms with `<Form method="post" />` will also navigate to the action prop but will submit the data as `FormData` instead of `URLSearchParams`. However, it is more common to `useFetcher()` to POST form data. See [Using Fetchers](../../how-to/fetchers).

[](#redirect)redirect
---------------------

Inside of route loaders and actions, you can return a `redirect` to another URL.

    import { redirect } from "react-router";
    
    export async function loader({ request }) {
      let user = await getUser(request);
      if (!user) {
        return redirect("/login");
      }
      return { userName: user.name };
    }
    

It is common to redirect to a new record after it has been created:

    import { redirect } from "react-router";
    
    export async function action({ request }) {
      let formData = await request.formData();
      let project = await createProject(formData);
      return redirect(`/projects/${project.id}`);
    }
    

[](#usenavigate)useNavigate
---------------------------

This hook allows the programmer to navigate the user to a new page without the user interacting. Usage of this hook should be uncommon. It's recommended to use the other APIs in this guide when possible.

Reserve usage of `useNavigate` to situations where the user is _not_ interacting but you need to navigate, for example:

*   Logging them out after inactivity
*   Timed UIs like quizzes, etc.

    import { useNavigate } from "react-router";
    
    export function useLogoutAfterInactivity() {
      let navigate = useNavigate();
    
      useFakeInactivityHook(() => {
        navigate("/logout");
      });
    }
    

* * *

Next: [Pending UI](./pending-ui)

[](#pending-ui)Pending UI
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

When the user navigates to a new route, or submits data to an action, the UI should immediately respond to the user's actions with a pending or optimistic state. Application code is responsible for this.

[](#global-pending-navigation)Global Pending Navigation
-------------------------------------------------------

When the user navigates to a new url, the loaders for the next page are awaited before the next page renders. You can get the pending state from `useNavigation`.

    import { useNavigation } from "react-router";
    
    export default function Root() {
      const navigation = useNavigation();
      const isNavigating = Boolean(navigation.location);
    
      return (
        <html>
          <body>
            {isNavigating && <GlobalSpinner />}
            <Outlet />
          </body>
        </html>
      );
    }
    

[](#local-pending-navigation)Local Pending Navigation
-----------------------------------------------------

Pending indicators can also be localized to the link. NavLink's children, className, and style props can be functions that receive the pending state.

    import { NavLink } from "react-router";
    
    function Navbar() {
      return (
        <nav>
          <NavLink to="/home">
            {({ isPending }) => (
              <span>Home {isPending && <Spinner />}</span>
            )}
          </NavLink>
          <NavLink
            to="/about"
            style={({ isPending }) => ({
              color: isPending ? "gray" : "black",
            })}
          >
            About
          </NavLink>
        </nav>
      );
    }
    

[](#pending-form-submission)Pending Form Submission
---------------------------------------------------

When a form is submitted, the UI should immediately respond to the user's actions with a pending state. This is easiest to do with a [fetcher](https://api.reactrouter.com/v7/functions/react_router.useFetcher.html) form because it has it's own independent state (whereas normal forms cause a global navigation).

    import { useFetcher } from "react-router";
    
    function NewProjectForm() {
      const fetcher = useFetcher();
    
      return (
        <fetcher.Form method="post">
          <input type="text" name="title" />
          <button type="submit">
            {fetcher.state !== "idle"
              ? "Submitting..."
              : "Submit"}
          </button>
        </fetcher.Form>
      );
    }
    

For non-fetcher form submissions, pending states are available on `useNavigation`.

    import { useNavigation, Form } from "react-router";
    
    function NewProjectForm() {
      const navigation = useNavigation();
    
      return (
        <Form method="post" action="/projects/new">
          <input type="text" name="title" />
          <button type="submit">
            {navigation.formAction === "/projects/new"
              ? "Submitting..."
              : "Submit"}
          </button>
        </Form>
      );
    }
    

[](#optimistic-ui)Optimistic UI
-------------------------------

When the future state of the UI is known by the form submission data, an optimistic UI can be implemented for instant UX.

    function Task({ task }) {
      const fetcher = useFetcher();
    
      let isComplete = task.status === "complete";
      if (fetcher.formData) {
        isComplete =
          fetcher.formData.get("status") === "complete";
      }
    
      return (
        <div>
          <div>{task.title}</div>
          <fetcher.Form method="post">
            <button
              name="status"
              value={isComplete ? "incomplete" : "complete"}
            >
              {isComplete ? "Mark Incomplete" : "Mark Complete"}
            </button>
          </fetcher.Form>
        </div>
      );
    }
    

* * *

Next: [Testing](./testing)

[](#testing)Testing
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

When components use things like `useLoaderData`, `<Link>`, etc, they are required to be rendered in context of a React Router app. The `createRoutesStub` function creates that context to test components in isolation.

Consider a login form component that relies on `useActionData`

    import { useActionData } from "react-router";
    
    export function LoginForm() {
      const { errors } = useActionData();
      return (
        <Form method="post">
          <label>
            <input type="text" name="username" />
            {errors?.username && <div>{errors.username}</div>}
          </label>
    
          <label>
            <input type="password" name="password" />
            {errors?.password && <div>{errors.password}</div>}
          </label>
    
          <button type="submit">Login</button>
        </Form>
      );
    }
    

We can test this component with `createRoutesStub`. It takes an array of objects that resemble route modules with loaders, actions, and components.

    import { createRoutesStub } from "react-router";
    import {
      render,
      screen,
      waitFor,
    } from "@testing-library/react";
    import userEvent from "@testing-library/user-event";
    import { LoginForm } from "./LoginForm";
    
    test("LoginForm renders error messages", async () => {
      const USER_MESSAGE = "Username is required";
      const PASSWORD_MESSAGE = "Password is required";
    
      const Stub = createRoutesStub([
        {
          path: "/login",
          Component: LoginForm,
          action() {
            return {
              errors: {
                username: USER_MESSAGE,
                password: PASSWORD_MESSAGE,
              },
            };
          },
        },
      ]);
    
      // render the app stub at "/login"
      render(<Stub initialEntries={["/login"]} />);
    
      // simulate interactions
      userEvent.click(screen.getByText("Login"));
      await waitFor(() => screen.findByText(USER_MESSAGE));
      await waitFor(() => screen.findByText(PASSWORD_MESSAGE));
    });
    

[](#deploying)Deploying
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

React Router can be deployed two ways:

*   Fullstack Hosting
*   Static Hosting

The official [React Router templates](https://github.com/remix-run/react-router-templates) can help you bootstrap an application or be used as a reference for your own application.

When deploying to static hosting, you can deploy React Router the same as any other single page application with React.

[](#templates)Templates
-----------------------

After running the `create-react-router` command, make sure to follow the instructions in the README.

### [](#nodejs-with-docker)Node.js with Docker

    npx create-react-router@latest --template remix-run/react-router-templates/default
    

*   Server Rendering
*   Tailwind CSS

The containerized application can be deployed to any platform that supports Docker, including:

*   AWS ECS
*   Google Cloud Run
*   Azure Container Apps
*   Digital Ocean App Platform
*   Fly.io
*   Railway

### [](#node-with-docker-custom-server)Node with Docker (Custom Server)

    npx create-react-router@latest --template remix-run/react-router-templates/node-custom-server
    

*   Server Rendering
*   Tailwind CSS
*   Custom express server for more control

The containerized application can be deployed to any platform that supports Docker, including:

*   AWS ECS
*   Google Cloud Run
*   Azure Container Apps
*   Digital Ocean App Platform
*   Fly.io
*   Railway

### [](#node-with-docker-and-postgres)Node with Docker and Postgres

    npx create-react-router@latest --template remix-run/react-router-templates/node-postgres
    

*   Server Rendering
*   Postgres Database with Drizzle
*   Tailwind CSS
*   Custom express server for more control

The containerized application can be deployed to any platform that supports Docker, including:

*   AWS ECS
*   Google Cloud Run
*   Azure Container Apps
*   Digital Ocean App Platform
*   Fly.io
*   Railway

### [](#vercel)Vercel

    npx create-react-router@latest --template remix-run/react-router-templates/vercel
    

*   Server Rendering
*   Tailwind CSS

### [](#cloudflare-workers-w-d1)Cloudflare Workers w/ D1

    npx create-react-router@latest --template remix-run/react-router-templates/cloudflare-d1
    

*   Server Rendering
*   D1 Database with Drizzle ORM
*   Tailwind CSS

### [](#cloudflare-workers)Cloudflare Workers

    npx create-react-router@latest --template remix-run/react-router-templates/cloudflare
    

*   Server Rendering
*   Tailwind CSS

### [](#netlify)Netlify

    npx create-react-router@latest --template remix-run/react-router-templates/netlify
    

*   Server Rendering
*   Tailwind CSS

[](#installation)Installation
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#bootstrap-with-a-bundler-template)Bootstrap with a Bundler Template
-----------------------------------------------------------------------

You can start with a React template from Vite and choose "React", otherwise bootstrap your application however you prefer (Parcel, Webpack, etc).

    npx create-vite@latest
    

[](#install-react-router)Install React Router
---------------------------------------------

Next install React Router from npm:

    npm i react-router
    

[](#create-a-router-and-render)Create a Router and Render
---------------------------------------------------------

Create a router and pass it to `RouterProvider`:

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    
    import React from "react";
    import ReactDOM from "react-dom/client";
    
    const router = createBrowserRouter([
      {
        path: "/",
        element: <div>Hello World</div>,
      },
    ]);
    
    const root = document.getElementById("root");
    
    ReactDOM.createRoot(root).render(
      <RouterProvider router={router} />
    );
    

* * *

Next: [Routing](./routing)

[](#routing)Routing
===================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#configuring-routes)Configuring Routes
-----------------------------------------

Routes are configured as the first argument to `createBrowserRouter`. At a minimum, you need a path and component:

    import { createBrowserRouter } from "react-router";
    
    function Root() {
      return <h1>Hello world</h1>;
    }
    
    const router = createBrowserRouter([
      { path: "/", Component: Root },
    ]);
    

Here is a larger sample route config:

    createBrowserRouter([
      {
        path: "/",
        Component: Root,
        children: [
          { index: true, Component: Home },
          { path: "about", Component: About },
          {
            path: "auth",
            Component: AuthLayout,
            children: [
              { path: "login", Component: Login },
              { path: "register", Component: Register },
            ],
          },
          {
            path: "concerts",
            children: [
              { index: true, Component: ConcertsHome },
              { path: ":city", Component: ConcertsCity },
              { path: "trending", Component: ConcertsTrending },
            ],
          },
        ],
      },
    ]);
    

[](#route-objects)Route Objects
-------------------------------

Route objects define the behavior of a route beyond just the path and component, like data loading and actions. We'll go into more detail in the [Route Object guide](./route-object), but here's a quick example of a loader.

    import {
      createBrowserRouter,
      useLoaderData,
    } from "react-router";
    
    createBrowserRouter([
      {
        path: "/teams/:teamId",
        loader: async ({ params }) => {
          let team = await fetchTeam(params.teamId);
          return { name: team.name };
        },
        Component: Team,
      },
    ]);
    
    function Team() {
      let data = useLoaderData();
      return <h1>{data.name}</h1>;
    }
    

[](#nested-routes)Nested Routes
-------------------------------

Routes can be nested inside parent routes through `children`.

    createBrowserRouter([
      {
        path: "/dashboard",
        Component: Dashboard,
        children: [
          { index: true, Component: Home },
          { path: "settings", Component: Settings },
        ],
      },
    ]);
    

The path of the parent is automatically included in the child, so this config creates both `"/dashboard"` and `"/dashboard/settings"` URLs.

Child routes are rendered through the `<Outlet/>` in the parent route.

    import { Outlet } from "react-router";
    
    export default function Dashboard() {
      return (
        <div>
          <h1>Dashboard</h1>
          {/* will either be <Home> or <Settings> */}
          <Outlet />
        </div>
      );
    }
    

[](#layout-routes)Layout Routes
-------------------------------

Omitting the `path` in a route creates new [Nested Routes](#nested-routes) for its children without adding any segments to the URL.

    createBrowserRouter([
      {
        // no path on this parent route, just the component
        Component: MarketingLayout,
        children: [
          { index: true, Component: Home },
          { path: "contact", Component: Contact },
        ],
      },
    
      {
        path: "projects",
        children: [
          { index: true, Component: ProjectsHome },
          {
            // again, no path, just a component for the layout
            Component: ProjectLayout,
            children: [
              { path: ":pid", Component: Project },
              { path: ":pid/edit", Component: EditProject },
            ],
          },
        ],
      },
    ]);
    

Note that:

*   `Home` and `Contact` will be rendered into the `MarketingLayout` outlet
*   `Project` and `EditProject` will be rendered into the `ProjectLayout` outlet while `ProjectsHome` will not.

[](#index-routes)Index Routes
-----------------------------

Index routes are defined by setting `index: true` on a route object without a path.

    { index: true, Component: Home }
    

Index routes render into their parent's [Outlet](https://api.reactrouter.com/v7/functions/react_router.Outlet.html) at their parent's URL (like a default child route).

    import { createBrowserRouter } from "react-router";
    
    createBrowserRouter([
      // renders at "/"
      { index: true, Component: Home },
      {
        Component: Dashboard,
        path: "/dashboard",
        children: [
          // renders at "/dashboard"
          { index: true, Component: DashboardHome },
          { path: "settings", Component: DashboardSettings },
        ],
      },
    ]);
    

Note that index routes can't have children.

[](#prefix-route)Prefix Route
-----------------------------

A route with just a path and no component creates a group of routes with a path prefix.

    createBrowserRouter([
      {
        // no component, just a path
        path: "/projects",
        children: [
          { index: true, Component: ProjectsHome },
          { path: ":pid", Component: Project },
          { path: ":pid/edit", Component: EditProject },
        ],
      },
    ]);
    

This creates the routes `/projects`, `/projects/:pid`, and `/projects/:pid/edit` without introducing a layout component.

[](#dynamic-segments)Dynamic Segments
-------------------------------------

If a path segment starts with `:` then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as `params` to other router APIs.

    {
      path: "teams/:teamId",
      loader: async ({ params }) => {
        // params are available in loaders/actions
        let team = await fetchTeam(params.teamId);
        return { name: team.name };
      },
      Component: Team,
    }
    

    import { useParams } from "react-router";
    
    function Team() {
      // params are available in components through useParams
      let params = useParams();
      // ...
    }
    

You can have multiple dynamic segments in one route path:

    {
      path: "c/:categoryId/p/:productId";
    }
    

[](#optional-segments)Optional Segments
---------------------------------------

You can make a route segment optional by adding a `?` to the end of the segment.

    {
      path: ":lang?/categories";
    }
    

You can have optional static segments, too:

    {
      path: "users/:userId/edit?";
    }
    

[](#splats)Splats
-----------------

Also known as "catchall" and "star" segments. If a route path pattern ends with `/*` then it will match any characters following the `/`, including other `/` characters.

    {
      path: "files/*";
      loader: async ({ params }) => {
        params["*"]; // will contain the remaining URL after files/
      };
    }
    

You can destructure the `*`, you just have to assign it a new name. A common name is `splat`:

    const { "*": splat } = params;
    

* * *

Next: [Route Object](./route-object)

[](#route-object)Route Object
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

The objects passed to `createBrowserRouter` are called Route Objects.

    createBrowserRouter([
      {
        path: "/",
        Component: App,
      },
    ]);
    

Route modules are the foundation of React Router's data features, they define:

*   data loading
*   actions
*   revalidation
*   error boundaries
*   and more

This guide is a quick overview of every route object feature.

[](#component)Component
-----------------------

The `Component` property in a route object defines the component that will render when the route matches.

    createBrowserRouter([
      {
        path: "/",
        Component: MyRouteComponent,
      },
    ]);
    
    function MyRouteComponent() {
      return (
        <div>
          <h1>Look ma!</h1>
          <p>
            I'm still using React Router after like 10 years.
          </p>
        </div>
      );
    }
    

[](#loader)`loader`
-------------------

Route loaders provide data to route components before they are rendered.

    import {
      useLoaderData,
      createBrowserRouter,
    } from "react-router";
    
    createBrowserRouter([
      {
        path: "/",
        loader: loader,
        Component: MyRoute,
      },
    ]);
    
    async function loader({ params }) {
      return { message: "Hello, world!" };
    }
    
    function MyRoute() {
      let data = useLoaderData();
      return <h1>{data.message}</h1>;
    }
    

See also:

*   [`loader` params](https://api.reactrouter.com/v7/interfaces/react_router.LoaderFunctionArgs)

[](#action)`action`
-------------------

Route actions allow server-side data mutations with automatic revalidation of all loader data on the page when called from `<Form>`, `useFetcher`, and `useSubmit`.

    import {
      createBrowserRouter,
      useLoaderData,
      useActionData,
      Form,
    } from "react-router";
    import { TodoList } from "~/components/TodoList";
    
    createBrowserRouter([
      {
        path: "/items",
        action: action,
        loader: loader,
        Component: Items,
      },
    ]);
    
    async function action({ request }) {
      const data = await request.formData();
      const todo = await fakeDb.addItem({
        title: data.get("title"),
      });
      return { ok: true };
    }
    
    // this data will be revalidated after the action completes...
    async function loader() {
      const items = await fakeDb.getItems();
      return { items };
    }
    
    // ...so that the list here is updated automatically
    export default function Items() {
      let data = useLoaderData();
      return (
        <div>
          <List items={data.items} />
          <Form method="post" navigate={false}>
            <input type="text" name="title" />
            <button type="submit">Create Todo</button>
          </Form>
        </div>
      );
    }
    

[](#shouldrevalidate)`shouldRevalidate`
---------------------------------------

Loader data is automatically revalidated after certain events like navigations and form submissions.

This hook enables you to opt in or out of the default revalidation behavior. The default behavior is nuanced to avoid calling loaders unnecessarily.

A route loader is revalidated when:

*   its own route params change
*   any change to URL search params
*   after any actions are called

By defining this function, you opt out of the default behavior completely and can manually control when loader data is revalidated for navigations and form submissions.

    import type { ShouldRevalidateFunctionArgs } from "react-router";
    
    function shouldRevalidate(
      arg: ShouldRevalidateFunctionArgs
    ) {
      return true; // false
    }
    
    createBrowserRouter([
      {
        path: "/",
        shouldRevalidate: shouldRevalidate,
        Component: MyRoute,
      },
    ]);
    

[`ShouldRevalidateFunctionArgs` Reference Documentation ↗](https://api.reactrouter.com/v7/interfaces/react_router.ShouldRevalidateFunctionArgs.html)

Please note the default behavior is different in [Framework Mode](../modes).

[](#lazy)`lazy`
---------------

Most properties can be lazily imported to reduce the initial bundle size.

    createBrowserRouter([
      {
        path: "/app",
        lazy: async () => {
          // load component and loader in parallel before rendering
          const [Component, loader] = await Promise.all([
            import("./app"),
            import("./app-loader"),
          ]);
          return { Component, loader };
        },
      },
    ]);
    

* * *

Next: [Data Loading](./data-loading)

[](#data-loading)Data Loading
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#providing-data)Providing Data
---------------------------------

Data is provided to route components from route loaders:

    createBrowserRouter([
      {
        path: "/",
        loader: async () => {
          // return data from here
          return { records: await getSomeRecords() };
        },
        Component: MyRoute,
      },
    ]);
    

[](#accessing-data)Accessing Data
---------------------------------

The data is available in route components with `useLoaderData`.

    import { useLoaderData } from "react-router";
    
    function MyRoute() {
      const { records } = useLoaderData();
      return <div>{records.length}</div>;
    }
    

As the user navigates between routes, the loaders are called before the route component is rendered.

* * *

Next: [Actions](./actions)

[](#actions)Actions
===================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#defining-actions)Defining Actions
-------------------------------------

Data mutations are done through Route actions defined on the `action` property of a route object. When the action completes, all loader data on the page is revalidated to keep your UI in sync with the data without writing any code to do it.

    import { createBrowserRouter } from "react-router";
    import { someApi } from "./api";
    
    let router = createBrowserRouter([
      {
        path: "/projects/:projectId",
        Component: Project,
        action: async ({ request }) => {
          let formData = await request.formData();
          let title = formData.get("title");
          let project = await someApi.updateProject({ title });
          return project;
        },
      },
    ]);
    

[](#calling-actions)Calling Actions
-----------------------------------

Actions are called declaratively through `<Form>` and imperatively through `useSubmit` (or `<fetcher.Form>` and `fetcher.submit`) by referencing the route's path and a "post" method.

### [](#calling-actions-with-a-form)Calling actions with a Form

    import { Form } from "react-router";
    
    function SomeComponent() {
      return (
        <Form action="/projects/123" method="post">
          <input type="text" name="title" />
          <button type="submit">Submit</button>
        </Form>
      );
    }
    

This will cause a navigation and a new entry will be added to the browser history.

### [](#calling-actions-with-usesubmit)Calling actions with useSubmit

You can submit form data to an action imperatively with `useSubmit`.

    import { useCallback } from "react";
    import { useSubmit } from "react-router";
    import { useFakeTimer } from "fake-lib";
    
    function useQuizTimer() {
      let submit = useSubmit();
    
      let cb = useCallback(() => {
        submit(
          { quizTimedOut: true },
          { action: "/end-quiz", method: "post" }
        );
      }, []);
    
      let tenMinutes = 10 * 60 * 1000;
      useFakeTimer(tenMinutes, cb);
    }
    

This will cause a navigation and a new entry will be added to the browser history.

### [](#calling-actions-with-a-fetcher)Calling actions with a fetcher

Fetchers allow you to submit data to actions (and loaders) without causing a navigation (no new entries in the browser history).

    import { useFetcher } from "react-router";
    
    function Task() {
      let fetcher = useFetcher();
      let busy = fetcher.state !== "idle";
    
      return (
        <fetcher.Form method="post" action="/update-task/123">
          <input type="text" name="title" />
          <button type="submit">
            {busy ? "Saving..." : "Save"}
          </button>
        </fetcher.Form>
      );
    }
    

They also have the imperative `submit` method.

    fetcher.submit(
      { title: "New Title" },
      { action: "/update-task/123", method: "post" }
    );
    

See the [Using Fetchers](../../how-to/fetchers) guide for more information.

[](#accessing-action-data)Accessing Action Data
-----------------------------------------------

Actions can return data available through `useActionData` in the route component or `fetcher.data` when using a fetcher.

    function Project() {
      let actionData = useActionData();
      return (
        <div>
          <h1>Project</h1>
          <Form method="post">
            <input type="text" name="title" />
            <button type="submit">Submit</button>
          </Form>
          {actionData ? (
            <p>{actionData.title} updated</p>
          ) : null}
        </div>
      );
    }
    

* * *

Next: [Navigating](./navigating)

[](#navigating)Navigating
=========================

Navigating in Data Mode is the same as Framework Mode, please see the [Navigating](../framework/navigating) guide for more information.

* * *

Next: [Pending UI](./pending-ui)

[](#pending-ui)Pending UI
=========================

Pending UI is the same as Framework Mode, please see the [Pending UI](../framework/pending-ui) guide for more information.

* * *

Next: [Custom Framework](./custom)

[](#custom-framework)Custom Framework
=====================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Instead of using `@react-router/dev`, you can integrate React Router's framework features (like loaders, actions, fetchers, etc.) into your own bundler and server abstractions with Data Mode.

[](#client-rendering)Client Rendering
-------------------------------------

### [](#1-create-a-router)1\. Create a Router

The browser runtime API that enables route module APIs (loaders, actions, etc.) is `createBrowserRouter`.

It takes an array of route objects that support loaders, actions, error boundaries and more. The React Router Vite plugin creates one of these from `routes.ts`, but you can create one manually (or with an abstraction) and use your own bundler.

    import { createBrowserRouter } from "react-router";
    
    let router = createBrowserRouter([
      {
        path: "/",
        Component: Root,
        children: [
          {
            path: "shows/:showId",
            Component: Show,
            loader: ({ request, params }) =>
              fetch(`/api/show/${params.id}.json`, {
                signal: request.signal,
              }),
          },
        ],
      },
    ]);
    

### [](#2-render-the-router)2\. Render the Router

To render the router in the browser, use `<RouterProvider>`.

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    import { createRoot } from "react-dom/client";
    
    createRoot(document.getElementById("root")).render(
      <RouterProvider router={router} />
    );
    

### [](#3-lazy-loading)3\. Lazy Loading

Routes can take most of their definition lazily with the `lazy` property.

    createBrowserRouter([
      {
        path: "/show/:showId",
        lazy: {
          loader: async () =>
            (await import("./show.loader.js")).loader,
          action: async () =>
            (await import("./show.action.js")).action,
          Component: async () =>
            (await import("./show.component.js")).Component,
        },
      },
    ]);
    

[](#server-rendering)Server Rendering
-------------------------------------

To server render a custom setup, there are a few server APIs available for rendering and data loading.

This guide simply gives you some ideas about how it works. For deeper understanding, please see the [Custom Framework Example Repo](https://github.com/remix-run/custom-react-router-framework-example)

### [](#1-define-your-routes)1\. Define Your Routes

Routes are the same kinds of objects on the server as the client.

    export default [
      {
        path: "/",
        Component: Root,
        children: [
          {
            path: "shows/:showId",
            Component: Show,
            loader: ({ params }) => {
              return db.loadShow(params.id);
            },
          },
        ],
      },
    ];
    

### [](#2-create-a-static-handler)2\. Create a static handler

Turn your routes into a request handler with `createStaticHandler`:

    import { createStaticHandler } from "react-router";
    import routes from "./some-routes";
    
    let { query, dataRoutes } = createStaticHandler(routes);
    

### [](#3-get-routing-context-and-render)3\. Get Routing Context and Render

React Router works with web fetch [Requests](https://developer.mozilla.org/en-US/docs/Web/API/Request), so if your server doesn't, you'll need to adapt whatever objects it uses to a web fetch `Request` object.

This step assumes your server receives `Request` objects.

    import { renderToString } from "react-dom/server";
    import {
      createStaticHandler,
      createStaticRouter,
      StaticRouterProvider,
    } from "react-router";
    
    import routes from "./some-routes.js";
    
    let { query, dataRoutes } = createStaticHandler(routes);
    
    export async function handler(request: Request) {
      // 1. run actions/loaders to get the routing context with `query`
      let context = await query(request);
    
      // If `query` returns a Response, send it raw (a route probably a redirected)
      if (context instanceof Response) {
        return context;
      }
    
      // 2. Create a static router for SSR
      let router = createStaticRouter(dataRoutes, context);
    
      // 3. Render everything with StaticRouterProvider
      let html = renderToString(
        <StaticRouterProvider
          router={router}
          context={context}
        />
      );
    
      // Setup headers from action and loaders from deepest match
      let leaf = context.matches[context.matches.length - 1];
      let actionHeaders = context.actionHeaders[leaf.route.id];
      let loaderHeaders = context.loaderHeaders[leaf.route.id];
      let headers = new Headers(actionHeaders);
      if (loaderHeaders) {
        for (let [key, value] of loaderHeaders.entries()) {
          headers.append(key, value);
        }
      }
    
      headers.set("Content-Type", "text/html; charset=utf-8");
    
      // 4. send a response
      return new Response(`<!DOCTYPE html>${html}`, {
        status: context.statusCode,
        headers,
      });
    }
    

### [](#4-hydrate-in-the-browser)4\. Hydrate in the browser

Hydration data is embedded onto `window.__staticRouterHydrationData`, use that to initialize your client side router and render a `<RouterProvider>`.

    import { StrictMode } from "react";
    import { hydrateRoot } from "react-dom/client";
    import { RouterProvider } from "react-router/dom";
    import routes from "./app/routes.js";
    import { createBrowserRouter } from "react-router";
    
    let router = createBrowserRouter(routes, {
      hydrationData: window.__staticRouterHydrationData,
    });
    
    hydrateRoot(
      document,
      <StrictMode>
        <RouterProvider router={router} />
      </StrictMode>
    );
    

[](#testing)Testing
===================

You can use `createRoutesStub` in data and framework modes. Please refer to the [Testing Guide](../framework/testing).

[](#installation)Installation
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#introduction)Introduction
-----------------------------

You can start with a React template from Vite and choose "React", otherwise bootstrap your application however you prefer.

    npx create-vite@latest
    

Next install React Router from npm:

    npm i react-router
    

Finally, render a `<BrowserRouter>` around your application:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { BrowserRouter } from "react-router";
    import App from "./app";
    
    const root = document.getElementById("root");
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    

* * *

Next: [Routing](./routing)

[](#routing)Routing
===================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#configuring-routes)Configuring Routes
-----------------------------------------

Routes are configured by rendering `<Routes>` and `<Route>` that couple URL segments to UI elements.

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { BrowserRouter, Routes, Route } from "react-router";
    import App from "./app";
    
    const root = document.getElementById("root");
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<App />} />
        </Routes>
      </BrowserRouter>
    );
    

Here's a larger sample config:

    <Routes>
      <Route index element={<Home />} />
      <Route path="about" element={<About />} />
    
      <Route element={<AuthLayout />}>
        <Route path="login" element={<Login />} />
        <Route path="register" element={<Register />} />
      </Route>
    
      <Route path="concerts">
        <Route index element={<ConcertsHome />} />
        <Route path=":city" element={<City />} />
        <Route path="trending" element={<Trending />} />
      </Route>
    </Routes>
    

[](#nested-routes)Nested Routes
-------------------------------

Routes can be nested inside parent routes.

    <Routes>
      <Route path="dashboard" element={<Dashboard />}>
        <Route index element={<Home />} />
        <Route path="settings" element={<Settings />} />
      </Route>
    </Routes>
    

The path of the parent is automatically included in the child, so this config creates both `"/dashboard"` and `"/dashboard/settings"` URLs.

Child routes are rendered through the `<Outlet/>` in the parent route.

    import { Outlet } from "react-router";
    
    export default function Dashboard() {
      return (
        <div>
          <h1>Dashboard</h1>
          {/* will either be <Home/> or <Settings/> */}
          <Outlet />
        </div>
      );
    }
    

[](#layout-routes)Layout Routes
-------------------------------

Routes _without_ a `path` create new nesting for their children, but they don't add any segments to the URL.

    <Routes>
      <Route element={<MarketingLayout />}>
        <Route index element={<MarketingHome />} />
        <Route path="contact" element={<Contact />} />
      </Route>
    
      <Route path="projects">
        <Route index element={<ProjectsHome />} />
        <Route element={<ProjectsLayout />}>
          <Route path=":pid" element={<Project />} />
          <Route path=":pid/edit" element={<EditProject />} />
        </Route>
      </Route>
    </Routes>
    

[](#index-routes)Index Routes
-----------------------------

Index routes render into their parent's `<Outlet/>` at their parent's URL (like a default child route). They are configured with the `index` prop:

    <Routes>
      <Route path="/" element={<Root />}>
        {/* renders into the outlet in <Root> at "/" */}
        <Route index element={<Home />} />
    
        <Route path="dashboard" element={<Dashboard />}>
          {/* renders into the outlet in <Dashboard> at "/dashboard" */}
          <Route index element={<DashboardHome />} />
          <Route path="settings" element={<Settings />} />
        </Route>
      </Route>
    </Routes>
    

Note that index routes can't have children. If you're expecting that behavior, you probably want a [layout route](#layout-routes).

[](#route-prefixes)Route Prefixes
---------------------------------

A `<Route path>` _without_ an `element` prop adds a path prefix to its child routes, without introducing a parent layout.

    <Route path="projects">
      <Route index element={<ProjectsHome />} />
      <Route element={<ProjectsLayout />}>
        <Route path=":pid" element={<Project />} />
        <Route path=":pid/edit" element={<EditProject />} />
      </Route>
    </Route>
    

[](#dynamic-segments)Dynamic Segments
-------------------------------------

If a path segment starts with `:` then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as `params` to other router APIs like `useParams`.

    <Route path="teams/:teamId" element={<Team />} />
    

    import { useParams } from "react-router";
    
    export default function Team() {
      let params = useParams();
      // params.teamId
    }
    

You can have multiple dynamic segments in one route path:

    <Route
      path="/c/:categoryId/p/:productId"
      element={<Product />}
    />
    

    import { useParams } from "react-router";
    
    export default function CategoryProduct() {
      let { categoryId, productId } = useParams();
      // ...
    }
    

You should ensure that all dynamic segments in a given path are unique. Otherwise, as the `params` object is populated - latter dynamic segment values will override earlier values.

[](#optional-segments)Optional Segments
---------------------------------------

You can make a route segment optional by adding a `?` to the end of the segment.

    <Route path=":lang?/categories" element={<Categories />} />
    

You can have optional static segments, too:

    <Route path="users/:userId/edit?" element={<User />} />
    

[](#splats)Splats
-----------------

Also known as "catchall" and "star" segments. If a route path pattern ends with `/*` then it will match any characters following the `/`, including other `/` characters.

    <Route path="files/*" element={<File />} />
    

    let params = useParams();
    // params["*"] will contain the remaining URL after files/
    let filePath = params["*"];
    

You can destructure the `*`, you just have to assign it a new name. A common name is `splat`:

    let { "*": splat } = useParams();
    

[](#linking)Linking
-------------------

Link to routes from your UI with `Link` and `NavLink`

    import { NavLink, Link } from "react-router";
    
    function Header() {
      return (
        <nav>
          {/* NavLink makes it easy to show active states */}
          <NavLink
            to="/"
            className={({ isActive }) =>
              isActive ? "active" : ""
            }
          >
            Home
          </NavLink>
    
          <Link to="/concerts/salt-lake-city">Concerts</Link>
        </nav>
      );
    }
    

* * *

Next: [Navigating](./navigating)

[](#navigating)Navigating
=========================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#introduction)Introduction
-----------------------------

Users navigate your application with `<Link>`, `<NavLink>`, and `useNavigate`.

[](#navlink)NavLink
-------------------

This component is for navigation links that need to render an active state.

    import { NavLink } from "react-router";
    
    export function MyAppNav() {
      return (
        <nav>
          <NavLink to="/" end>
            Home
          </NavLink>
          <NavLink to="/trending" end>
            Trending Concerts
          </NavLink>
          <NavLink to="/concerts">All Concerts</NavLink>
          <NavLink to="/account">Account</NavLink>
        </nav>
      );
    }
    

Whenever a `NavLink` is active, it will automatically have an `.active` class name for easy styling with CSS:

    a.active {
      color: red;
    }
    

It also has callback props on `className`, `style`, and `children` with the active state for inline styling or conditional rendering:

    // className
    <NavLink
      to="/messages"
      className={({ isActive }) =>
        isActive ? "text-red-500" : "text-black"
      }
    >
      Messages
    </NavLink>
    

    // style
    <NavLink
      to="/messages"
      style={({ isActive }) => ({
        color: isActive ? "red" : "black",
      })}
    >
      Messages
    </NavLink>
    

    // children
    <NavLink to="/message">
      {({ isActive }) => (
        <span className={isActive ? "active" : ""}>
          {isActive ? "👉" : ""} Tasks
        </span>
      )}
    </NavLink>
    

[](#link)Link
-------------

Use `<Link>` when the link doesn't need active styling:

    import { Link } from "react-router";
    
    export function LoggedOutMessage() {
      return (
        <p>
          You've been logged out.{" "}
          <Link to="/login">Login again</Link>
        </p>
      );
    }
    

[](#usenavigate)useNavigate
---------------------------

This hook allows the programmer to navigate the user to a new page without the user interacting.

For normal navigation, it's best to use `Link` or `NavLink`. They provide a better default user experience like keyboard events, accessibility labeling, "open in new window", right click context menus, etc.

Reserve usage of `useNavigate` to situations where the user is _not_ interacting but you need to navigate, for example:

*   After a form submission completes
*   Logging them out after inactivity
*   Timed UIs like quizzes, etc.

    import { useNavigate } from "react-router";
    
    export function LoginPage() {
      let navigate = useNavigate();
    
      return (
        <>
          <MyHeader />
          <MyLoginForm
            onSuccess={() => {
              navigate("/dashboard");
            }}
          />
          <MyFooter />
        </>
      );
    }
    

* * *

Next: [Url values](./url-values)

[](#url-values)URL Values
=========================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#route-params)Route Params
-----------------------------

Route params are the parsed values from a dynamic segment.

    <Route path="/concerts/:city" element={<City />} />
    

In this case, `:city` is the dynamic segment. The parsed value for that city will be available from `useParams`

    import { useParams } from "react-router";
    
    function City() {
      let { city } = useParams();
      let data = useFakeDataLibrary(`/api/v2/cities/${city}`);
      // ...
    }
    

[](#url-search-params)URL Search Params
---------------------------------------

Search params are the values after a `?` in the URL. They are accessible from `useSearchParams`, which returns an instance of [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)

    function SearchResults() {
      let [searchParams] = useSearchParams();
      return (
        <div>
          <p>
            You searched for <i>{searchParams.get("q")}</i>
          </p>
          <FakeSearchResults />
        </div>
      );
    }
    

[](#location-object)Location Object
-----------------------------------

React Router creates a custom `location` object with some useful information on it accessible with `useLocation`.

    function useAnalytics() {
      let location = useLocation();
      useEffect(() => {
        sendFakeAnalytics(location.pathname);
      }, [location]);
    }
    
    function useScrollRestoration() {
      let location = useLocation();
      useEffect(() => {
        fakeRestoreScroll(location.key);
      }, [location]);
    }
    

[](#upgrading-from-v6)Upgrading from v6
=======================================

React Router v7 requires the following minimum versions:

*   `node@20`
*   `react@18`
*   `react-dom@18`

The v7 upgrade has no breaking changes if you have enabled all future flags. These flags allow you to update your app one change at a time. We highly recommend you make a commit after each step and ship it instead of doing everything all at once.

[](#update-to-latest-v6x)Update to latest v6.x
----------------------------------------------

First update to the latest minor version of v6.x to have the latest future flags and console warnings.

👉 **Update to latest v6**

    npm install react-router-dom@6
    

### [](#v7_relativesplatpath)v7\_relativeSplatPath

**Background**

Changes the relative path matching and linking for multi-segment splats paths like `dashboard/*` (vs. just `*`). [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#futurev7_relativesplatpath) for more information.

👉 **Enable the flag**

Enabling the flag depends on the type of router:

    <BrowserRouter
      future={{
        v7_relativeSplatPath: true,
      }}
    />
    

    createBrowserRouter(routes, {
      future: {
        v7_relativeSplatPath: true,
      },
    });
    

**Update your Code**

If you have any routes with a path + a splat like `<Route path="dashboard/*">` that have relative links like `<Link to="relative">` or `<Link to="../relative">` beneath them, you will need to update your code.

👉 **Split the `<Route>` into two**

Split any multi-segment splat `<Route>` into a parent route with the path and a child route with the splat:

    <Routes>
      <Route path="/" element={<Home />} />
    -  <Route path="dashboard/*" element={<Dashboard />} />
    +  <Route path="dashboard">
    +    <Route path="*" element={<Dashboard />} />
    +  </Route>
    </Routes>
    
    // or
    createBrowserRouter([
      { path: "/", element: <Home /> },
      {
    -    path: "dashboard/*",
    -    element: <Dashboard />,
    +    path: "dashboard",
    +    children: [{ path: "*", element: <Dashboard /> }],
      },
    ]);
    

👉 **Update relative links**

Update any `<Link>` elements within that route tree to include the extra `..` relative segment to continue linking to the same place:

    function Dashboard() {
      return (
        <div>
          <h2>Dashboard</h2>
          <nav>
    -        <Link to="/">Dashboard Home</Link>
    -        <Link to="team">Team</Link>
    -        <Link to="projects">Projects</Link>
    +        <Link to="../">Dashboard Home</Link>
    +        <Link to="../team">Team</Link>
    +        <Link to="../projects">Projects</Link>
          </nav>
    
          <Routes>
            <Route path="/" element={<DashboardHome />} />
            <Route path="team" element={<DashboardTeam />} />
            <Route
              path="projects"
              element={<DashboardProjects />}
            />
          </Routes>
        </div>
      );
    }
    

### [](#v7_starttransition)v7\_startTransition

**Background**

This uses `React.useTransition` instead of `React.useState` for Router state updates. View the [CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#futurev7_starttransition) for more information.

👉 **Enable the flag**

    <BrowserRouter
      future={{
        v7_startTransition: true,
      }}
    />
    
    // or
    <RouterProvider
      future={{
        v7_startTransition: true,
      }}
    />
    

👉 **Update your Code**

You don't need to update anything unless you are using `React.lazy` _inside_ of a component.

Using `React.lazy` inside of a component is incompatible with `React.useTransition` (or other code that makes promises inside of components). Move `React.lazy` to the module scope and stop making promises inside of components. This is not a limitation of React Router but rather incorrect usage of React.

### [](#v7_fetcherpersist)v7\_fetcherPersist

If you are not using a `<RouterProvider>` you can skip this

**Background**

The fetcher lifecycle is now based on when it returns to an idle state rather than when its owner component unmounts: [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#persistence-future-flag-futurev7_fetcherpersist) for more information.

**Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_fetcherPersist: true,
      },
    });
    

**Update your Code**

It's unlikely to affect your app. You may want to check any usage of `useFetchers` as they may persist longer than they did before. Depending on what you're doing, you may render something longer than before.

### [](#v7_normalizeformmethod)v7\_normalizeFormMethod

If you are not using a `<RouterProvider>` you can skip this

This normalizes `formMethod` fields as uppercase HTTP methods to align with the `fetch()` behavior. [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#futurev7_normalizeformmethod) for more information.

👉 **Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_normalizeFormMethod: true,
      },
    });
    

**Update your Code**

If any of your code is checking for lowercase HTTP methods, you will need to update it to check for uppercase HTTP methods (or call `toLowerCase()` on it).

👉 **Compare `formMethod` to UPPERCASE**

    -useNavigation().formMethod === "post"
    -useFetcher().formMethod === "get";
    +useNavigation().formMethod === "POST"
    +useFetcher().formMethod === "GET";
    

### [](#v7_partialhydration)v7\_partialHydration

If you are not using a `<RouterProvider>` you can skip this

This enables partial hydration of a data router which is primarily used for SSR frameworks, but it is also useful if you are using `lazy` to load your route modules. It's unlikely you need to worry about this, just turn the flag on. [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#partial-hydration) for more information.

👉 **Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_partialHydration: true,
      },
    });
    

**Update your Code**

With partial hydration, you need to provide a `HydrateFallback` component to render during initial hydration. Additionally, if you were using `fallbackElement` before, you need to remove it as it is now deprecated. In most cases, you will want to reuse the `fallbackElement` as the `HydrateFallback`.

👉 **Replace `fallbackElement` with `HydrateFallback`**

    const router = createBrowserRouter(
      [
        {
          path: "/",
          Component: Layout,
    +      HydrateFallback: Fallback,
          // or
    +      hydrateFallbackElement: <Fallback />,
          children: [],
        },
      ],
    );
    
    
    <RouterProvider
      router={router}
    -  fallbackElement={<Fallback />}
    />
    

### [](#v7_skipactionerrorrevalidation)v7\_skipActionErrorRevalidation

If you are not using a `createBrowserRouter` you can skip this

When this flag is enabled, loaders will no longer revalidate by default after an action throws/returns a `Response` with a `4xx`/`5xx` status code. You may opt-into revalidation in these scenarios via `shouldRevalidate` and the `actionStatus` parameter.

👉 **Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_skipActionErrorRevalidation: true,
      },
    });
    

**Update your Code**

In most cases, you probably won't have to make changes to your app code. Usually, if an action errors, it's unlikely data was mutated and needs revalidation. If any of your code _does_ mutate data in action error scenarios you have 2 options:

👉 **Option 1: Change the `action` to avoid mutations in error scenarios**

    // Before
    async function action() {
      await mutateSomeData();
      if (detectError()) {
        throw new Response(error, { status: 400 });
      }
      await mutateOtherData();
      // ...
    }
    
    // After
    async function action() {
      if (detectError()) {
        throw new Response(error, { status: 400 });
      }
      // All data is now mutated after validations
      await mutateSomeData();
      await mutateOtherData();
      // ...
    }
    

👉 **Option 2: Opt-into revalidation via `shouldRevalidate` and `actionStatus`**

    async function action() {
      await mutateSomeData();
      if (detectError()) {
        throw new Response(error, { status: 400 });
      }
      await mutateOtherData();
    }
    
    async function loader() { ... }
    
    function shouldRevalidate({ actionStatus, defaultShouldRevalidate }) {
      if (actionStatus != null && actionStatus >= 400) {
        // Revalidate this loader when actions return a 4xx/5xx status
        return true;
      }
      return defaultShouldRevalidate;
    }
    

[](#deprecations)Deprecations
-----------------------------

The `json` and `defer` methods are deprecated in favor of returning raw objects.

    async function loader() {
    - return json({ data });
    + return { data };
    

If you were using `json` to serialize your data to JSON, you can use the native [Response.json()](https://developer.mozilla.org/en-US/docs/Web/API/Response/json) method instead.

[](#upgrade-to-v7)Upgrade to v7
-------------------------------

Now that your app is caught up, you can simply update to v7 (theoretically!) without issue.

👉 **Install v7**

    npm install react-router-dom@latest
    

👉 **Replace react-router-dom with react-router**

In v7 we no longer need `"react-router-dom"` as the packages have been simplified. You can import everything from `"react-router"`:

    npm uninstall react-router-dom
    npm install react-router@latest
    

Note you only need `"react-router"` in your package.json.

👉 **Update imports**

Now you should update your imports to use `react-router`:

    -import { useLocation } from "react-router-dom";
    +import { useLocation } from "react-router";
    

Instead of manually updating imports, you can use this command. Make sure your git working tree is clean though so you can revert if it doesn't work as expected.

    find ./path/to/src \( -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.jsx" \) -type f -exec sed -i '' 's|from "react-router-dom"|from "react-router"|g' {} +
    

If you have GNU `sed` installed (most Linux distributions), use this command instead:

    find ./path/to/src \( -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.jsx" \) -type f -exec sed -i 's|from "react-router-dom"|from "react-router"|g' {} +
    

👉 **Update DOM-specific imports**

`RouterProvider` and `HydratedRouter` come from a deep import because they depend on `"react-dom"`:

    -import { RouterProvider } from "react-router-dom";
    +import { RouterProvider } from "react-router/dom";
    

Note you should use a top-level import for non-DOM contexts, such as Jest tests:

    -import { RouterProvider } from "react-router-dom";
    +import { RouterProvider } from "react-router";
    

Congratulations, you're now on v7!

[](#upgrading-from-remix)Upgrading from Remix
=============================================

React Router v7 requires the following minimum versions:

*   `node@20`
*   `react@18`
*   `react-dom@18`

React Router v7 is the next major version of Remix after v2 (see our ["Incremental Path to React 19" blog post](https://remix.run/blog/incremental-path-to-react-19) for more information).

If you have enabled all [Remix v2 future flags](https://remix.run/docs/start/future-flags), upgrading from Remix v2 to React Router v7 mainly involves updating dependencies.

The majority of steps 2-8 can be automatically updated using a [codemod](https://codemod.com/registry/remix-2-react-router-upgrade) created by community member [James Restall](https://github.com/jrestall).

[](#1-adopt-future-flags)1\. Adopt future flags
-----------------------------------------------

**👉 Adopt future flags**

Adopt all existing [future flags](https://remix.run/docs/start/future-flags) in your Remix v2 application.

[](#2-update-dependencies)2\. Update dependencies
-------------------------------------------------

Most of the "shared" APIs that used to be re-exported through the runtime-specific packages (`@remix-run/node`, `@remix-run/cloudflare`, etc.) have all been collapsed into `react-router` in v7. So instead of importing from `@react-router/node` or `@react-router/cloudflare`, you'll import those directly from `react-router`.

    -import { redirect } from "@remix-run/node";
    +import { redirect } from "react-router";
    

The only APIs you should be importing from the runtime-specific packages in v7 are APIs that are specific to that runtime, such as `createFileSessionStorage` for Node and `createWorkersKVSessionStorage` for Cloudflare.

**👉 Run the codemod (automated)**

You can automatically update your packages and imports with the following [codemod](https://codemod.com/registry/remix-2-react-router-upgrade). This codemod updates all of your packages and imports. Be sure to commit any pending changes before running the codemod, in case you need to revert.

    npx codemod remix/2/react-router/upgrade
    

**👉 Install the new dependencies**

After the codemod updates your dependencies, you need to install the dependencies to remove Remix packages and add the new React Router packages.

    npm install
    

**👉 Update your dependencies (manual)**

If you prefer not to use the codemod, you can manually update your dependencies.

Expand to see a table of package name changes in alphabetical order

Remix v2 Package

React Router v7 Package

`@remix-run/architect`

➡️

`@react-router/architect`

`@remix-run/cloudflare`

➡️

`@react-router/cloudflare`

`@remix-run/dev`

➡️

`@react-router/dev`

`@remix-run/express`

➡️

`@react-router/express`

`@remix-run/fs-routes`

➡️

`@react-router/fs-routes`

`@remix-run/node`

➡️

`@react-router/node`

`@remix-run/react`

➡️

`react-router`

`@remix-run/route-config`

➡️

`@react-router/dev`

`@remix-run/routes-option-adapter`

➡️

`@react-router/remix-routes-option-adapter`

`@remix-run/serve`

➡️

`@react-router/serve`

`@remix-run/server-runtime`

➡️

`react-router`

`@remix-run/testing`

➡️

`react-router`

[](#3-change-scripts-in-packagejson)3\. Change `scripts` in `package.json`
--------------------------------------------------------------------------

If you used the codemod you can skip this step as it was automatically completed.

**👉 Update the scripts in your `package.json`**

Script

Remix v2

React Router v7

`dev`

`remix vite:dev`

➡️

`react-router dev`

`build`

`remix vite:build`

➡️

`react-router build`

`start`

`remix-serve build/server/index.js`

➡️

`react-router-serve build/server/index.js`

`typecheck`

`tsc`

➡️

`react-router typegen && tsc`

[](#4-add-a-routests-file)4\. Add a `routes.ts` file
----------------------------------------------------

If you used the codemod _and_ Remix v2 `v3_routeConfig` flag, you can skip this step as it was automatically completed.

In React Router v7 you define your routes using the `app/routes.ts` file. View the [routing documentation](../start/framework/routing) for more information.

**👉 Update dependencies (if using Remix v2 `v3_routeConfig` flag)**

    // app/routes.ts
    -import { type RouteConfig } from "@remix-run/route-config";
    -import { flatRoutes } from "@remix-run/fs-routes";
    -import { remixRoutesOptionAdapter } from "@remix-run/routes-option-adapter";
    +import { type RouteConfig } from "@react-router/dev/routes";
    +import { flatRoutes } from "@react-router/fs-routes";
    +import { remixRoutesOptionAdapter } from "@react-router/remix-routes-option-adapter";
    
    export default [
      // however your routes are defined
    ] satisfies RouteConfig;
    
    

**👉 Add a `routes.ts` file (if _not_ using Remix v2 `v3_routeConfig` flag)**

    touch app/routes.ts
    

For backwards-compatibility and for folks who prefer [file-based conventions](../how-to/file-route-conventions), you can opt-into the same "flat routes" convention you are using in Remix v2 via the new `@react-router/fs-routes` package:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default flatRoutes() satisfies RouteConfig;
    

Or, if you were using the `routes` option to define config-based routes:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { remixRoutesOptionAdapter } from "@react-router/remix-routes-option-adapter";
    
    export default remixRoutesOptionAdapter((defineRoutes) => {
      return defineRoutes((route) => {
        route("/", "home/route.tsx", { index: true });
        route("about", "about/route.tsx");
        route("", "concerts/layout.tsx", () => {
          route("trending", "concerts/trending.tsx");
          route(":city", "concerts/city.tsx");
        });
      });
    }) satisfies RouteConfig;
    

If you were using the `routes` option in your `vite.config.ts`, be sure to remove it.

    export default defineConfig({
      plugins: [
        remix({
          ssr: true,
    -     ignoredRouteFiles: ['**/*'],
    -     routes(defineRoutes) {
    -       return defineRoutes((route) => {
    -         route("/somewhere/cool/*", "catchall.tsx");
    -       });
    -     },
        })
        tsconfigPaths(),
      ],
    });
    

[](#5-add-a-react-router-config)5\. Add a React Router config
-------------------------------------------------------------

**👉 Add `react-router.config.ts` your project**

The config that was previously passed to the `remix` plugin in `vite.config.ts` is now exported from `react-router.config.ts`.

Note: At this point you should remove the v3 future flags you added in step 1.

    touch react-router.config.ts
    

    // vite.config.ts
    export default defineConfig({
      plugins: [
    -   remix({
    -     ssr: true,
    -     future: {/* all the v3 flags */}
    -   }),
    +   reactRouter(),
        tsconfigPaths(),
      ],
    });
    
    // react-router.config.ts
    +import type { Config } from "@react-router/dev/config";
    +export default {
    +  ssr: true,
    +} satisfies Config;
    

[](#6-add-react-router-plugin-to-viteconfig)6\. Add React Router plugin to `vite.config`
----------------------------------------------------------------------------------------

If you used the codemod you can skip this step as it was automatically completed.

**👉 Add `reactRouter` plugin to `vite.config`**

Change `vite.config.ts` to import and use the new `reactRouter` plugin from `@react-router/dev/vite`:

    -import { vitePlugin as remix } from "@remix-run/dev";
    +import { reactRouter } from "@react-router/dev/vite";
    import { defineConfig } from "vite";
    import tsconfigPaths from "vite-tsconfig-paths";
    
    export default defineConfig({
      plugins: [
    -   remix(),
    +   reactRouter(),
        tsconfigPaths(),
      ],
    });
    

[](#7-enable-type-safety)7\. Enable type safety
-----------------------------------------------

If you are not using TypeScript, you can skip this step.

React Router automatically generates types for your route modules into a `.react-router/` directory at the root of your app. This directory is fully managed by React Router and should be gitignore'd. Learn more about the [new type safety features](../explanation/type-safety).

**👉 Add `.react-router/` to `.gitignore`**

    .react-router/
    

**👉 Update `tsconfig.json`**

Update the `types` field in your `tsconfig.json` to include:

*   `.react-router/types/**/*` path in the `include` field
*   The appropriate `@react-router/*` package in the `types` field
*   `rootDirs` for simplified relative imports

    {
      "include": [
        /* ... */
    +   ".react-router/types/**/*"
      ],
      "compilerOptions": {
    -   "types": ["@remix-run/node", "vite/client"],
    +   "types": ["@react-router/node", "vite/client"],
        /* ... */
    +   "rootDirs": [".", "./.react-router/types"]
      }
    }
    

[](#8-rename-components-in-entry-files)8\. Rename components in entry files
---------------------------------------------------------------------------

If you used the codemod you can skip this step as it was automatically completed.

If you have an `entry.server.tsx` and/or an `entry.client.tsx` file in your application, you will need to update the main components in these files:

    -import { RemixServer } from "@remix-run/react";
    +import { ServerRouter } from "react-router";
    
    -<RemixServer context={remixContext} url={request.url} />,
    +<ServerRouter context={remixContext} url={request.url} />,
    

    -import { RemixBrowser } from "@remix-run/react";
    +import { HydratedRouter } from "react-router/dom";
    
    hydrateRoot(
      document,
      <StrictMode>
    -   <RemixBrowser />
    +   <HydratedRouter />
      </StrictMode>,
    );
    

[](#9-update-types-for-apploadcontext)9\. Update types for `AppLoadContext`
---------------------------------------------------------------------------

If you were using `remix-serve` you can skip this step. This is only applicable if you were using a custom server in Remix v2.

Since React Router can be used as both a React framework _and_ a stand-alone routing library, the `context` argument for `LoaderFunctionArgs` and `ActionFunctionArgs` is now optional and typed as `any` by default. You can register types for your load context to get type safety for your loaders and actions.

👉 **Register types for your load context**

Before you migrate to the new `Route.LoaderArgs` and `Route.ActionArgs` types, you can temporarily augment `LoaderFunctionArgs` and `ActionFunctionArgs` with your load context type to ease migration.

    declare module "react-router" {
      // Your AppLoadContext used in v2
      interface AppLoadContext {
        whatever: string;
      }
    
      // TODO: remove this once we've migrated to `Route.LoaderArgs` instead for our loaders
      interface LoaderFunctionArgs {
        context: AppLoadContext;
      }
    
      // TODO: remove this once we've migrated to `Route.ActionArgs` instead for our actions
      interface ActionFunctionArgs {
        context: AppLoadContext;
      }
    }
    
    export {}; // necessary for TS to treat this as a module
    

Using `declare module` to register types is a standard TypeScript technique called [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation). You can do this in any TypeScript file covered by your `tsconfig.json`'s `include` field, but we recommend a dedicated `env.ts` within your app directory.

👉 **Use the new types**

Once you adopt the [new type generation](../explanation/type-safety), you can remove the `LoaderFunctionArgs`/`ActionFunctionArgs` augmentations and use the `context` argument from [`Route.LoaderArgs`](../start/framework/data-loading#server-data-loading) and [`Route.ActionArgs`](../start/framework/actions#server-actions) instead.

    declare module "react-router" {
      // Your AppLoadContext used in v2
      interface AppLoadContext {
        whatever: string;
      }
    }
    
    export {}; // necessary for TS to treat this as a module
    

    import type { Route } from "./+types/my-route";
    
    export function loader({ context }: Route.LoaderArgs) {}
    // { whatever: string }  ^^^^^^^
    
    export function action({ context }: Route.ActionArgs) {}
    // { whatever: string }  ^^^^^^^
    

Congratulations! You are now on React Router v7. Go ahead and run your application to make sure everything is working as expected.

[](#framework-adoption-from-component-routes)Framework Adoption from Component Routes
=====================================================================================

If you are using `<RouterProvider>` please see [Framework Adoption from RouterProvider](./router-provider) instead.

If you are using `<Routes>` this is the right place.

The React Router Vite plugin adds framework features to React Router. This guide will help you adopt the plugin in your app. If you run into any issues, please reach out for help on [Twitter](https://x.com/remix_run) or [Discord](https://rmx.as/discord).

[](#features)Features
---------------------

The Vite plugin adds:

*   Route loaders, actions, and automatic data revalidation
*   Typesafe Routes Modules
*   Automatic route code-splitting
*   Automatic scroll restoration across navigations
*   Optional Static pre-rendering
*   Optional Server rendering

The initial setup requires the most work. However, once complete, you can adopt new features incrementally, one route at a time.

[](#prerequisites)Prerequisites
-------------------------------

To use the Vite plugin, your project requires:

*   Node.js 20+ (if using Node as your runtime)
*   Vite 5+

[](#1-install-the-vite-plugin)1\. Install the Vite plugin
---------------------------------------------------------

**👉 Install the React Router Vite plugin**

    npm install -D @react-router/dev
    

**👉 Install a runtime adapter**

We will assume you are using Node as your runtime.

    npm install @react-router/node
    

**👉 Swap out the React plugin for React Router.**

    -import react from '@vitejs/plugin-react'
    +import { reactRouter } from "@react-router/dev/vite";
    import { defineConfig } from "vite";
    
    
    export default defineConfig({
      plugins: [
    -    react()
    +    reactRouter()
      ],
    });
    

[](#2-add-the-react-router-config)2\. Add the React Router config
-----------------------------------------------------------------

**👉 Create a `react-router.config.ts` file**

Add the following to the root of your project. In this config you can tell React Router about your project, like where to find the app directory and to not use SSR (server-side rendering) for now.

    touch react-router.config.ts
    

    import type { Config } from "@react-router/dev/config";
    
    export default {
      appDirectory: "src",
      ssr: false,
    } satisfies Config;
    

[](#3-add-the-root-entry-point)3\. Add the Root entry point
-----------------------------------------------------------

In a typical Vite app, the `index.html` file is the entry point for bundling. The React Router Vite plugin moves the entry point to a `root.tsx` file so you can use React to render the shell of your app instead of static HTML, and eventually upgrade to Server Rendering if you want.

**👉 Move your existing `index.html` to `root.tsx`**

For example, if your current `index.html` looks like this:

    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1.0"
        />
        <title>My App</title>
      </head>
      <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
      </body>
    </html>
    

You would move that markup into `src/root.tsx` and delete `index.html`:

    touch src/root.tsx
    

    import {
      Links,
      Meta,
      Outlet,
      Scripts,
      ScrollRestoration,
    } from "react-router";
    
    export function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <head>
            <meta charSet="UTF-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1.0"
            />
            <title>My App</title>
            <Meta />
            <Links />
          </head>
          <body>
            {children}
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    
    export default function Root() {
      return <Outlet />;
    }
    

[](#4-add-client-entry-module)4\. Add client entry module
---------------------------------------------------------

In the typical Vite app the `index.html` file points to `src/main.tsx` as the client entry point. React Router uses a file named `src/entry.client.tsx` instead.

**👉 Make `src/entry.client.tsx` your entry point**

If your current `src/main.tsx` looks like this:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { BrowserRouter } from "react-router";
    import "./index.css";
    import App from "./App";
    
    ReactDOM.createRoot(
      document.getElementById("root")!
    ).render(
      <React.StrictMode>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </React.StrictMode>
    );
    

You would rename it to `entry.client.tsx` and change it to this:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { HydratedRouter } from "react-router/dom";
    import "./index.css";
    
    ReactDOM.hydrateRoot(
      document,
      <React.StrictMode>
        <HydratedRouter />
      </React.StrictMode>
    );
    

*   Use `hydrateRoot` instead of `createRoot`
*   Render a `<HydratedRouter>` instead of your `<App/>` component
*   Note: we stopped rendering the `<App/>` component. We'll bring it back in a later step, but first we want to get the app to boot with the new entry point.

[](#5-shuffle-stuff-around)5\. Shuffle stuff around
---------------------------------------------------

Between `root.tsx` and `entry.client.tsx`, you may want to shuffle some stuff around between them.

In general:

*   `root.tsx` contains any rendering things like context providers, layouts, styles, etc.
*   `entry.client.tsx` should be as minimal as possible
*   Remember to _not_ try to render your existing `<App/>` component yet, we'll do that in a later step

Note that your `root.tsx` file will be statically generated and served as the entry point of your app, so just that module will need to be compatible with server rendering. This is where most of your trouble will come.

[](#6-set-up-your-routes)6\. Set up your routes
-----------------------------------------------

The React Router Vite plugin uses a `routes.ts` file to configure your routes. For now we'll add a simple catchall route to get things going.

**👉 Set up a `catchall.tsx` route**

    touch src/routes.ts src/catchall.tsx
    

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      // * matches all URLs, the ? makes it optional so it will match / as well
      route("*?", "catchall.tsx"),
    ] satisfies RouteConfig;
    

**👉 Render a placeholder route**

Eventually we'll replace this with our original `App` component, but for now we'll just render something simple to make sure we can boot the app.

    export default function Component() {
      return <div>Hello, world!</div>;
    }
    

[View our guide on configuring routes](../start/framework/routing) to learn more about the `routes.ts` file.

[](#7-boot-the-app)7\. Boot the app
-----------------------------------

At this point you should be able to to boot the app and see the root layout.

**👉 Add `dev` script and run the app**

    "scripts": {
      "dev": "react-router dev"
    }
    

Now make sure you can boot your app at this point before moving on:

    npm run dev
    

You will probably want to add `.react-router/` to your `.gitignore` file to avoid tracking unnecessary files in your repository.

    .react-router/
    

You can check out [Type Safety](../how-to/route-module-type-safety) to learn how to fully set up and use autogenerated type safety for params, loader data, and more.

[](#8-render-your-app)8\. Render your app
-----------------------------------------

To get back to rendering your app, we'll update the "catchall" route we set up earlier that matches all URLs so that your existing `<Routes>` get a chance to render.

**👉 Update the catchall route to render your app**

    import App from "./App";
    
    export default function Component() {
      return <App />;
    }
    

Your app should be back on the screen and working as usual!

[](#9-migrate-a-route-to-a-route-module)9\. Migrate a route to a Route Module
-----------------------------------------------------------------------------

You can now incrementally migrate your routes to route modules.

Given an existing route like this:

    // ...
    import About from "./containers/About";
    
    export default function App() {
      return (
        <Routes>
          <Route path="/about" element={<About />} />
        </Routes>
      );
    }
    

**👉 Add the route definition to `routes.ts`**

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("/about", "./pages/about.tsx"),
      route("*?", "catchall.tsx"),
    ] satisfies RouteConfig;
    

**👉 Add the route module**

Edit the route module to use the [Route Module API](../start/framework/route-module):

    export async function clientLoader() {
      // you can now fetch data here
      return {
        title: "About page",
      };
    }
    
    export default function Component({ loaderData }) {
      return <h1>{loaderData.title}</h1>;
    }
    

See [Type Safety](../how-to/route-module-type-safety) to set up autogenerated type safety for params, loader data, and more.

The first few routes you migrate are the hardest because you often have to access various abstractions a bit differently than before (like in a loader instead of from a hook or context). But once the trickiest bits get dealt with, you get into an incremental groove.

[](#enable-ssr-andor-pre-rendering)Enable SSR and/or Pre-rendering
------------------------------------------------------------------

If you want to enable server rendering and static pre-rendering, you can do so with the `ssr` and `prerender` options in the bundler plugin. For SSR you'll need to also deploy the server build to a server.

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: true,
      async prerender() {
        return ["/", "/about", "/contact"];
      },
    } satisfies Config;
    

[](#future-flags-and-deprecations)Future Flags and Deprecations
===============================================================

This guide walks you through the process of adopting future flags in your React Router app. By following this strategy, you will be able to upgrade to the next major version of React Router with minimal changes. To read more about future flags see [API Development Strategy](../community/api-development-strategy).

We highly recommend you make a commit after each step and ship it instead of doing everything all at once. Most flags can be adopted in any order, with exceptions noted below.

**There are no current future flags in React Router v7**

[](#framework-adoption-from-routerprovider)Framework Adoption from RouterProvider
=================================================================================

If you are not using `<RouterProvider>` please see [Framework Adoption from Component Routes](./component-routes) instead.

The React Router Vite plugin adds framework features to React Router. This guide will help you adopt the plugin in your app. If you run into any issues, please reach out for help on [Twitter](https://x.com/remix_run) or [Discord](https://rmx.as/discord).

[](#features)Features
---------------------

The Vite plugin adds:

*   Route loaders, actions, and automatic data revalidation
*   Typesafe Routes Modules
*   Automatic route code-splitting
*   Automatic scroll restoration across navigations
*   Optional Static pre-rendering
*   Optional Server rendering

The initial setup requires the most work. However, once complete, you can adopt new features incrementally.

[](#prerequisites)Prerequisites
-------------------------------

To use the Vite plugin, your project requires:

*   Node.js 20+ (if using Node as your runtime)
*   Vite 5+

[](#1-move-route-definitions-into-route-modules)1\. Move route definitions into route modules
---------------------------------------------------------------------------------------------

The React Router Vite plugin renders its own `RouterProvider`, so you can't render an existing `RouterProvider` within it. Instead, you will need to format all of your route definitions to match the [Route Module API](../start/framework/route-module).

This step will take the longest, however there are several benefits to doing this regardless of adopting the React Router Vite plugin:

*   Route modules will be lazy loaded, decreasing the initial bundle size of your app
*   Route definitions will be uniform, simplifying your app's architecture
*   Moving to route modules is incremental, you can migrate one route at a time

**👉 Move your route definitions into route modules**

Export each piece of your route definition as a separate named export, following the [Route Module API](../start/framework/route-module).

    export async function clientLoader() {
      return {
        title: "About",
      };
    }
    
    export default function About() {
      let data = useLoaderData();
      return <div>{data.title}</div>;
    }
    
    // clientAction, ErrorBoundary, etc.
    

**👉 Create a convert function**

Create a helper function to convert route module definitions into the format expected by your data router:

    function convert(m: any) {
      let {
        clientLoader,
        clientAction,
        default: Component,
        ...rest
      } = m;
      return {
        ...rest,
        loader: clientLoader,
        action: clientAction,
        Component,
      };
    }
    

**👉 Lazy load and convert your route modules**

Instead of importing your route modules directly, lazy load and convert them to the format expected by your data router.

Not only does your route definition now conform to the Route Module API, but you also get the benefits of code-splitting your routes.

    let router = createBrowserRouter([
      // ... other routes
      {
        path: "about",
    -   loader: aboutLoader,
    -   Component: About,
    +   lazy: () => import("./routes/about").then(convert),
      },
      // ... other routes
    ]);
    

Repeat this process for each route in your app.

[](#2-install-the-vite-plugin)2\. Install the Vite plugin
---------------------------------------------------------

Once all of your route definitions are converted to route modules, you can adopt the React Router Vite plugin.

**👉 Install the React Router Vite plugin**

    npm install -D @react-router/dev
    

**👉 Install a runtime adapter**

We will assume you are using Node as your runtime.

    npm install @react-router/node
    

**👉 Swap out the React plugin for React Router**

    -import react from '@vitejs/plugin-react'
    +import { reactRouter } from "@react-router/dev/vite";
    import { defineConfig } from "vite";
    
    
    export default defineConfig({
      plugins: [
    -    react()
    +    reactRouter()
      ],
    });
    

[](#3-add-the-react-router-config)3\. Add the React Router config
-----------------------------------------------------------------

**👉 Create a `react-router.config.ts` file**

Add the following to the root of your project. In this config you can tell React Router about your project, like where to find the app directory and to not use SSR (server-side rendering) for now.

    touch react-router.config.ts
    

    import type { Config } from "@react-router/dev/config";
    
    export default {
      appDirectory: "src",
      ssr: false,
    } satisfies Config;
    

[](#4-add-the-root-entry-point)4\. Add the Root entry point
-----------------------------------------------------------

In a typical Vite app, the `index.html` file is the entry point for bundling. The React Router Vite plugin moves the entry point to a `root.tsx` file so you can use React to render the shell of your app instead of static HTML, and eventually upgrade to Server Rendering if you want.

**👉 Move your existing `index.html` to `root.tsx`**

For example, if your current `index.html` looks like this:

    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1.0"
        />
        <title>My App</title>
      </head>
      <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
      </body>
    </html>
    

You would move that markup into `src/root.tsx` and delete `index.html`:

    touch src/root.tsx
    

    import {
      Links,
      Meta,
      Outlet,
      Scripts,
      ScrollRestoration,
    } from "react-router";
    
    export function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <head>
            <meta charSet="UTF-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1.0"
            />
            <title>My App</title>
            <Meta />
            <Links />
          </head>
          <body>
            {children}
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    
    export default function Root() {
      return <Outlet />;
    }
    

**👉 Move everything above `RouterProvider` to `root.tsx`**

Any global styles, context providers, etc. should be moved into `root.tsx` so they can be shared across all routes.

For example, if your `App.tsx` looks like this:

    import "./index.css";
    
    export default function App() {
      return (
        <OtherProviders>
          <AppLayout>
            <RouterProvider router={router} />
          </AppLayout>
        </OtherProviders>
      );
    }
    

You would move everything above the `RouterProvider` into `root.tsx`.

    +import "./index.css";
    
    // ... other imports and Layout
    
    export default function Root() {
      return (
    +   <OtherProviders>
    +     <AppLayout>
            <Outlet />
    +     </AppLayout>
    +   </OtherProviders>
      );
    }
    

[](#5-add-client-entry-module-optional)5\. Add client entry module (optional)
-----------------------------------------------------------------------------

In the typical Vite app the `index.html` file points to `src/main.tsx` as the client entry point. React Router uses a file named `src/entry.client.tsx` instead.

If no `entry.client.tsx` exists, the React Router Vite plugin will use a default, hidden one.

**👉 Make `src/entry.client.tsx` your entry point**

If your current `src/main.tsx` looks like this:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { BrowserRouter } from "react-router";
    import App from "./App";
    
    const router = createBrowserRouter([
      // ... route definitions
    ]);
    
    ReactDOM.createRoot(
      document.getElementById("root")!
    ).render(
      <React.StrictMode>
        <RouterProvider router={router} />;
      </React.StrictMode>
    );
    

You would rename it to `entry.client.tsx` and change it to this:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { HydratedRouter } from "react-router/dom";
    
    ReactDOM.hydrateRoot(
      document,
      <React.StrictMode>
        <HydratedRouter />
      </React.StrictMode>
    );
    

*   Use `hydrateRoot` instead of `createRoot`
*   Render a `<HydratedRouter>` instead of your `<App/>` component
*   Note: We are no longer creating the routes and manually passing them to `<RouterProvider />`. We will migrate our route definitions in the next step.

[](#6-migrate-your-routes)6\. Migrate your routes
-------------------------------------------------

The React Router Vite plugin uses a `routes.ts` file to configure your routes. The format will be pretty similar to the definitions of your data router.

**👉 Move definitions to a `routes.ts` file**

    touch src/routes.ts src/catchall.tsx
    

Move your route definitions to `routes.ts`. Note that the schemas don't match exactly, so you will get type errors; we'll fix this next.

    +import type { RouteConfig } from "@react-router/dev/routes";
    
    -const router = createBrowserRouter([
    +export default [
      {
        path: "/",
        lazy: () => import("./routes/layout").then(convert),
        children: [
          {
            index: true,
            lazy: () => import("./routes/home").then(convert),
          },
          {
            path: "about",
            lazy: () => import("./routes/about").then(convert),
          },
          {
            path: "todos",
            lazy: () => import("./routes/todos").then(convert),
            children: [
              {
                path: ":id",
                lazy: () =>
                  import("./routes/todo").then(convert),
              },
            ],
          },
        ],
      },
    -]);
    +] satisfies RouteConfig;
    

**👉 Replace the `lazy` loader with a `file` loader**

    export default [
      {
        path: "/",
    -   lazy: () => import("./routes/layout").then(convert),
    +   file: "./routes/layout.tsx",
        children: [
          {
            index: true,
    -       lazy: () => import("./routes/home").then(convert),
    +       file: "./routes/home.tsx",
          },
          {
            path: "about",
    -       lazy: () => import("./routes/about").then(convert),
    +       file: "./routes/about.tsx",
          },
          {
            path: "todos",
    -       lazy: () => import("./routes/todos").then(convert),
    +       file: "./routes/todos.tsx",
            children: [
              {
                path: ":id",
    -           lazy: () => import("./routes/todo").then(convert),
    +           file: "./routes/todo.tsx",
              },
            ],
          },
        ],
      },
    ] satisfies RouteConfig;
    

[View our guide on configuring routes](../start/framework/routing) to learn more about the `routes.ts` file and helper functions to further simplify the route definitions.

[](#7-boot-the-app)7\. Boot the app
-----------------------------------

At this point you should be fully migrated to the React Router Vite plugin. Go ahead and update your `dev` script and run the app to make sure everything is working.

**👉 Add `dev` script and run the app**

    "scripts": {
      "dev": "react-router dev"
    }
    

Now make sure you can boot your app at this point before moving on:

    npm run dev
    

You will probably want to add `.react-router/` to your `.gitignore` file to avoid tracking unnecessary files in your repository.

    .react-router/
    

You can checkout [Type Safety](../how-to/route-module-type-safety) to learn how to fully setup and use autogenerated type safety for params, loader data, and more.

[](#enable-ssr-andor-pre-rendering)Enable SSR and/or Pre-rendering
------------------------------------------------------------------

If you want to enable server rendering and static pre-rendering, you can do so with the `ssr` and `prerender` options in the bundler plugin. For SSR you'll need to also deploy the server build to a server.

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: true,
      async prerender() {
        return ["/", "/about", "/contact"];
      },
    } satisfies Config;
    

[](#await)Await
===============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Await.html)

Used to render promise values with automatic error handling.

    import { Await, useLoaderData } from "react-router";
    
    export function loader() {
      // not awaited
      const reviews = getReviews();
      // awaited (blocks the transition)
      const book = await fetch("/api/book").then((res) =>
        res.json()
      );
      return { book, reviews };
    }
    
    function Book() {
      const { book, reviews } = useLoaderData();
      return (
        <div>
          <h1>{book.title}</h1>
          <p>{book.description}</p>
          <React.Suspense fallback={<ReviewsSkeleton />}>
            <Await
              resolve={reviews}
              errorElement={
                <div>Could not load reviews 😬</div>
              }
              children={(resolvedReviews) => (
                <Reviews items={resolvedReviews} />
              )}
            />
          </React.Suspense>
        </div>
      );
    }
    

`<Await>` expects to be rendered inside of a `<React.Suspense>`

[](#props)Props
---------------

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

When using a function, the resolved value is provided as the parameter.

    <Await resolve={reviewsPromise}>
      {(resolvedReviews) => <Reviews items={resolvedReviews} />}
    </Await>
    

When using React elements, [useAsyncValue](../hooks/useAsyncValue) will provide the resolved value:

    <Await resolve={reviewsPromise}>
      <Reviews />
    </Await>;
    
    function Reviews() {
      const resolvedReviews = useAsyncValue();
      return <div>...</div>;
    }
    

### [](#errorelement)errorElement

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The error element renders instead of the children when the promise rejects.

    <Await
      errorElement={<div>Oops</div>}
      resolve={reviewsPromise}
    >
      <Reviews />
    </Await>
    

To provide a more contextual error, you can use the [useAsyncError](../hooks/useAsyncError) in a child component

    <Await
      errorElement={<ReviewsError />}
      resolve={reviewsPromise}
    >
      <Reviews />
    </Await>;
    
    function ReviewsError() {
      const error = useAsyncError();
      return <div>Error loading reviews: {error.message}</div>;
    }
    

If you do not provide an errorElement, the rejected value will bubble up to the nearest route-level ErrorBoundary and be accessible via [useRouteError](../hooks/useRouteError) hook.

### [](#resolve)resolve

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Takes a promise returned from a [LoaderFunction](../Other/LoaderFunction) value to be resolved and rendered.

    import { useLoaderData, Await } from "react-router";
    
    export async function loader() {
      let reviews = getReviews(); // not awaited
      let book = await getBook();
      return {
        book,
        reviews, // this is a promise
      };
    }
    
    export default function Book() {
      const {
        book,
        reviews, // this is the same promise
      } = useLoaderData();
    
      return (
        <div>
          <h1>{book.title}</h1>
          <p>{book.description}</p>
          <React.Suspense fallback={<ReviewsSkeleton />}>
            <Await
              // and is the promise we pass to Await
              resolve={reviews}
            >
              <Reviews />
            </Await>
          </React.Suspense>
        </div>
      );
    }
    

[](#form)Form
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Form.html)

A progressively enhanced HTML [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) that submits data to actions via `fetch`, activating pending states in `useNavigation` which enables advanced user interfaces beyond a basic HTML form. After a form's action completes, all data on the page is automatically revalidated to keep the UI in sync with the data.

Because it uses the HTML form API, server rendered pages are interactive at a basic level before JavaScript loads. Instead of React Router managing the submission, the browser manages the submission as well as the pending states (like the spinning favicon). After JavaScript loads, React Router takes over enabling web application user experiences.

Form is most useful for submissions that should also change the URL or otherwise add an entry to the browser history stack. For forms that shouldn't manipulate the browser history stack, use \[`<fetcher.Form>`\]\[fetcher\_form\].

    import { Form } from "react-router";
    
    function NewEvent() {
      return (
        <Form action="/events" method="post">
          <input name="title" type="text" />
          <input name="description" type="text" />
        </Form>
      );
    }
    

[](#props)Props
---------------

### [](#action)action

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The URL to submit the form data to. If `undefined`, this defaults to the closest route in context.

### [](#discover)discover

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Determines application manifest discovery behavior.

### [](#enctype)encType

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The encoding type to use for the form submission.

### [](#fetcherkey)fetcherKey

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Indicates a specific fetcherKey to use when using `navigate={false}` so you can pick up the fetcher's state in a different component in a [useFetcher](../hooks/useFetcher).

### [](#method)method

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The HTTP verb to use when the form is submitted. Supports "get", "post", "put", "delete", and "patch".

Native `<form>` only supports `get` and `post`, avoid the other verbs if you'd like to support progressive enhancement

### [](#navigate)navigate

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Skips the navigation and uses a [useFetcher](../hooks/useFetcher) internally when `false`. This is essentially a shorthand for `useFetcher()` + `<fetcher.Form>` where you don't care about the resulting data in this component.

### [](#onsubmit)onSubmit

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

A function to call when the form is submitted. If you call `event.preventDefault()` then this form will not do anything.

### [](#preventscrollreset)preventScrollReset

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Prevent the scroll position from resetting to the top of the viewport on completion of the navigation when using the component

### [](#relative)relative

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Determines whether the form action is relative to the route hierarchy or the pathname. Use this if you want to opt out of navigating the route hierarchy and want to instead route based on /-delimited URL segments

### [](#reloaddocument)reloadDocument

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Forces a full document navigation instead of client side routing + data fetch.

### [](#replace)replace

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Replaces the current entry in the browser history stack when the form navigates. Use this if you don't want the user to be able to click "back" to the page with the form on it.

### [](#state)state

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

State object to add to the history stack entry for this navigation

### [](#viewtransition)viewTransition

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Enables a [View Transition](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) for this navigation. To apply specific styles during the transition see [useViewTransitionState](../hooks/useViewTransitionState).

[](#link)Link
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Link.html)

A progressively enhanced `<a href>` wrapper to enable navigation with client-side routing.

    import { Link } from "react-router";
    
    <Link to="/dashboard">Dashboard</Link>;
    
    <Link
      to={{
        pathname: "/some/path",
        search: "?query=string",
        hash: "#hash",
      }}
    />;
    

[](#props)Props
---------------

### [](#discover)discover

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Defines the link discovery behavior

    <Link discover="render" />
    

*   **render** - default, discover the route when the link renders
*   **none** - don't eagerly discover, only discover if the link is clicked

### [](#prefetch)prefetch

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Defines the data and module prefetching behavior for the link.

    <Link prefetch="intent" />
    

*   **none** - default, no prefetching
*   **intent** - prefetches when the user hovers or focuses the link
*   **render** - prefetches when the link renders
*   **viewport** - prefetches when the link is in the viewport, very useful for mobile

Prefetching is done with HTML `<link rel="prefetch">` tags. They are inserted after the link.

    <a href="..." />
    <a href="..." />
    <link rel="prefetch" /> // might conditionally render
    

Because of this, if you are using `nav :last-child` you will need to use `nav :last-of-type` so the styles don't conditionally fall off your last link (and any other similar selectors).

### [](#preventscrollreset)preventScrollReset

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Prevents the scroll position from being reset to the top of the window when the link is clicked and the app is using [ScrollRestoration](../components/ScrollRestoration). This only prevents new locations reseting scroll to the top, scroll position will be restored for back/forward button navigation.

    <Link to="?tab=one" preventScrollReset />
    

### [](#relative)relative

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Defines the relative path behavior for the link.

    <Link to=".." /> // default: "route"
    <Link relative="route" />
    <Link relative="path" />
    

Consider a route hierarchy where a parent route pattern is "blog" and a child route pattern is "blog/:slug/edit".

*   **route** - default, resolves the link relative to the route pattern. In the example above a relative link of `".."` will remove both `:slug/edit` segments back to "/blog".
*   **path** - relative to the path so `..` will only remove one URL segment up to "/blog/:slug"

Note that index routes and layout routes have no paths so they are not included in the relative path calculation.

### [](#reloaddocument)reloadDocument

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Will use document navigation instead of client side routing when the link is clicked: the browser will handle the transition normally (as if it were an `<a href>`).

    <Link to="/logout" reloadDocument />
    

### [](#replace)replace

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Replaces the current entry in the history stack instead of pushing a new one onto it.

    <Link replace />
    

    # with a history stack like this
    A -> B
    
    # normal link click pushes a new entry
    A -> B -> C
    
    # but with `replace`, B is replaced by C
    A -> C
    

### [](#state)state

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Adds persistent client side routing state to the next location.

    <Link to="/somewhere/else" state={{ some: "value" }} />
    

The location state is accessed from the `location`.

    function SomeComp() {
      const location = useLocation();
      location.state; // { some: "value" }
    }
    

This state is inaccessible on the server as it is implemented on top of [`history.state`](https://developer.mozilla.org/en-US/docs/Web/API/History/state)

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Can be a string or a partial [Path](../Other/Path):

    <Link to="/some/path" />
    
    <Link
      to={{
        pathname: "/some/path",
        search: "?query=string",
        hash: "#hash",
      }}
    />
    

### [](#viewtransition)viewTransition

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Enables a [View Transition](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) for this navigation.

    <Link to={to} viewTransition>
      Click me
    </Link>
    

To apply specific styles for the transition, see [useViewTransitionState](../hooks/useViewTransitionState)

[](#links)Links
===============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Links.html)

Renders all of the `<link>` tags created by route module [`links`](../../start/framework/route-module#links) export. You should render it inside the `<head>` of your document.

    import { Links } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head>
            <Links />
          </head>
          <body></body>
        </html>
      );
    }
    

[](#props)Props
---------------

None

[](#meta)Meta
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Meta.html)

Renders all the `<meta>` tags created by route module [`meta`](../../start/framework/route-module#meta) export. You should render it inside the `<head>` of your HTML.

    import { Meta } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head>
            <Meta />
          </head>
        </html>
      );
    }
    

[](#props)Props
---------------

None

[](#navlink)NavLink
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.NavLink.html)

Wraps [Link](../components/Link) with additional props for styling active and pending states.

*   Automatically applies classes to the link based on its active and pending states, see NavLinkProps.className.
*   Automatically applies `aria-current="page"` to the link when the link is active. See [`aria-current`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current) on MDN.

    import { NavLink } from "react-router";
    <NavLink to="/message" />;
    

States are available through the className, style, and children render props. See [NavLinkRenderProps](../Other/NavLinkRenderProps).

    <NavLink
      to="/messages"
      className={({ isActive, isPending }) =>
        isPending ? "pending" : isActive ? "active" : ""
      }
    >
      Messages
    </NavLink>
    

[](#props)Props
---------------

### [](#casesensitive)caseSensitive

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Changes the matching logic to make it case-sensitive:

Link

URL

isActive

`<NavLink to="/SpOnGe-bOB" />`

`/sponge-bob`

true

`<NavLink to="/SpOnGe-bOB" caseSensitive />`

`/sponge-bob`

false

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Can be regular React children or a function that receives an object with the active and pending states of the link.

    <NavLink to="/tasks">
      {({ isActive }) => (
        <span className={isActive ? "active" : ""}>Tasks</span>
      )}
    </NavLink>
    

### [](#classname)className

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Classes are automatically applied to NavLink that correspond to the state.

    a.active {
      color: red;
    }
    a.pending {
      color: blue;
    }
    a.transitioning {
      view-transition-name: my-transition;
    }
    

Note that `pending` is only available with Framework and Data modes.

### [](#discover)discover

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Defines the link discovery behavior

    <Link discover="render" />
    

*   **render** - default, discover the route when the link renders
*   **none** - don't eagerly discover, only discover if the link is clicked

### [](#end)end

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Changes the matching logic for the `active` and `pending` states to only match to the "end" of the NavLinkProps.to. If the URL is longer, it will no longer be considered active.

Link

URL

isActive

`<NavLink to="/tasks" />`

`/tasks`

true

`<NavLink to="/tasks" />`

`/tasks/123`

true

`<NavLink to="/tasks" end />`

`/tasks`

true

`<NavLink to="/tasks" end />`

`/tasks/123`

false

`<NavLink to="/">` is an exceptional case because _every_ URL matches `/`. To avoid this matching every single route by default, it effectively ignores the `end` prop and only matches when you're at the root route.

### [](#prefetch)prefetch

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Defines the data and module prefetching behavior for the link.

    <Link prefetch="intent" />
    

*   **none** - default, no prefetching
*   **intent** - prefetches when the user hovers or focuses the link
*   **render** - prefetches when the link renders
*   **viewport** - prefetches when the link is in the viewport, very useful for mobile

Prefetching is done with HTML `<link rel="prefetch">` tags. They are inserted after the link.

    <a href="..." />
    <a href="..." />
    <link rel="prefetch" /> // might conditionally render
    

Because of this, if you are using `nav :last-child` you will need to use `nav :last-of-type` so the styles don't conditionally fall off your last link (and any other similar selectors).

### [](#preventscrollreset)preventScrollReset

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Prevents the scroll position from being reset to the top of the window when the link is clicked and the app is using [ScrollRestoration](../components/ScrollRestoration). This only prevents new locations reseting scroll to the top, scroll position will be restored for back/forward button navigation.

    <Link to="?tab=one" preventScrollReset />
    

### [](#relative)relative

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Defines the relative path behavior for the link.

    <Link to=".." /> // default: "route"
    <Link relative="route" />
    <Link relative="path" />
    

Consider a route hierarchy where a parent route pattern is "blog" and a child route pattern is "blog/:slug/edit".

*   **route** - default, resolves the link relative to the route pattern. In the example above a relative link of `".."` will remove both `:slug/edit` segments back to "/blog".
*   **path** - relative to the path so `..` will only remove one URL segment up to "/blog/:slug"

### [](#reloaddocument)reloadDocument

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Will use document navigation instead of client side routing when the link is clicked: the browser will handle the transition normally (as if it were an `<a href>`).

    <Link to="/logout" reloadDocument />
    

### [](#replace)replace

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Replaces the current entry in the history stack instead of pushing a new one onto it.

    <Link replace />
    

    # with a history stack like this
    A -> B
    
    # normal link click pushes a new entry
    A -> B -> C
    
    # but with `replace`, B is replaced by C
    A -> C
    

### [](#state)state

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Adds persistent client side routing state to the next location.

    <Link to="/somewhere/else" state={{ some: "value" }} />
    

The location state is accessed from the `location`.

    function SomeComp() {
      const location = useLocation();
      location.state; // { some: "value" }
    }
    

This state is inaccessible on the server as it is implemented on top of [`history.state`](https://developer.mozilla.org/en-US/docs/Web/API/History/state)

### [](#style)style

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Regular React style object or a function that receives an object with the active and pending states of the link.

    <NavLink to="/tasks" style={{ color: "red" }} />
    <NavLink to="/tasks" style={({ isActive, isPending }) => ({
      color:
        isActive ? "red" :
        isPending ? "blue" : "black"
    })} />
    

Note that `pending` is only available with Framework and Data modes.

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Can be a string or a partial [Path](../Other/Path):

    <Link to="/some/path" />
    
    <Link
      to={{
        pathname: "/some/path",
        search: "?query=string",
        hash: "#hash",
      }}
    />
    

### [](#viewtransition)viewTransition

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Enables a [View Transition](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) for this navigation.

    <Link to={to} viewTransition>
      Click me
    </Link>
    

To apply specific styles for the transition, see [useViewTransitionState](../hooks/useViewTransitionState)

[](#navigate)Navigate
=====================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Navigate.html)

A component-based version of [useNavigate](../hooks/useNavigate) to use in a [`React.Component Class`](https://reactjs.org/docs/react-component.html) where hooks are not able to be used.

It's recommended to avoid using this component in favor of [useNavigate](../hooks/useNavigate)

    <Navigate to="/tasks" />
    

[](#props)Props
---------------

### [](#relative)relative

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#replace)replace

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#state)state

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#outlet)Outlet
=================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Outlet.html)

Renders the matching child route of a parent route or nothing if no child route matches.

    import { Outlet } from "react-router";
    
    export default function SomeParent() {
      return (
        <div>
          <h1>Parent Content</h1>
          <Outlet />
        </div>
      );
    }
    

[](#props)Props
---------------

### [](#context)context

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Provides a context value to the element tree below the outlet. Use when the parent route needs to provide values to child routes.

    <Outlet context={myContextValue} />
    

Access the context with [useOutletContext](../hooks/useOutletContext).

[](#prefetchpagelinks)PrefetchPageLinks
=======================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.PrefetchPageLinks.html)

Renders `<link rel=prefetch|modulepreload>` tags for modules and data of another page to enable an instant navigation to that page. `<Link prefetch>` uses this internally, but you can render it to prefetch a page for any other reason.

    import { PrefetchPageLinks } from "react-router";
    
    <PrefetchPageLinks page="/absolute/path" />;
    

For example, you may render one of this as the user types into a search field to prefetch search results before they click through to their selection.

[](#props)Props
---------------

### [](#crossorigin)crossOrigin

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

How the element handles crossorigin requests

### [](#disabled)disabled

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Whether the link is disabled

### [](#hreflang)hrefLang

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Language of the linked resource

### [](#integrity)integrity

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Integrity metadata used in Subresource Integrity checks

### [](#media)media

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Applicable media: "screen", "print", "(max-width: 764px)"

### [](#page)page

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

The absolute path of the page to prefetch.

### [](#referrerpolicy)referrerPolicy

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Referrer policy for fetches initiated by the element

[](#route)Route
===============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Route.html)

Configures an element to render when a pattern matches the current location. It must be rendered within a [Routes](../components/Routes) element. Note that these routes do not participate in data loading, actions, code splitting, or any other route module features.

[](#props)Props
---------------

### [](#casesensitive)caseSensitive

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Whether the path should be matched in a case-sensitive manner.

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#component)Component

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#element)element

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#path)path

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

The path to match against the current location.

[](#routes)Routes
=================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Routes.html)

Renders a branch of [Route](../components/Route) that best matches the current location. Note that these routes do not participate in data loading, actions, code splitting, or any other route module features.

    import { Routes, Route } from "react-router"
    
    <Routes>
     <Route index element={<StepOne />} />
     <Route path="step-2" element={<StepTwo />} />
     <Route path="step-3" element={<StepThree />} />
    </Routes>
    

[](#props)Props
---------------

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Nested [Route](../components/Route) elements

### [](#location)location

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

The location to match against. Defaults to the current location.

[](#scripts)Scripts
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Scripts.html)

Renders the client runtime of your app. It should be rendered inside the `<body>` of the document.

    import { Scripts } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head />
          <body>
            <Scripts />
          </body>
        </html>
      );
    }
    

If server rendering, you can omit `<Scripts/>` and the app will work as a traditional web app without JavaScript, relying solely on HTML and browser behaviors.

[](#props)Props
---------------

### [](#scriptsprops)ScriptsProps

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

A couple common attributes:

*   `<Scripts crossOrigin>` for hosting your static assets on a different server than your app.
*   `<Scripts nonce>` to support a [content security policy for scripts](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src) with [nonce-sources](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources) for your `<script>` tags.

You cannot pass through attributes such as `async`, `defer`, `src`, `type`, `noModule` because they are managed by React Router internally.

[](#scrollrestoration)ScrollRestoration
=======================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.ScrollRestoration.html)

Emulates the browser's scroll restoration on location changes. Apps should only render one of these, right before the [Scripts](../components/Scripts) component.

    import { ScrollRestoration } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <body>
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    

This component renders an inline `<script>` to prevent scroll flashing. The `nonce` prop will be passed down to the script tag to allow CSP nonce usage.

    <ScrollRestoration nonce={cspNonce} />
    

[](#props)Props
---------------

### [](#scriptsprops)ScriptsProps

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

A couple common attributes:

*   `<Scripts crossOrigin>` for hosting your static assets on a different server than your app.
*   `<Scripts nonce>` to support a [content security policy for scripts](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src) with [nonce-sources](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources) for your `<script>` tags.

You cannot pass through attributes such as `async`, `defer`, `src`, `type`, `noModule` because they are managed by React Router internally.

[](#serverrouter)ServerRouter
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.ServerRouter.html)

Rendered at the top of the app in a custom entry.server.tsx.

[](#props)Props
---------------

### [](#context)context

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#nonce)nonce

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#url)url

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#unstable_useprompt)unstable\_usePrompt
==========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.unstable_usePrompt.html)

Wrapper around useBlocker to show a window.confirm prompt to users instead of building a custom UI with [useBlocker](../hooks/useBlocker).

The `unstable_` flag will not be removed because this technique has a lot of rough edges and behaves very differently (and incorrectly sometimes) across browsers if users click addition back/forward navigations while the confirmation is open. Use at your own risk.

    function ImportantForm() {
      let [value, setValue] = React.useState("");
    
      // Block navigating elsewhere when data has been entered into the input
      unstable_usePrompt({
        message: "Are you sure?",
        when: ({ currentLocation, nextLocation }) =>
          value !== "" &&
          currentLocation.pathname !== nextLocation.pathname,
      });
    
      return (
        <Form method="post">
          <label>
            Enter some important data:
            <input
              name="data"
              value={value}
              onChange={(e) => setValue(e.target.value)}
            />
          </label>
          <button type="submit">Save</button>
        </Form>
      );
    }
    

[](#signature)Signature
-----------------------

    unstable_usePrompt(options): void
    

[](#params)Params
-----------------

### [](#options)options

_No documentation_

[](#useactiondata)useActionData
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useActionData.html)

Returns the action data from the most recent POST navigation form submission or `undefined` if there hasn't been one.

    import { Form, useActionData } from "react-router";
    
    export async function action({ request }) {
      const body = await request.formData();
      const name = body.get("visitorsName");
      return { message: `Hello, ${name}` };
    }
    
    export default function Invoices() {
      const data = useActionData();
      return (
        <Form method="post">
          <input type="text" name="visitorsName" />
          {data ? data.message : "Waiting..."}
        </Form>
      );
    }
    

[](#signature)Signature
-----------------------

    useActionData(): undefined
    

[](#useasyncerror)useAsyncError
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useAsyncError.html)

Returns the rejection value from the closest [Await](../components/Await).

    import { Await, useAsyncError } from "react-router";
    
    function ErrorElement() {
      const error = useAsyncError();
      return (
        <p>Uh Oh, something went wrong! {error.message}</p>
      );
    }
    
    // somewhere in your app
    <Await
      resolve={promiseThatRejects}
      errorElement={<ErrorElement />}
    />;
    

[](#signature)Signature
-----------------------

    useAsyncError(): unknown
    

[](#useasyncvalue)useAsyncValue
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useAsyncValue.html)

Returns the resolved promise value from the closest [Await](../components/Await).

    function SomeDescendant() {
      const value = useAsyncValue();
      // ...
    }
    
    // somewhere in your app
    <Await resolve={somePromise}>
      <SomeDescendant />
    </Await>;
    

[](#signature)Signature
-----------------------

    useAsyncValue(): unknown
    

[](#usebeforeunload)useBeforeUnload
===================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useBeforeUnload.html)

Setup a callback to be fired on the window's `beforeunload` event.

[](#signature)Signature
-----------------------

    useBeforeUnload(callback, options): void
    

[](#params)Params
-----------------

### [](#callback)callback

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#options)options

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#useblocker)useBlocker
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useBlocker.html)

Allow the application to block navigations within the SPA and present the user a confirmation dialog to confirm the navigation. Mostly used to avoid using half-filled form data. This does not handle hard-reloads or cross-origin navigations.

[](#signature)Signature
-----------------------

    useBlocker(shouldBlock): Blocker
    

[](#params)Params
-----------------

### [](#shouldblock)shouldBlock

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#examples)Examples
---------------------

### [](#basic)Basic

    import { useCallback, useState } from "react";
    import { BlockerFunction, useBlocker } from "react-router";
    
    export function ImportantForm() {
      const [value, setValue] = useState("");
    
      const shouldBlock = useCallback<BlockerFunction>(
        () => value !== "",
        [value]
      );
      const blocker = useBlocker(shouldBlock);
    
      return (
        <form
          onSubmit={(e) => {
            e.preventDefault();
            setValue("");
            if (blocker.state === "blocked") {
              blocker.proceed();
            }
          }}
        >
          <input
            name="data"
            value={value}
            onChange={(e) => setValue(e.target.value)}
          />
    
          <button type="submit">Save</button>
    
          {blocker.state === "blocked" ? (
            <>
              <p style={{ color: "red" }}>
                Blocked the last navigation to
              </p>
              <button
                type="button"
                onClick={() => blocker.proceed()}
              >
                Let me through
              </button>
              <button
                type="button"
                onClick={() => blocker.reset()}
              >
                Keep me here
              </button>
            </>
          ) : blocker.state === "proceeding" ? (
            <p style={{ color: "orange" }}>
              Proceeding through blocked navigation
            </p>
          ) : (
            <p style={{ color: "green" }}>
              Blocker is currently unblocked
            </p>
          )}
        </form>
      );
    }
    

[](#usefetcher)useFetcher
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useFetcher.html)

Useful for creating complex, dynamic user interfaces that require multiple, concurrent data interactions without causing a navigation.

Fetchers track their own, independent state and can be used to load data, submit forms, and generally interact with loaders and actions.

    import { useFetcher } from "react-router"
    
    function SomeComponent() {
      let fetcher = useFetcher()
    
      // states are available on the fetcher
      fetcher.state // "idle" | "loading" | "submitting"
      fetcher.data // the data returned from the action or loader
    
      // render a form
      <fetcher.Form method="post" />
    
      // load data
      fetcher.load("/some/route")
    
      // submit data
      fetcher.submit(someFormRef, { method: "post" })
      fetcher.submit(someData, {
        method: "post",
        encType: "application/json"
      })
    }
    

[](#signature)Signature
-----------------------

    useFetcher(options): FetcherWithComponents
    

[](#params)Params
-----------------

### [](#options)options

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#usefetchers)useFetchers
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useFetchers.html)

Returns an array of all in-flight fetchers. This is useful for components throughout the app that didn't create the fetchers but want to use their submissions to participate in optimistic UI.

    import { useFetchers } from "react-router";
    
    function SomeComponent() {
      const fetchers = useFetchers();
      fetchers[0].formData; // FormData
      fetchers[0].state; // etc.
      // ...
    }
    

[](#signature)Signature
-----------------------

    useFetchers(): undefined
    

[](#useformaction)useFormAction
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useFormAction.html)

Resolves the URL to the closest route in the component hierarchy instead of the current URL of the app.

This is used internally by [Form](../components/Form) resolve the action to the closest route, but can be used generically as well.

    import { useFormAction } from "react-router";
    
    function SomeComponent() {
      // closest route URL
      let action = useFormAction();
    
      // closest route URL + "destroy"
      let destroyAction = useFormAction("destroy");
    }
    

[](#signature)Signature
-----------------------

    useFormAction(action, __namedParameters): string
    

[](#params)Params
-----------------

### [](#action)action

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The action to append to the closest route URL.

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#usehref)useHref
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useHref.html)

Resolves a URL against the current location.

    import { useHref } from "react-router";
    
    function SomeComponent() {
      let href = useHref("some/where");
      // "/resolved/some/where"
    }
    

[](#signature)Signature
-----------------------

    useHref(to, __namedParameters): string
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#useinroutercontext)useInRouterContext
=========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useInRouterContext.html)

Returns true if this component is a descendant of a Router, useful to ensure a component is used within a Router.

[](#signature)Signature
-----------------------

    useInRouterContext(): boolean
    

[](#uselinkclickhandler)useLinkClickHandler
===========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useLinkClickHandler.html)

Handles the click behavior for router `<Link>` components. This is useful if you need to create custom `<Link>` components with the same click behavior we use in our exported `<Link>`.

[](#signature)Signature
-----------------------

    useLinkClickHandler(to, __namedParameters): undefined
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#useloaderdata)useLoaderData
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useLoaderData.html)

Returns the data from the closest route [LoaderFunction](../Other/LoaderFunction) or [ClientLoaderFunction](../Other/ClientLoaderFunction).

    import { useLoaderData } from "react-router";
    
    export async function loader() {
      return await fakeDb.invoices.findAll();
    }
    
    export default function Invoices() {
      let invoices = useLoaderData<typeof loader>();
      // ...
    }
    

[](#signature)Signature
-----------------------

    useLoaderData(): SerializeFrom
    

[](#uselocation)useLocation
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useLocation.html)

Returns the current [Location](%5B../Other/Location%5D\(https://api.reactrouter.com/v7/interfaces/react_router.Location.html\)). This can be useful if you'd like to perform some side effect whenever it changes.

    import * as React from 'react'
    import { useLocation } from 'react-router'
    
    function SomeComponent() {
      let location = useLocation()
    
      React.useEffect(() => {
        // Google Analytics
        ga('send', 'pageview')
      }, [location]);
    
      return (
        // ...
      );
    }
    

[](#signature)Signature
-----------------------

    useLocation(): Location
    

[](#usematch)useMatch
=====================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useMatch.html)

Returns a PathMatch object if the given pattern matches the current URL. This is useful for components that need to know "active" state, e.g. `<NavLink>`.

[](#signature)Signature
-----------------------

    useMatch(pattern): undefined
    

[](#params)Params
-----------------

### [](#pattern)pattern

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#usematches)useMatches
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useMatches.html)

Returns the active route matches, useful for accessing loaderData for parent/child routes or the route "handle" property

[](#signature)Signature
-----------------------

    useMatches(): undefined
    

[](#usenavigate)useNavigate
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useNavigate.html)

Returns a function that lets you navigate programmatically in the browser in response to user interactions or effects.

    import { useNavigate } from "react-router";
    
    function SomeComponent() {
      let navigate = useNavigate();
      return (
        <button
          onClick={() => {
            navigate(-1);
          }}
        />
      );
    }
    

It's often better to use [redirect](../utils/redirect) in [ActionFunction](../Other/ActionFunction) and [LoaderFunction](../Other/LoaderFunction) than this hook.

[](#signature)Signature
-----------------------

    navigate(
      to: To,
      options?: {
        flushSync?: boolean;
        preventScrollReset?: boolean;
        relative?: RelativeRoutingType;
        replace?: boolean;
        state?: any;
        viewTransition?: boolean;
      }
    ): void | Promise<void>;
    

[](#examples)Examples
---------------------

### [](#navigate-to-another-path)Navigate to another path:

    navigate("/some/route");
    navigate("/some/route?search=param");
    

### [](#navigate-with-a-to-object)Navigate with a `To` object:

All properties are optional.

    navigate({
      pathname: "/some/route",
      search: "?search=param",
      hash: "#hash",
      state: { some: "state" },
    });
    

If you use `state`, that will be available on the `location` object on the next page. Access it with `useLocation().state` (see [useLocation](./useLocation)).

### [](#navigate-back-or-forward-in-the-history-stack)Navigate back or forward in the history stack:

    // back
    // often used to close modals
    navigate(-1);
    
    // forward
    // often used in a multi-step wizard workflows
    navigate(1);
    

Be cautions with `navigate(number)`. If your application can load up to a route that has a button that tries to navigate forward/back, there may not be a history entry to go back or forward to, or it can go somewhere you don't expect (like a different domain).

Only use this if you're sure they will have an entry in the history stack to navigate to.

### [](#replace-the-current-entry-in-the-history-stack)Replace the current entry in the history stack:

This will remove the current entry in the history stack, replacing it with a new one, similar to a server side redirect.

    navigate("/some/route", { replace: true });
    

### [](#prevent-scroll-reset)Prevent Scroll Reset

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

To prevent `<ScrollRestoration>` from resetting the scroll position, use the `preventScrollReset` option.

    navigate("?some-tab=1", { preventScrollReset: true });
    

For example, if you have a tab interface connected to search params in the middle of a page and you don't want it to scroll to the top when a tab is clicked.

[](#usenavigation)useNavigation
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useNavigation.html)

Returns the current navigation, defaulting to an "idle" navigation when no navigation is in progress. You can use this to render pending UI (like a global spinner) or read FormData from a form navigation.

    import { useNavigation } from "react-router";
    
    function SomeComponent() {
      let navigation = useNavigation();
      navigation.state;
      navigation.formData;
      // etc.
    }
    

[](#signature)Signature
-----------------------

    useNavigation(): Navigation
    

[](#usenavigationtype)useNavigationType
=======================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useNavigationType.html)

Returns the current navigation action which describes how the router came to the current location, either by a pop, push, or replace on the history stack.

[](#signature)Signature
-----------------------

    useNavigationType(): NavigationType
    

[](#useoutlet)useOutlet
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useOutlet.html)

Returns the element for the child route at this level of the route hierarchy. Used internally by `<Outlet>` to render child routes.

[](#signature)Signature
-----------------------

    useOutlet(context): undefined
    

[](#params)Params
-----------------

### [](#context)context

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#useoutletcontext)useOutletContext
=====================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useOutletContext.html)

Returns the parent route `<Outlet context>`.

[](#signature)Signature
-----------------------

    useOutletContext(): Context
    

[](#useparams)useParams
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useParams.html)

Returns an object of key/value pairs of the dynamic params from the current URL that were matched by the routes. Child routes inherit all params from their parent routes.

    import { useParams } from "react-router";
    
    function SomeComponent() {
      let params = useParams();
      params.postId;
    }
    

Assuming a route pattern like `/posts/:postId` is matched by `/posts/123` then `params.postId` will be `"123"`.

[](#examples)Examples
---------------------

### [](#basic-usage)Basic Usage

    import { useParams } from "react-router";
    
    // given a route like:
    <Route path="/posts/:postId" element={<Post />} />;
    
    // or a data route like:
    createBrowserRouter([
      {
        path: "/posts/:postId",
        component: Post,
      },
    ]);
    
    // or in routes.ts
    route("/posts/:postId", "routes/post.tsx");
    

Access the params in a component:

    import { useParams } from "react-router";
    
    export default function Post() {
      let params = useParams();
      return <h1>Post: {params.postId}</h1>;
    }
    

### [](#multiple-params)Multiple Params

Patterns can have multiple params:

    "/posts/:postId/comments/:commentId";
    

All will be available in the params object:

    import { useParams } from "react-router";
    
    export default function Post() {
      let params = useParams();
      return (
        <h1>
          Post: {params.postId}, Comment: {params.commentId}
        </h1>
      );
    }
    

### [](#catchall-params)Catchall Params

Catchall params are defined with `*`:

    "/files/*";
    

The matched value will be available in the params object as follows:

    import { useParams } from "react-router";
    
    export default function File() {
      let params = useParams();
      let catchall = params["*"];
      // ...
    }
    

You can destructure the catchall param:

    export default function File() {
      let { "*": catchall } = useParams();
      console.log(catchall);
    }
    

[](#useresolvedpath)useResolvedPath
===================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useResolvedPath.html)

Resolves the pathname of the given `to` value against the current location. Similar to [useHref](../hooks/useHref), but returns a [Path](../Other/Path) instead of a string.

    import { useResolvedPath } from "react-router";
    
    function SomeComponent() {
      // if the user is at /dashboard/profile
      let path = useResolvedPath("../accounts");
      path.pathname; // "/dashboard/accounts"
      path.search; // ""
      path.hash; // ""
    }
    

[](#signature)Signature
-----------------------

    useResolvedPath(to, __namedParameters): Path
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#userevalidator)useRevalidator
=================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useRevalidator.html)

Revalidate the data on the page for reasons outside of normal data mutations like window focus or polling on an interval.

    import { useRevalidator } from "react-router";
    
    function WindowFocusRevalidator() {
      const revalidator = useRevalidator();
    
      useFakeWindowFocus(() => {
        revalidator.revalidate();
      });
    
      return (
        <div hidden={revalidator.state === "idle"}>
          Revalidating...
        </div>
      );
    }
    

Note that page data is already revalidated automatically after actions. If you find yourself using this for normal CRUD operations on your data in response to user interactions, you're probably not taking advantage of the other APIs like [useFetcher](../hooks/useFetcher), [Form](../components/Form), [useSubmit](../hooks/useSubmit) that do this automatically.

[](#signature)Signature
-----------------------

    useRevalidator(): undefined
    

[](#userouteerror)useRouteError
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useRouteError.html)

Accesses the error thrown during an [ActionFunction](../Other/ActionFunction), [LoaderFunction](../Other/LoaderFunction), or component render to be used in a route module Error Boundary.

    export function ErrorBoundary() {
      const error = useRouteError();
      return <div>{error.message}</div>;
    }
    

[](#signature)Signature
-----------------------

    useRouteError(): unknown
    

[](#userouteloaderdata)useRouteLoaderData
=========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useRouteLoaderData.html)

Returns the loader data for a given route by route ID.

    import { useRouteLoaderData } from "react-router";
    
    function SomeComponent() {
      const { user } = useRouteLoaderData("root");
    }
    

Route IDs are created automatically. They are simply the path of the route file relative to the app folder without the extension.

Route Filename

Route ID

`app/root.tsx`

`"root"`

`app/routes/teams.tsx`

`"routes/teams"`

`app/whatever/teams.$id.tsx`

`"whatever/teams.$id"`

If you created an ID manually, you can use that instead:

    route("/", "containers/app.tsx", { id: "app" }})
    

[](#signature)Signature
-----------------------

    useRouteLoaderData(routeId): undefined
    

[](#params)Params
-----------------

### [](#routeid)routeId

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#useroutes)useRoutes
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useRoutes.html)

Hook version of [Routes](../components/Routes) that uses objects instead of components. These objects have the same properties as the component props.

The return value of `useRoutes` is either a valid React element you can use to render the route tree, or `null` if nothing matched.

    import * as React from "react";
    import { useRoutes } from "react-router";
    
    function App() {
      let element = useRoutes([
        {
          path: "/",
          element: <Dashboard />,
          children: [
            {
              path: "messages",
              element: <DashboardMessages />,
            },
            { path: "tasks", element: <DashboardTasks /> },
          ],
        },
        { path: "team", element: <AboutPage /> },
      ]);
    
      return element;
    }
    

[](#signature)Signature
-----------------------

    useRoutes(routes, locationArg): undefined
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#locationarg)locationArg

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#usesearchparams)useSearchParams
===================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useSearchParams.html)

Returns a tuple of the current URL's URLSearchParams and a function to update them. Setting the search params causes a navigation.

    import { useSearchParams } from "react-router";
    
    export function SomeComponent() {
      const [searchParams, setSearchParams] = useSearchParams();
      // ...
    }
    

[](#signature)Signature
-----------------------

    useSearchParams(defaultInit): undefined
    

[](#params)Params
-----------------

### [](#defaultinit)defaultInit

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

You can initialize the search params with a default value, though it **will not** change the URL on the first render.

    // a search param string
    useSearchParams("?tab=1");
    
    // a short-hand object
    useSearchParams({ tab: "1" });
    
    // object keys can be arrays for multiple values on the key
    useSearchParams({ brand: ["nike", "reebok"] });
    
    // an array of tuples
    useSearchParams([["tab", "1"]]);
    
    // a URLSearchParams object
    useSearchParams(new URLSearchParams("?tab=1"));
    

[](#setsearchparams-function)SetSearchParams Function
-----------------------------------------------------

The second element of the tuple is a function that can be used to update the search params. It accepts the same types as `defaultInit` and will cause a navigation to the new URL.

    let [searchParams, setSearchParams] = useSearchParams();
    
    // a search param string
    setSearchParams("?tab=1");
    
    // a short-hand object
    setSearchParams({ tab: "1" });
    
    // object keys can be arrays for multiple values on the key
    setSearchParams({ brand: ["nike", "reebok"] });
    
    // an array of tuples
    setSearchParams([["tab", "1"]]);
    
    // a URLSearchParams object
    setSearchParams(new URLSearchParams("?tab=1"));
    

It also supports a function callback like `setState`:

    setSearchParams((searchParams) => {
      searchParams.set("tab", "2");
      return searchParams;
    });
    

[](#notes)Notes
---------------

Note that `searchParams` is a stable reference, so you can reliably use it as a dependency in `useEffect` hooks.

    useEffect(() => {
      console.log(searchParams.get("tab"));
    }, [searchParams]);
    

However, this also means it's mutable. If you change the object without calling `setSearchParams`, its values will change between renders if some other state causes the component to re-render and URL will not reflect the values.

[](#usesubmit)useSubmit
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useSubmit.html)

The imperative version of [Form](../components/Form) that lets you submit a form from code instead of a user interaction.

    import { useSubmit } from "react-router";
    
    function SomeComponent() {
      const submit = useSubmit();
      return (
        <Form
          onChange={(event) => {
            submit(event.currentTarget);
          }}
        />
      );
    }
    

[](#signature)Signature
-----------------------

    useSubmit(): SubmitFunction
    

[](#useviewtransitionstate)useViewTransitionState
=================================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useViewTransitionState.html)

This hook returns `true` when there is an active [View Transition](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) to the specified location. This can be used to apply finer-grained styles to elements to further customize the view transition. This requires that view transitions have been enabled for the given navigation via LinkProps.viewTransition (or the `Form`, `submit`, or `navigate` call)

[](#signature)Signature
-----------------------

    useViewTransitionState(to, opts): boolean
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#hydratedrouter)HydratedRouter
=================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.HydratedRouter.html)

Hydrates a server rendered StaticRouterProvider.

[](#props)Props
---------------

None

[](#routerprovider)RouterProvider
=================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.RouterProvider.html)

Initializes a data router, subscribes to its changes, and renders the matching components. Should typically be at the top of an app's element tree.

    import {
      RouterProvider,
      createBrowserRouter,
    } from "react-router";
    import { createRoot } from "react-dom/client";
    let router = createBrowserRouter();
    createRoot(document.getElementById("root")).render(
      <RouterProvider router={router} />
    );
    

[](#props)Props
---------------

### [](#flushsync)flushSync

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#router)router

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#staticrouterprovider)StaticRouterProvider
=============================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.StaticRouterProvider.html)

A Data Router that may not navigate to any other location. This is useful on the server where there is no stateful UI.

[](#props)Props
---------------

### [](#context)context

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#hydrate)hydrate

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#nonce)nonce

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#router)router

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#createbrowserrouter)createBrowserRouter
===========================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createBrowserRouter.html)

[](#signature)Signature
-----------------------

    createBrowserRouter(routes, opts): DataRouter
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#createhashrouter)createHashRouter
=====================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createHashRouter.html)

[](#signature)Signature
-----------------------

    createHashRouter(routes, opts): DataRouter
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#creatememoryrouter)createMemoryRouter
=========================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createMemoryRouter.html)

[](#signature)Signature
-----------------------

    createMemoryRouter(routes, opts): DataRouter
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#createstaticrouter)createStaticRouter
=========================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createStaticRouter.html)

[](#signature)Signature
-----------------------

    createStaticRouter(routes, context, opts): DataRouter
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#context)context

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#browserrouter)BrowserRouter
===============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.BrowserRouter.html)

A declarative router using the browser history API for client side routing.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#window)window

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#hashrouter)HashRouter
=========================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.HashRouter.html)

A `<Router>` for use in web browsers. Stores the location in the hash portion of the URL.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#window)window

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#memoryrouter)MemoryRouter
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.MemoryRouter.html)

A `<Router>` that stores all entries in memory.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#initialentries)initialEntries

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#initialindex)initialIndex

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#router)Router
=================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Router.html)

Provides location context for the rest of the app.

Note: You usually won't render a `<Router>` directly. Instead, you'll render a router that is more specific to your environment such as a `<BrowserRouter>` in web browsers or a `<StaticRouter>` for server rendering.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#location)location

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#navigationtype)navigationType

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#navigator)navigator

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#static)static

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#staticrouter)StaticRouter
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.StaticRouter.html)

A `<Router>` that may not navigate to any other location. This is useful on the server where there is no stateful UI.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#location)location

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#historyrouter)HistoryRouter
===============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.unstable_HistoryRouter.html)

A `<Router>` that accepts a pre-instantiated history object. It's important to note that using your own history object is highly discouraged and may add two versions of the history library to your bundles unless you use the same version of the history library that React Router uses internally.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#history)history

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#iscookiefunction)IsCookieFunction
=====================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.IsCookieFunction.html)

[](#issessionfunction)IsSessionFunction
=======================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.IsSessionFunction.html)

[](#createcookie)createCookie
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createCookie.html)

Creates a logical container for managing a browser cookie from the server.

[](#createcookiesessionstorage)createCookieSessionStorage
=========================================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createCookieSessionStorage.html)

Creates and returns a SessionStorage object that stores all session data directly in the session cookie itself.

This has the advantage that no database or other backend services are needed, and can help to simplify some load-balanced scenarios. However, it also has the limitation that serialized session data may not exceed the browser's maximum cookie size. Trade-offs!

[](#creatememorysessionstorage)createMemorySessionStorage
=========================================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createMemorySessionStorage.html)

Creates and returns a simple in-memory SessionStorage object, mostly useful for testing and as a reference implementation.

Note: This storage does not scale beyond a single process, so it is not suitable for most production scenarios.

[](#createpath)createPath
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createPath.html)

Creates a string URL path from the given pathname, search, and hash components.

[](#signature)Signature
-----------------------

    createPath(__namedParameters): string
    

[](#params)Params
-----------------

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#createroutesfromelements)createRoutesFromElements
=====================================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createRoutesFromElements.html)

Create route objects from JSX elements instead of arrays of objects

[](#signature)Signature
-----------------------

    createRoutesFromElements(children, parentPath): undefined
    

[](#params)Params
-----------------

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#parentpath)parentPath

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#createroutesstub)createRoutesStub
=====================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createRoutesStub.html)

[](#signature)Signature
-----------------------

    createRoutesStub(routes, context): undefined
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#context)context

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#createsearchparams)createSearchParams
=========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createSearchParams.html)

Creates a URLSearchParams object using the given initializer.

This is identical to `new URLSearchParams(init)` except it also supports arrays as values in the object form of the initializer instead of just strings. This is convenient when you need multiple values for a given key, but don't want to use an array initializer.

For example, instead of:

    let searchParams = new URLSearchParams([
      ["sort", "name"],
      ["sort", "price"],
    ]);
    

you can do:

    let searchParams = createSearchParams({
      sort: ['name', 'price']
    });
    

[](#signature)Signature
-----------------------

    createSearchParams(init): URLSearchParams
    

[](#params)Params
-----------------

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#createstatichandler)createStaticHandler
===========================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createStaticHandler.html)

[](#signature)Signature
-----------------------

    createStaticHandler(routes, opts): StaticHandler
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#data)data
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.data.html)

Create "responses" that contain `status`/`headers` without forcing serialization into an actual `Response` - used by Remix single fetch

[](#signature)Signature
-----------------------

    data(data, init): DataWithResponseInit
    

[](#params)Params
-----------------

### [](#data-1)data

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#generatepath)generatePath
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.generatePath.html)

Returns a path with params interpolated.

[](#signature)Signature
-----------------------

    generatePath(originalPath, params): string
    

[](#params)Params
-----------------

### [](#originalpath)originalPath

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#params-1)params

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#href)href
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.href.html)

Returns a resolved URL path for the specified route.

    const h = href("/:lang?/about", { lang: "en" })
    // -> `/en/about`
    
    <Link to={href("/products/:id", { id: "abc123" })} />
    

[](#iscookie)isCookie
=====================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.isCookie.html)

Returns true if an object is a Remix cookie container.

[](#isrouteerrorresponse)isRouteErrorResponse
=============================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.isRouteErrorResponse.html)

Check if the given error is an ErrorResponse generated from a 4xx/5xx Response thrown from an action/loader

[](#signature)Signature
-----------------------

    isRouteErrorResponse(error): error
    

[](#params)Params
-----------------

### [](#error)error

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#issession)isSession
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.isSession.html)

Returns true if an object is a React Router session.

[](#matchpath)matchPath
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.matchPath.html)

Performs pattern matching on a URL pathname and returns information about the match.

[](#signature)Signature
-----------------------

    matchPath(pattern, pathname): undefined
    

[](#params)Params
-----------------

### [](#pattern)pattern

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#pathname)pathname

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#matchroutes)matchRoutes
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.matchRoutes.html)

Matches the given routes to a location and returns the match data.

[](#signature)Signature
-----------------------

    matchRoutes(routes, locationArg, basename): undefined
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#locationarg)locationArg

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#basename)basename

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#parsepath)parsePath
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.parsePath.html)

Parses a string URL path into its separate pathname, search, and hash components.

[](#signature)Signature
-----------------------

    parsePath(path): Partial
    

[](#params)Params
-----------------

### [](#path)path

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#redirect)redirect
=====================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.redirect.html)

A redirect response. Sets the status code and the `Location` header. Defaults to "302 Found".

[](#signature)Signature
-----------------------

    redirect(url, init): Response
    

[](#params)Params
-----------------

### [](#url)url

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#redirectdocument)redirectDocument
=====================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.redirectDocument.html)

A redirect response that will force a document reload to the new location. Sets the status code and the `Location` header. Defaults to "302 Found".

[](#signature)Signature
-----------------------

    redirectDocument(url, init): Response
    

[](#params)Params
-----------------

### [](#url)url

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#rendermatches)renderMatches
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.renderMatches.html)

Renders the result of `matchRoutes()` into a React element.

[](#signature)Signature
-----------------------

    renderMatches(matches): undefined
    

[](#params)Params
-----------------

### [](#matches)matches

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#replace)replace
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.replace.html)

A redirect response that will perform a `history.replaceState` instead of a `history.pushState` for client-side navigation redirects. Sets the status code and the `Location` header. Defaults to "302 Found".

[](#signature)Signature
-----------------------

    replace(url, init): Response
    

[](#params)Params
-----------------

### [](#url)url

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#resolvepath)resolvePath
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.resolvePath.html)

Returns a resolved path object relative to the given pathname.

[](#signature)Signature
-----------------------

    resolvePath(to, fromPathname): Path
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#frompathname)fromPathname

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#address-book)Address Book
=============================

We'll be building a small, but feature-rich address book app that lets you keep track of your contacts. There's no database or other "production ready" things, so we can stay focused on the features React Router gives you. We expect it to take 30-45m if you're following along, otherwise it's a quick read.

You can also watch our [walkthrough of the React Router Tutorial](https://www.youtube.com/watch?v=pw8FAg07kdo) if you prefer 🎥

👉 **Every time you see this it means you need to do something in the app!**

The rest is just there for your information and deeper understanding. Let's get to it.

[](#setup)Setup
---------------

👉 **Generate a basic template**

    npx create-react-router@latest --template remix-run/react-router/tutorials/address-book
    

This uses a pretty bare-bones template but includes our css and data model, so we can focus on React Router.

👉 **Start the app**

    # cd into the app directory
    cd {wherever you put the app}
    
    # install dependencies if you haven't already
    npm install
    
    # start the server
    npm run dev
    

You should be able to open up [http://localhost:5173](http://localhost:5173) and see an unstyled screen that looks like this:

[](#the-root-route)The Root Route
---------------------------------

Note the file at `app/root.tsx`. This is what we call the ["Root Route"](../explanation/special-files#roottsx). It's the first component in the UI that renders, so it typically contains the global layout for the page, as well as a the default [Error Boundary](../how-to/error-boundary).

Expand here to see the root component code

    import {
      Form,
      Scripts,
      ScrollRestoration,
      isRouteErrorResponse,
    } from "react-router";
    import type { Route } from "./+types/root";
    
    import appStylesHref from "./app.css?url";
    
    export default function App() {
      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            <div>
              <Form id="search-form" role="search">
                <input
                  aria-label="Search contacts"
                  id="q"
                  name="q"
                  placeholder="Search"
                  type="search"
                />
                <div
                  aria-hidden
                  hidden={true}
                  id="search-spinner"
                />
              </Form>
              <Form method="post">
                <button type="submit">New</button>
              </Form>
            </div>
            <nav>
              <ul>
                <li>
                  <a href={`/contacts/1`}>Your Name</a>
                </li>
                <li>
                  <a href={`/contacts/2`}>Your Friend</a>
                </li>
              </ul>
            </nav>
          </div>
        </>
      );
    }
    
    // The Layout component is a special export for the root route.
    // It acts as your document's "app shell" for all route components, HydrateFallback, and ErrorBoundary
    // For more information, see https://reactrouter.com/explanation/special-files#layout-export
    export function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <head>
            <meta charSet="utf-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1"
            />
            <link rel="stylesheet" href={appStylesHref} />
          </head>
          <body>
            {children}
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    
    // The top most error boundary for the app, rendered when your app throws an error
    // For more information, see https://reactrouter.com/start/framework/route-module#errorboundary
    export function ErrorBoundary({
      error,
    }: Route.ErrorBoundaryProps) {
      let message = "Oops!";
      let details = "An unexpected error occurred.";
      let stack: string | undefined;
    
      if (isRouteErrorResponse(error)) {
        message = error.status === 404 ? "404" : "Error";
        details =
          error.status === 404
            ? "The requested page could not be found."
            : error.statusText || details;
      } else if (
        import.meta.env.DEV &&
        error &&
        error instanceof Error
      ) {
        details = error.message;
        stack = error.stack;
      }
    
      return (
        <main id="error-page">
          <h1>{message}</h1>
          <p>{details}</p>
          {stack && (
            <pre>
              <code>{stack}</code>
            </pre>
          )}
        </main>
      );
    }

[](#the-contact-route-ui)The Contact Route UI
---------------------------------------------

If you click on one of the sidebar items you'll get the default 404 page. Let's create a route that matches the url `/contacts/1`.

👉 **Create a contact route module**

    mkdir app/routes
    touch app/routes/contact.tsx
    

We could put this file anywhere we want, but to make things a bit more organized, we'll put all our routes inside the `app/routes` directory.

You can also use [file-based routing if you prefer](../how-to/file-route-conventions).

👉 **Configure the route**

We need to tell React Router about our new route. `routes.ts` is a special file where we can configure all our routes.

    import type { RouteConfig } from "@react-router/dev/routes";
    import { route } from "@react-router/dev/routes";
    
    export default [
      route("contacts/:contactId", "routes/contact.tsx"),
    ] satisfies RouteConfig;
    

In React Router, `:` makes a segment dynamic. We just made the following urls match the `routes/contact.tsx` route module:

*   `/contacts/123`
*   `/contacts/abc`

👉 **Add the contact component UI**

It's just a bunch of elements, feel free to copy/paste.

    import { Form } from "react-router";
    
    import type { ContactRecord } from "../data";
    
    export default function Contact() {
      const contact = {
        first: "Your",
        last: "Name",
        avatar: "https://placecats.com/200/200",
        twitter: "your_handle",
        notes: "Some notes",
        favorite: true,
      };
    
      return (
        <div id="contact">
          <div>
            <img
              alt={`${contact.first} ${contact.last} avatar`}
              key={contact.avatar}
              src={contact.avatar}
            />
          </div>
    
          <div>
            <h1>
              {contact.first || contact.last ? (
                <>
                  {contact.first} {contact.last}
                </>
              ) : (
                <i>No Name</i>
              )}
              <Favorite contact={contact} />
            </h1>
    
            {contact.twitter ? (
              <p>
                <a
                  href={`https://twitter.com/${contact.twitter}`}
                >
                  {contact.twitter}
                </a>
              </p>
            ) : null}
    
            {contact.notes ? <p>{contact.notes}</p> : null}
    
            <div>
              <Form action="edit">
                <button type="submit">Edit</button>
              </Form>
    
              <Form
                action="destroy"
                method="post"
                onSubmit={(event) => {
                  const response = confirm(
                    "Please confirm you want to delete this record."
                  );
                  if (!response) {
                    event.preventDefault();
                  }
                }}
              >
                <button type="submit">Delete</button>
              </Form>
            </div>
          </div>
        </div>
      );
    }
    
    function Favorite({
      contact,
    }: {
      contact: Pick<ContactRecord, "favorite">;
    }) {
      const favorite = contact.favorite;
    
      return (
        <Form method="post">
          <button
            aria-label={
              favorite
                ? "Remove from favorites"
                : "Add to favorites"
            }
            name="favorite"
            value={favorite ? "false" : "true"}
          >
            {favorite ? "★" : "☆"}
          </button>
        </Form>
      );
    }
    

Now if we click one of the links or visit [`/contacts/1`](http://localhost:5173/contacts/1) we get ... nothing new?

[](#nested-routes-and-outlets)Nested Routes and Outlets
-------------------------------------------------------

React Router supports nested routing. In order for child routes to render inside of parent layouts, we need to render an [`Outlet`](https://api.reactrouter.com/v7/functions/react_router.Outlet) in the parent. Let's fix it, open up `app/root.tsx` and render an outlet inside.

👉 **Render an [`<Outlet />`](https://api.reactrouter.com/v7/functions/react_router.Outlet)**

    import {
      Form,
      Outlet,
      Scripts,
      ScrollRestoration,
      isRouteErrorResponse,
    } from "react-router";
    
    // existing imports & exports
    
    export default function App() {
      return (
        <>
          <div id="sidebar">{/* other elements */}</div>
          <div id="detail">
            <Outlet />
          </div>
        </>
      );
    }
    

Now the child route should be rendering through the outlet.

[](#client-side-routing)Client Side Routing
-------------------------------------------

You may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of client side routing, which completely remounts our app.

Client side routing allows our app to update the URL without reloading the entire page. Instead, the app can immediately render new UI. Let's make it happen with [`<Link>`](https://api.reactrouter.com/v7/functions/react_router.Link).

👉 **Change the sidebar `<a href>` to `<Link to>`**

    import {
      Form,
      Link,
      Outlet,
      Scripts,
      ScrollRestoration,
      isRouteErrorResponse,
    } from "react-router";
    
    // existing imports & exports
    
    export default function App() {
      return (
        <>
          <div id="sidebar">
            {/* other elements */}
            <nav>
              <ul>
                <li>
                  <Link to={`/contacts/1`}>Your Name</Link>
                </li>
                <li>
                  <Link to={`/contacts/2`}>Your Friend</Link>
                </li>
              </ul>
            </nav>
          </div>
          {/* other elements */}
        </>
      );
    }
    

You can open the network tab in the browser devtools to see that it's not requesting documents anymore.

[](#loading-data)Loading Data
-----------------------------

URL segments, layouts, and data are more often than not coupled (tripled?) together. We can see it in this app already:

URL Segment

Component

Data

/

`<App>`

list of contacts

contacts/:contactId

`<Contact>`

individual contact

Because of this natural coupling, React Router has data conventions to get data into your route components easily.

First we'll create and export a [`clientLoader`](../start/framework/route-module#clientloader) function in the root route and then render the data.

👉 **Export a `clientLoader` function from `app/root.tsx` and render the data**

The following code has a type error in it, we'll fix it in the next section

    // existing imports
    import { getContacts } from "./data";
    
    // existing exports
    
    export async function clientLoader() {
      const contacts = await getContacts();
      return { contacts };
    }
    
    export default function App({ loaderData }) {
      const { contacts } = loaderData;
    
      return (
        <>
          <div id="sidebar">
            {/* other elements */}
            <nav>
              {contacts.length ? (
                <ul>
                  {contacts.map((contact) => (
                    <li key={contact.id}>
                      <Link to={`contacts/${contact.id}`}>
                        {contact.first || contact.last ? (
                          <>
                            {contact.first} {contact.last}
                          </>
                        ) : (
                          <i>No Name</i>
                        )}
                        {contact.favorite ? (
                          <span>★</span>
                        ) : null}
                      </Link>
                    </li>
                  ))}
                </ul>
              ) : (
                <p>
                  <i>No contacts</i>
                </p>
              )}
            </nav>
          </div>
          {/* other elements */}
        </>
      );
    }
    

That's it! React Router will now automatically keep that data in sync with your UI. The sidebar should now look like this:

You may be wondering why we're "client" loading data instead of loading the data on the server so we can do server-side rendering (SSR). Right now our contacts site is a [Single Page App](../how-to/spa), so there's no server-side rendering. This makes it really easy to deploy to any static hosting provider, but we'll talk more about how to enable SSR in a bit so you can learn about all the different [rendering strategies](../start/framework/rendering) React Router offers.

[](#type-safety)Type Safety
---------------------------

You probably noticed that we didn't assign a type to the `loaderData` prop. Let's fix that.

👉 **Add the `ComponentProps` type to the `App` component**

    // existing imports
    import type { Route } from "./+types/root";
    // existing imports & exports
    
    export default function App({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts } = loaderData;
    
      // existing code
    }
    

Wait, what? Where did these types come from?!

We didn't define them, yet somehow they already know about the `contacts` property we returned from our `clientLoader`.

That's because React Router [generates types for each route in your app](../explanation/type-safety) to provide automatic type safety.

[](#adding-a-hydratefallback)Adding a `HydrateFallback`
-------------------------------------------------------

We mentioned earlier that we are working on a [Single Page App](../how-to/spa) with no server-side rendering. If you look inside of [`react-router.config.ts`](../explanation/special-files#react-routerconfigts) you'll see that this is configured with a simple boolean:

    import { type Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
    } satisfies Config;
    

You might have started noticing that whenever you refresh the page you get a flash of white before the app loads. Since we're only rendering on the client, there's nothing to show the user while the app is loading.

👉 **Add a `HydrateFallback` export**

We can provide a fallback that will show up before the app is hydrated (rendering on the client for the first time) with a [`HydrateFallback`](../start/framework/route-module#hydratefallback) export.

    // existing imports & exports
    
    export function HydrateFallback() {
      return (
        <div id="loading-splash">
          <div id="loading-splash-spinner" />
          <p>Loading, please wait...</p>
        </div>
      );
    }
    

Now if you refresh the page, you'll briefly see the loading splash before the app is hydrated.

[](#index-routes)Index Routes
-----------------------------

When you load the app and aren't yet on a contact page, you'll notice a big blank page on the right side of the list.

When a route has children, and you're at the parent route's path, the `<Outlet>` has nothing to render because no children match. You can think of [index routes](../start/framework/routing#index-routes) as the default child route to fill in that space.

👉 **Create an index route for the root route**

    touch app/routes/home.tsx
    

    import type { RouteConfig } from "@react-router/dev/routes";
    import { index, route } from "@react-router/dev/routes";
    
    export default [
      index("routes/home.tsx"),
      route("contacts/:contactId", "routes/contact.tsx"),
    ] satisfies RouteConfig;
    

👉 **Fill in the index component's elements**

Feel free to copy/paste, nothing special here.

    export default function Home() {
      return (
        <p id="index-page">
          This is a demo for React Router.
          <br />
          Check out{" "}
          <a href="https://reactrouter.com">
            the docs at reactrouter.com
          </a>
          .
        </p>
      );
    }
    

Voilà! No more blank space. It's common to put dashboards, stats, feeds, etc. at index routes. They can participate in data loading as well.

[](#adding-an-about-route)Adding an About Route
-----------------------------------------------

Before we move on to working with dynamic data that the user can interact with, let's add a page with static content we expect to rarely change. An about page will be perfect for this.

👉 **Create the about route**

    touch app/routes/about.tsx
    

Don't forget to add the route to `app/routes.ts`:

    export default [
      index("routes/home.tsx"),
      route("contacts/:contactId", "routes/contact.tsx"),
      route("about", "routes/about.tsx"),
    ] satisfies RouteConfig;
    

👉 **Add the about page UI**

Nothing too special here, just copy and paste:

    import { Link } from "react-router";
    
    export default function About() {
      return (
        <div id="about">
          <Link to="/">← Go to demo</Link>
          <h1>About React Router Contacts</h1>
    
          <div>
            <p>
              This is a demo application showing off some of the
              powerful features of React Router, including
              dynamic routing, nested routes, loaders, actions,
              and more.
            </p>
    
            <h2>Features</h2>
            <p>
              Explore the demo to see how React Router handles:
            </p>
            <ul>
              <li>
                Data loading and mutations with loaders and
                actions
              </li>
              <li>
                Nested routing with parent/child relationships
              </li>
              <li>URL-based routing with dynamic segments</li>
              <li>Pending and optimistic UI</li>
            </ul>
    
            <h2>Learn More</h2>
            <p>
              Check out the official documentation at{" "}
              <a href="https://reactrouter.com">
                reactrouter.com
              </a>{" "}
              to learn more about building great web
              applications with React Router.
            </p>
          </div>
        </div>
      );
    }
    

👉 **Add a link to the about page in the sidebar**

    export default function App() {
      return (
        <>
          <div id="sidebar">
            <h1>
              <Link to="about">React Router Contacts</Link>
            </h1>
            {/* other elements */}
          </div>
          {/* other elements */}
        </>
      );
    }
    

Now navigate to the [about page](http://localhost:5173/about) and it should look like this:

[](#layout-routes)Layout Routes
-------------------------------

We don't actually want the about page to be nested inside of the sidebar layout. Let's move the sidebar to a layout so we can avoid rendering it on the about page. Additionally, we want to avoid loading all the contacts data on the about page.

👉 **Create a layout route for the sidebar**

You can name and put this layout route wherever you want, but putting it inside of a `layouts` directory will help keep things organized for our simple app.

    mkdir app/layouts
    touch app/layouts/sidebar.tsx
    

For now just return an [`<Outlet>`](https://api.reactrouter.com/v7/functions/react_router.Outlet).

    import { Outlet } from "react-router";
    
    export default function SidebarLayout() {
      return <Outlet />;
    }
    

👉 **Move route definitions under the sidebar layout**

We can define a `layout` route to automatically render the sidebar for all matched routes within it. This is basically what our `root` was, but now we can scope it to specific routes.

    import type { RouteConfig } from "@react-router/dev/routes";
    import {
      index,
      layout,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      layout("layouts/sidebar.tsx", [
        index("routes/home.tsx"),
        route("contacts/:contactId", "routes/contact.tsx"),
      ]),
      route("about", "routes/about.tsx"),
    ] satisfies RouteConfig;
    

👉 **Move the layout and data fetching to the sidebar layout**

We want to move the `clientLoader` and everything inside the `App` component to the sidebar layout. It should look like this:

    import { Form, Link, Outlet } from "react-router";
    import { getContacts } from "../data";
    import type { Route } from "./+types/sidebar";
    
    export async function clientLoader() {
      const contacts = await getContacts();
      return { contacts };
    }
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts } = loaderData;
    
      return (
        <>
          <div id="sidebar">
            <h1>
              <Link to="about">React Router Contacts</Link>
            </h1>
            <div>
              <Form id="search-form" role="search">
                <input
                  aria-label="Search contacts"
                  id="q"
                  name="q"
                  placeholder="Search"
                  type="search"
                />
                <div
                  aria-hidden
                  hidden={true}
                  id="search-spinner"
                />
              </Form>
              <Form method="post">
                <button type="submit">New</button>
              </Form>
            </div>
            <nav>
              {contacts.length ? (
                <ul>
                  {contacts.map((contact) => (
                    <li key={contact.id}>
                      <Link to={`contacts/${contact.id}`}>
                        {contact.first || contact.last ? (
                          <>
                            {contact.first} {contact.last}
                          </>
                        ) : (
                          <i>No Name</i>
                        )}
                        {contact.favorite ? (
                          <span>★</span>
                        ) : null}
                      </Link>
                    </li>
                  ))}
                </ul>
              ) : (
                <p>
                  <i>No contacts</i>
                </p>
              )}
            </nav>
          </div>
          <div id="detail">
            <Outlet />
          </div>
        </>
      );
    }
    

And inside `app/root.tsx`, `App` should just return an [`<Outlet>`](https://api.reactrouter.com/v7/functions/react_router.Outlet), and all unused imports can be removed. Make sure there is no `clientLoader` in `root.tsx`.

    // existing imports and exports
    
    export default function App() {
      return <Outlet />;
    }
    

Now with that shuffling around done, our about page no longer loads contacts data nor is it nested inside of the sidebar layout:

[](#pre-rendering-a-static-route)Pre-rendering a Static Route
-------------------------------------------------------------

If you refresh the about page, you still see the loading spinner for just a split second before the page render on the client. This is really not a good experience, plus the page is just static information, we should be able to pre-render it as static HTML at build time.

👉 **Pre-render the about page**

Inside of `react-router.config.ts`, we can add a [`prerender`](../how-to/pre-rendering) array to the config to tell React Router to pre-render certain urls at build time. In this case we just want to pre-render the about page.

    import { type Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
      prerender: ["/about"],
    } satisfies Config;
    

Now if you go to the [about page](http://localhost:5173/about) and refresh, you won't see the loading spinner!

If you're still seeing a spinner when you refresh, make sure you deleted the `clientLoader` in `root.tsx`.

[](#server-side-rendering)Server-Side Rendering
-----------------------------------------------

React Router is a great framework for building [Single Page Apps](../how-to/spa). Many applications are served well by only client-side rendering, and _maybe_ statically pre-rendering a few pages at build time.

If you ever do want to introduce server-side rendering into your React Router application, it's incredibly easy (remember that `ssr: false` boolean from earlier?).

👉 **Enable server-side rendering**

    export default {
      ssr: true,
      prerender: ["/about"],
    } satisfies Config;
    

And now... nothing is different? We're still getting our spinner for a split second before the page renders on the client? Plus, aren't we using `clientLoader`, so our data is still being fetched on the client?

That's right! With React Router you can still use `clientLoader` (and `clientAction`) to do client-side data fetching where you see fit. React Router gives you a lot of flexibility to use the right tool for the job.

Let's switch to using [`loader`](../start/framework/route-module#loader), which (you guessed it) is used to fetch data on the server.

👉 **Switch to using `loader` to fetch data**

    // existing imports
    
    export async function loader() {
      const contacts = await getContacts();
      return { contacts };
    }
    

Whether you set `ssr` to `true` or `false` depends on you and your users needs. Both strategies are perfectly valid. For the remainder of this tutorial we're going to use server-side rendering, but know that all rendering strategies are first class citizens in React Router.

[](#url-params-in-loaders)URL Params in Loaders
-----------------------------------------------

👉 **Click on one of the sidebar links**

We should be seeing our old static contact page again, with one difference: the URL now has a real ID for the record.

Remember the `:contactId` part of the route definition in `app/routes.ts`? These dynamic segments will match dynamic (changing) values in that position of the URL. We call these values in the URL "URL Params", or just "params" for short.

These `params` are passed to the loader with keys that match the dynamic segment. For example, our segment is named `:contactId` so the value will be passed as `params.contactId`.

These params are most often used to find a record by ID. Let's try it out.

👉 **Add a `loader` function to the contact page and access data with `loaderData`**

The following code has type errors in it, we'll fix them in the next section

    // existing imports
    import { getContact } from "../data";
    import type { Route } from "./+types/contact";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const contact = await getContact(params.contactId);
      return { contact };
    }
    
    export default function Contact({
      loaderData,
    }: Route.ComponentProps) {
      const { contact } = loaderData;
    
      // existing code
    }
    
    // existing code
    

[](#throwing-responses)Throwing Responses
-----------------------------------------

You'll notice that the type of `loaderData.contact` is `ContactRecord | null`. Based on our automatic type safety, TypeScript already knows that `params.contactId` is a string, but we haven't done anything to make sure it's a valid ID. Since the contact might not exist, `getContact` could return `null`, which is why we have type errors.

We could account for the possibility of the contact being not found in component code, but the webby thing to do is send a proper 404. We can do that in the loader and solve all of our problems at once.

    // existing imports
    
    export async function loader({ params }: Route.LoaderArgs) {
      const contact = await getContact(params.contactId);
      if (!contact) {
        throw new Response("Not Found", { status: 404 });
      }
      return { contact };
    }
    
    // existing code
    

Now, if the user isn't found, code execution down this path stops and React Router renders the error path instead. Components in React Router can focus only on the happy path 😁

[](#data-mutations)Data Mutations
---------------------------------

We'll create our first contact in a second, but first let's talk about HTML.

React Router emulates HTML Form navigation as the data mutation primitive, which used to be the only way prior to the JavaScript cambrian explosion. Don't be fooled by the simplicity! Forms in React Router give you the UX capabilities of client rendered apps with the simplicity of the "old school" web model.

While unfamiliar to some web developers, HTML `form`s actually cause a navigation in the browser, just like clicking a link. The only difference is in the request: links can only change the URL while `form`s can also change the request method (`GET` vs. `POST`) and the request body (`POST` form data).

Without client side routing, the browser will serialize the `form`'s data automatically and send it to the server as the request body for `POST`, and as [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) for `GET`. React Router does the same thing, except instead of sending the request to the server, it uses client side routing and sends it to the route's [`action`](../start/framework/route-module#action) function.

We can test this out by clicking the "New" button in our app.

React Router sends a 405 because there is no code on the server to handle this form navigation.

[](#creating-contacts)Creating Contacts
---------------------------------------

We'll create new contacts by exporting an `action` function in our root route. When the user clicks the "new" button, the form will `POST` to the root route action.

👉 **Export an `action` function from `app/root.tsx`**

    // existing imports
    
    import { createEmptyContact } from "./data";
    
    export async function action() {
      const contact = await createEmptyContact();
      return { contact };
    }
    
    // existing code
    

That's it! Go ahead and click the "New" button, and you should see a new record pop into the list 🥳

The `createEmptyContact` method just creates an empty contact with no name or data or anything. But it does still create a record, promise!

> 🧐 Wait a sec ... How did the sidebar update? Where did we call the `action` function? Where's the code to re-fetch the data? Where are `useState`, `onSubmit` and `useEffect`?!

This is where the "old school web" programming model shows up. [`<Form>`](https://api.reactrouter.com/v7/functions/react_router.Form) prevents the browser from sending the request to the server and sends it to your route's `action` function instead with [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch).

In web semantics, a `POST` usually means some data is changing. By convention, React Router uses this as a hint to automatically revalidate the data on the page after the `action` finishes.

In fact, since it's all just HTML and HTTP, you could disable JavaScript and the whole thing will still work. Instead of React Router serializing the form and making a [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) request to your server, the browser will serialize the form and make a document request. From there React Router will render the page server side and send it down. It's the same UI in the end either way.

We'll keep JavaScript around though because we're going to make a better user experience than spinning favicons and static documents.

[](#updating-data)Updating Data
-------------------------------

Let's add a way to fill the information for our new record.

Just like creating data, you update data with [`<Form>`](https://api.reactrouter.com/v7/functions/react_router.Form). Let's make a new route module inside `app/routes/edit-contact.tsx`.

👉 **Create the edit contact route**

    touch app/routes/edit-contact.tsx
    

Don't forget to add the route to `app/routes.ts`:

    export default [
      layout("layouts/sidebar.tsx", [
        index("routes/home.tsx"),
        route("contacts/:contactId", "routes/contact.tsx"),
        route(
          "contacts/:contactId/edit",
          "routes/edit-contact.tsx"
        ),
      ]),
      route("about", "routes/about.tsx"),
    ] satisfies RouteConfig;
    

👉 **Add the edit page UI**

Nothing we haven't seen before, feel free to copy/paste:

    import { Form } from "react-router";
    import type { Route } from "./+types/edit-contact";
    
    import { getContact } from "../data";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const contact = await getContact(params.contactId);
      if (!contact) {
        throw new Response("Not Found", { status: 404 });
      }
      return { contact };
    }
    
    export default function EditContact({
      loaderData,
    }: Route.ComponentProps) {
      const { contact } = loaderData;
    
      return (
        <Form key={contact.id} id="contact-form" method="post">
          <p>
            <span>Name</span>
            <input
              aria-label="First name"
              defaultValue={contact.first}
              name="first"
              placeholder="First"
              type="text"
            />
            <input
              aria-label="Last name"
              defaultValue={contact.last}
              name="last"
              placeholder="Last"
              type="text"
            />
          </p>
          <label>
            <span>Twitter</span>
            <input
              defaultValue={contact.twitter}
              name="twitter"
              placeholder="@jack"
              type="text"
            />
          </label>
          <label>
            <span>Avatar URL</span>
            <input
              aria-label="Avatar URL"
              defaultValue={contact.avatar}
              name="avatar"
              placeholder="https://example.com/avatar.jpg"
              type="text"
            />
          </label>
          <label>
            <span>Notes</span>
            <textarea
              defaultValue={contact.notes}
              name="notes"
              rows={6}
            />
          </label>
          <p>
            <button type="submit">Save</button>
            <button type="button">Cancel</button>
          </p>
        </Form>
      );
    }
    

Now click on your new record, then click the "Edit" button. We should see the new route.

[](#updating-contacts-with-formdata)Updating Contacts with `FormData`
---------------------------------------------------------------------

The edit route we just created already renders a `form`. All we need to do is add the `action` function. React Router will serialize the `form`, `POST` it with [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch), and automatically revalidate all the data.

👉 **Add an `action` function to the edit route**

    import { Form, redirect } from "react-router";
    // existing imports
    
    import { getContact, updateContact } from "../data";
    
    export async function action({
      params,
      request,
    }: Route.ActionArgs) {
      const formData = await request.formData();
      const updates = Object.fromEntries(formData);
      await updateContact(params.contactId, updates);
      return redirect(`/contacts/${params.contactId}`);
    }
    
    // existing code
    

Fill out the form, hit save, and you should see something like this! (Except easier on the eyes and maybe with the patience to cut watermelon.)

[](#mutation-discussion)Mutation Discussion
-------------------------------------------

> 😑 It worked, but I have no idea what is going on here...

Let's dig in a bit...

Open up `app/routes/edit-contact.tsx` and look at the `form` elements. Notice how they each have a name:

    <input
      aria-label="First name"
      defaultValue={contact.first}
      name="first"
      placeholder="First"
      type="text"
    />
    

Without JavaScript, when a form is submitted, the browser will create [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) and set it as the body of the request when it sends it to the server. As mentioned before, React Router prevents that and emulates the browser by sending the request to your `action` function with [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) instead, including the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

Each field in the `form` is accessible with `formData.get(name)`. For example, given the input field from above, you could access the first and last names like this:

    export const action = async ({
      params,
      request,
    }: ActionFunctionArgs) => {
      const formData = await request.formData();
      const firstName = formData.get("first");
      const lastName = formData.get("last");
      // ...
    };
    

Since we have a handful of form fields, we used [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) to collect them all into an object, which is exactly what our `updateContact` function wants.

    const updates = Object.fromEntries(formData);
    updates.first; // "Some"
    updates.last; // "Name"
    

Aside from the `action` function, none of these APIs we're discussing are provided by React Router: [`request`](https://developer.mozilla.org/en-US/docs/Web/API/Request), [`request.formData`](https://developer.mozilla.org/en-US/docs/Web/API/Request/formData), [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) are all provided by the web platform.

After we finished the `action`, note the [`redirect`](https://api.reactrouter.com/v7/functions/react_router.redirect) at the end:

    export async function action({
      params,
      request,
    }: Route.ActionArgs) {
      invariant(params.contactId, "Missing contactId param");
      const formData = await request.formData();
      const updates = Object.fromEntries(formData);
      await updateContact(params.contactId, updates);
      return redirect(`/contacts/${params.contactId}`);
    }
    

`action` and `loader` functions can both return a `Response` (makes sense, since they received a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)!). The [`redirect`](https://api.reactrouter.com/v7/functions/react_router.redirect) helper just makes it easier to return a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) that tells the app to change locations.

Without client side routing, if a server redirected after a `POST` request, the new page would fetch the latest data and render. As we learned before, React Router emulates this model and automatically revalidates the data on the page after the `action` call. That's why the sidebar automatically updates when we save the form. The extra revalidation code doesn't exist without client side routing, so it doesn't need to exist with client side routing in React Router either!

One last thing. Without JavaScript, the [`redirect`](https://api.reactrouter.com/v7/functions/react_router.redirect) would be a normal redirect. However, with JavaScript it's a client-side redirect, so the user doesn't lose client state like scroll positions or component state.

[](#redirecting-new-records-to-the-edit-page)Redirecting new records to the edit page
-------------------------------------------------------------------------------------

Now that we know how to redirect, let's update the action that creates new contacts to redirect to the edit page:

👉 **Redirect to the new record's edit page**

    import {
      Outlet,
      Scripts,
      ScrollRestoration,
      isRouteErrorResponse,
      redirect,
    } from "react-router";
    // existing imports
    
    export async function action() {
      const contact = await createEmptyContact();
      return redirect(`/contacts/${contact.id}/edit`);
    }
    
    // existing code
    

Now when we click "New", we should end up on the edit page:

[](#active-link-styling)Active Link Styling
-------------------------------------------

Now that we have a bunch of records, it's not clear which one we're looking at in the sidebar. We can use [`NavLink`](https://api.reactrouter.com/v7/functions/react_router.NavLink) to fix this.

👉 **Replace `<Link>` with `<NavLink>` in the sidebar**

    import { Form, Link, NavLink, Outlet } from "react-router";
    
    // existing imports and exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts } = loaderData;
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <ul>
              {contacts.map((contact) => (
                <li key={contact.id}>
                  <NavLink
                    className={({ isActive, isPending }) =>
                      isActive
                        ? "active"
                        : isPending
                        ? "pending"
                        : ""
                    }
                    to={`contacts/${contact.id}`}
                  >
                    {/* existing elements */}
                  </NavLink>
                </li>
              ))}
            </ul>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

Note that we are passing a function to `className`. When the user is at the URL that matches `<NavLink to>`, then `isActive` will be true. When it's _about_ to be active (the data is still loading) then `isPending` will be true. This allows us to easily indicate where the user is and also provide immediate feedback when links are clicked but data needs to be loaded.

[](#global-pending-ui)Global Pending UI
---------------------------------------

As the user navigates the app, React Router will _leave the old page up_ as data is loading for the next page. You may have noticed the app feels a little unresponsive as you click between the list. Let's provide the user with some feedback so the app doesn't feel unresponsive.

React Router is managing all the state behind the scenes and reveals the pieces you need to build dynamic web apps. In this case, we'll use the [`useNavigation`](https://api.reactrouter.com/v7/functions/react_router.useNavigation) hook.

👉 **Use `useNavigation` to add global pending UI**

    import {
      Form,
      Link,
      NavLink,
      Outlet,
      useNavigation,
    } from "react-router";
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts } = loaderData;
      const navigation = useNavigation();
    
      return (
        <>
          {/* existing elements */}
          <div
            className={
              navigation.state === "loading" ? "loading" : ""
            }
            id="detail"
          >
            <Outlet />
          </div>
        </>
      );
    }
    

[`useNavigation`](https://api.reactrouter.com/v7/functions/react_router.useNavigation) returns the current navigation state: it can be one of `"idle"`, `"loading"` or `"submitting"`.

In our case, we add a `"loading"` class to the main part of the app if we're not idle. The CSS then adds a nice fade after a short delay (to avoid flickering the UI for fast loads). You could do anything you want though, like show a spinner or loading bar across the top.

[](#deleting-records)Deleting Records
-------------------------------------

If we review code in the contact route, we can find the delete button looks like this:

    <Form
      action="destroy"
      method="post"
      onSubmit={(event) => {
        const response = confirm(
          "Please confirm you want to delete this record."
        );
        if (!response) {
          event.preventDefault();
        }
      }}
    >
      <button type="submit">Delete</button>
    </Form>
    

Note the `action` points to `"destroy"`. Like `<Link to>`, `<Form action>` can take a _relative_ value. Since the form is rendered in the route `contacts/:contactId`, then a relative action with `destroy` will submit the form to `contacts/:contactId/destroy` when clicked.

At this point you should know everything you need to know to make the delete button work. Maybe give it a shot before moving on? You'll need:

1.  A new route
2.  An `action` at that route
3.  `deleteContact` from `app/data.ts`
4.  `redirect` to somewhere after

👉 **Configure the "destroy" route module**

    touch app/routes/destroy-contact.tsx
    

    export default [
      // existing routes
      route(
        "contacts/:contactId/destroy",
        "routes/destroy-contact.tsx"
      ),
      // existing routes
    ] satisfies RouteConfig;
    

👉 **Add the destroy action**

    import { redirect } from "react-router";
    import type { Route } from "./+types/destroy-contact";
    
    import { deleteContact } from "../data";
    
    export async function action({ params }: Route.ActionArgs) {
      await deleteContact(params.contactId);
      return redirect("/");
    }
    

Alright, navigate to a record and click the "Delete" button. It works!

> 😅 I'm still confused why this all works

When the user clicks the submit button:

1.  `<Form>` prevents the default browser behavior of sending a new document `POST` request to the server, but instead emulates the browser by creating a `POST` request with client side routing and [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)
2.  The `<Form action="destroy">` matches the new route at `contacts/:contactId/destroy` and sends it the request
3.  After the `action` redirects, React Router calls all the `loader`s for the data on the page to get the latest values (this is "revalidation"). `loaderData` in `routes/contact.tsx` now has new values and causes the components to update!

Add a `Form`, add an `action`, React Router does the rest.

[](#cancel-button)Cancel Button
-------------------------------

On the edit page we've got a cancel button that doesn't do anything yet. We'd like it to do the same thing as the browser's back button.

We'll need a click handler on the button as well as [`useNavigate`](https://api.reactrouter.com/v7/functions/react_router.useNavigate).

👉 **Add the cancel button click handler with `useNavigate`**

    import { Form, redirect, useNavigate } from "react-router";
    // existing imports & exports
    
    export default function EditContact({
      loaderData,
    }: Route.ComponentProps) {
      const { contact } = loaderData;
      const navigate = useNavigate();
    
      return (
        <Form key={contact.id} id="contact-form" method="post">
          {/* existing elements */}
          <p>
            <button type="submit">Save</button>
            <button onClick={() => navigate(-1)} type="button">
              Cancel
            </button>
          </p>
        </Form>
      );
    }
    

Now when the user clicks "Cancel", they'll be sent back one entry in the browser's history.

> 🧐 Why is there no `event.preventDefault()` on the button?

A `<button type="button">`, while seemingly redundant, is the HTML way of preventing a button from submitting its form.

Two more features to go. We're on the home stretch!

[](#urlsearchparams-and-get-submissions)`URLSearchParams` and `GET` Submissions
-------------------------------------------------------------------------------

All of our interactive UI so far have been either links that change the URL or `form`s that post data to `action` functions. The search field is interesting because it's a mix of both: it's a `form`, but it only changes the URL, it doesn't change data.

Let's see what happens when we submit the search form:

👉 **Type a name into the search field and hit the enter key**

Note the browser's URL now contains your query in the URL as [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams):

    http://localhost:5173/?q=ryan
    

Since it's not `<Form method="post">`, React Router emulates the browser by serializing the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) into the [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) instead of the request body.

`loader` functions have access to the search params from the `request`. Let's use it to filter the list:

👉 **Filter the list if there are `URLSearchParams`**

    // existing imports & exports
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const url = new URL(request.url);
      const q = url.searchParams.get("q");
      const contacts = await getContacts(q);
      return { contacts };
    }
    
    // existing code
    

Because this is a `GET`, not a `POST`, React Router _does not_ call the `action` function. Submitting a `GET` `form` is the same as clicking a link: only the URL changes.

This also means it's a normal page navigation. You can click the back button to get back to where you were.

[](#synchronizing-urls-to-form-state)Synchronizing URLs to Form State
---------------------------------------------------------------------

There are a couple of UX issues here that we can take care of quickly.

1.  If you click back after a search, the form field still has the value you entered even though the list is no longer filtered.
2.  If you refresh the page after searching, the form field no longer has the value in it, even though the list is filtered

In other words, the URL and our input's state are out of sync.

Let's solve (2) first and start the input with the value from the URL.

👉 **Return `q` from your `loader`, set it as the input's default value**

    // existing imports & exports
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const url = new URL(request.url);
      const q = url.searchParams.get("q");
      const contacts = await getContacts(q);
      return { contacts, q };
    }
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form id="search-form" role="search">
                <input
                  aria-label="Search contacts"
                  defaultValue={q || ""}
                  id="q"
                  name="q"
                  placeholder="Search"
                  type="search"
                />
                {/* existing elements */}
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

The input field will show the query if you refresh the page after a search now.

Now for problem (1), clicking the back button and updating the input. We can bring in `useEffect` from React to manipulate the input's value in the DOM directly.

👉 **Synchronize input value with the `URLSearchParams`**

    // existing imports
    import { useEffect } from "react";
    
    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
    
      useEffect(() => {
        const searchField = document.getElementById("q");
        if (searchField instanceof HTMLInputElement) {
          searchField.value = q || "";
        }
      }, [q]);
    
      // existing code
    }
    

> 🤔 Shouldn't you use a controlled component and React State for this?

You could certainly do this as a controlled component. You will have more synchronization points, but it's up to you.

Expand this to see what it would look like

    // existing imports
    import { useEffect, useState } from "react";
    
    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
      // the query now needs to be kept in state
      const [query, setQuery] = useState(q || "");
    
      // we still have a `useEffect` to synchronize the query
      // to the component state on back/forward button clicks
      useEffect(() => {
        setQuery(q || "");
      }, [q]);
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form id="search-form" role="search">
                <input
                  aria-label="Search contacts"
                  id="q"
                  name="q"
                  // synchronize user's input to component state
                  onChange={(event) =>
                    setQuery(event.currentTarget.value)
                  }
                  placeholder="Search"
                  type="search"
                  // switched to `value` from `defaultValue`
                  value={query}
                />
                {/* existing elements */}
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }

Alright, you should now be able to click the back/forward/refresh buttons and the input's value should be in sync with the URL and results.

[](#submitting-forms-onchange)Submitting `Form`'s `onChange`
------------------------------------------------------------

We've got a product decision to make here. Sometimes you want the user to submit the `form` to filter some results, other times you want to filter as the user types. We've already implemented the first, so let's see what it's like for the second.

We've seen `useNavigate` already, we'll use its cousin, [`useSubmit`](https://api.reactrouter.com/v7/functions/react_router.useSubmit), for this.

    import {
      Form,
      Link,
      NavLink,
      Outlet,
      useNavigation,
      useSubmit,
    } from "react-router";
    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
      const submit = useSubmit();
    
      // existing code
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form
                id="search-form"
                onChange={(event) =>
                  submit(event.currentTarget)
                }
                role="search"
              >
                {/* existing elements */}
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

As you type, the `form` is automatically submitted now!

Note the argument to [`submit`](https://api.reactrouter.com/v7/functions/react_router.useSubmit). The `submit` function will serialize and submit any form you pass to it. We're passing in `event.currentTarget`. The `currentTarget` is the DOM node the event is attached to (the `form`).

[](#adding-search-spinner)Adding Search Spinner
-----------------------------------------------

In a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side. That's why this demo has some faked network latency.

Without any loading indicator, the search feels kinda sluggish. Even if we could make our database faster, we'll always have the user's network latency in the way and out of our control.

For a better user experience, let's add some immediate UI feedback for the search. We'll use [`useNavigation`](https://api.reactrouter.com/v7/functions/react_router.useNavigation) again.

👉 **Add a variable to know if we're searching**

    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
      const submit = useSubmit();
      const searching =
        navigation.location &&
        new URLSearchParams(navigation.location.search).has(
          "q"
        );
    
      // existing code
    }
    

When nothing is happening, `navigation.location` will be `undefined`, but when the user navigates it will be populated with the next location while data loads. Then we check if they're searching with `location.search`.

👉 **Add classes to search form elements using the new `searching` state**

    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      // existing code
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form
                id="search-form"
                onChange={(event) =>
                  submit(event.currentTarget)
                }
                role="search"
              >
                <input
                  aria-label="Search contacts"
                  className={searching ? "loading" : ""}
                  defaultValue={q || ""}
                  id="q"
                  name="q"
                  placeholder="Search"
                  type="search"
                />
                <div
                  aria-hidden
                  hidden={!searching}
                  id="search-spinner"
                />
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

Bonus points, avoid fading out the main screen when searching:

    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      // existing code
    
      return (
        <>
          {/* existing elements */}
          <div
            className={
              navigation.state === "loading" && !searching
                ? "loading"
                : ""
            }
            id="detail"
          >
            <Outlet />
          </div>
          {/* existing elements */}
        </>
      );
    }
    

You should now have a nice spinner on the left side of the search input.

[](#managing-the-history-stack)Managing the History Stack
---------------------------------------------------------

Since the form is submitted for every keystroke, typing the characters "alex" and then deleting them with backspace results in a huge history stack 😂. We definitely don't want this:

We can avoid this by _replacing_ the current entry in the history stack with the next page, instead of pushing into it.

👉 **Use `replace` in `submit`**

    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      // existing code
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form
                id="search-form"
                onChange={(event) => {
                  const isFirstSearch = q === null;
                  submit(event.currentTarget, {
                    replace: !isFirstSearch,
                  });
                }}
                role="search"
              >
                {/* existing elements */}
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

After a quick check if this is the first search or not, we decide to replace. Now the first search will add a new entry, but every keystroke after that will replace the current entry. Instead of clicking back 7 times to remove the search, users only have to click back once.

[](#forms-without-navigation)`Form`s Without Navigation
-------------------------------------------------------

So far all of our forms have changed the URL. While these user flows are common, it's equally common to want to submit a form _without_ causing a navigation.

For these cases, we have [`useFetcher`](https://api.reactrouter.com/v7/functions/react_router.useFetcher). It allows us to communicate with `action`s and `loader`s without causing a navigation.

The ★ button on the contact page makes sense for this. We aren't creating or deleting a new record, and we don't want to change pages. We simply want to change the data on the page we're looking at.

👉 **Change the `<Favorite>` form to a fetcher form**

    import { Form, useFetcher } from "react-router";
    
    // existing imports & exports
    
    function Favorite({
      contact,
    }: {
      contact: Pick<ContactRecord, "favorite">;
    }) {
      const fetcher = useFetcher();
      const favorite = contact.favorite;
    
      return (
        <fetcher.Form method="post">
          <button
            aria-label={
              favorite
                ? "Remove from favorites"
                : "Add to favorites"
            }
            name="favorite"
            value={favorite ? "false" : "true"}
          >
            {favorite ? "★" : "☆"}
          </button>
        </fetcher.Form>
      );
    }
    

This form will no longer cause a navigation, but simply fetch to the `action`. Speaking of which ... this won't work until we create the `action`.

👉 **Create the `action`**

    // existing imports
    import { getContact, updateContact } from "../data";
    // existing imports
    
    export async function action({
      params,
      request,
    }: Route.ActionArgs) {
      const formData = await request.formData();
      return updateContact(params.contactId, {
        favorite: formData.get("favorite") === "true",
      });
    }
    
    // existing code
    

Alright, we're ready to click the star next to the user's name!

Check that out, both stars automatically update. Our new `<fetcher.Form method="post">` works almost exactly like the `<Form>` we've been using: it calls the action and then all data is revalidated automatically — even your errors will be caught the same way.

There is one key difference though, it's not a navigation, so the URL doesn't change and the history stack is unaffected.

[](#optimistic-ui)Optimistic UI
-------------------------------

You probably noticed the app felt kind of unresponsive when we clicked the favorite button from the last section. Once again, we added some network latency because you're going to have it in the real world.

To give the user some feedback, we could put the star into a loading state with `fetcher.state` (a lot like `navigation.state` from before), but we can do something even better this time. We can use a strategy called "Optimistic UI".

The fetcher knows the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) being submitted to the `action`, so it's available to you on `fetcher.formData`. We'll use that to immediately update the star's state, even though the network hasn't finished. If the update eventually fails, the UI will revert to the real data.

👉 **Read the optimistic value from `fetcher.formData`**

    // existing code
    
    function Favorite({
      contact,
    }: {
      contact: Pick<ContactRecord, "favorite">;
    }) {
      const fetcher = useFetcher();
      const favorite = fetcher.formData
        ? fetcher.formData.get("favorite") === "true"
        : contact.favorite;
    
      return (
        <fetcher.Form method="post">
          <button
            aria-label={
              favorite
                ? "Remove from favorites"
                : "Add to favorites"
            }
            name="favorite"
            value={favorite ? "false" : "true"}
          >
            {favorite ? "★" : "☆"}
          </button>
        </fetcher.Form>
      );
    }
    

Now the star _immediately_ changes to the new state when you click it.

* * *

That's it! Thanks for giving React Router a shot. We hope this tutorial gives you a solid start to build great user experiences. There's a lot more you can do, so make sure to check out all the [APIs](https://api.reactrouter.com/v7/modules/react_router) 😀

[](#client-data)Client Data
===========================

You can fetch and mutate data directly in the browser using `clientLoader` and `clientAction` functions.

These functions are the primary mechanism for data handling when using [SPA mode](../how-to/spa). This guide demonstrates common use cases for leveraging client data in Server-Side Rendering (SSR).

[](#skip-the-server-hop)Skip the Server Hop
-------------------------------------------

When using React Router with a Backend-For-Frontend (BFF) architecture, you might want to bypass the React Router server and communicate directly with your backend API. This approach requires proper authentication handling and assumes no CORS restrictions. Here's how to implement this:

1.  Load the data from server `loader` on the document load
2.  Load the data from the `clientLoader` on all subsequent loads

In this scenario, React Router will _not_ call the `clientLoader` on hydration - and will only call it on subsequent navigations.

    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const data = await fetchApiFromServer({ request }); // (1)
      return data;
    }
    
    export async function clientLoader({
      request,
    }: Route.ClientLoaderArgs) {
      const data = await fetchApiFromClient({ request }); // (2)
      return data;
    }
    

[](#fullstack-state)Fullstack State
-----------------------------------

Sometimes you need to combine data from both the server and browser (like IndexedDB or browser SDKs) before rendering a component. Here's how to implement this pattern:

1.  Load the partial data from server `loader` on the document load
2.  Export a [`HydrateFallback`](../start/framework/route-module#hydratefallback) component to render during SSR because we don't yet have a full set of data
3.  Set `clientLoader.hydrate = true`, this instructs React Router to call the clientLoader as part of initial document hydration
4.  Combine the server data with the client data in `clientLoader`

    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const partialData = await getPartialDataFromDb({
        request,
      }); // (1)
      return partialData;
    }
    
    export async function clientLoader({
      request,
      serverLoader,
    }: Route.ClientLoaderArgs) {
      const [serverData, clientData] = await Promise.all([
        serverLoader(),
        getClientData(request),
      ]);
      return {
        ...serverData, // (4)
        ...clientData, // (4)
      };
    }
    clientLoader.hydrate = true as const; // (3)
    
    export function HydrateFallback() {
      return <p>Skeleton rendered during SSR</p>; // (2)
    }
    
    export default function Component({
      // This will always be the combined set of server + client data
      loaderData,
    }: Route.ComponentProps) {
      return <>...</>;
    }
    

[](#choosing-server-or-client-data-loading)Choosing Server or Client Data Loading
---------------------------------------------------------------------------------

You can mix data loading strategies across your application, choosing between server-only or client-only data loading for each route. Here's how to implement both approaches:

1.  Export a `loader` when you want to use server data
2.  Export `clientLoader` and a `HydrateFallback` when you want to use client data

A route that only depends on a server loader looks like this:

    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const data = await getServerData(request);
      return data;
    }
    
    export default function Component({
      loaderData, // (1) - server data
    }: Route.ComponentProps) {
      return <>...</>;
    }
    

A route that only depends on a client loader looks like this.

    export async function clientLoader({
      request,
    }: Route.ClientLoaderArgs) {
      const clientData = await getClientData(request);
      return clientData;
    }
    // Note: you do not have to set this explicitly - it is implied if there is no `loader`
    clientLoader.hydrate = true;
    
    // (2)
    export function HydrateFallback() {
      return <p>Skeleton rendered during SSR</p>;
    }
    
    export default function Component({
      loaderData, // (2) - client data
    }: Route.ComponentProps) {
      return <>...</>;
    }
    

[](#client-side-caching)Client-Side Caching
-------------------------------------------

You can implement client-side caching (using memory, localStorage, etc.) to optimize server requests. Here's a pattern that demonstrates cache management:

1.  Load the data from server `loader` on the document load
2.  Set `clientLoader.hydrate = true` to prime the cache
3.  Load subsequent navigations from the cache via `clientLoader`
4.  Invalidate the cache in your `clientAction`

Note that since we are not exporting a `HydrateFallback` component, we will SSR the route component and then run the `clientLoader` on hydration, so it's important that your `loader` and `clientLoader` return the same data on initial load to avoid hydration errors.

    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const data = await getDataFromDb({ request }); // (1)
      return data;
    }
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      await saveDataToDb({ request });
      return { ok: true };
    }
    
    let isInitialRequest = true;
    
    export async function clientLoader({
      request,
      serverLoader,
    }: Route.ClientLoaderArgs) {
      const cacheKey = generateKey(request);
    
      if (isInitialRequest) {
        isInitialRequest = false;
        const serverData = await serverLoader();
        cache.set(cacheKey, serverData); // (2)
        return serverData;
      }
    
      const cachedData = await cache.get(cacheKey);
      if (cachedData) {
        return cachedData; // (3)
      }
    
      const serverData = await serverLoader();
      cache.set(cacheKey, serverData);
      return serverData;
    }
    clientLoader.hydrate = true; // (2)
    
    export async function clientAction({
      request,
      serverAction,
    }: Route.ClientActionArgs) {
      const cacheKey = generateKey(request);
      cache.delete(cacheKey); // (4)
      const serverData = await serverAction();
      return serverData;
    }
    

[](#error-boundaries)Error Boundaries
=====================================

To avoid rendering an empty page to users, route modules will automatically catch errors in your code and render the closest `ErrorBoundary`.

Error boundaries are not intended for error reporting or rendering form validation errors. Please see [Form Validation](./form-validation) and [Error Reporting](./error-reporting) instead.

[](#1-add-a-root-error-boundary)1\. Add a root error boundary
-------------------------------------------------------------

All applications should at a minimum export a root error boundary. This one handles the three main cases:

*   Thrown `data` with a status code and text
*   Instances of errors with a stack trace
*   Randomly thrown values

    import { Route } from "./+types/root";
    
    export function ErrorBoundary({
      error,
    }: Route.ErrorBoundaryProps) {
      if (isRouteErrorResponse(error)) {
        return (
          <>
            <h1>
              {error.status} {error.statusText}
            </h1>
            <p>{error.data}</p>
          </>
        );
      } else if (error instanceof Error) {
        return (
          <div>
            <h1>Error</h1>
            <p>{error.message}</p>
            <p>The stack trace is:</p>
            <pre>{error.stack}</pre>
          </div>
        );
      } else {
        return <h1>Unknown Error</h1>;
      }
    }
    

[](#2-write-a-bug)2\. Write a bug
---------------------------------

It's not recommended to intentionally throw errors to force the error boundary to render as a means of control flow. Error Boundaries are primarily for catching unintentional errors in your code.

    export async function loader() {
      return undefined();
    }
    

This will render the `instanceof Error` branch of the UI from step 1.

This is not just for loaders, but for all route module APIs: loaders, actions, components, headers, links, and meta.

[](#3-throw-data-in-loadersactions)3\. Throw data in loaders/actions
--------------------------------------------------------------------

There are exceptions to the rule in #2, especially 404s. You can intentionally `throw data()` (with a proper status code) to the closest error boundary when your loader can't find what it needs to render the page. Throw a 404 and move on.

    import { data } from "react-router";
    
    export async function loader({ params }) {
      let record = await fakeDb.getRecord(params.id);
      if (!record) {
        throw data("Record Not Found", { status: 404 });
      }
      return record;
    }
    

This will render the `isRouteErrorResponse` branch of the UI from step 1.

[](#4-nested-error-boundaries)4\. Nested error boundaries
---------------------------------------------------------

When an error is thrown, the "closest error boundary" will be rendered. Consider these nested routes:

    // ✅ has error boundary
    route("/app", "app.tsx", [
      // ❌ no error boundary
      route("invoices", "invoices.tsx", [
        // ✅ has error boundary
        route("invoices/:id", "invoice-page.tsx", [
          // ❌ no error boundary
          route("payments", "payments.tsx"),
        ]),
      ]),
    ]);
    

The following table shows which error boundary will render given the origin of the error:

error origin

rendered boundary

app.tsx

app.tsx

invoices.tsx

app.tsx

invoice-page.tsx

invoice-page.tsx

payments.tsx

invoice-page.tsx

[](#error-sanitization)Error Sanitization
-----------------------------------------

In production mode, any errors that happen on the server are automatically sanitized before being sent to the browser to prevent leaking any sensitive server information (like stack traces).

This means that a thrown `Error` will have a generic message and no stack trace in production in the browser. The original error is untouched on the server.

Also note that data sent with `throw data(yourData)` is not sanitized as the data there is intended to be rendered.

[](#error-reporting)Error Reporting
===================================

React Router catches errors in your route modules and sends them to [error boundaries](./error-boundary) to prevent blank pages when errors occur. However, ErrorBoundary isn't sufficient for logging and reporting errors. To access these caught errors, use the handleError export of the server entry module.

[](#1-reveal-the-server-entry)1\. Reveal the server entry
---------------------------------------------------------

If you don't see `entry.server.tsx` in your app directory, you're using a default entry. Reveal it with this cli command:

    react-router reveal
    

[](#2-export-your-error-handler)2\. Export your error handler
-------------------------------------------------------------

This function is called whenever React Router catches an error in your application on the server.

    import { type HandleErrorFunction } from "react-router";
    
    export const handleError: HandleErrorFunction = (
      error,
      { request }
    ) => {
      // React Router may abort some interrupted requests, don't log those
      if (!request.signal.aborted) {
        myReportError(error);
    
        // make sure to still log the error so you can see it
        console.error(error);
      }
    };
    

[](#using-fetchers)Using Fetchers
=================================

Fetchers are useful for creating complex, dynamic user interfaces that require multiple, concurrent data interactions without causing a navigation.

Fetchers track their own, independent state and can be used to load data, mutate data, submit forms, and generally interact with loaders and actions.

[](#calling-actions)Calling Actions
-----------------------------------

The most common case for a fetcher is to submit data to an action, triggering a revalidation of route data. Consider the following route module:

    import { useLoaderData } from "react-router";
    
    export async function clientLoader({ request }) {
      let title = localStorage.getItem("title") || "No Title";
      return { title };
    }
    
    export default function Component() {
      let data = useLoaderData();
      return (
        <div>
          <h1>{data.title}</h1>
        </div>
      );
    }
    

### [](#1-add-an-action)1\. Add an action

First we'll add an action to the route for the fetcher to call:

    import { useLoaderData } from "react-router";
    
    export async function clientLoader({ request }) {
      // ...
    }
    
    export async function clientAction({ request }) {
      await new Promise((res) => setTimeout(res, 1000));
      let data = await request.formData();
      localStorage.setItem("title", data.get("title"));
      return { ok: true };
    }
    
    export default function Component() {
      let data = useLoaderData();
      // ...
    }
    

### [](#2-create-a-fetcher)2\. Create a fetcher

Next create a fetcher and render a form with it:

    import { useLoaderData, useFetcher } from "react-router";
    
    // ...
    
    export default function Component() {
      let data = useLoaderData();
      let fetcher = useFetcher();
      return (
        <div>
          <h1>{data.title}</h1>
    
          <fetcher.Form method="post">
            <input type="text" name="title" />
          </fetcher.Form>
        </div>
      );
    }
    

### [](#3-submit-the-form)3\. Submit the form

If you submit the form now, the fetcher will call the action and revalidate the route data automatically.

### [](#4-render-pending-state)4\. Render pending state

Fetchers make their state available during the async work so you can render pending UI the moment the user interacts:

    export default function Component() {
      let data = useLoaderData();
      let fetcher = useFetcher();
      return (
        <div>
          <h1>{data.title}</h1>
    
          <fetcher.Form method="post">
            <input type="text" name="title" />
            {fetcher.state !== "idle" && <p>Saving...</p>}
          </fetcher.Form>
        </div>
      );
    }
    

### [](#5-optimistic-ui)5\. Optimistic UI

Sometimes there's enough information in the form to render the next state immediately. You can access the form data with `fetcher.formData`:

    export default function Component() {
      let data = useLoaderData();
      let fetcher = useFetcher();
      let title = fetcher.formData?.get("title") || data.title;
    
      return (
        <div>
          <h1>{title}</h1>
    
          <fetcher.Form method="post">
            <input type="text" name="title" />
            {fetcher.state !== "idle" && <p>Saving...</p>}
          </fetcher.Form>
        </div>
      );
    }
    

### [](#6-fetcher-data-and-validation)6\. Fetcher Data and Validation

Data returned from an action is available in the fetcher's `data` property. This is primarily useful for returning error messages to the user for a failed mutation:

    // ...
    
    export async function clientAction({ request }) {
      await new Promise((res) => setTimeout(res, 1000));
      let data = await request.formData();
    
      let title = data.get("title") as string;
      if (title.trim() === "") {
        return { ok: false, error: "Title cannot be empty" };
      }
    
      localStorage.setItem("title", title);
      return { ok: true, error: null };
    }
    
    export default function Component() {
      let data = useLoaderData();
      let fetcher = useFetcher();
      let title = fetcher.formData?.get("title") || data.title;
    
      return (
        <div>
          <h1>{title}</h1>
    
          <fetcher.Form method="post">
            <input type="text" name="title" />
            {fetcher.state !== "idle" && <p>Saving...</p>}
            {fetcher.data?.error && (
              <p style={{ color: "red" }}>
                {fetcher.data.error}
              </p>
            )}
          </fetcher.Form>
        </div>
      );
    }
    

[](#loading-data)Loading Data
-----------------------------

Another common use case for fetchers is to load data from a route for something like a combobox.

### [](#1-create-a-search-route)1\. Create a search route

Consider the following route with a very basic search:

    // { path: '/search-users', filename: './search-users.tsx' }
    const users = [
      { id: 1, name: "Ryan" },
      { id: 2, name: "Michael" },
      // ...
    ];
    
    export async function loader({ request }) {
      await new Promise((res) => setTimeout(res, 300));
      let url = new URL(request.url);
      let query = url.searchParams.get("q");
      return users.filter((user) =>
        user.name.toLowerCase().includes(query.toLowerCase())
      );
    }
    

### [](#2-render-a-fetcher-in-a-combobox-component)2\. Render a fetcher in a combobox component

    import { useFetcher } from "react-router";
    
    export function UserSearchCombobox() {
      let fetcher = useFetcher();
      return (
        <div>
          <fetcher.Form method="get" action="/search-users">
            <input type="text" name="q" />
          </fetcher.Form>
        </div>
      );
    }
    

*   The action points to the route we created above: "/search-users"
*   The name of the input is "q" to match the query parameter

### [](#3-add-type-inference)3\. Add type inference

    import { useFetcher } from "react-router";
    import type { loader } from "./search-users";
    
    export function UserSearchCombobox() {
      let fetcher = useFetcher<typeof loader>();
      // ...
    }
    

Ensure you use `import type` so you only import the types.

### [](#4-render-the-data)4\. Render the data

    import { useFetcher } from "react-router";
    
    export function UserSearchCombobox() {
      let fetcher = useFetcher<typeof loader>();
      return (
        <div>
          <fetcher.Form method="get" action="/search-users">
            <input type="text" name="q" />
          </fetcher.Form>
          {fetcher.data && (
            <ul>
              {fetcher.data.map((user) => (
                <li key={user.id}>{user.name}</li>
              ))}
            </ul>
          )}
        </div>
      );
    }
    

Note you will need to hit "enter" to submit the form and see the results.

### [](#5-render-a-pending-state)5\. Render a pending state

    import { useFetcher } from "react-router";
    
    export function UserSearchCombobox() {
      let fetcher = useFetcher<typeof loader>();
      return (
        <div>
          <fetcher.Form method="get" action="/search-users">
            <input type="text" name="q" />
          </fetcher.Form>
          {fetcher.data && (
            <ul
              style={{
                opacity: fetcher.state === "idle" ? 1 : 0.25,
              }}
            >
              {fetcher.data.map((user) => (
                <li key={user.id}>{user.name}</li>
              ))}
            </ul>
          )}
        </div>
      );
    }
    

### [](#6-search-on-user-input)6\. Search on user input

Fetchers can be submitted programmatically with `fetcher.submit`:

    <fetcher.Form method="get" action="/search-users">
      <input
        type="text"
        name="q"
        onChange={(event) => {
          fetcher.submit(event.currentTarget.form);
        }}
      />
    </fetcher.Form>
    

Note the input event's form is passed as the first argument to `fetcher.submit`. The fetcher will use that form to submit the request, reading its attributes and serializing the data from its elements.

[](#file-route-conventions)File Route Conventions
=================================================

The `@react-router/fs-routes` package enables file-convention based route config.

[](#setting-up)Setting up
-------------------------

First install the `@react-router/fs-routes` package:

    npm i @react-router/fs-routes
    

Then use it to provide route config in your `app/routes.ts` file:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default flatRoutes() satisfies RouteConfig;
    

Any modules in the `app/routes` directory will become routes in your application by default. The `ignoredRouteFiles` option allows you to specify files that should not be included as routes:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default flatRoutes({
      ignoredRouteFiles: ["home.tsx"],
    }) satisfies RouteConfig;
    

This will look for routes in the `app/routes` directory by default, but this can be configured via the `rootDirectory` option which is relative to your app directory:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default flatRoutes({
      rootDirectory: "file-routes",
    }) satisfies RouteConfig;
    

The rest of this guide will assume you're using the default `app/routes` directory.

[](#basic-routes)Basic Routes
-----------------------------

The filename maps to the route's URL pathname, except for `_index.tsx` which is the [index route](../start/framework/routing#index-routes) for the [root route](../start/framework/route-module). You can use `.js`, `.jsx`, `.ts` or `.tsx` file extensions.

    app/
    ├── routes/
    │   ├── _index.tsx
    │   └── about.tsx
    └── root.tsx
    

URL

Matched Routes

`/`

`app/routes/_index.tsx`

`/about`

`app/routes/about.tsx`

Note that these routes will be rendered in the outlet of `app/root.tsx` because of [nested routing](../start/framework/routing#nested-routes).

[](#dot-delimiters)Dot Delimiters
---------------------------------

Adding a `.` to a route filename will create a `/` in the URL.

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── about.tsx
    │   ├── concerts.trending.tsx
    │   ├── concerts.salt-lake-city.tsx
    │   └── concerts.san-diego.tsx
    └── root.tsx
    

URL

Matched Route

`/`

`app/routes/_index.tsx`

`/about`

`app/routes/about.tsx`

`/concerts/trending`

`app/routes/concerts.trending.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.salt-lake-city.tsx`

`/concerts/san-diego`

`app/routes/concerts.san-diego.tsx`

The dot delimiter also creates nesting, see the [nesting section](#nested-routes) for more information.

[](#dynamic-segments)Dynamic Segments
-------------------------------------

Usually your URLs aren't static but data-driven. Dynamic segments allow you to match segments of the URL and use that value in your code. You create them with the `$` prefix.

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── about.tsx
    │   ├── concerts.$city.tsx
    │   └── concerts.trending.tsx
    └── root.tsx
    

URL

Matched Route

`/`

`app/routes/_index.tsx`

`/about`

`app/routes/about.tsx`

`/concerts/trending`

`app/routes/concerts.trending.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.$city.tsx`

`/concerts/san-diego`

`app/routes/concerts.$city.tsx`

The value will be parsed from the URL and passed to various APIs. We call these values "URL Parameters". The most useful places to access the URL params are in [loaders](../start/framework/data-loading) and [actions](../start/framework/actions).

    export async function serverLoader({ params }) {
      return fakeDb.getAllConcertsForCity(params.city);
    }
    

You'll note the property name on the `params` object maps directly to the name of your file: `$city.tsx` becomes `params.city`.

Routes can have multiple dynamic segments, like `concerts.$city.$date`, both are accessed on the params object by name:

    export async function serverLoader({ params }) {
      return fake.db.getConcerts({
        date: params.date,
        city: params.city,
      });
    }
    

See the [routing guide](../start/framework/routing) for more information.

[](#nested-routes)Nested Routes
-------------------------------

Nested Routing is the general idea of coupling segments of the URL to component hierarchy and data. You can read more about it in the [Routing Guide](../start/framework/routing#nested-routes).

You create nested routes with [dot delimiters](#dot-delimiters). If the filename before the `.` matches another route filename, it automatically becomes a child route to the matching parent. Consider these routes:

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── about.tsx
    │   ├── concerts._index.tsx
    │   ├── concerts.$city.tsx
    │   ├── concerts.trending.tsx
    │   └── concerts.tsx
    └── root.tsx
    

All the routes that start with `app/routes/concerts.` will be child routes of `app/routes/concerts.tsx` and render inside the [parent route's outlet](../start/framework/routing#nested-routes).

URL

Matched Route

Layout

`/`

`app/routes/_index.tsx`

`app/root.tsx`

`/about`

`app/routes/about.tsx`

`app/root.tsx`

`/concerts`

`app/routes/concerts._index.tsx`

`app/routes/concerts.tsx`

`/concerts/trending`

`app/routes/concerts.trending.tsx`

`app/routes/concerts.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.$city.tsx`

`app/routes/concerts.tsx`

Note you typically want to add an index route when you add nested routes so that something renders inside the parent's outlet when users visit the parent URL directly.

For example, if the URL is `/concerts/salt-lake-city` then the UI hierarchy will look like this:

    <Root>
      <Concerts>
        <City />
      </Concerts>
    </Root>
    

[](#nested-urls-without-layout-nesting)Nested URLs without Layout Nesting
-------------------------------------------------------------------------

Sometimes you want the URL to be nested, but you don't want the automatic layout nesting. You can opt out of nesting with a trailing underscore on the parent segment:

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── about.tsx
    │   ├── concerts.$city.tsx
    │   ├── concerts.trending.tsx
    │   ├── concerts.tsx
    │   └── concerts_.mine.tsx
    └── root.tsx
    

URL

Matched Route

Layout

`/`

`app/routes/_index.tsx`

`app/root.tsx`

`/about`

`app/routes/about.tsx`

`app/root.tsx`

`/concerts/mine`

`app/routes/concerts_.mine.tsx`

`app/root.tsx`

`/concerts/trending`

`app/routes/concerts.trending.tsx`

`app/routes/concerts.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.$city.tsx`

`app/routes/concerts.tsx`

Note that `/concerts/mine` does not nest with `app/routes/concerts.tsx` anymore, but `app/root.tsx`. The `trailing_` underscore creates a path segment, but it does not create layout nesting.

Think of the `trailing_` underscore as the long bit at the end of your parent's signature, writing you out of the will, removing the segment that follows from the layout nesting.

[](#nested-layouts-without-nested-urls)Nested Layouts without Nested URLs
-------------------------------------------------------------------------

We call these **Pathless Routes**

Sometimes you want to share a layout with a group of routes without adding any path segments to the URL. A common example is a set of authentication routes that have a different header/footer than the public pages or the logged in app experience. You can do this with a `_leading` underscore.

     app/
    ├── routes/
    │   ├── _auth.login.tsx
    │   ├── _auth.register.tsx
    │   ├── _auth.tsx
    │   ├── _index.tsx
    │   ├── concerts.$city.tsx
    │   └── concerts.tsx
    └── root.tsx
    

URL

Matched Route

Layout

`/`

`app/routes/_index.tsx`

`app/root.tsx`

`/login`

`app/routes/_auth.login.tsx`

`app/routes/_auth.tsx`

`/register`

`app/routes/_auth.register.tsx`

`app/routes/_auth.tsx`

`/concerts`

`app/routes/concerts.tsx`

`app/routes/concerts.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.$city.tsx`

`app/routes/concerts.tsx`

Think of the `_leading` underscore as a blanket you're pulling over the filename, hiding the filename from the URL.

[](#optional-segments)Optional Segments
---------------------------------------

Wrapping a route segment in parentheses will make the segment optional.

     app/
    ├── routes/
    │   ├── ($lang)._index.tsx
    │   ├── ($lang).$productId.tsx
    │   └── ($lang).categories.tsx
    └── root.tsx
    

URL

Matched Route

`/`

`app/routes/($lang)._index.tsx`

`/categories`

`app/routes/($lang).categories.tsx`

`/en/categories`

`app/routes/($lang).categories.tsx`

`/fr/categories`

`app/routes/($lang).categories.tsx`

`/american-flag-speedo`

`app/routes/($lang)._index.tsx`

`/en/american-flag-speedo`

`app/routes/($lang).$productId.tsx`

`/fr/american-flag-speedo`

`app/routes/($lang).$productId.tsx`

You may wonder why `/american-flag-speedo` is matching the `($lang)._index.tsx` route instead of `($lang).$productId.tsx`. This is because when you have an optional dynamic param segment followed by another dynamic param, it cannot reliably be determined if a single-segment URL such as `/american-flag-speedo` should match `/:lang` `/:productId`. Optional segments match eagerly and thus it will match `/:lang`. If you have this type of setup it's recommended to look at `params.lang` in the `($lang)._index.tsx` loader and redirect to `/:lang/american-flag-speedo` for the current/default language if `params.lang` is not a valid language code.

[](#splat-routes)Splat Routes
-----------------------------

While [dynamic segments](#dynamic-segments) match a single path segment (the stuff between two `/` in a URL), a splat route will match the rest of a URL, including the slashes.

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── $.tsx
    │   ├── about.tsx
    │   └── files.$.tsx
    └── root.tsx
    

URL

Matched Route

`/`

`app/routes/_index.tsx`

`/about`

`app/routes/about.tsx`

`/beef/and/cheese`

`app/routes/$.tsx`

`/files`

`app/routes/files.$.tsx`

`/files/talks/react-conf_old.pdf`

`app/routes/files.$.tsx`

`/files/talks/react-conf_final.pdf`

`app/routes/files.$.tsx`

`/files/talks/react-conf-FINAL-MAY_2024.pdf`

`app/routes/files.$.tsx`

Similar to dynamic route parameters, you can access the value of the matched path on the splat route's `params` with the `"*"` key.

    export async function serverLoader({ params }) {
      const filePath = params["*"];
      return fake.getFileInfo(filePath);
    }
    

[](#escaping-special-characters)Escaping Special Characters
-----------------------------------------------------------

If you want one of the special characters used for these route conventions to actually be a part of the URL, you can escape the conventions with `[]` characters. This can be especially helpful for [resource routes](../how-to/resource-routes) that include an extension in the URL.

Filename

URL

`app/routes/sitemap[.]xml.tsx`

`/sitemap.xml`

`app/routes/[sitemap.xml].tsx`

`/sitemap.xml`

`app/routes/weird-url.[_index].tsx`

`/weird-url/_index`

`app/routes/dolla-bills-[$].tsx`

`/dolla-bills-$`

`app/routes/[[so-weird]].tsx`

`/[so-weird]`

`app/routes/reports.$id[.pdf].ts`

`/reports/123.pdf`

[](#folders-for-organization)Folders for Organization
-----------------------------------------------------

Routes can also be folders with a `route.tsx` file inside defining the route module. The rest of the files in the folder will not become routes. This allows you to organize your code closer to the routes that use them instead of repeating the feature names across other folders.

The files inside a folder have no meaning for the route paths, the route path is completely defined by the folder name.

Consider these routes:

     app/
    ├── routes/
    │   ├── _landing._index.tsx
    │   ├── _landing.about.tsx
    │   ├── _landing.tsx
    │   ├── app._index.tsx
    │   ├── app.projects.tsx
    │   ├── app.tsx
    │   └── app_.projects.$id.roadmap.tsx
    └── root.tsx
    

Some, or all of them can be folders holding their own `route` module inside.

    app/
    ├── routes/
    │   ├── _landing._index/
    │   │   ├── route.tsx
    │   │   └── scroll-experience.tsx
    │   ├── _landing.about/
    │   │   ├── employee-profile-card.tsx
    │   │   ├── get-employee-data.server.ts
    │   │   ├── route.tsx
    │   │   └── team-photo.jpg
    │   ├── _landing/
    │   │   ├── footer.tsx
    │   │   ├── header.tsx
    │   │   └── route.tsx
    │   ├── app._index/
    │   │   ├── route.tsx
    │   │   └── stats.tsx
    │   ├── app.projects/
    │   │   ├── get-projects.server.ts
    │   │   ├── project-buttons.tsx
    │   │   ├── project-card.tsx
    │   │   └── route.tsx
    │   ├── app/
    │   │   ├── footer.tsx
    │   │   ├── primary-nav.tsx
    │   │   └── route.tsx
    │   ├── app_.projects.$id.roadmap/
    │   │   ├── chart.tsx
    │   │   ├── route.tsx
    │   │   └── update-timeline.server.ts
    │   └── contact-us.tsx
    └── root.tsx
    

Note that when you turn a route module into a folder, the route module becomes `folder/route.tsx`, all other modules in the folder will not become routes. For example:

    # these are the same route:
    app/routes/app.tsx
    app/routes/app/route.tsx
    
    # as are these
    app/routes/app._index.tsx
    app/routes/app._index/route.tsx
    

[](#file-uploads)File Uploads
=============================

Handle file uploads in your React Router applications. This guide uses some packages from the [Remix The Web](https://github.com/mjackson/remix-the-web) project to make file uploads easier.

_Thank you to David Adams for [writing an original guide](https://programmingarehard.com/2024/09/06/remix-file-uploads-updated.html/) on which this doc is based. You can refer to it for even more examples._

[](#basic-file-upload)Basic File Upload
---------------------------------------

### [](#1-setup-some-routes)1\. Setup some routes

You can setup your routes however you like. This example uses the following structure:

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      // ... other routes
      route("user/:id", "pages/user-profile.tsx", [
        route("avatar", "api/avatar.tsx"),
      ]),
    ] satisfies RouteConfig;
    

### [](#2-add-the-form-data-parser)2\. Add the form data parser

`form-data-parser` is a wrapper around `request.formData()` that provides streaming support for handling file uploads.

    npm i @mjackson/form-data-parser
    

[See the `form-data-parser` docs for more information](https://github.com/mjackson/remix-the-web/tree/main/packages/form-data-parser)

### [](#3-create-a-route-with-an-upload-action)3\. Create a route with an upload action

The `parseFormData` function takes an `uploadHandler` function as an argument. This function will be called for each file upload in the form.

You must set the form's `enctype` to `multipart/form-data` for file uploads to work.

    import {
      type FileUpload,
      parseFormData,
    } from "@mjackson/form-data-parser";
    
    export async function action({
      request,
    }: ActionFunctionArgs) {
      const uploadHandler = async (fileUpload: FileUpload) => {
        if (fileUpload.fieldName === "avatar") {
          // process the upload and return a File
        }
      };
    
      const formData = await parseFormData(
        request,
        uploadHandler
      );
      // 'avatar' has already been processed at this point
      const file = formData.get("avatar");
    }
    
    export default function Component() {
      return (
        <form method="post" encType="multipart/form-data">
          <input type="file" name="avatar" />
          <button>Submit</button>
        </form>
      );
    }
    

[](#local-storage-implementation)Local Storage Implementation
-------------------------------------------------------------

### [](#1-add-the-storage-package)1\. Add the storage package

`file-storage` is a key/value interface for storing [File objects](https://developer.mozilla.org/en-US/docs/Web/API/File) in JavaScript. Similar to how `localStorage` allows you to store key/value pairs of strings in the browser, file-storage allows you to store key/value pairs of files on the server.

    npm i @mjackson/file-storage
    

[See the `file-storage` docs for more information](https://github.com/mjackson/remix-the-web/tree/main/packages/file-storage)

### [](#2-create-a-storage-configuration)2\. Create a storage configuration

Create a file that exports a `LocalFileStorage` instance to be used by different routes.

    import { LocalFileStorage } from "@mjackson/file-storage/local";
    
    export const fileStorage = new LocalFileStorage(
      "./uploads/avatars"
    );
    
    export function getStorageKey(userId: string) {
      return `user-${userId}-avatar`;
    }
    

### [](#3-implement-the-upload-handler)3\. Implement the upload handler

Update the form's `action` to store files in the `fileStorage` instance.

    import {
      type FileUpload,
      parseFormData,
    } from "@mjackson/form-data-parser";
    import {
      fileStorage,
      getStorageKey,
    } from "~/avatar-storage.server";
    import type { Route } from "./+types/user-profile";
    
    export async function action({
      request,
      params,
    }: Route.ActionArgs) {
      async function uploadHandler(fileUpload: FileUpload) {
        if (
          fileUpload.fieldName === "avatar" &&
          fileUpload.type.startsWith("image/")
        ) {
          let storageKey = getStorageKey(params.id);
    
          // FileUpload objects are not meant to stick around for very long (they are
          // streaming data from the request.body); store them as soon as possible.
          await fileStorage.set(storageKey, fileUpload);
    
          // Return a File for the FormData object. This is a LazyFile that knows how
          // to access the file's content if needed (using e.g. file.stream()) but
          // waits until it is requested to actually read anything.
          return fileStorage.get(storageKey);
        }
      }
    
      const formData = await parseFormData(
        request,
        uploadHandler
      );
    }
    
    export default function UserPage({
      actionData,
      params,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>User {params.id}</h1>
          <form
            method="post"
            // The form's enctype must be set to "multipart/form-data" for file uploads
            encType="multipart/form-data"
          >
            <input type="file" name="avatar" accept="image/*" />
            <button>Submit</button>
          </form>
    
          <img
            src={`/user/${params.id}/avatar`}
            alt="user avatar"
          />
        </div>
      );
    }
    

### [](#4-add-a-route-to-serve-the-uploaded-file)4\. Add a route to serve the uploaded file

Create a [resource route](../how-to/resource-routes) that streams the file as a response.

    import {
      fileStorage,
      getStorageKey,
    } from "~/avatar-storage.server";
    import type { Route } from "./+types/avatar";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const storageKey = getStorageKey(params.id);
      const file = await fileStorage.get(storageKey);
    
      if (!file) {
        throw new Response("User avatar not found", {
          status: 404,
        });
      }
    
      return new Response(file.stream(), {
        headers: {
          "Content-Type": file.type,
          "Content-Disposition": `attachment; filename=${file.name}`,
        },
      });
    }
    

[](#form-validation)Form Validation
===================================

This guide walks through a simple signup form implementation. You will likely want to pair these concepts with third-party validation libraries and error components, but this guide only focuses on the moving pieces for React Router.

[](#1-setting-up)1\. Setting Up
-------------------------------

We'll start by creating a basic signup route with form.

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("signup", "signup.tsx"),
    ] satisfies RouteConfig;
    

    import type { Route } from "./+types/signup";
    import { useFetcher } from "react-router";
    
    export default function Signup(_: Route.ComponentProps) {
      let fetcher = useFetcher();
      return (
        <fetcher.Form method="post">
          <p>
            <input type="email" name="email" />
          </p>
    
          <p>
            <input type="password" name="password" />
          </p>
    
          <button type="submit">Sign Up</button>
        </fetcher.Form>
      );
    }
    

[](#2-defining-the-action)2\. Defining the Action
-------------------------------------------------

In this step, we'll define a server `action` in the same file as our `Signup` component. Note that the aim here is to provide a broad overview of the mechanics involved rather than digging deep into form validation rules or error object structures. We'll use rudimentary checks for the email and password to demonstrate the core concepts.

    import type { Route } from "./+types/signup";
    import { redirect, useFetcher, data } from "react-router";
    
    export default function Signup(_: Route.ComponentProps) {
      // omitted for brevity
    }
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      const formData = await request.formData();
      const email = String(formData.get("email"));
      const password = String(formData.get("password"));
    
      const errors = {};
    
      if (!email.includes("@")) {
        errors.email = "Invalid email address";
      }
    
      if (password.length < 12) {
        errors.password =
          "Password should be at least 12 characters";
      }
    
      if (Object.keys(errors).length > 0) {
        return data({ errors }, { status: 400 });
      }
    
      // Redirect to dashboard if validation is successful
      return redirect("/dashboard");
    }
    

If any validation errors are found, they are returned from the `action` to the fetcher. This is our way of signaling to the UI that something needs to be corrected, otherwise the user will be redirected to the dashboard.

Note the `data({ errors }, { status: 400 })` call. Setting a 400 status is the web standard way to signal to the client that there was a validation error (Bad Request). In React Router, only 200 status codes trigger page data revalidation so a 400 prevent that.

[](#3-displaying-validation-errors)3\. Displaying Validation Errors
-------------------------------------------------------------------

Finally, we'll modify the `Signup` component to display validation errors, if any, from `fetcher.data`.

    export default function Signup(_: Route.ComponentProps) {
      let fetcher = useFetcher();
      let errors = fetcher.data?.errors;
      return (
        <fetcher.Form method="post">
          <p>
            <input type="email" name="email" />
            {errors?.email ? <em>{errors.email}</em> : null}
          </p>
    
          <p>
            <input type="password" name="password" />
            {errors?.password ? (
              <em>{errors.password}</em>
            ) : null}
          </p>
    
          <button type="submit">Sign Up</button>
        </fetcher.Form>
      );
    }
    

[](#http-headers)HTTP Headers
=============================

Headers are primarily defined with the route module `headers` export. You can also set headers in `entry.server.tsx`.

[](#from-route-modules)From Route Modules
-----------------------------------------

    import { Route } from "./+types/some-route";
    
    export function headers(_: Route.HeadersArgs) {
      return {
        "Content-Security-Policy": "default-src 'self'",
        "X-Frame-Options": "DENY",
        "X-Content-Type-Options": "nosniff",
        "Cache-Control": "max-age=3600, s-maxage=86400",
      };
    }
    

You can return either a [`Headers`](https://developer.mozilla.org/en-US/docs/Web/API/Headers) instance or `HeadersInit`.

[](#from-loaders-and-actions)From loaders and actions
-----------------------------------------------------

When the header is dependent on loader data, loaders and actions can also set headers.

### [](#1-wrap-your-return-value-in-data)1\. Wrap your return value in `data`

    import { data } from "react-router";
    
    export async function loader({ params }: LoaderArgs) {
      let [page, ms] = await fakeTimeCall(
        await getPage(params.id)
      );
    
      return data(page, {
        headers: {
          "Server-Timing": `page;dur=${ms};desc="Page query"`,
        },
      });
    }
    

### [](#2-return-from-headers-export)2\. Return from `headers` export

Headers from loaders and actions are not sent automatically. You must explicitly return them from the `headers` export.

    export function headers({
      actionHeaders,
      loaderHeaders,
    }: HeadersArgs) {
      return actionHeaders ? actionHeaders : loaderHeaders;
    }
    

One notable exception is `Set-Cookie` headers, which are automatically preserved from `headers`, `loader`, and `action` in parent routes, even without exporting `headers` from the child route.

[](#merging-with-parent-headers)Merging with parent headers
-----------------------------------------------------------

Consider these nested routes

    route("pages", "pages-layout-with-nav.tsx", [
      route(":slug", "page.tsx"),
    ]);
    

If both route modules want to set headers, the headers from the deepest matching route will be sent.

When you need to keep both the parent and the child headers, you need to merge them in the child route.

### [](#appending)Appending

The easiest way is to simply append to the parent headers. This avoids overwriting a header the parent may have set and both are important.

    export function headers({ parentHeaders }: HeadersArgs) {
      parentHeaders.append(
        "Permissions-Policy: geolocation=()"
      );
      return parentHeaders;
    }
    

### [](#setting)Setting

Sometimes it's important to overwrite the parent header. Do this with `set` instead of `append`:

    export function headers({ parentHeaders }: HeadersArgs) {
      parentHeaders.set(
        "Cache-Control",
        "max-age=3600, s-maxage=86400"
      );
      return parentHeaders;
    }
    

You can avoid the need to merge headers by only defining headers in "leaf routes" (index routes and child routes without children) and not in parent routes.

[](#from-entryservertsx)From `entry.server.tsx`
-----------------------------------------------

The `handleRequest` export receives the headers from the route module as an argument. You can append global headers here.

    export default function handleRequest(
      request,
      responseStatusCode,
      responseHeaders,
      routerContext,
      loadContext
    ) {
      // set, append global headers
      responseHeaders.set(
        "X-App-Version",
        routerContext.manifest.version
      );
    
      return new Response(await getStream(), {
        headers: responseHeaders,
        status: responseStatusCode,
      });
    }
    

If you don't have an `entry.server.tsx` run the `reveal` command:

    react-router reveal
    

[](#navigation-blocking)Navigation Blocking
===========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#overview)Overview
---------------------

When users are in the middle of a workflow, like filling out an important form, you may want to prevent them from navigating away from the page.

This example will show:

*   Setting up a route with a form and action called with a fetcher
*   Blocking navigation when the form is dirty
*   Showing a confirmation when the user tries to leave the page

[](#1-set-up-a-route-with-a-form)1\. Set up a route with a form
---------------------------------------------------------------

Add a route with the form, we'll use a "contact" route for this example:

    import {
      type RouteConfig,
      index,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      index("routes/home.tsx"),
      route("contact", "routes/contact.tsx"),
    ] satisfies RouteConfig;
    

Add the form to the contact route module:

    import { useFetcher } from "react-router";
    import type { Route } from "./+types/contact";
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      let formData = await request.formData();
      let email = formData.get("email");
      let message = formData.get("message");
      console.log(email, message);
      return { ok: true };
    }
    
    export default function Contact() {
      let fetcher = useFetcher();
    
      return (
        <fetcher.Form method="post">
          <p>
            <label>
              Email: <input name="email" type="email" />
            </label>
          </p>
          <p>
            <textarea name="message" />
          </p>
          <p>
            <button type="submit">
              {fetcher.state === "idle" ? "Send" : "Sending..."}
            </button>
          </p>
        </fetcher.Form>
      );
    }
    

[](#2-add-dirty-state-and-onchange-handler)2\. Add dirty state and onChange handler
-----------------------------------------------------------------------------------

To track the dirty state of the form, we'll use a single boolean and a quick form onChange handler. You may want to track the dirty state differently but this works for this guide.

    export default function Contact() {
      let [isDirty, setIsDirty] = useState(false);
      let fetcher = useFetcher();
    
      return (
        <fetcher.Form
          method="post"
          onChange={(event) => {
            let email = event.currentTarget.email.value;
            let message = event.currentTarget.message.value;
            setIsDirty(Boolean(email || message));
          }}
        >
          {/* existing code */}
        </fetcher.Form>
      );
    }
    

[](#3-block-navigation-when-the-form-is-dirty)3\. Block navigation when the form is dirty
-----------------------------------------------------------------------------------------

    import { useBlocker } from "react-router";
    
    export default function Contact() {
      let [isDirty, setIsDirty] = useState(false);
      let fetcher = useFetcher();
      let blocker = useBlocker(
        useCallback(() => isDirty, [isDirty])
      );
    
      // ... existing code
    }
    

While this will now block a navigation, there's no way for the user to confirm it.

[](#4-show-confirmation-ui)4\. Show confirmation UI
---------------------------------------------------

This uses a simple div, but you may want to use a modal dialog.

    export default function Contact() {
      let [isDirty, setIsDirty] = useState(false);
      let fetcher = useFetcher();
      let blocker = useBlocker(
        useCallback(() => isDirty, [isDirty])
      );
    
      return (
        <fetcher.Form
          method="post"
          onChange={(event) => {
            let email = event.currentTarget.email.value;
            let message = event.currentTarget.message.value;
            setIsDirty(Boolean(email || message));
          }}
        >
          {/* existing code */}
    
          {blocker.state === "blocked" && (
            <div>
              <p>Wait! You didn't send the message yet:</p>
              <p>
                <button
                  type="button"
                  onClick={() => blocker.proceed()}
                >
                  Leave
                </button>{" "}
                <button
                  type="button"
                  onClick={() => blocker.reset()}
                >
                  Stay here
                </button>
              </p>
            </div>
          )}
        </fetcher.Form>
      );
    }
    

If the user clicks "leave" then `blocker.proceed()` will proceed with the navigation. If they click "stay here" then `blocker.reset()` will clear the blocker and keep them on the current page.

[](#5-reset-the-blocker-when-the-action-resolves)5\. Reset the blocker when the action resolves
-----------------------------------------------------------------------------------------------

If the user doesn't click either "leave" or "stay here", then then submits the form, the blocker will still be active. Let's reset the blocker when the action resolves with an effect.

    useEffect(() => {
      if (fetcher.data?.ok) {
        if (blocker.state === "blocked") {
          blocker.reset();
        }
      }
    }, [fetcher.data]);
    

[](#6-clear-the-form-when-the-action-resolves)6\. Clear the form when the action resolves
-----------------------------------------------------------------------------------------

While unrelated to navigation blocking, let's clear the form when the action resolves with a ref.

    let formRef = useRef<HTMLFormElement>(null);
    
    // put it on the form
    <fetcher.Form
      ref={formRef}
      method="post"
      onChange={(event) => {
        // ... existing code
      }}
    >
      {/* existing code */}
    </fetcher.Form>;
    

    useEffect(() => {
      if (fetcher.data?.ok) {
        // clear the form in the effect
        formRef.current?.reset();
        if (blocker.state === "blocked") {
          blocker.reset();
        }
      }
    }, [fetcher.data]);
    

Alternatively, if a navigation is currently blocked, instead of resetting the blocker, you can proceed through to the blocked navigation.

    useEffect(() => {
      if (fetcher.data?.ok) {
        if (blocker.state === "blocked") {
          // proceed with the blocked navigation
          blocker.proceed();
        } else {
          formRef.current?.reset();
        }
      }
    }, [fetcher.data]);
    

In this case the user flow is:

*   User fills out the form
*   User forgets to click "send" and clicks a link instead
*   The navigation is blocked, and the confirmation message is shown
*   Instead of clicking "leave" or "stay here", the user submits the form
*   The user is taken to the requested page

[](#pre-rendering)Pre-Rendering
===============================

Pre-Rendering allows you to speed up page loads for static content by rendering pages at build time instead of at runtime. Pre-rendering is enabled via the `prerender` config in `react-router.config.ts` and can be used in two ways based on the `ssr` config value:

*   Alongside a runtime SSR server with `ssr:true` (the default value)
*   Deployed to a static file server with `ssr:false`

[](#pre-rendering-with-ssrtrue)Pre-rendering with `ssr:true`
------------------------------------------------------------

### [](#configuration)Configuration

Add the `prerender` option to your config, there are three signatures:

    import type { Config } from "@react-router/dev/config";
    
    export default {
      // Can be omitted - defaults to true
      ssr: true,
    
      // all static paths (no dynamic segments like "/post/:slug")
      prerender: true,
    
      // specific paths
      prerender: ["/", "/blog", "/blog/popular-post"],
    
      // async function for dependencies like a CMS
      async prerender({ getStaticPaths }) {
        let posts = await fakeGetPostsFromCMS();
        return [
          "/",
          "/blog",
          ...posts.map((post) => post.href),
        ];
      },
    } satisfies Config;
    

### [](#data-loading-and-pre-rendering)Data Loading and Pre-rendering

There is no extra application API for pre-rendering. Routes being pre-rendered use the same route `loader` functions as server rendering:

    export async function loader({ request, params }) {
      let post = await getPost(params.slug);
      return post;
    }
    
    export function Post({ loaderData }) {
      return <div>{loaderData.title}</div>;
    }
    

Instead of a request coming to your route on a deployed server, the build creates a `new Request()` and runs it through your app just like a server would.

When server rendering, requests to paths that have not been pre-rendered will be server rendered as usual.

### [](#static-file-output)Static File Output

The rendered result will be written out to your `build/client` directory. You'll notice two files for each path:

*   `[url].html` HTML file for initial document requests
*   `[url].data` file for client side navigation browser requests

The output of your build will indicate what files were pre-rendered:

    > react-router build
    vite v5.2.11 building for production...
    ...
    vite v5.2.11 building SSR bundle for production...
    ...
    Prerender: Generated build/client/index.html
    Prerender: Generated build/client/blog.data
    Prerender: Generated build/client/blog/index.html
    Prerender: Generated build/client/blog/my-first-post.data
    Prerender: Generated build/client/blog/my-first-post/index.html
    ...
    

During development, pre-rendering doesn't save the rendered results to the public directory, this only happens for `react-router build`.

[](#pre-rendering-with-ssrfalse)Pre-rendering with `ssr:false`
--------------------------------------------------------------

The above examples assume you are deploying a runtime server but are pre-rendering some static pages to avoid hitting the server, resulting in faster loads.

To disable runtime SSR and configure pre-rendering to be served from a static file server, you can set the `ssr:false` config flag:

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: false, // disable runtime server rendering
      prerender: true, // pre-render all static routes
    } satisfies Config;
    

If you specify `ssr:false` without a `prerender` config, React Router refers to that as [SPA Mode](./spa). In SPA Mode, we render a single HTML file that is capable of hydrating for _any_ of your application paths. It can do this because it only renders the `root` route into the HTML file and then determines which child routes to load based on the browser URL during hydration. This means you can use a `loader` on the root route, but not on any other routes because we don't know which routes to load until hydration in the browser.

If you want to pre-render paths with `ssr:false`, those matched routes _can_ have loaders because we'll pre-render all of the matched routes for those paths, not just the root. You cannot include `actions` or `headers` functions in any routes when `ssr:false` is set because there will be no runtime server to run them on.

### [](#pre-rendering-with-a-spa-fallback)Pre-rendering with a SPA Fallback

If you want `ssr:false` but don't want to pre-render _all_ of your routes - that's fine too! You may have some paths where you need the performance/SEO benefits of pre-rendering, but other pages where a SPA would be fine.

You can do this using the combination of config options as well - just limit your `prerender` config to the paths that you want to pre-render and React Router will also output a "SPA Fallback" HTML file that can be served to hydrate any other paths (using the same approach as [SPA Mode](./spa)).

This will be written to one of the following paths:

*   `build/client/index.html` - If the `/` path is not pre-rendered
*   `build/client/__spa-fallback.html` - If the `/` path is pre-rendered

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
    
      // SPA fallback will be written to build/client/index.html
      prerender: ["/about-us"],
    
      // SPA fallback will be written to build/client/__spa-fallback.html
      prerender: ["/", "/about-us"],
    } satisfies Config;
    

You can configure your deployment server to serve this file for any path that otherwise would 404. Some hosts do this by default, but others don't. As an example, a host may support a `_redirects` file to do this:

    # If you did not pre-render the `/` route
    /*    /index.html   200
    
    # If you pre-rendered the `/` route
    /*    /__spa-fallback.html   200
    

If you're getting 404s at valid routes for your app, it's likely you need to configure your host.

Here's another example of how you can do this with the [`sirv-cli`](https://www.npmjs.com/package/sirv-cli#user-content-single-page-applications) tool:

    # If you did not pre-render the `/` route
    sirv-cli build/client --single index.html
    
    # If you pre-rendered the `/` route
    sirv-cli build/client --single __spa-fallback.html
    

### [](#invalid-exports)Invalid Exports

When pre-rendering with `ssr:false`, React Router will error at build time if you have invalid exports to help prevent some mistakes that can be easily overlooked.

*   `headers`/`action` functions are prohibited in all routes because there will be no runtime server on which to run them
*   When using `ssr:false` without a `prerender` config (SPA Mode), a `loader` is permitted on the root route only
*   When using `ssr:false` with a `prerender` config, a `loader` is permitted on any route matched by a `prerender` path
    *   If you are using a `loader` on a pre-rendered route that has child routes, you will need to make sure the parent `loaderData` can be determined at run-time properly by either:
        *   Pre-rendering all child routes so that the parent `loader` can be called at build-time for each child route path and rendered into a `.data` file, or
        *   Use a `clientLoader` on the parent that can be called at run-time for non-pre-rendered child paths

[](#resource-routes)Resource Routes
===================================

When server rendering, routes can serve "resources" instead of rendering components, like images, PDFs, JSON payloads, webhooks, etc.

[](#defining-a-resource-route)Defining a Resource Route
-------------------------------------------------------

A route becomes a resource route by convention when its module exports a loader or action but does not export a default component.

Consider a route that serves a PDF instead of UI:

    route("/reports/pdf/:id", "pdf-report.ts");
    

    import type { Route } from "./+types/pdf-report";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const report = await getReport(params.id);
      const pdf = await generateReportPDF(report);
      return new Response(pdf, {
        status: 200,
        headers: {
          "Content-Type": "application/pdf",
        },
      });
    }
    

Note there is no default export. That makes this route a resource route.

[](#linking-to-resource-routes)Linking to Resource Routes
---------------------------------------------------------

When linking to resource routes, use `<a>` or `<Link reloadDocument>`, otherwise React Router will attempt to use client side routing and fetching the payload (you'll get a helpful error message if you make this mistake).

    <Link reloadDocument to="/reports/pdf/123">
      View as PDF
    </Link>
    

[](#handling-different-request-methods)Handling different request methods
-------------------------------------------------------------------------

GET requests are handled by the `loader`, while POST, PUT, PATCH, and DELETE are handled by the `action`:

    import type { Route } from "./+types/resource";
    
    export function loader(_: Route.LoaderArgs) {
      return Response.json({ message: "I handle GET" });
    }
    
    export function action(_: Route.ActionArgs) {
      return Response.json({
        message: "I handle everything else",
      });
    }
    

[](#route-module-type-safety)Route Module Type Safety
=====================================================

React Router generates route-specific types to power type inference for URL params, loader data, and more. This guide will help you set it up if you didn't start with a template.

To learn more about how type safety works in React Router, check out [Type Safety Explanation](../explanation/type-safety).

[](#1-add-react-router-to-gitignore)1\. Add `.react-router/` to `.gitignore`
----------------------------------------------------------------------------

React Router generates types into a `.react-router/` directory at the root of your app. This directory is fully managed by React Router and should be gitignore'd.

    .react-router/
    

[](#2-include-the-generated-types-in-tsconfig)2\. Include the generated types in tsconfig
-----------------------------------------------------------------------------------------

Edit your tsconfig to get TypeScript to use the generated types. Additionally, `rootDirs` needs to be configured so the types can be imported as relative siblings to route modules.

    {
      "include": [".react-router/types/**/*"],
      "compilerOptions": {
        "rootDirs": [".", "./.react-router/types"]
      }
    }
    

If you are using multiple `tsconfig` files for your app, you'll need to make these changes in whichever one `include`s your app directory. For example, the [`node-custom-server` template](https://github.com/remix-run/react-router-templates/tree/390fcec476dd336c810280479688fe893da38713/node-custom-server) contains `tsconfig.json`, `tsconfig.node.json`, and `tsconfig.vite.json`. Since `tsconfig.vite.json` is the one that [includes the app directory](https://github.com/remix-run/react-router-templates/blob/390fcec476dd336c810280479688fe893da38713/node-custom-server/tsconfig.vite.json#L4-L6), that's the one that sets up `.react-router/types` for route module type safety.

[](#3-generate-types-before-type-checking)3\. Generate types before type checking
---------------------------------------------------------------------------------

If you want to run type checking as its own command — for example, as part of your Continuous Integration pipeline — you'll need to make sure to generate types _before_ running typechecking:

    {
      "scripts": {
        "typecheck": "react-router typegen && tsc"
      }
    }
    

[](#4-typing-apploadcontext)4\. Typing `AppLoadContext`
-------------------------------------------------------

[](#extending-app-context-types)Extending app `Context` types
-------------------------------------------------------------

To define your app's `context` type, add the following in a `.ts` or `.d.ts` file within your project:

    import "react-router";
    declare module "react-router" {
      interface AppLoadContext {
        // add context properties here
      }
    }
    

[](#5-type-only-auto-imports-optional)5\. Type-only auto-imports (optional)
---------------------------------------------------------------------------

When auto-importing the `Route` type helper, TypeScript will generate:

    import { Route } from "./+types/my-route";
    

But if you enable [verbatimModuleSyntax](https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax):

    {
      "compilerOptions": {
        "verbatimModuleSyntax": true
      }
    }
    

Then, you will get the `type` modifier for the import automatically as well:

    import type { Route } from "./+types/my-route";
    //     ^^^^
    

This helps tools like bundlers to detect type-only module that can be safely excluded from the bundle.

[](#conclusion)Conclusion
-------------------------

React Router's Vite plugin should be automatically generating types into `.react-router/types/` anytime you edit your route config (`routes.ts`). That means all you need to do is run `react-router dev` (or your custom dev server) to get to up-to-date types in your routes.

Check out our [Type Safety Explanation](../explanation/type-safety) for an example of how to pull in those types into your routes.

[](#security)Security
=====================

This is by no means a comprehensive guide, but React Router provides features to help address a few aspects under the _very large_ umbrella that is _Security_.

[](#content-security-policy)`Content-Security-Policy`
-----------------------------------------------------

If you are implementing a [Content-Security-Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP) in your application, specifically one using the `unsafe-inline` directive, you will need to specify a [`nonce`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) attribute on the inline `<script>` elements rendered in your HTML. This must be specified on any API that generates inline scripts, including:

*   [`<Scripts nonce>`](../api/components/Scripts) (`root.tsx`)
*   [`<ScrollRestoration nonce>`](../api/components/ScrollRestoration) (`root.tsx`)
*   [`<ServerRouter nonce>`](../api/components/ServerRouter) (`entry.server.tsx`)
*   [`renderToPipeableStream(..., { nonce })`](https://react.dev/reference/react-dom/server/renderToPipeableStream) (`entry.server.tsx`)
*   [`renderToReadableStream(..., { nonce })`](https://react.dev/reference/react-dom/server/renderToReadableStream) (`entry.server.tsx`)

[](#single-page-app-spa)Single Page App (SPA)
=============================================

There are two ways to ship a single page app with React Router

*   **as a library** - Instead of using React Router's framework features, you can use it as a library in your own SPA architecture. Refer to [React Router as a Library](../start/library/installation) guides.
*   **as a framework** - This guide will focus here

[](#overview)Overview
---------------------

When using React Router as a framework, you can enable "SPA Mode" by setting `ssr:false` in your `react-router.config.ts` file. This will disable runtime server rendering and generate an `index.html` at build time that you can serve and hydrate as a SPA.

Typical Single Page apps send a mostly blank `index.html` template with little more than an empty `<div id="root"></div>`. In contrast, `react-router build` (in SPA Mode) pre-renders your root route at build time into an `index.html` file. This means you can:

*   Send more than an empty `<div>`
*   Use a root `loader` to load data for your application shell
*   Use React components to generate the initial page users see (root `HydrateFallback`)
*   Re-enable server rendering later without changing anything about your UI

It's important to note that setting `ssr:false` only disables _runtime server rendering_. React Router will still server render your root route at _build time_ to generate the `index.html` file. This is why your project still needs a dependency on `@react-router/node` and your routes need to be SSR-safe. That means you can't call `window` or other browser-only APIs during the initial render, even when server rendering is disabled.

SPA Mode is a special form of "Pre-Rendering" that allows you to serve all paths in your application from the same HTML file. Please refer to the [Pre-Rendering](./pre-rendering) guide if you want to do more extensive pre-rendering.

[](#1-disable-runtime-server-rendering)1\. Disable Runtime Server Rendering
---------------------------------------------------------------------------

Server rendering is enabled by default. Set the `ssr` flag to `false` in `react-router.config.ts` to disable it.

    import { type Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
    } satisfies Config;
    

With this set to false, the server build will no longer be generated.

It's important to note that setting `ssr:false` only disables _runtime server rendering_. React Router will still server render your root route at _build time_ to generate the `index.html` file. This is why your project still needs a dependency on `@react-router/node` and your routes need to be SSR-safe. That means you can't call `window` or other browser-only APIs during the initial render, even when server rendering is disabled.

[](#2-add-a-hydratefallback-and-optional-loader-to-your-root-route)2\. Add a `HydrateFallback` and optional `loader` to your root route
---------------------------------------------------------------------------------------------------------------------------------------

SPA Mode will generate an `index.html` file at build-time that you can serve as the entry point for your SPA. This will only render the root route so that it is capable of hydrating at runtime for any path in your application.

To provide a better loading UI than an empty `<div>`, you can add a `HydrateFallback` component to your root route to render your loading UI into the `index.html` at build time. This way, it will be shown to users immediately while the SPA is loading/hydrating.

    import LoadingScreen from "./components/loading-screen";
    
    export function Layout() {
      return <html>{/*...*/}</html>;
    }
    
    export function HydrateFallback() {
      return <LoadingScreen />;
    }
    
    export default function App() {
      return <Outlet />;
    }
    

Because the root route is server-rendered at build time, you can also use a `loader` in your root route if you choose. This `loader` will be called at build time and the data will be available via the optional `HydrateFallback` `loaderData` prop.

    import { Route } from "./+types/root";
    
    export async function loader() {
      return {
        version: await getVersion(),
      };
    }
    
    export function HydrateFallback({
      loaderData,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>Loading version {loaderData.version}...</h1>
          <AwesomeSpinner />
        </div>
      );
    }
    

You cannot include a `loader` in any other routes in your app when using SPA Mode unless you are [pre-rendering those pages](./pre-rendering).

[](#3-use-client-loaders-and-client-actions)3\. Use client loaders and client actions
-------------------------------------------------------------------------------------

With server rendering disabled, you can still use `clientLoader` and `clientAction` to manage route data and mutations.

    import { Route } from "./+types/some-route";
    
    export async function clientLoader({
      params,
    }: Route.ClientLoaderArgs) {
      let data = await fetch(`/some/api/stuff/${params.id}`);
      return data;
    }
    
    export async function clientAction({
      request,
    }: Route.ClientActionArgs) {
      let formData = await request.formData();
      return await processPayment(formData);
    }
    

[](#4-direct-all-urls-to-indexhtml)4\. Direct all URLs to index.html
--------------------------------------------------------------------

After running `react-router build`, deploy the `build/client` directory to whatever static host you prefer.

Common to deploying any SPA, you'll need to configure your host to direct all URLs to the `index.html` of the client build. Some hosts do this by default, but others don't. As an example, a host may support a `_redirects` file to do this:

    /*    /index.html   200
    

If you're getting 404s at valid routes for your app, it's likely you need to configure your host.

[](#status-codes)Status Codes
=============================

Set status codes from loaders and actions with `data`.

    // route('/projects/:projectId', './project.tsx')
    import type { Route } from "./+types/project";
    import { data } from "react-router";
    import { fakeDb } from "../db";
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      let formData = await request.formData();
      let title = formData.get("title");
      if (!title) {
        return data(
          { message: "Invalid title" },
          { status: 400 }
        );
      }
    
      if (!projectExists(title)) {
        let project = await fakeDb.createProject({ title });
        return data(project, { status: 201 });
      } else {
        let project = await fakeDb.updateProject({ title });
        // the default status code is 200, no need for `data`
        return project;
      }
    }
    

See [Form Validation](./form-validation) for more information on rendering form errors like this.

Another common status code is 404:

    // route('/projects/:projectId', './project.tsx')
    import type { Route } from "./+types/project";
    import { data } from "react-router";
    import { fakeDb } from "../db";
    
    export async function loader({ params }: Route.ActionArgs) {
      let project = await fakeDb.getProject(params.id);
      if (!project) {
        // throw to ErrorBoundary
        throw data(null, { status: 404 });
      }
      return project;
    }
    

See the [Error Boundaries](./error-boundary) for more information on thrown `data`.

[](#streaming-with-suspense)Streaming with Suspense
===================================================

Streaming with React Suspense allows apps to speed up initial renders by deferring non-critical data and unblocking UI rendering.

React Router supports React Suspense by returning promises from loaders and actions.

[](#1-return-a-promise-from-loader)1\. Return a promise from loader
-------------------------------------------------------------------

React Router awaits route loaders before rendering route components. To unblock the loader for non-critical data, return the promise instead of awaiting it in the loader.

    import type { Route } from "./+types/my-route";
    
    export async function loader({}: Route.LoaderArgs) {
      // note this is NOT awaited
      let nonCriticalData = new Promise((res) =>
        setTimeout(() => res("non-critical"), 5000)
      );
    
      let criticalData = await new Promise((res) =>
        setTimeout(() => res("critical"), 300)
      );
    
      return { nonCriticalData, criticalData };
    }
    

Note you can't return a single promise, it must be an object with keys.

[](#2-render-the-fallback-and-resolved-ui)2\. Render the fallback and resolved UI
---------------------------------------------------------------------------------

The promise will be available on `loaderData`, `<Await>` will await the promise and trigger `<Suspense>` to render the fallback UI.

    import * as React from "react";
    import { Await } from "react-router";
    
    // [previous code]
    
    export default function MyComponent({
      loaderData,
    }: Route.ComponentProps) {
      let { criticalData, nonCriticalData } = loaderData;
    
      return (
        <div>
          <h1>Streaming example</h1>
          <h2>Critical data value: {criticalData}</h2>
    
          <React.Suspense fallback={<div>Loading...</div>}>
            <Await resolve={nonCriticalData}>
              {(value) => <h3>Non critical value: {value}</h3>}
            </Await>
          </React.Suspense>
        </div>
      );
    }
    

[](#with-react-19)With React 19
-------------------------------

If you're experimenting with React 19, you can use `React.use` instead of `Await`, but you'll need to create a new component and pass the promise down to trigger the suspense fallback.

    <React.Suspense fallback={<div>Loading...</div>}>
      <NonCriticalUI p={nonCriticalData} />
    </React.Suspense>
    

    function NonCriticalUI({ p }: { p: Promise<string> }) {
      let value = React.use(p);
      return <h3>Non critical value {value}</h3>;
    }
    

[](#timeouts)Timeouts
---------------------

By default, loaders and actions reject any outstanding promises after 4950ms. You can control this by exporting a `streamTimeout` numerical value from your `entry.server.tsx`.

    // Reject all pending promises from handler functions after 10 seconds
    export const streamTimeout = 10_000;
    

[](#view-transitions)View Transitions
=====================================

Enable smooth animations between page transitions in your React Router applications using the [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition). This feature allows you to create seamless visual transitions during client-side navigation.

[](#basic-view-transition)Basic View Transition
-----------------------------------------------

### [](#1-enable-view-transitions-on-navigation)1\. Enable view transitions on navigation

The simplest way to enable view transitions is by adding the `viewTransition` prop to your `Link`, `NavLink`, or `Form` components. This automatically wraps the navigation update in `document.startViewTransition()`.

    <Link to="/about" viewTransition>
      About
    </Link>
    

Without any additional CSS, this provides a basic cross-fade animation between pages.

### [](#2-enable-view-transitions-with-programmatic-navigation)2\. Enable view transitions with programmatic navigation

When using programmatic navigation with the `useNavigate` hook, you can enable view transitions by passing the `viewTransition: true` option:

    import { useNavigate } from "react-router";
    
    function NavigationButton() {
      const navigate = useNavigate();
    
      return (
        <button
          onClick={() =>
            navigate("/about", { viewTransition: true })
          }
        >
          About
        </button>
      );
    }
    

This provides the same cross-fade animation as using the `viewTransition` prop on Link components.

For more information on using the View Transitions API, please refer to the ["Smooth transitions with the View Transition API" guide](https://developer.chrome.com/docs/web-platform/view-transitions) from the Google Chrome team.

[](#image-gallery-example)Image Gallery Example
-----------------------------------------------

Let's build an image gallery that demonstrates how to trigger and use view transitions. We'll create a list of images that expand into a detail view with smooth animations.

### [](#1-create-the-image-gallery-route)1\. Create the image gallery route

    import { NavLink } from "react-router";
    
    export const images = [
      "https://remix.run/blog-images/headers/the-future-is-now.jpg",
      "https://remix.run/blog-images/headers/waterfall.jpg",
      "https://remix.run/blog-images/headers/webpack.png",
      // ... more images ...
    ];
    
    export default function ImageGalleryRoute() {
      return (
        <div className="image-list">
          <h1>Image List</h1>
          <div>
            {images.map((src, idx) => (
              <NavLink
                key={src}
                to={`/image/${idx}`}
                viewTransition // Enable view transitions for this link
              >
                <p>Image Number {idx}</p>
                <img
                  className="max-w-full contain-layout"
                  src={src}
                />
              </NavLink>
            ))}
          </div>
        </div>
      );
    }
    

### [](#2-add-transition-styles)2\. Add transition styles

Define view transition names and animations for elements that should transition smoothly between routes.

    /* Layout styles for the image grid */
    .image-list > div {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      column-gap: 10px;
    }
    
    .image-list h1 {
      font-size: 2rem;
      font-weight: 600;
    }
    
    .image-list img {
      max-width: 100%;
      contain: layout;
    }
    
    .image-list p {
      width: fit-content;
    }
    
    /* Assign transition names to elements during navigation */
    .image-list a.transitioning img {
      view-transition-name: image-expand;
    }
    
    .image-list a.transitioning p {
      view-transition-name: image-title;
    }
    

### [](#3-create-the-image-detail-route)3\. Create the image detail route

The detail view needs to use the same view transition names to create a seamless animation.

    import { Link } from "react-router";
    import { images } from "./home";
    import type { Route } from "./+types/image-details";
    
    export default function ImageDetailsRoute({
      params,
    }: Route.ComponentProps) {
      return (
        <div className="image-detail">
          <Link to="/" viewTransition>
            Back
          </Link>
          <h1>Image Number {params.id}</h1>
          <img src={images[Number(params.id)]} />
        </div>
      );
    }
    

### [](#4-add-matching-transition-styles-for-the-detail-view)4\. Add matching transition styles for the detail view

    /* Match transition names from the list view */
    .image-detail h1 {
      font-size: 2rem;
      font-weight: 600;
      width: fit-content;
      view-transition-name: image-title;
    }
    
    .image-detail img {
      max-width: 100%;
      contain: layout;
      view-transition-name: image-expand;
    }
    

[](#advanced-usage)Advanced Usage
---------------------------------

You can control view transitions more precisely using either render props or the `useViewTransitionState` hook.

### [](#1-using-render-props)1\. Using render props

    <NavLink to={`/image/${idx}`} viewTransition>
      {({ isTransitioning }) => (
        <>
          <p
            style={{
              viewTransitionName: isTransitioning
                ? "image-title"
                : "none",
            }}
          >
            Image Number {idx}
          </p>
          <img
            src={src}
            style={{
              viewTransitionName: isTransitioning
                ? "image-expand"
                : "none",
            }}
          />
        </>
      )}
    </NavLink>
    

### [](#2-using-the-useviewtransitionstate-hook)2\. Using the `useViewTransitionState` hook

    function NavImage(props: { src: string; idx: number }) {
      const href = `/image/${props.idx}`;
      // Hook provides transition state for specific route
      const isTransitioning = useViewTransitionState(href);
    
      return (
        <Link to={href} viewTransition>
          <p
            style={{
              viewTransitionName: isTransitioning
                ? "image-title"
                : "none",
            }}
          >
            Image Number {props.idx}
          </p>
          <img
            src={props.src}
            style={{
              viewTransitionName: isTransitioning
                ? "image-expand"
                : "none",
            }}
          />
        </Link>
      );
    }
    

[](#automatic-code-splitting)Automatic Code Splitting
=====================================================

When using React Router's framework features, your application is automatically code split to improve the performance of initial load times when users visit your application.

[](#code-splitting-by-route)Code Splitting by Route
---------------------------------------------------

Consider this simple route config:

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("/contact", "./contact.tsx"),
      route("/about", "./about.tsx"),
    ] satisfies RouteConfig;
    

Instead of bundling all routes into a single giant build, the modules referenced (`contact.tsx` and `about.tsx`) become entry points to the bundler.

Because these entry points are coupled to URL segments, React Router knows just from a URL which bundles are needed in the browser, and more importantly, which are not.

If the user visits `"/about"` then the bundles for `about.tsx` will be loaded but not `contact.tsx`. This ensures drastically reduces the JavaScript footprint for initial page loads and speeds up your application.

[](#removal-of-server-code)Removal of Server Code
-------------------------------------------------

Any server-only [Route Module APIs](../../start/framework/route-module) will be removed from the bundles. Consider this route module:

    export async function loader() {
      return { message: "hello" };
    }
    
    export async function action() {
      console.log(Date.now());
      return { ok: true };
    }
    
    export async function headers() {
      return { "Cache-Control": "max-age=300" };
    }
    
    export default function Component({ loaderData }) {
      return <div>{loaderData.message}</div>;
    }
    

After building for the browser, only the `Component` will still be in the bundle, so you can use server-only code in the other module exports.

[](#hot-module-replacement)Hot Module Replacement
=================================================

Hot Module Replacement is a technique for updating modules in your app without needing to reload the page. It's a great developer experience, and React Router supports it when using Vite.

HMR does its best to preserve browser state across updates. For example, let's say you have form within a modal and you fill out all the fields. As soon as you save any changes to the code, traditional live reload would hard refresh the page causing all of those fields to be reset. Every time you make a change, you'd have to open up the modal _again_ and fill out the form _again_.

But with HMR, all of that state is preserved _across updates_.

[](#react-fast-refresh)React Fast Refresh
-----------------------------------------

React already has mechanisms for updating the DOM via its [virtual DOM](https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom) in response to user interactions like clicking a button. Wouldn't it be great if React could handle updating the DOM in response to code changes too?

That's exactly what [React Fast Refresh](https://github.com/facebook/react/tree/main/packages/react-refresh) is all about! Of course, React is all about components, not general JavaScript code, so React Fast Refresh only handles hot updates for exported React components.

But React Fast Refresh does have some limitations that you should be aware of.

### [](#class-component-state)Class Component State

React Fast Refresh does not preserve state for class components. This includes higher-order components that internally return classes:

    export class ComponentA extends Component {} // ❌
    
    export const ComponentB = HOC(ComponentC); // ❌ Won't work if HOC returns a class component
    
    export function ComponentD() {} // ✅
    export const ComponentE = () => {}; // ✅
    export default function ComponentF() {} // ✅
    

### [](#named-function-components)Named Function Components

Function components must be named, not anonymous, for React Fast Refresh to track changes:

    export default () => {}; // ❌
    export default function () {} // ❌
    
    const ComponentA = () => {};
    export default ComponentA; // ✅
    
    export default function ComponentB() {} // ✅
    

### [](#supported-exports)Supported Exports

React Fast Refresh can only handle component exports. While React Router manages [route exports like `action`, `headers`, `links`, `loader`, and `meta`](../start/framework/route-module) for you, any user-defined exports will cause full reloads:

    // These exports are handled by the React Router Vite plugin
    // to be HMR-compatible
    export const meta = { title: "Home" }; // ✅
    export const links = [
      { rel: "stylesheet", href: "style.css" },
    ]; // ✅
    
    // These exports are removed by the React Router Vite plugin
    // so they never affect HMR
    export const headers = { "Cache-Control": "max-age=3600" }; // ✅
    export const loader = async () => {}; // ✅
    export const action = async () => {}; // ✅
    
    // This is not a route module export, nor a component export,
    // so it will cause a full reload for this route
    export const myValue = "some value"; // ❌
    
    export default function Route() {} // ✅
    

👆 Routes probably shouldn't be exporting random values like that anyway. If you want to reuse values across routes, stick them in their own non-route module:

    export const myValue = "some value";
    

### [](#changing-hooks)Changing Hooks

React Fast Refresh cannot track changes for a component when hooks are being added or removed from it, causing full reloads just for the next render. After the hooks have been updated, changes should result in hot updates again. For example, if you add a `useState` to your component, you may lose that component's local state for the next render.

Additionally, if you are destructuring a hook's return value, React Fast Refresh will not be able to preserve state for the component if the destructured key is removed or renamed. For example:

    export default function Component({ loaderData }) {
      const { pet } = useMyCustomHook();
      return (
        <div>
          <input />
          <p>My dog's name is {pet.name}!</p>
        </div>
      );
    }
    

If you change the key `pet` to `dog`:

     export default function Component() {
    -  const { pet } = useMyCustomHook();
    +  const { dog } = useMyCustomHook();
       return (
         <div>
           <input />
    -      <p>My dog's name is {pet.name}!</p>
    +      <p>My dog's name is {dog.name}!</p>
         </div>
       );
     }
    

then React Fast Refresh will not be able to preserve state `<input />` ❌.

### [](#component-keys)Component Keys

In some cases, React cannot distinguish between existing components being changed and new components being added. [React needs `key`s](https://react.dev/learn/rendering-lists#why-does-react-need-keys) to disambiguate these cases and track changes when sibling elements are modified.

[](#progressive-enhancement)Progressive Enhancement
===================================================

> Progressive enhancement is a strategy in web design that puts emphasis on web content first, allowing everyone to access the basic content and functionality of a web page, whilst users with additional browser features or faster Internet access receive the enhanced version instead.

\- [Wikipedia](https://en.wikipedia.org/wiki/Progressive_enhancement)

When using React Router with Server-Side Rendering (the default in framework mode), you can automatically leverage the benefits of progressive enhancement.

[](#why-progressive-enhancement-matters)Why Progressive Enhancement Matters
---------------------------------------------------------------------------

Coined in 2003 by Steven Champeon & Nick Finck, the phrase emerged during a time of varied CSS and JavaScript support across different browsers, with many users actually browsing the web with JavaScript disabled.

Today, we are fortunate to develop for a much more consistent web and where the majority of users have JavaScript enabled.

However, we still believe in the core principles of progressive enhancement in React Router. It leads to fast and resilient apps with simple development workflows.

**Performance**: While it's easy to think that only 5% of your users have slow connections, the reality is that 100% of your users have slow connections 5% of the time.

**Resilience**: Everybody has JavaScript disabled until it's loaded.

**Simplicity**: Building your apps in a progressively enhanced way with React Router is actually simpler than building a traditional SPA.

[](#performance)Performance
---------------------------

Server rendering allows your app to do more things in parallel than a typical [Single Page App (SPA)](../how-to/spa), making the initial loading experience and subsequent navigations faster.

Typical SPAs send a blank document and only start doing work when JavaScript has loaded:

    HTML        |---|
    JavaScript      |---------|
    Data                      |---------------|
                                page rendered 👆
    

A React Router app can start doing work the moment the request hits the server and stream the response so that the browser can start downloading JavaScript, other assets, and data in parallel:

                   👇 first byte
    HTML        |---|-----------|
    JavaScript      |---------|
    Data        |---------------|
                  page rendered 👆
    

[](#resilience-and-accessibility)Resilience and Accessibility
-------------------------------------------------------------

While your users probably don't browse the web with JavaScript disabled, everybody uses the websites without JavaScript before it finishes loading. React Router embraces progressive enhancement by building on top of HTML, allowing you to build your app in a way that works without JavaScript, and then layer on JavaScript to enhance the experience.

The simplest case is a `<Link to="/account">`. These render an `<a href="/account">` tag that works without JavaScript. When JavaScript loads, React Router will intercept clicks and handle the navigation with client side routing. This gives you more control over the UX instead of just spinning favicons in the browser tab--but it works either way.

Now consider a simple add to cart button:

    export function AddToCart({ id }) {
      return (
        <Form method="post" action="/add-to-cart">
          <input type="hidden" name="id" value={id} />
          <button type="submit">Add To Cart</button>
        </Form>
      );
    }
    

Whether JavaScript has loaded or not doesn't matter, this button will add the product to the cart.

When JavaScript loads, React Router will intercept the form submission and handle it client side. This allows you to add your own pending UI, or other client side behavior.

[](#simplicity)Simplicity
-------------------------

When you start to rely on basic features of the web like HTML and URLs, you will find that you reach for client side state and state management much less.

Consider the button from before, with no fundamental change to the code, we can pepper in some client side behavior:

    import { useFetcher } from "react-router";
    
    export function AddToCart({ id }) {
      const fetcher = useFetcher();
    
      return (
        <fetcher.Form method="post" action="/add-to-cart">
          <input name="id" value={id} />
          <button type="submit">
            {fetcher.state === "submitting"
              ? "Adding..."
              : "Add To Cart"}
          </button>
        </fetcher.Form>
      );
    }
    

This feature continues to work the very same as it did before when JavaScript is loading, but once JavaScript loads:

*   `useFetcher` no longer causes a navigation like `<Form>` does, so the user can stay on the same page and keep shopping
*   The app code determines the pending UI instead of spinning favicons in the browser

It's not about building it two different ways–once for JavaScript and once without–it's about building it in iterations. Start with the simplest version of the feature and ship it; then iterate to an enhanced user experience.

Not only will the user get a progressively enhanced experience, but the app developer gets to "progressively enhance" the UI without changing the fundamental design of the feature.

Another example where progressive enhancement leads to simplicity is with the URL. When you start with a URL, you don't need to worry about client side state management. You can just use the URL as the source of truth for the UI.

    export function SearchBox() {
      return (
        <Form method="get" action="/search">
          <input type="search" name="query" />
          <SearchIcon />
        </Form>
      );
    }
    

This component doesn't need any state management. It just renders a form that submits to `/search`. When JavaScript loads, React Router will intercept the form submission and handle it client side. Here's the next iteration:

    import { useNavigation } from "react-router";
    
    export function SearchBox() {
      const navigation = useNavigation();
      const isSearching =
        navigation.location.pathname === "/search";
    
      return (
        <Form method="get" action="/search">
          <input type="search" name="query" />
          {isSearching ? <Spinner /> : <SearchIcon />}
        </Form>
      );
    }
    

No fundamental change in architecture, simply a progressive enhancement for both the user and the code.

See also: [State Management](./state-management)

[](#race-conditions)Race Conditions
===================================

While impossible to eliminate every possible race condition in your application, React Router automatically handles the most common race conditions found in web user interfaces.

[](#browser-behavior)Browser Behavior
-------------------------------------

React Router's handling of network concurrency is heavily inspired by the behavior of web browsers when processing documents.

Consider clicking a link to a new document, and then clicking a different link before the new page has finished loading. The browser will:

1.  cancel the first request
2.  immediately process the new navigation

The same behavior applies to form submissions. When a pending form submission is interrupted by a new one, the first is canceled and the new submission is immediately processed.

[](#react-router-behavior)React Router Behavior
-----------------------------------------------

Like the browser, interrupted navigations with links and form submissions will cancel in flight data requests and immediately process the new event.

Fetchers are a bit more nuanced since they are not singleton events like navigation. Fetchers can't interrupt other fetcher instances, but they can interrupt themselves and the behavior is the same as everything else: cancel the interrupted request and immediately process the new one.

Fetchers do, however, interact with each other when it comes to revalidation. After a fetcher's action request returns to the browser, a revalidation for all page data is sent. This means multiple revalidation requests can be in-flight at the same time. React Router will commit all "fresh" revalidation responses and cancel any stale requests. A stale request is any request that started _earlier_ than one that has returned.

This management of the network prevents the most common UI bugs caused by network race conditions.

Since networks are unpredictable, and your server still processes these cancelled requests, your backend may still experience race conditions and have potential data integrity issues. These risks are the same risks as using default browser behavior with plain HTML `<forms>`, which we consider to be low, and outside the scope of React Router.

[](#practical-benefits)Practical Benefits
-----------------------------------------

Consider building a type-ahead combobox. As the user types, you send a request to the server. As they type each new character you send a new request. It's important to not show the user results for a value that's not in the text field anymore.

When using a fetcher, this is automatically managed for you. Consider this pseudo-code:

    // route("/city-search", "./search-cities.ts")
    export async function loader({ request }) {
      const { searchParams } = new URL(request.url);
      return searchCities(searchParams.get("q"));
    }
    

    export function CitySearchCombobox() {
      const fetcher = useFetcher();
    
      return (
        <fetcher.Form action="/city-search">
          <Combobox aria-label="Cities">
            <ComboboxInput
              name="q"
              onChange={(event) =>
                // submit the form onChange to get the list of cities
                fetcher.submit(event.target.form)
              }
            />
    
            {fetcher.data ? (
              <ComboboxPopover className="shadow-popup">
                {fetcher.data.length > 0 ? (
                  <ComboboxList>
                    {fetcher.data.map((city) => (
                      <ComboboxOption
                        key={city.id}
                        value={city.name}
                      />
                    ))}
                  </ComboboxList>
                ) : (
                  <span>No results found</span>
                )}
              </ComboboxPopover>
            ) : null}
          </Combobox>
        </fetcher.Form>
      );
    }
    

Calls to `fetcher.submit` will cancel pending requests on that fetcher automatically. This ensures you never show the user results for a request for a different input value.

[](#sessions-and-cookies)Sessions and Cookies
=============================================

[](#sessions)Sessions
---------------------

Sessions are an important part of websites that allow the server to identify requests coming from the same person, especially when it comes to server-side form validation or when JavaScript is not on the page. Sessions are a fundamental building block of many sites that let users "log in", including social, e-commerce, business, and educational websites.

When using React Router as your framework, sessions are managed on a per-route basis (rather than something like express middleware) in your `loader` and `action` methods using a "session storage" object (that implements the [`SessionStorage`](https://api.reactrouter.com/v7/interfaces/react_router.SessionStorage) interface). Session storage understands how to parse and generate cookies, and how to store session data in a database or filesystem.

### [](#using-sessions)Using Sessions

This is an example of a cookie session storage:

    import { createCookieSessionStorage } from "react-router";
    
    type SessionData = {
      userId: string;
    };
    
    type SessionFlashData = {
      error: string;
    };
    
    const { getSession, commitSession, destroySession } =
      createCookieSessionStorage<SessionData, SessionFlashData>(
        {
          // a Cookie from `createCookie` or the CookieOptions to create one
          cookie: {
            name: "__session",
    
            // all of these are optional
            domain: "reactrouter.com",
            // Expires can also be set (although maxAge overrides it when used in combination).
            // Note that this method is NOT recommended as `new Date` creates only one date on each server deployment, not a dynamic date in the future!
            //
            // expires: new Date(Date.now() + 60_000),
            httpOnly: true,
            maxAge: 60,
            path: "/",
            sameSite: "lax",
            secrets: ["s3cret1"],
            secure: true,
          },
        }
      );
    
    export { getSession, commitSession, destroySession };
    

We recommend setting up your session storage object in `app/sessions.server.ts` so all routes that need to access session data can import from the same spot.

The input/output to a session storage object are HTTP cookies. `getSession()` retrieves the current session from the incoming request's `Cookie` header, and `commitSession()`/`destroySession()` provide the `Set-Cookie` header for the outgoing response.

You'll use methods to get access to sessions in your `loader` and `action` functions.

After retrieving a session with `getSession`, the returned session object has a handful of methods and properties:

    export async function action({
      request,
    }: ActionFunctionArgs) {
      const session = await getSession(
        request.headers.get("Cookie")
      );
      session.get("foo");
      session.has("bar");
      // etc.
    }
    

See the [Session API](https://api.reactrouter.com/v7/interfaces/react_router.Session) for all methods available on the session object.

### [](#login-form-example)Login form example

A login form might look something like this:

    import { data, redirect } from "react-router";
    import type { Route } from "./+types/login";
    
    import {
      getSession,
      commitSession,
    } from "../sessions.server";
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const session = await getSession(
        request.headers.get("Cookie")
      );
    
      if (session.has("userId")) {
        // Redirect to the home page if they are already signed in.
        return redirect("/");
      }
    
      return data(
        { error: session.get("error") },
        {
          headers: {
            "Set-Cookie": await commitSession(session),
          },
        }
      );
    }
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      const session = await getSession(
        request.headers.get("Cookie")
      );
      const form = await request.formData();
      const username = form.get("username");
      const password = form.get("password");
    
      const userId = await validateCredentials(
        username,
        password
      );
    
      if (userId == null) {
        session.flash("error", "Invalid username/password");
    
        // Redirect back to the login page with errors.
        return redirect("/login", {
          headers: {
            "Set-Cookie": await commitSession(session),
          },
        });
      }
    
      session.set("userId", userId);
    
      // Login succeeded, send them to the home page.
      return redirect("/", {
        headers: {
          "Set-Cookie": await commitSession(session),
        },
      });
    }
    
    export default function Login({
      loaderData,
    }: Route.ComponentProps) {
      const { error } = loaderData;
    
      return (
        <div>
          {error ? <div className="error">{error}</div> : null}
          <form method="POST">
            <div>
              <p>Please sign in</p>
            </div>
            <label>
              Username: <input type="text" name="username" />
            </label>
            <label>
              Password:{" "}
              <input type="password" name="password" />
            </label>
          </form>
        </div>
      );
    }
    

And then a logout form might look something like this:

    import {
      getSession,
      destroySession,
    } from "../sessions.server";
    import type { Route } from "./+types/logout";
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      const session = await getSession(
        request.headers.get("Cookie")
      );
      return redirect("/login", {
        headers: {
          "Set-Cookie": await destroySession(session),
        },
      });
    }
    
    export default function LogoutRoute() {
      return (
        <>
          <p>Are you sure you want to log out?</p>
          <Form method="post">
            <button>Logout</button>
          </Form>
          <Link to="/">Never mind</Link>
        </>
      );
    }
    

It's important that you logout (or perform any mutation for that matter) in an `action` and not a `loader`. Otherwise you open your users to [Cross-Site Request Forgery](https://developer.mozilla.org/en-US/docs/Glossary/CSRF) attacks.

### [](#session-gotchas)Session Gotchas

Because of nested routes, multiple loaders can be called to construct a single page. When using `session.flash()` or `session.unset()`, you need to be sure no other loaders in the request are going to want to read that, otherwise you'll get race conditions. Typically if you're using flash, you'll want to have a single loader read it, if another loader wants a flash message, use a different key for that loader.

### [](#creating-custom-session-storage)Creating custom session storage

React Router makes it easy to store sessions in your own database if needed. The [`createSessionStorage()`](https://api.reactrouter.com/v7/functions/react_router.createSessionStorage) API requires a `cookie` (for options for creating a cookie, see [cookies](#cookies)) and a set of create, read, update, and delete (CRUD) methods for managing the session data. The cookie is used to persist the session ID.

*   `createData` will be called from `commitSession` on the initial session creation when no session ID exists in the cookie
*   `readData` will be called from `getSession` when a session ID exists in the cookie
*   `updateData` will be called from `commitSession` when a session ID already exists in the cookie
*   `deleteData` is called from `destroySession`

The following example shows how you could do this using a generic database client:

    import { createSessionStorage } from "react-router";
    
    function createDatabaseSessionStorage({
      cookie,
      host,
      port,
    }) {
      // Configure your database client...
      const db = createDatabaseClient(host, port);
    
      return createSessionStorage({
        cookie,
        async createData(data, expires) {
          // `expires` is a Date after which the data should be considered
          // invalid. You could use it to invalidate the data somehow or
          // automatically purge this record from your database.
          const id = await db.insert(data);
          return id;
        },
        async readData(id) {
          return (await db.select(id)) || null;
        },
        async updateData(id, data, expires) {
          await db.update(id, data);
        },
        async deleteData(id) {
          await db.delete(id);
        },
      });
    }
    

And then you can use it like this:

    const { getSession, commitSession, destroySession } =
      createDatabaseSessionStorage({
        host: "localhost",
        port: 1234,
        cookie: {
          name: "__session",
          sameSite: "lax",
        },
      });
    

The `expires` argument to `createData` and `updateData` is the same `Date` at which the cookie itself expires and is no longer valid. You can use this information to automatically purge the session record from your database to save on space, or to ensure that you do not otherwise return any data for old, expired cookies.

### [](#additional-session-utils)Additional session utils

There are also several other session utilities available if you need them:

*   [`isSession`](https://api.reactrouter.com/v7/functions/react_router.isSession)
*   [`createMemorySessionStorage`](https://api.reactrouter.com/v7/functions/react_router.createMemorySessionStorage)
*   [`createSession`](https://api.reactrouter.com/v7/functions/react_router.createSession) (custom storage)
*   [`createFileSessionStorage`](https://api.reactrouter.com/v7/functions/_react_router_node.createFileSessionStorage) (node)
*   [`createWorkersKVSessionStorage`](https://api.reactrouter.com/v7/functions/_react_router_cloudflare.createWorkersKVSessionStorage) (Cloudflare Workers)
*   [`createArcTableSessionStorage`](https://api.reactrouter.com/v7/functions/_react_router_architect.createArcTableSessionStorage) (architect, Amazon DynamoDB)

[](#cookies)Cookies
-------------------

A [cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) is a small piece of information that your server sends someone in a HTTP response that their browser will send back on subsequent requests. This technique is a fundamental building block of many interactive websites that adds state so you can build authentication (see [sessions](#sessions)), shopping carts, user preferences, and many other features that require remembering who is "logged in".

React Router's [`Cookie` interface](https://api.reactrouter.com/v7/interfaces/react_router.Cookie) provides a logical, reusable container for cookie metadata.

### [](#using-cookies)Using cookies

While you may create these cookies manually, it is more common to use a [session storage](#sessions).

In React Router, you will typically work with cookies in your `loader` and/or `action` functions, since those are the places where you need to read and write data.

Let's say you have a banner on your e-commerce site that prompts users to check out the items you currently have on sale. The banner spans the top of your homepage, and includes a button on the side that allows the user to dismiss the banner so they don't see it for at least another week.

First, create a cookie:

    import { createCookie } from "react-router";
    
    export const userPrefs = createCookie("user-prefs", {
      maxAge: 604_800, // one week
    });
    

Then, you can `import` the cookie and use it in your `loader` and/or `action`. The `loader` in this case just checks the value of the user preference so you can use it in your component for deciding whether to render the banner. When the button is clicked, the `<form>` calls the `action` on the server and reloads the page without the banner.

### [](#user-preferences-example)User preferences example

    import { Link, Form, redirect } from "react-router";
    import type { Route } from "./+types/home";
    
    import { userPrefs } from "../cookies.server";
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const cookieHeader = request.headers.get("Cookie");
      const cookie =
        (await userPrefs.parse(cookieHeader)) || {};
      return { showBanner: cookie.showBanner };
    }
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      const cookieHeader = request.headers.get("Cookie");
      const cookie =
        (await userPrefs.parse(cookieHeader)) || {};
      const bodyParams = await request.formData();
    
      if (bodyParams.get("bannerVisibility") === "hidden") {
        cookie.showBanner = false;
      }
    
      return redirect("/", {
        headers: {
          "Set-Cookie": await userPrefs.serialize(cookie),
        },
      });
    }
    
    export default function Home({
      loaderData,
    }: Route.ComponentProps) {
      return (
        <div>
          {loaderData.showBanner ? (
            <div>
              <Link to="/sale">Don't miss our sale!</Link>
              <Form method="post">
                <input
                  type="hidden"
                  name="bannerVisibility"
                  value="hidden"
                />
                <button type="submit">Hide</button>
              </Form>
            </div>
          ) : null}
          <h1>Welcome!</h1>
        </div>
      );
    }
    

### [](#cookie-attributes)Cookie attributes

Cookies have [several attributes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes) that control when they expire, how they are accessed, and where they are sent. Any of these attributes may be specified either in `createCookie(name, options)`, or during `serialize()` when the `Set-Cookie` header is generated.

    const cookie = createCookie("user-prefs", {
      // These are defaults for this cookie.
      path: "/",
      sameSite: "lax",
      httpOnly: true,
      secure: true,
      expires: new Date(Date.now() + 60_000),
      maxAge: 60,
    });
    
    // You can either use the defaults:
    cookie.serialize(userPrefs);
    
    // Or override individual ones as needed:
    cookie.serialize(userPrefs, { sameSite: "strict" });
    

Please read [more info about these attributes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes) to get a better understanding of what they do.

### [](#signing-cookies)Signing cookies

It is possible to sign a cookie to automatically verify its contents when it is received. Since it's relatively easy to spoof HTTP headers, this is a good idea for any information that you do not want someone to be able to fake, like authentication information (see [sessions](#sessions)).

To sign a cookie, provide one or more `secrets` when you first create the cookie:

    const cookie = createCookie("user-prefs", {
      secrets: ["s3cret1"],
    });
    

Cookies that have one or more `secrets` will be stored and verified in a way that ensures the cookie's integrity.

Secrets may be rotated by adding new secrets to the front of the `secrets` array. Cookies that have been signed with old secrets will still be decoded successfully in `cookie.parse()`, and the newest secret (the first one in the array) will always be used to sign outgoing cookies created in `cookie.serialize()`.

    export const cookie = createCookie("user-prefs", {
      secrets: ["n3wsecr3t", "olds3cret"],
    });
    

    import { data } from "react-router";
    import { cookie } from "../cookies.server";
    import type { Route } from "./+types/my-route";
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const oldCookie = request.headers.get("Cookie");
      // oldCookie may have been signed with "olds3cret", but still parses ok
      const value = await cookie.parse(oldCookie);
    
      return data("...", {
        headers: {
          // Set-Cookie is signed with "n3wsecr3t"
          "Set-Cookie": await cookie.serialize(value),
        },
      });
    }
    

### [](#additional-cookie-utils)Additional cookie utils

There are also several other cookie utilities available if you need them:

*   [`isCookie`](https://api.reactrouter.com/v7/functions/react_router.isCookie)
*   [`createCookie`](https://api.reactrouter.com/v7/functions/react_router.createCookie)

To learn more about each attribute, please see the [MDN Set-Cookie docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes).

[](#special-files)Special Files
===============================

There are a few special files that React Router looks for in your project. Not all of these files are required

[](#react-routerconfigts)react-router.config.ts
-----------------------------------------------

**This file is optional**

The config file is used to configure certain aspects of your app, such as whether you are using server-side rendering, where certain directories are located, and more.

    import type { Config } from "@react-router/dev/config";
    
    export default {
      // Config options...
    } satisfies Config;
    

See the details on [react-router config API](https://api.reactrouter.com/v7/types/_react_router_dev.config.Config.html) for more information.

[](#roottsx)root.tsx
--------------------

**This file is required**

The "root" route (`app/root.tsx`) is the only _required_ route in your React Router application because it is the parent to all routes in your `routes/` directory and is in charge of rendering the root `<html>` document.

Because the root route manages your document, it is the proper place to render a handful of "document-level" components React Router provides. These components are to be used once inside your root route and they include everything React Router figured out or built in order for your page to render properly.

    import type { LinksFunction } from "react-router";
    import {
      Links,
      Meta,
      Outlet,
      Scripts,
      ScrollRestoration,
    } from "react-router";
    
    import "./global-styles.css";
    
    export default function App() {
      return (
        <html lang="en">
          <head>
            <meta charSet="utf-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1"
            />
    
            {/* All `meta` exports on all routes will render here */}
            <Meta />
    
            {/* All `link` exports on all routes will render here */}
            <Links />
          </head>
          <body>
            {/* Child routes render here */}
            <Outlet />
    
            {/* Manages scroll position for client-side transitions */}
            {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
            <ScrollRestoration />
    
            {/* Script tags go here */}
            {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
            <Scripts />
          </body>
        </html>
      );
    }
    

### [](#layout-export)Layout export

The root route supports all [route module exports](../start/framework/route-module).

The root route also supports an additional optional `Layout` export. The `Layout` component serves 2 purposes:

1.  Avoid duplicating your document's "app shell" across your root component, `HydrateFallback`, and `ErrorBoundary`
2.  Prevent React from re-mounting your app shell elements when switching between the root component/`HydrateFallback`/`ErrorBoundary` which can cause a FOUC if React removes and re-adds `<link rel="stylesheet">` tags from your `<Links>` component.

    export function Layout({ children }) {
      return (
        <html lang="en">
          <head>
            <meta charSet="utf-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1"
            />
            <Meta />
            <Links />
          </head>
          <body>
            {/* children will be the root Component, ErrorBoundary, or HydrateFallback */}
            {children}
            <Scripts />
            <ScrollRestoration />
          </body>
        </html>
      );
    }
    
    export default function App() {
      return <Outlet />;
    }
    
    export function ErrorBoundary() {}
    

**A note on `useLoaderData`in the `Layout` Component**

`useLoaderData` is not permitted to be used in `ErrorBoundary` components because it is intended for the happy-path route rendering, and its typings have a built-in assumption that the `loader` ran successfully and returned something. That assumption doesn't hold in an `ErrorBoundary` because it could have been the `loader` that threw and triggered the boundary! In order to access loader data in `ErrorBoundary`'s, you can use `useRouteLoaderData` which accounts for the loader data potentially being `undefined`.

Because your `Layout` component is used in both success and error flows, this same restriction holds. If you need to fork logic in your `Layout` depending on if it was a successful request or not, you can use `useRouteLoaderData("root")` and `useRouteError()`.

Because your `<Layout>` component is used for rendering the `ErrorBoundary`, you should be _very defensive_ to ensure that you can render your `ErrorBoundary` without encountering any render errors. If your `Layout` throws another error trying to render the boundary, then it can't be used and your UI will fall back to the very minimal built-in default `ErrorBoundary`.

    export function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const data = useRouteLoaderData("root");
      const error = useRouteError();
    
      return (
        <html lang="en">
          <head>
            <meta charSet="utf-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1"
            />
            <Meta />
            <Links />
            <style
              dangerouslySetInnerHTML={{
                __html: `
                  :root {
                    --themeVar: ${
                      data?.themeVar || defaultThemeVar
                    }
                  }
                `,
              }}
            />
          </head>
          <body>
            {data ? (
              <Analytics token={data.analyticsToken} />
            ) : null}
            {children}
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    

[](#routests)routes.ts
----------------------

**This file is required**

The `routes.ts` file is used to configure which url patterns are matched to which route modules.

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("some/path", "./some/file.tsx"),
      // pattern ^           ^ module file
    ] satisfies RouteConfig;
    

See the [routing guide](../start/framework/routing) for more information.

[](#entryclienttsx)entry.client.tsx
-----------------------------------

**This file is optional**

By default, React Router will handle hydrating your app on the client for you. You can reveal the default entry client file with the following:

    react-router reveal
    

This file is the entry point for the browser and is responsible for hydrating the markup generated by the server in your [server entry module](#entryservertsx), however you can also initialize any other client-side code here.

    import { startTransition, StrictMode } from "react";
    import { hydrateRoot } from "react-dom/client";
    import { HydratedRouter } from "react-router/dom";
    
    startTransition(() => {
      hydrateRoot(
        document,
        <StrictMode>
          <HydratedRouter />
        </StrictMode>
      );
    });
    

This is the first piece of code that runs in the browser. You can initialize client side libraries, add client only providers, etc.

[](#entryservertsx)entry.server.tsx
-----------------------------------

**This file is optional**

By default, React Router will handle generating the HTTP Response for you. You can reveal the default entry server file with the following:

    react-router reveal
    

The `default` export of this module is a function that lets you create the response, including HTTP status, headers, and HTML, giving you full control over the way the markup is generated and sent to the client.

This module should render the markup for the current page using a `<ServerRouter>` element with the `context` and `url` for the current request. This markup will (optionally) be re-hydrated once JavaScript loads in the browser using the [client entry module](#entryclienttsx).

### [](#streamtimeout)`streamTimeout`

If you are [streaming](../how-to/suspense) responses, you can export an optional `streamTimeout` value (in milliseconds) that will control the amount of time the server will wait for streamed promises to settle before rejecting outstanding promises them and closing the stream.

It's recommended to decouple this value from the timeout in which you abort the React renderer. You should always set the React rendering timeout to a higher value so it has time to stream down the underlying rejections from your `streamTimeout`.

    // Reject all pending promises from handler functions after 10 seconds
    export const streamTimeout = 10000;
    
    export default function handleRequest(...) {
      return new Promise((resolve, reject) => {
        // ...
    
        const { pipe, abort } = renderToPipeableStream(
          <ServerRouter context={routerContext} url={request.url} />,
          { /* ... */ }
        );
    
        // Abort the streaming render pass after 11 seconds to allow the rejected
        // boundaries to be flushed
        setTimeout(abort, streamTimeout + 1000);
      });
    }
    

### [](#handledatarequest)`handleDataRequest`

You can export an optional `handleDataRequest` function that will allow you to modify the response of a data request. These are the requests that do not render HTML, but rather return the loader and action data to the browser once client-side hydration has occurred.

    export function handleDataRequest(
      response: Response,
      {
        request,
        params,
        context,
      }: LoaderFunctionArgs | ActionFunctionArgs
    ) {
      response.headers.set("X-Custom-Header", "value");
      return response;
    }
    

### [](#handleerror)`handleError`

By default, React Router will log encountered server-side errors to the console. If you'd like more control over the logging, or would like to also report these errors to an external service, then you can export an optional `handleError` function which will give you control (and will disable the built-in error logging).

    export function handleError(
      error: unknown,
      {
        request,
        params,
        context,
      }: LoaderFunctionArgs | ActionFunctionArgs
    ) {
      if (!request.signal.aborted) {
        sendErrorToErrorReportingService(error);
        console.error(formatErrorForJsonLogging(error));
      }
    }
    

_Note that you generally want to avoid logging when the request was aborted, since React Router's cancellation and race-condition handling can cause a lot of requests to be aborted._

### [](#streaming-rendering-errors)Streaming Rendering Errors

When you are streaming your HTML responses via [`renderToPipeableStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream) or [`renderToReadableStream`](https://react.dev/reference/react-dom/server/renderToReadableStream), your own `handleError` implementation will only handle errors encountered during the initial shell render. If you encounter a rendering error during subsequent streamed rendering you will need to handle these errors manually since the React Router server has already sent the Response by that point.

For `renderToPipeableStream`, you can handle these errors in the `onError` callback function. You will need to toggle a boolean in `onShellReady` so you know if the error was a shell rendering error (and can be ignored) or an async

For an example, please refer to the default [`entry.server.tsx`](https://github.com/remix-run/react-router/blob/dev/packages/react-router-dev/config/defaults/entry.server.node.tsx) for Node.

**Thrown Responses**

Note that this does not handle thrown `Response` instances from your `loader`/`action` functions. The intention of this handler is to find bugs in your code which result in unexpected thrown errors. If you are detecting a scenario and throwing a 401/404/etc. `Response` in your `loader`/`action` then it's an expected flow that is handled by your code. If you also wish to log, or send those to an external service, that should be done at the time you throw the response.

[](#server-modules)`.server` modules
------------------------------------

While not strictly necessary, `.server` modules are a good way to explicitly mark entire modules as server-only. The build will fail if any code in a `.server` file or `.server` directory accidentally ends up in the client module graph.

    app
    ├── .server 👈 marks all files in this directory as server-only
    │   ├── auth.ts
    │   └── db.ts
    ├── cms.server.ts 👈 marks this file as server-only
    ├── root.tsx
    └── routes.ts
    

`.server` modules must be within your app directory.

Refer to the Route Module section in the sidebar for more information.

[](#client-modules)`.client` modules
------------------------------------

While uncommon, you may have a file or dependency that uses module side effects in the browser. You can use `*.client.ts` on file names or nest files within `.client` directories to force them out of server bundles.

    // this would break the server
    export const supportsVibrationAPI =
      "vibrate" in window.navigator;
    

Note that values exported from this module will all be `undefined` on the server, so the only places to use them are in [`useEffect`](https://react.dev/reference/react/useEffect) and user events like click handlers.

    import { supportsVibrationAPI } from "./feature-check.client.ts";
    
    console.log(supportsVibrationAPI);
    // server: undefined
    // client: true | false
    

[](#state-management)State Management
=====================================

State management in React typically involves maintaining a synchronized cache of server data on the client side. However, when using React Router as your framework, most of the traditional caching solutions become redundant because of how it inherently handles data synchronization.

[](#understanding-state-management-in-react)Understanding State Management in React
-----------------------------------------------------------------------------------

In a typical React context, when we refer to "state management", we're primarily discussing how we synchronize server state with the client. A more apt term could be "cache management" because the server is the source of truth and the client state is mostly functioning as a cache.

Popular caching solutions in React include:

*   **Redux:** A predictable state container for JavaScript apps.
*   **React Query:** Hooks for fetching, caching, and updating asynchronous data in React.
*   **Apollo:** A comprehensive state management library for JavaScript that integrates with GraphQL.

In certain scenarios, using these libraries may be warranted. However, with React Router's unique server-focused approach, their utility becomes less prevalent. In fact, most React Router applications forgo them entirely.

[](#how-react-router-simplifies-state)How React Router Simplifies State
-----------------------------------------------------------------------

React Router seamlessly bridges the gap between the backend and frontend via mechanisms like loaders, actions, and forms with automatic synchronization through revalidation. This offers developers the ability to directly use server state within components without managing a cache, the network communication, or data revalidation, making most client-side caching redundant.

Here's why using typical React state patterns might be an anti-pattern in React Router:

1.  **Network-related State:** If your React state is managing anything related to the network—such as data from loaders, pending form submissions, or navigational states—it's likely that you're managing state that React Router already manages:
    
    *   **[`useNavigation`](https://api.reactrouter.com/v7/functions/react_router.useNavigation)**: This hook gives you access to `navigation.state`, `navigation.formData`, `navigation.location`, etc.
    *   **[`useFetcher`](https://api.reactrouter.com/v7/functions/react_router.useFetcher)**: This facilitates interaction with `fetcher.state`, `fetcher.formData`, `fetcher.data` etc.
    *   **[`loaderData`](../start/framework/data-loading)**: Access the data for a route.
    *   **[`actionData`](../start/framework/actions)**: Access the data from the latest action.
2.  **Storing Data in React Router:** A lot of data that developers might be tempted to store in React state has a more natural home in React Router, such as:
    
    *   **URL Search Params:** Parameters within the URL that hold state.
    *   **[Cookies](./sessions-and-cookies#cookies):** Small pieces of data stored on the user's device.
    *   **[Server Sessions](./sessions-and-cookies#sessions):** Server-managed user sessions.
    *   **Server Caches:** Cached data on the server side for quicker retrieval.
3.  **Performance Considerations:** At times, client state is leveraged to avoid redundant data fetching. With React Router, you can use the [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) headers within `loader`s, allowing you to tap into the browser's native cache. However, this approach has its limitations and should be used judiciously. It's usually more beneficial to optimize backend queries or implement a server cache. This is because such changes benefit all users and do away with the need for individual browser caches.
    

As a developer transitioning to React Router, it's essential to recognize and embrace its inherent efficiencies rather than applying traditional React patterns. React Router offers a streamlined solution to state management leading to less code, fresh data, and no state synchronization bugs.

[](#examples)Examples
---------------------

### [](#network-related-state)Network Related State

For examples on using React Router's internal state to manage network related state, refer to [Pending UI](../start/framework/pending-ui).

### [](#url-search-params)URL Search Params

Consider a UI that lets the user customize between list view or detail view. Your instinct might be to reach for React state:

    export function List() {
      const [view, setView] = useState("list");
      return (
        <div>
          <div>
            <button onClick={() => setView("list")}>
              View as List
            </button>
            <button onClick={() => setView("details")}>
              View with Details
            </button>
          </div>
          {view === "list" ? <ListView /> : <DetailView />}
        </div>
      );
    }
    

Now consider you want the URL to update when the user changes the view. Note the state synchronization:

    import { useNavigate, useSearchParams } from "react-router";
    
    export function List() {
      const navigate = useNavigate();
      const [searchParams] = useSearchParams();
      const [view, setView] = useState(
        searchParams.get("view") || "list"
      );
    
      return (
        <div>
          <div>
            <button
              onClick={() => {
                setView("list");
                navigate(`?view=list`);
              }}
            >
              View as List
            </button>
            <button
              onClick={() => {
                setView("details");
                navigate(`?view=details`);
              }}
            >
              View with Details
            </button>
          </div>
          {view === "list" ? <ListView /> : <DetailView />}
        </div>
      );
    }
    

Instead of synchronizing state, you can simply read and set the state in the URL directly with boring old HTML forms:

    import { Form, useSearchParams } from "react-router";
    
    export function List() {
      const [searchParams] = useSearchParams();
      const view = searchParams.get("view") || "list";
    
      return (
        <div>
          <Form>
            <button name="view" value="list">
              View as List
            </button>
            <button name="view" value="details">
              View with Details
            </button>
          </Form>
          {view === "list" ? <ListView /> : <DetailView />}
        </div>
      );
    }
    

### [](#persistent-ui-state)Persistent UI State

Consider a UI that toggles a sidebar's visibility. We have three ways to handle the state:

1.  React state
2.  Browser local storage
3.  Cookies

In this discussion, we'll break down the trade-offs associated with each method.

#### [](#react-state)React State

React state provides a simple solution for temporary state storage.

**Pros**:

*   **Simple**: Easy to implement and understand.
*   **Encapsulated**: State is scoped to the component.

**Cons**:

*   **Transient**: Doesn't survive page refreshes, returning to the page later, or unmounting and remounting the component.

**Implementation**:

    function Sidebar() {
      const [isOpen, setIsOpen] = useState(false);
      return (
        <div>
          <button onClick={() => setIsOpen((open) => !open)}>
            {isOpen ? "Close" : "Open"}
          </button>
          <aside hidden={!isOpen}>
            <Outlet />
          </aside>
        </div>
      );
    }
    

#### [](#local-storage)Local Storage

To persist state beyond the component lifecycle, browser local storage is a step-up. See our doc on [Client Data](../how-to/client-data) for more advanced examples.

**Pros**:

*   **Persistent**: Maintains state across page refreshes and component mounts/unmounts.
*   **Encapsulated**: State is scoped to the component.

**Cons**:

*   **Requires Synchronization**: React components must sync up with local storage to initialize and save the current state.
*   **Server Rendering Limitation**: The [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) and [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) objects are not accessible during server-side rendering, so state must be initialized in the browser with an effect.
*   **UI Flickering**: On initial page loads, the state in local storage may not match what was rendered by the server and the UI will flicker when JavaScript loads.

**Implementation**:

    function Sidebar() {
      const [isOpen, setIsOpen] = useState(false);
    
      // synchronize initially
      useLayoutEffect(() => {
        const isOpen = window.localStorage.getItem("sidebar");
        setIsOpen(isOpen);
      }, []);
    
      // synchronize on change
      useEffect(() => {
        window.localStorage.setItem("sidebar", isOpen);
      }, [isOpen]);
    
      return (
        <div>
          <button onClick={() => setIsOpen((open) => !open)}>
            {isOpen ? "Close" : "Open"}
          </button>
          <aside hidden={!isOpen}>
            <Outlet />
          </aside>
        </div>
      );
    }
    

In this approach, state must be initialized within an effect. This is crucial to avoid complications during server-side rendering. Directly initializing the React state from `localStorage` will cause errors since `window.localStorage` is unavailable during server rendering.

    function Sidebar() {
      const [isOpen, setIsOpen] = useState(
        // error: window is not defined
        window.localStorage.getItem("sidebar")
      );
    
      // ...
    }
    

By initializing the state within an effect, there's potential for a mismatch between the server-rendered state and the state stored in local storage. This discrepancy will lead to brief UI flickering shortly after the page renders and should be avoided.

#### [](#cookies)Cookies

Cookies offer a comprehensive solution for this use case. However, this method introduces added preliminary setup before making the state accessible within the component.

**Pros**:

*   **Server Rendering**: State is available on the server for rendering and even for server actions.
*   **Single Source of Truth**: Eliminates state synchronization hassles.
*   **Persistence**: Maintains state across page loads and component mounts/unmounts. State can even persist across devices if you switch to a database-backed session.
*   **Progressive Enhancement**: Functions even before JavaScript loads.

**Cons**:

*   **Boilerplate**: Requires more code because of the network.
*   **Exposed**: The state is not encapsulated to a single component, other parts of the app must be aware of the cookie.

**Implementation**:

First we'll need to create a cookie object:

    import { createCookie } from "react-router";
    export const prefs = createCookie("prefs");
    

Next we set up the server action and loader to read and write the cookie:

    import { data, Outlet } from "react-router";
    import type { Route } from "./+types/sidebar";
    
    import { prefs } from "./prefs-cookie";
    
    // read the state from the cookie
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const cookieHeader = request.headers.get("Cookie");
      const cookie = (await prefs.parse(cookieHeader)) || {};
      return data({ sidebarIsOpen: cookie.sidebarIsOpen });
    }
    
    // write the state to the cookie
    export async function action({
      request,
    }: Route.ActionArgs) {
      const cookieHeader = request.headers.get("Cookie");
      const cookie = (await prefs.parse(cookieHeader)) || {};
      const formData = await request.formData();
    
      const isOpen = formData.get("sidebar") === "open";
      cookie.sidebarIsOpen = isOpen;
    
      return data(isOpen, {
        headers: {
          "Set-Cookie": await prefs.serialize(cookie),
        },
      });
    }
    

After the server code is set up, we can use the cookie state in our UI:

    function Sidebar({ loaderData }: Route.ComponentProps) {
      const fetcher = useFetcher();
      let { sidebarIsOpen } = loaderData;
    
      // use optimistic UI to immediately change the UI state
      if (fetcher.formData?.has("sidebar")) {
        sidebarIsOpen =
          fetcher.formData.get("sidebar") === "open";
      }
    
      return (
        <div>
          <fetcher.Form method="post">
            <button
              name="sidebar"
              value={sidebarIsOpen ? "closed" : "open"}
            >
              {sidebarIsOpen ? "Close" : "Open"}
            </button>
          </fetcher.Form>
          <aside hidden={!sidebarIsOpen}>
            <Outlet />
          </aside>
        </div>
      );
    }
    

While this is certainly more code that touches more of the application to account for the network requests and responses, the UX is greatly improved. Additionally, state comes from a single source of truth without any state synchronization required.

In summary, each of the discussed methods offers a unique set of benefits and challenges:

*   **React state**: Offers simple but transient state management.
*   **Local Storage**: Provides persistence but with synchronization requirements and UI flickering.
*   **Cookies**: Delivers robust, persistent state management at the cost of added boilerplate.

None of these are wrong, but if you want to persist the state across visits, cookies offer the best user experience.

### [](#form-validation-and-action-data)Form Validation and Action Data

Client-side validation can augment the user experience, but similar enhancements can be achieved by leaning more towards server-side processing and letting it handle the complexities.

The following example illustrates the inherent complexities of managing network state, coordinating state from the server, and implementing validation redundantly on both the client and server sides. It's just for illustration, so forgive any obvious bugs or problems you find.

    export function Signup() {
      // A multitude of React State declarations
      const [isSubmitting, setIsSubmitting] = useState(false);
    
      const [userName, setUserName] = useState("");
      const [userNameError, setUserNameError] = useState(null);
    
      const [password, setPassword] = useState(null);
      const [passwordError, setPasswordError] = useState("");
    
      // Replicating server-side logic in the client
      function validateForm() {
        setUserNameError(null);
        setPasswordError(null);
        const errors = validateSignupForm(userName, password);
        if (errors) {
          if (errors.userName) {
            setUserNameError(errors.userName);
          }
          if (errors.password) {
            setPasswordError(errors.password);
          }
        }
        return Boolean(errors);
      }
    
      // Manual network interaction handling
      async function handleSubmit() {
        if (validateForm()) {
          setSubmitting(true);
          const res = await postJSON("/api/signup", {
            userName,
            password,
          });
          const json = await res.json();
          setIsSubmitting(false);
    
          // Server state synchronization to the client
          if (json.errors) {
            if (json.errors.userName) {
              setUserNameError(json.errors.userName);
            }
            if (json.errors.password) {
              setPasswordError(json.errors.password);
            }
          }
        }
      }
    
      return (
        <form
          onSubmit={(event) => {
            event.preventDefault();
            handleSubmit();
          }}
        >
          <p>
            <input
              type="text"
              name="username"
              value={userName}
              onChange={() => {
                // Synchronizing form state for the fetch
                setUserName(event.target.value);
              }}
            />
            {userNameError ? <i>{userNameError}</i> : null}
          </p>
    
          <p>
            <input
              type="password"
              name="password"
              onChange={(event) => {
                // Synchronizing form state for the fetch
                setPassword(event.target.value);
              }}
            />
            {passwordError ? <i>{passwordError}</i> : null}
          </p>
    
          <button disabled={isSubmitting} type="submit">
            Sign Up
          </button>
    
          {isSubmitting ? <BusyIndicator /> : null}
        </form>
      );
    }
    

The backend endpoint, `/api/signup`, also performs validation and sends error feedback. Note that some essential validation, like detecting duplicate usernames, can only be done server-side using information the client doesn't have access to.

    export async function signupHandler(request: Request) {
      const errors = await validateSignupRequest(request);
      if (errors) {
        return { ok: false, errors: errors };
      }
      await signupUser(request);
      return { ok: true, errors: null };
    }
    

Now, let's contrast this with a React Router-based implementation. The action remains consistent, but the component is vastly simplified due to the direct utilization of server state via `actionData`, and leveraging the network state that React Router inherently manages.

    import { useNavigation } from "react-router";
    import type { Route } from "./+types/signup";
    
    export async function action({
      request,
    }: ActionFunctionArgs) {
      const errors = await validateSignupRequest(request);
      if (errors) {
        return { ok: false, errors: errors };
      }
      await signupUser(request);
      return { ok: true, errors: null };
    }
    
    export function Signup({
      actionData,
    }: Route.ComponentProps) {
      const navigation = useNavigation();
    
      const userNameError = actionData?.errors?.userName;
      const passwordError = actionData?.errors?.password;
      const isSubmitting = navigation.formAction === "/signup";
    
      return (
        <Form method="post">
          <p>
            <input type="text" name="username" />
            {userNameError ? <i>{userNameError}</i> : null}
          </p>
    
          <p>
            <input type="password" name="password" />
            {passwordError ? <i>{passwordError}</i> : null}
          </p>
    
          <button disabled={isSubmitting} type="submit">
            Sign Up
          </button>
    
          {isSubmitting ? <BusyIndicator /> : null}
        </Form>
      );
    }
    

The extensive state management from our previous example is distilled into just three code lines. We eliminate the necessity for React state, change event listeners, submit handlers, and state management libraries for such network interactions.

Direct access to the server state is made possible through `actionData`, and network state through `useNavigation` (or `useFetcher`).

As bonus party trick, the form is functional even before JavaScript loads (see [Progressive Enhancement](./progressive-enhancement)). Instead of React Router managing the network operations, the default browser behaviors step in.

If you ever find yourself entangled in managing and synchronizing state for network operations, React Router likely offers a more elegant solution.

[](#type-safety)Type Safety
===========================

If you haven't done so already, check out our guide for [setting up type safety](../how-to/route-module-type-safety) in a new project.

React Router generates types for each route in your app to provide type safety for the route module exports.

For example, let's say you have a `products/:id` route configured:

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("products/:id", "./routes/product.tsx"),
    ] satisfies RouteConfig;
    

You can import route-specific types like so:

    import type { Route } from "./+types/product";
    // types generated for this route 👆
    
    export function loader({ params }: Route.LoaderArgs) {
      //                      👆 { id: string }
      return { planet: `world #${params.id}` };
    }
    
    export default function Component({
      loaderData, // 👈 { planet: string }
    }: Route.ComponentProps) {
      return <h1>Hello, {loaderData.planet}!</h1>;
    }
    

[](#how-it-works)How it works
-----------------------------

React Router's type generation executes your route config (`app/routes.ts` by default) to determine the routes for your app. It then generates a `+types/<route file>.d.ts` for each route within a special `.react-router/types/` directory. With [`rootDirs` configured](../how-to/route-module-type-safety), TypeScript can import these generated files as if they were right next to their corresponding route modules.

For a deeper dive into some of the design decisions, check out our [type inference decision doc](https://github.com/remix-run/react-router/blob/dev/decisions/0012-type-inference.md).

[](#typegen-command)`typegen` command
-------------------------------------

You can manually generate types with the `typegen` command:

    react-router typegen
    

The following types are generated for each route:

*   `LoaderArgs`
*   `ClientLoaderArgs`
*   `ActionArgs`
*   `ClientActionArgs`
*   `HydrateFallbackProps`
*   `ComponentProps` (for the `default` export)
*   `ErrorBoundaryProps`

### [](#--watch)\--watch

If you run `react-router dev` — or if your custom server calls `vite.createServer` — then React Router's Vite plugin is already generating up-to-date types for you. But if you really need to run type generation on its own, you can also use `--watch` to automatically regenerate types as files change:

    react-router typegen --watch
    

[](#api-development-strategy)API Development Strategy
=====================================================

React Router is foundational to your application. We want to make sure that upgrading to new major versions is as smooth as possible while still allowing us to adjust and enhance the behavior and API as the React ecosystem advances.

Our strategy and motivations are discussed in more detail in our [Future Flags](https://remix.run/blog/future-flags) blog post.

[](#future-flags)Future Flags
-----------------------------

When an API changes in a breaking way, it is introduced in a future flag. This allows you to opt-in to one change a time before it becomes the default in the next major version.

*   Without enabling the future flag, nothing changes about your app
*   Enabling the flag changes the behavior for that feature

All current future flags are documented in the [Future Flags Guide](../upgrading/future) to help you stay up-to-date.

[](#unstable-flags)Unstable Flags
---------------------------------

Unstable flags are for features still being designed and developed and made available to our users to help us get it right.

Unstable flags are not recommended for production:

*   they will change without warning and without upgrade paths
*   they will have bugs
*   they aren't documented
*   they may be scrapped completely

When you opt-in to an unstable flag you are becoming a contributor to the project, rather than a user. We appreciate your help, but please be aware of the new role!

Because unstable flags are experimental and not guaranteed to stick around, we ship them in SemVer patch releases because they're not new _stable_/_documented_ APIs. When an unstable flag stabilizes into a Future Flag, that will be released in a SemVer minor release and will be properly documented and added to the [Future Flags Guide](../upgrading/future).

To learn about current unstable flags, keep an eye on the [CHANGELOG](../start/changelog).

### [](#example-new-feature-flow)Example New Feature Flow

The decision flow for a new feature looks something like this (note this diagram is in relation to Remix v1/v2 but applies to React Router v6/v7 as well):

[](#contributing-to-react-router)Contributing to React Router
=============================================================

Thanks for contributing, you rock!

When it comes to open source, there are many different kinds of contributions that can be made, all of which are valuable. Here are a few guidelines that should help you as you prepare your contribution.

[](#setup)Setup
---------------

Before you can contribute to the codebase, you will need to fork the repo. This will look a bit different depending on what type of contribution you are making:

*   All new features, bug-fixes, or **anything that touches `react-router` code** should be branched off of and merged into the `dev` branch
*   Changes that only touch documentation can be branched off of and merged into the `main` branch

The following steps will get you set up to contribute changes to this repo:

1.  Fork the repo (click the Fork button at the top right of [this page](https://github.com/remix-run/react-router))
    
2.  Clone your fork locally
    
        # in a terminal, cd to parent directory where you want your clone to be, then
        git clone https://github.com/<your_github_username>/react-router.git
        cd react-router
        
        # if you are making *any* code changes, make sure to checkout the dev branch
        git checkout dev
        
    
3.  Install dependencies and build. React Router uses [pnpm](https://pnpm.io), so you should too. If you install using `npm`, unnecessary `package-lock.json` files will be generated.
    

[](#think-you-found-a-bug)Think You Found a Bug?
------------------------------------------------

Please conform to the issue template and provide a clear path to reproduction with a code example. Best is a pull request with a [failing test](https://github.com/remix-run/react-router/blob/dev/integration/bug-report-test.ts). Next best is a link to [StackBlitz](https://reactrouter.com/new) or repository that illustrates the bug.

[](#adding-an-example)Adding an Example?
----------------------------------------

Examples can be added directly to the main branch. Create a branch off of your local clone of main. Once you've finished, create a pull request and outline your example.

[](#proposing-new-or-changed-api)Proposing New or Changed API?
--------------------------------------------------------------

Please provide thoughtful comments and some sample code that show what you'd like to do with React Router in your app. It helps the conversation if you can show us how you're limited by the current API first before jumping to a conclusion about what needs to be changed and/or added.

We have learned by experience that small APIs are usually better, so we may be a little reluctant to add something new unless there's an obvious limitation with the current API. That being said, we are always anxious to hear about cases that we just haven't considered before, so please don't be shy! :)

[](#issue-not-getting-attention)Issue Not Getting Attention?
------------------------------------------------------------

If you need a bug fixed and nobody is fixing it, your best bet is to provide a fix for it and make a [pull request](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request). Open source code belongs to all of us, and it's all of our responsibility to push it forward.

[](#making-a-pull-request)Making a Pull Request?
------------------------------------------------

Pull requests need only the approval of two or more collaborators to be merged; when the PR author is a collaborator, that counts as one.

When creating the PR in GitHub, make sure that you set the base to the correct branch. If you are submitting a PR that touches any code, this should be the `dev` branch. You set the base in GitHub when authoring the PR with the dropdown below the "Compare changes" heading:

### [](#tests)Tests

All commits that fix bugs or add features need a test.

Do not merge code without tests!

### [](#docs--examples)Docs + Examples

All commits that change or add to the API must be done in a pull request that also updates all relevant examples and docs.

Documentation is located in the `docs` directory. Once changes make their way into the `main` branch, they will automatically be published to the docs site.

If you want to preview how the changes will look on the docs site, clone the [`react-router-website` repository](https://github.com/remix-run/react-router-website) and follow the instructions in `README.md` to view your changes locally.

[](#development)Development
---------------------------

### [](#packages)Packages

React Router uses a monorepo to host code for multiple packages. These packages live in the `packages` directory.

We use [pnpm workspaces](https://pnpm.io/workspaces/) to manage installation of dependencies and running various scripts. To get everything installed, make sure you have [pnpm installed](https://pnpm.io/installation), and then run `pnpm install` from the repo root.

### [](#building)Building

Calling `pnpm build` from the root directory will run the build, which should take only a few seconds. It's important to build all the packages together because the individual packages have dependencies on one another.

### [](#testing)Testing

Before running the tests, you need to run a build. After you build, running `pnpm test` from the root directory will run **every** package's tests. If you want to run tests for a specific package, use `pnpm test --projects packages/<package-name>`:

    # Test all packages
    pnpm test
    
    # Test only react-router-dom
    pnpm test --projects packages/react-router-dom
    

[](#repository-branching)Repository Branching
---------------------------------------------

This repo maintains separate branches for different purposes. They will look something like this:

    - main   > the most recent release and current docs
    - dev    > code under active development between stable releases
    - v5     > the most recent code for a specific major release
    

There may be other branches for various features and experimentation, but all of the magic happens from these branches.

[](#new-releases)New Releases
-----------------------------

When it's time to cut a new release, we follow a process based on our branching strategy depending on the type of release.

### [](#react-routernext-releases)`react-router@next` Releases

We create experimental releases from the current state of the `dev` branch. They can be installed by using the `@next` tag:

    pnpm add react-router-dom@next
    # or
    npm install react-router-dom@next
    

These releases will be automated as PRs are merged into the `dev` branch.

### [](#latest-major-releases)Latest Major Releases

    # Start from the dev branch.
    git checkout dev
    
    # Merge the main branch into dev to ensure that any hotfixes and
    # docs updates are available in the release.
    git merge main
    
    # Create a new release branch from dev.
    git checkout -b release/v6.1.0
    
    # Create a new tag and update version references throughout the
    # codebase.
    pnpm run version [nextVersion]
    
    # Push the release branch along with the new release tag.
    git push origin release/v6.1.0 --follow-tags
    
    # Wait for GitHub actions to run all tests. If the tests pass, the
    # release is ready to go! Merge the release branch into main and dev.
    git checkout main
    git merge release/v6.1.0
    git checkout dev
    git merge release/v6.1.0
    
    # The release branch can now be deleted.
    git branch -D release/v6.1.0
    git push origin --delete release/v6.1.0
    
    # Now go to GitHub and create the release from the new tag. Let
    # GitHub Actions take care of the rest!
    

### [](#hot-fix-releases)Hot-fix Releases

Sometimes we have a crucial bug that needs to be patched right away. If the bug affects the latest release, we can create a new version directly from `main` (or the relevant major release branch where the bug exists):

    # From the main branch, make sure to run the build and all tests
    # before creating a new release.
    pnpm install && pnpm build && pnpm test
    
    # Assuming the tests pass, create the release tag and update
    # version references throughout the codebase.
    pnpm run version [nextVersion]
    
    # Push changes along with the new release tag.
    git push origin main --follow-tags
    
    # In GitHub, create the release from the new tag and it will be
    # published via GitHub actions
    
    # When the hot-fix is done, merge the changes into dev and clean
    # up conflicts as needed.
    git checkout dev
    git merge main
    git push origin dev
    

[](#react-router-releases)React Router Releases
===============================================

This page lists all releases/release notes for React Router back to `v6.0.0`. For releases prior to v6, please refer to the [Github Releases Page](https://github.com/remix-run/react-router/releases).

We manage release notes in this file instead of the paginated Github Releases Page for 2 reasons:

*   Pagination in the Github UI means that you cannot easily search release notes for a large span of releases at once
*   The paginated Github interface also cuts off longer releases notes without indication in list view, and you need to click into the detail view to see the full set of release notes

Table of Contents

*   [React Router Releases](#react-router-releases)
    *   [v7.6.0](#v760)
        *   [What's Changed](#whats-changed)
            *   [`routeDiscovery` Config Option](#routediscovery-config-option)
            *   [Automatic Types for Future Flags](#automatic-types-for-future-flags)
        *   [Minor Changes](#minor-changes)
        *   [Patch Changes](#patch-changes)
        *   [Unstable Changes](#unstable-changes)
        *   [Changes by Package](#changes-by-package)
    *   [v7.5.3](#v753)
        *   [Patch Changes](#patch-changes-1)
    *   [v7.5.2](#v752)
        *   [Security Notice](#security-notice)
        *   [Patch Changes](#patch-changes-2)
    *   [v7.5.1](#v751)
        *   [Patch Changes](#patch-changes-3)
        *   [Unstable Changes](#unstable-changes-1)
    *   [v7.5.0](#v750)
        *   [What's Changed](#whats-changed-1)
            *   [`route.lazy` Object API](#routelazy-object-api)
        *   [Minor Changes](#minor-changes-1)
        *   [Patch Changes](#patch-changes-4)
        *   [Unstable Changes](#unstable-changes-2)
        *   [Changes by Package](#changes-by-package-1)
    *   [v7.4.1](#v741)
        *   [Security Notice](#security-notice-1)
        *   [Patch Changes](#patch-changes-5)
        *   [Unstable Changes](#unstable-changes-3)
    *   [v7.4.0](#v740)
        *   [Minor Changes](#minor-changes-2)
        *   [Patch Changes](#patch-changes-6)
        *   [Unstable Changes](#unstable-changes-4)
        *   [Changes by Package](#changes-by-package-2)
    *   [v7.3.0](#v730)
        *   [Minor Changes](#minor-changes-3)
        *   [Patch Changes](#patch-changes-7)
        *   [Unstable Changes](#unstable-changes-5)
            *   [Client-side `context` (unstable)](#client-side-context-unstable)
            *   [Middleware (unstable)](#middleware-unstable)
                *   [Middleware `context` parameter](#middleware-context-parameter)
            *   [`unstable_SerializesTo`](#unstable_serializesto)
        *   [Changes by Package](#changes-by-package-3)
    *   [v7.2.0](#v720)
        *   [What's Changed](#whats-changed-2)
            *   [Type-safe `href` utility](#type-safe-href-utility)
            *   [Prerendering with a SPA Fallback](#prerendering-with-a-spa-fallback)
            *   [Allow a root `loader` in SPA Mode](#allow-a-root-loader-in-spa-mode)
        *   [Minor Changes](#minor-changes-4)
        *   [Patch Changes](#patch-changes-8)
        *   [Unstable Changes](#unstable-changes-6)
            *   [Split Route Modules (unstable)](#split-route-modules-unstable)
        *   [Changes by Package](#changes-by-package-4)
    *   [v7.1.5](#v715)
        *   [Patch Changes](#patch-changes-9)
    *   [v7.1.4](#v714)
        *   [Patch Changes](#patch-changes-10)
    *   [v7.1.3](#v713)
        *   [Patch Changes](#patch-changes-11)
    *   [v7.1.2](#v712)
        *   [Patch Changes](#patch-changes-12)
    *   [v7.1.1](#v711)
        *   [Patch Changes](#patch-changes-13)
    *   [v7.1.0](#v710)
        *   [Minor Changes](#minor-changes-5)
        *   [Patch Changes](#patch-changes-14)
        *   [Changes by Package](#changes-by-package-5)
    *   [v7.0.2](#v702)
        *   [Patch Changes](#patch-changes-15)
    *   [v7.0.1](#v701)
        *   [Patch Changes](#patch-changes-16)
    *   [v7.0.0](#v700)
        *   [Breaking Changes](#breaking-changes)
            *   [Package Restructuring](#package-restructuring)
            *   [Removed Adapter Re-exports](#removed-adapter-re-exports)
            *   [Removed APIs](#removed-apis)
            *   [Minimum Versions](#minimum-versions)
            *   [Adopted Future Flag Behaviors](#adopted-future-flag-behaviors)
            *   [Vite Compiler](#vite-compiler)
            *   [Exposed Router Promises](#exposed-router-promises)
        *   [Other Notable Changes](#other-notable-changes)
            *   [`routes.ts`](#routests)
            *   [Typesafety improvements](#typesafety-improvements)
            *   [Prerendering](#prerendering)
        *   [Major Changes (`react-router`)](#major-changes-react-router)
        *   [Major Changes (`@react-router/*`)](#major-changes-react-router-1)
        *   [Minor Changes](#minor-changes-6)
        *   [Patch Changes](#patch-changes-17)
        *   [Changes by Package](#changes-by-package-6)
*   [React Router v6 Releases](#react-router-v6-releases)
    *   [v6.30.1](#v6301)
        *   [Patch Changes](#patch-changes-18)
    *   [v6.30.0](#v6300)
        *   [Minor Changes](#minor-changes-7)
        *   [Patch Changes](#patch-changes-19)
    *   [v6.29.0](#v6290)
        *   [Minor Changes](#minor-changes-8)
        *   [Patch Changes](#patch-changes-20)
    *   [v6.28.2](#v6282)
        *   [Patch Changes](#patch-changes-21)
    *   [v6.28.1](#v6281)
        *   [Patch Changes](#patch-changes-22)
    *   [v6.28.0](#v6280)
        *   [What's Changed](#whats-changed-3)
        *   [Minor Changes](#minor-changes-9)
        *   [Patch Changes](#patch-changes-23)
    *   [v6.27.0](#v6270)
        *   [What's Changed](#whats-changed-4)
            *   [Stabilized APIs](#stabilized-apis)
        *   [Minor Changes](#minor-changes-10)
        *   [Patch Changes](#patch-changes-24)
    *   [v6.26.2](#v6262)
        *   [Patch Changes](#patch-changes-25)
    *   [v6.26.1](#v6261)
        *   [Patch Changes](#patch-changes-26)
    *   [v6.26.0](#v6260)
        *   [Minor Changes](#minor-changes-11)
        *   [Patch Changes](#patch-changes-27)
    *   [v6.25.1](#v6251)
        *   [Patch Changes](#patch-changes-28)
    *   [v6.25.0](#v6250)
        *   [What's Changed](#whats-changed-5)
            *   [Stabilized `v7_skipActionErrorRevalidation`](#stabilized-v7_skipactionerrorrevalidation)
        *   [Minor Changes](#minor-changes-12)
        *   [Patch Changes](#patch-changes-29)
    *   [v6.24.1](#v6241)
        *   [Patch Changes](#patch-changes-30)
    *   [v6.24.0](#v6240)
        *   [What's Changed](#whats-changed-6)
            *   [Lazy Route Discovery (a.k.a. "Fog of War")](#lazy-route-discovery-aka-fog-of-war)
        *   [Minor Changes](#minor-changes-13)
        *   [Patch Changes](#patch-changes-31)
    *   [v6.23.1](#v6231)
        *   [Patch Changes](#patch-changes-32)
    *   [v6.23.0](#v6230)
        *   [What's Changed](#whats-changed-7)
            *   [Data Strategy (unstable)](#data-strategy-unstable)
            *   [Skip Action Error Revalidation (unstable)](#skip-action-error-revalidation-unstable)
        *   [Minor Changes](#minor-changes-14)
    *   [v6.22.3](#v6223)
        *   [Patch Changes](#patch-changes-33)
    *   [v6.22.2](#v6222)
        *   [Patch Changes](#patch-changes-34)
    *   [v6.22.1](#v6221)
        *   [Patch Changes](#patch-changes-35)
    *   [v6.22.0](#v6220)
        *   [What's Changed](#whats-changed-8)
            *   [Core Web Vitals Technology Report Flag](#core-web-vitals-technology-report-flag)
        *   [Minor Changes](#minor-changes-15)
        *   [Patch Changes](#patch-changes-36)
    *   [v6.21.3](#v6213)
        *   [Patch Changes](#patch-changes-37)
    *   [v6.21.2](#v6212)
        *   [Patch Changes](#patch-changes-38)
    *   [v6.21.1](#v6211)
        *   [Patch Changes](#patch-changes-39)
    *   [v6.21.0](#v6210)
        *   [What's Changed](#whats-changed-9)
            *   [`future.v7_relativeSplatPath`](#futurev7_relativesplatpath)
            *   [Partial Hydration](#partial-hydration)
        *   [Minor Changes](#minor-changes-16)
        *   [Patch Changes](#patch-changes-40)
    *   [v6.20.1](#v6201)
        *   [Patch Changes](#patch-changes-41)
    *   [v6.20.0](#v6200)
        *   [Minor Changes](#minor-changes-17)
        *   [Patch Changes](#patch-changes-42)
    *   [v6.19.0](#v6190)
        *   [What's Changed](#whats-changed-10)
            *   [`unstable_flushSync` API](#unstable_flushsync-api)
        *   [Minor Changes](#minor-changes-18)
        *   [Patch Changes](#patch-changes-43)
    *   [v6.18.0](#v6180)
        *   [What's Changed](#whats-changed-11)
            *   [New Fetcher APIs](#new-fetcher-apis)
            *   [Persistence Future Flag (`future.v7_fetcherPersist`)](#persistence-future-flag-futurev7_fetcherpersist)
        *   [Minor Changes](#minor-changes-19)
        *   [Patch Changes](#patch-changes-44)
    *   [v6.17.0](#v6170)
        *   [What's Changed](#whats-changed-12)
            *   [View Transitions 🚀](#view-transitions-)
        *   [Minor Changes](#minor-changes-20)
        *   [Patch Changes](#patch-changes-45)
    *   [v6.16.0](#v6160)
        *   [Minor Changes](#minor-changes-21)
        *   [Patch Changes](#patch-changes-46)
    *   [v6.15.0](#v6150)
        *   [Minor Changes](#minor-changes-22)
        *   [Patch Changes](#patch-changes-47)
    *   [v6.14.2](#v6142)
        *   [Patch Changes](#patch-changes-48)
    *   [v6.14.1](#v6141)
        *   [Patch Changes](#patch-changes-49)
    *   [v6.14.0](#v6140)
        *   [What's Changed](#whats-changed-13)
            *   [JSON/Text Submissions](#jsontext-submissions)
        *   [Minor Changes](#minor-changes-23)
        *   [Patch Changes](#patch-changes-50)
    *   [v6.13.0](#v6130)
        *   [What's Changed](#whats-changed-14)
            *   [`future.v7_startTransition`](#futurev7_starttransition)
        *   [Minor Changes](#minor-changes-24)
        *   [Patch Changes](#patch-changes-51)
    *   [v6.12.1](#v6121)
        *   [Patch Changes](#patch-changes-52)
    *   [v6.12.0](#v6120)
        *   [What's Changed](#whats-changed-15)
            *   [`React.startTransition` support](#reactstarttransition-support)
        *   [Minor Changes](#minor-changes-25)
        *   [Patch Changes](#patch-changes-53)
    *   [v6.11.2](#v6112)
        *   [Patch Changes](#patch-changes-54)
    *   [v6.11.1](#v6111)
        *   [Patch Changes](#patch-changes-55)
    *   [v6.11.0](#v6110)
        *   [Minor Changes](#minor-changes-26)
        *   [Patch Changes](#patch-changes-56)
    *   [v6.10.0](#v6100)
        *   [What's Changed](#whats-changed-16)
        *   [Minor Changes](#minor-changes-27)
            *   [`future.v7_normalizeFormMethod`](#futurev7_normalizeformmethod)
        *   [Patch Changes](#patch-changes-57)
    *   [v6.9.0](#v690)
        *   [What's Changed](#whats-changed-17)
            *   [`Component`/`ErrorBoundary` route properties](#componenterrorboundary-route-properties)
            *   [Introducing Lazy Route Modules](#introducing-lazy-route-modules)
        *   [Minor Changes](#minor-changes-28)
        *   [Patch Changes](#patch-changes-58)
    *   [v6.8.2](#v682)
        *   [Patch Changes](#patch-changes-59)
    *   [v6.8.1](#v681)
        *   [Patch Changes](#patch-changes-60)
    *   [v6.8.0](#v680)
        *   [Minor Changes](#minor-changes-29)
        *   [Patch Changes](#patch-changes-61)
    *   [v6.7.0](#v670)
        *   [Minor Changes](#minor-changes-30)
        *   [Patch Changes](#patch-changes-62)
    *   [v6.6.2](#v662)
        *   [Patch Changes](#patch-changes-63)
    *   [v6.6.1](#v661)
        *   [Patch Changes](#patch-changes-64)
    *   [v6.6.0](#v660)
        *   [What's Changed](#whats-changed-18)
        *   [Minor Changes](#minor-changes-31)
        *   [Patch Changes](#patch-changes-65)
    *   [v6.5.0](#v650)
        *   [What's Changed](#whats-changed-19)
        *   [Minor Changes](#minor-changes-32)
        *   [Patch Changes](#patch-changes-66)
    *   [v6.4.5](#v645)
        *   [Patch Changes](#patch-changes-67)
    *   [v6.4.4](#v644)
        *   [Patch Changes](#patch-changes-68)
    *   [v6.4.3](#v643)
        *   [Patch Changes](#patch-changes-69)
    *   [v6.4.2](#v642)
        *   [Patch Changes](#patch-changes-70)
    *   [v6.4.1](#v641)
        *   [Patch Changes](#patch-changes-71)
    *   [v6.4.0](#v640)
        *   [What's Changed](#whats-changed-20)
            *   [Remix Data APIs](#remix-data-apis)
        *   [Patch Changes](#patch-changes-72)
    *   [v6.3.0](#v630)
        *   [Minor Changes](#minor-changes-33)
    *   [v6.2.2](#v622)
        *   [Patch Changes](#patch-changes-73)
    *   [v6.2.1](#v621)
        *   [Patch Changes](#patch-changes-74)
    *   [v6.2.0](#v620)
        *   [Minor Changes](#minor-changes-34)
        *   [Patch Changes](#patch-changes-75)
    *   [v6.1.1](#v611)
        *   [Patch Changes](#patch-changes-76)
    *   [v6.1.0](#v610)
        *   [Minor Changes](#minor-changes-35)
        *   [Patch Changes](#patch-changes-77)
    *   [v6.0.2](#v602)
        *   [Patch Changes](#patch-changes-78)
    *   [v6.0.1](#v601)
        *   [Patch Changes](#patch-changes-79)
    *   [v6.0.0](#v600)

[](#v760)v7.6.0
---------------

Date: 2025-05-08

### [](#whats-changed)What's Changed

#### [](#routediscovery-config-option)`routeDiscovery` Config Option

We've added a new config option in `7.6.0` which grants you more control over the Lazy Route Discovery feature. You can now configure the `/__manifest` path if you're running multiple RR applications on the same server, or you can also disable the feature entirely if your application is small enough and the feature isn't necessary.

    // react-router.config.ts
    
    export default {
      // You can modify the manifest path used:
      routeDiscovery: { mode: "lazy", manifestPath: "/custom-manifest" }
    
      // Or you can disable this feature entirely and include all routes in the
      // manifest on initial document load:
      routeDiscovery: { mode: "initial" }
    
      // If you don't specify anything, the default config is as follows, which enables
      // Lazy Route Discovery and makes manifest requests to the `/__manifest` path:
      // routeDiscovery: { mode: "lazy", manifestPath: "/__manifest" }
    } satisfies Config;
    

#### [](#automatic-types-for-future-flags)Automatic Types for Future Flags

Some future flags alter the way types should work in React Router. Previously, you had to remember to manually opt-in to the new types. For example, for `future.unstable_middleware`:

    // react-router.config.ts
    
    // Step 1: Enable middleware
    export default {
      future: {
        unstable_middleware: true,
      },
    };
    
    // Step 2: Enable middleware types
    declare module "react-router" {
      interface Future {
        unstable_middleware: true; // 👈 Enable middleware types
      }
    }
    

It was up to you to keep the runtime future flags synced with the types for those flags. This was confusing and error-prone.

Now, React Router will automatically enable types for future flags. That means you only need to specify the runtime future flag:

    // react-router.config.ts
    
    // Step 1: Enable middleware
    export default {
      future: {
        unstable_middleware: true,
      },
    };
    
    // No step 2! That's it!
    

Behind the scenes, React Router will generate the corresponding `declare module` into `.react-router/types`. Currently this is done in `.react-router/types/+register.ts` but this is an implementation detail that may change in the future.

### [](#minor-changes)Minor Changes

*   `react-router` - Added a new `routeDiscovery` option in `react-router.config.ts` to configure Lazy Route Discovery behavior ([#13451](https://github.com/remix-run/react-router/pull/13451))
    
*   `react-router` - Add support for route component props in `createRoutesStub` ([#13528](https://github.com/remix-run/react-router/pull/13528))
    
    *   This allows you to unit test your route components using the props instead of the hooks:
        
            let RoutesStub = createRoutesStub([
              {
                path: "/",
                Component({ loaderData }) {
                  let data = loaderData as { message: string };
                  return <pre data-testid="data">Message: {data.message}</pre>;
                },
                loader() {
                  return { message: "hello" };
                },
              },
            ]);
            
            render(<RoutesStub />);
            
            await waitFor(() => screen.findByText("Message: hello"));
            
        
*   `@react-router/dev` - Automatic types for future flags ([#13506](https://github.com/remix-run/react-router/pull/13506))
    

### [](#patch-changes)Patch Changes

You may notice this list is a bit larger than usual! The team ate their vegetables last week and spent the week [squashing bugs](https://x.com/BrooksLybrand/status/1918406062920589731) to work on lowering the issue count that had ballooned a bit since the v7 release.

*   `react-router` - Fix `react-router` module augmentation for `NodeNext` ([#13498](https://github.com/remix-run/react-router/pull/13498))
*   `react-router` - Don't bundle `react-router` in `react-router/dom` CJS export ([#13497](https://github.com/remix-run/react-router/pull/13497))
*   `react-router` - Fix bug where a submitting `fetcher` would get stuck in a `loading` state if a revalidating `loader` redirected ([#12873](https://github.com/remix-run/react-router/pull/12873))
*   `react-router` - Fix hydration error if a server `loader` returned `undefined` ([#13496](https://github.com/remix-run/react-router/pull/13496))
*   `react-router` - Fix initial load 404 scenarios in data mode ([#13500](https://github.com/remix-run/react-router/pull/13500))
*   `react-router` - Stabilize `useRevalidator`'s `revalidate` function ([#13542](https://github.com/remix-run/react-router/pull/13542))
*   `react-router` - Preserve status code if a `clientAction` throws a `data()` result in framework mode ([#13522](https://github.com/remix-run/react-router/pull/13522))
*   `react-router` - Be defensive against leading double slashes in paths to avoid `Invalid URL` errors from the URL constructor ([#13510](https://github.com/remix-run/react-router/pull/13510))
    *   Note we do not sanitize/normalize these paths - we only detect them so we can avoid the error that would be thrown by `new URL("//", window.location.origin)`
*   `react-router` - Remove `Navigator` declaration for `navigator.connection.saveData` to avoid messing with any other types beyond `saveData` in user land ([#13512](https://github.com/remix-run/react-router/pull/13512))
*   `react-router` - Fix `handleError` `params` values on `.data` requests for routes with a dynamic param as the last URL segment ([#13481](https://github.com/remix-run/react-router/pull/13481))
*   `react-router` - Don't trigger an `ErrorBoundary` UI before the reload when we detect a manifest version mismatch in Lazy Route Discovery ([#13480](https://github.com/remix-run/react-router/pull/13480))
*   `react-router` - Inline `turbo-stream@2.4.1` dependency and fix decoding ordering of `Map`/`Set` instances ([#13518](https://github.com/remix-run/react-router/pull/13518))
*   `react-router` - Only render dev warnings during dev ([#13461](https://github.com/remix-run/react-router/pull/13461))
*   `react-router` - Short circuit post-processing on aborted `dataStrategy` requests ([#13521](https://github.com/remix-run/react-router/pull/13521))
    *   This resolves non-user-facing console errors of the form `Cannot read properties of undefined (reading 'result')`
*   `@react-router/dev` - Support project root directories without a `package.json` if it exists in a parent directory ([#13472](https://github.com/remix-run/react-router/pull/13472))
*   `@react-router/dev` - When providing a custom Vite config path via the CLI `--config`/`-c` flag, default the project root directory to the directory containing the Vite config when not explicitly provided ([#13472](https://github.com/remix-run/react-router/pull/13472))
*   `@react-router/dev` - In a `routes.ts` context, ensure the `--mode` flag is respected for `import.meta.env.MODE` ([#13485](https://github.com/remix-run/react-router/pull/13485))
    *   Previously, `import.meta.env.MODE` within a `routes.ts` context was always `"development"` for the `dev` and `typegen --watch` commands, but otherwise resolved to `"production"`. These defaults are still in place, but if a `--mode` flag is provided, this will now take precedence.
*   `@react-router/dev` - Ensure consistent project root directory resolution logic in CLI commands ([#13472](https://github.com/remix-run/react-router/pull/13472))
*   `@react-router/dev` - When executing `react-router.config.ts` and `routes.ts` with `vite-node`, ensure that PostCSS config files are ignored ([#13489](https://github.com/remix-run/react-router/pull/13489))
*   `@react-router/dev` - When extracting critical CSS during development, ensure it's loaded from the client environment to avoid issues with plugins that handle the SSR environment differently ([#13503](https://github.com/remix-run/react-router/pull/13503))
*   `@react-router/dev` - Fix "Status message is not supported by HTTP/2" error during dev when using HTTPS ([#13460](https://github.com/remix-run/react-router/pull/13460))
*   `@react-router/dev` - Update config when `react-router.config.ts` is created or deleted during development ([#12319](https://github.com/remix-run/react-router/pull/12319))
*   `@react-router/dev` - Skip unnecessary `routes.ts` evaluation before Vite build is started ([#13513](https://github.com/remix-run/react-router/pull/13513))
*   `@react-router/dev` - Fix `TS2300: Duplicate identifier` errors caused by generated types ([#13499](https://github.com/remix-run/react-router/pull/13499))
*   Previously, routes that had the same full path would cause duplicate entries in the generated types for `href` (`.react-router/types/+register.ts`), causing type checking errors

### [](#unstable-changes)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Fix a few bugs with error bubbling in middleware use-cases ([#13538](https://github.com/remix-run/react-router/pull/13538))
*   `@react-router/dev` - When `future.unstable_viteEnvironmentApi` is enabled, ensure that `build.assetsDir` in Vite config is respected when `environments.client.build.assetsDir` is not configured ([#13491](https://github.com/remix-run/react-router/pull/13491))

### [](#changes-by-package)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/create-react-router/CHANGELOG.md#760)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router/CHANGELOG.md#760)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-architect/CHANGELOG.md#760)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-cloudflare/CHANGELOG.md#760)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-dev/CHANGELOG.md#760)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-express/CHANGELOG.md#760)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-fs-routes/CHANGELOG.md#760)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-node/CHANGELOG.md#760)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#760)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.6.0/packages/react-router-serve/CHANGELOG.md#760)

**Full Changelog**: [`v7.5.3...v7.6.0`](https://github.com/remix-run/react-router/compare/react-router@7.5.3...react-router@7.6.0)

[](#v753)v7.5.3
---------------

Date: 2025-04-28

### [](#patch-changes-1)Patch Changes

*   `react-router` - Fix bug where bubbled action errors would result in `loaderData` being cleared at the handling `ErrorBoundary` route ([#13476](https://github.com/remix-run/react-router/pull/13476))
*   `react-router` - Handle redirects from `clientLoader.hydrate` initial load executions ([#13477](https://github.com/remix-run/react-router/pull/13477))

**Full Changelog**: [`v7.5.2...v7.5.3`](https://github.com/remix-run/react-router/compare/react-router@7.5.2...react-router@7.5.3)

[](#v752)v7.5.2
---------------

Date: 2025-04-24

### [](#security-notice)Security Notice

Fixed 2 security vulnerabilities that could result in cache-poisoning attacks by sending specific headers intended for build-time usage for SPA Mode and Pre-rendering ([GHSA-f46r-rw29-r322](https://github.com/remix-run/react-router/security/advisories/GHSA-f46r-rw29-r322), [GHSA-cpj6-fhp6-mr6j](https://github.com/remix-run/react-router/security/advisories/GHSA-cpj6-fhp6-mr6j)).

### [](#patch-changes-2)Patch Changes

*   `react-router` - Adjust approach for Pre-rendering/SPA Mode via headers ([#13453](https://github.com/remix-run/react-router/pull/13453))
*   `react-router` - Update Single Fetch to also handle the 204 redirects used in `?_data` requests in Remix v2 ([#13364](https://github.com/remix-run/react-router/pull/13364))
    *   This allows applications to trigger a redirect on `.data` requests from outside the scope of React Router (i.e., an `express`/`hono` middleware) the same way they did in Remix v2 before Single Fetch was implemented
    *   This is a bit of an escape hatch - the recommended way to handle this is redirecting from a root route middleware
    *   To use this functionality, you may return from a `.data` request wih a response as follows:
        *   Set a 204 status code
        *   Set an `X-Remix-Redirect: <new-location>` header
        *   Optionally, set `X-Remix-Replace: true` or `X-Remix-Reload-Document: true` headers to replicate `replace()`/`redirectDocument()` functionality
    *   ⚠️ Please note that these responses rely on implementation details that are subject to change without a SemVer major release, and it is recommended you set up integration tests for your application to confirm this functionality is working correctly with each future React Router upgrade

**Full Changelog**: [`v7.5.1...v7.5.2`](https://github.com/remix-run/react-router/compare/react-router@7.5.1...react-router@7.5.2)

[](#v751)v7.5.1
---------------

Date: 2025-04-17

### [](#patch-changes-3)Patch Changes

*   `react-router` - When using the object-based `route.lazy` API, the `HydrateFallback` and `hydrateFallbackElement` properties are now skipped when lazy loading routes after hydration ([#13376](https://github.com/remix-run/react-router/pull/13376))
    
    *   If you move the code for these properties into a separate file, since the hydrate properties were unused already (if the route wasn't present during hydration), you can avoid downloading them at all. For example:
        
            createBrowserRouter([
              {
                path: "/show/:showId",
                lazy: {
                  loader: async () => (await import("./show.loader.js")).loader,
                  Component: async () =>
                    (await import("./show.component.js")).Component,
                  HydrateFallback: async () =>
                    (await import("./show.hydrate-fallback.js")).HydrateFallback,
                },
              },
            ]);
            
        
*   `react-router` - Fix single fetch bug where no revalidation request would be made when navigating upwards to a reused parent route ([#13253](https://github.com/remix-run/react-router/pull/13253))
    
*   `react-router` - Properly revalidate pre-rendered paths when param values change when using `ssr:false` + `prerender` configs ([#13380](https://github.com/remix-run/react-router/pull/13380))
    
*   `react-router` - Fix pre-rendering when a loader returns a redirect ([#13365](https://github.com/remix-run/react-router/pull/13365))
    
*   `react-router` - Do not automatically add `null` to `staticHandler.query()` `context.loaderData` if routes do not have loaders ([#13223](https://github.com/remix-run/react-router/pull/13223))
    
    *   This was a Remix v2 implementation detail inadvertently left in for React Router v7
    *   Now that we allow returning `undefined` from loaders, our prior check of `loaderData[routeId] !== undefined` was no longer sufficient and was changed to a `routeId in loaderData` check - these `null` values can cause issues for this new check
    *   ⚠️ This could be a "breaking bug fix" for you if you are doing manual SSR with `createStaticHandler()`/`<StaticRouterProvider>`, and using `context.loaderData` to control `<RouterProvider>` hydration behavior on the client

### [](#unstable-changes-1)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Add better error messaging when `getLoadContext` is not updated to return a `Map` ([#13242](https://github.com/remix-run/react-router/pull/13242))
*   `react-router` - Update context type for `LoaderFunctionArgs`/`ActionFunctionArgs` when middleware is enabled ([#13381](https://github.com/remix-run/react-router/pull/13381))
*   `react-router` - Add a new `unstable_runClientMiddleware` argument to `dataStrategy` to enable middleware execution in custom `dataStrategy` implementations ([#13395](https://github.com/remix-run/react-router/pull/13395))
*   `react-router` - Add support for the new `unstable_shouldCallHandler`/`unstable_shouldRevalidateArgs` APIs in `dataStrategy` ([#13253](https://github.com/remix-run/react-router/pull/13253))

**Full Changelog**: [`v7.5.0...v7.5.1`](https://github.com/remix-run/react-router/compare/react-router@7.5.0...react-router@7.5.1)

[](#v750)v7.5.0
---------------

Date: 2025-04-04

### [](#whats-changed-1)What's Changed

#### [](#routelazy-object-api)`route.lazy` Object API

We've introduced a new `route.lazy` API which gives you more granular control over the lazy loading of route properties that you could not achieve with the `route.lazy()` function signature. This is useful for Framework mode and performance-critical library mode applications.

    createBrowserRouter([
      {
        path: "/show/:showId",
        lazy: {
          loader: async () => (await import("./show.loader.js")).loader,
          action: async () => (await import("./show.action.js")).action,
          Component: async () => (await import("./show.component.js")).Component,
        },
      },
    ]);
    

⚠️ This is a breaking change if you have adopted the `route.unstable_lazyMiddleware` API which has been removed in favor of `route.lazy.unstable_middleware`. See the `Unstable Changes` section below for more information.

### [](#minor-changes-1)Minor Changes

*   `react-router` - Add granular object-based API for `route.lazy` to support lazy loading of individual route properties ([#13294](https://github.com/remix-run/react-router/pull/13294))

### [](#patch-changes-4)Patch Changes

*   `@react-router/dev` - Update optional `wrangler` peer dependency range to support `wrangler` v4 ([#13258](https://github.com/remix-run/react-router/pull/13258))
*   `@react-router/dev` - Reinstate dependency optimization in the child compiler to fix `depsOptimizer is required in dev mode` errors when using `vite-plugin-cloudflare` and importing Node.js builtins ([#13317](https://github.com/remix-run/react-router/pull/13317))

### [](#unstable-changes-2)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Introduce `future.unstable_subResourceIntegrity` flag that enables generation of an `importmap` with `integrity` for the scripts that will be loaded by the browser ([#13163](https://github.com/remix-run/react-router/pull/13163))
*   `react-router` - Remove support for the `route.unstable_lazyMiddleware` property ([#13294](https://github.com/remix-run/react-router/pull/13294))
    *   In order to lazily load middleware, you can use the new object-based `route.lazy.unstable_middleware` API
*   `@react-router/dev` - When `future.unstable_viteEnvironmentApi` is enabled, ensure critical CSS in development works when using a custom Vite `base` has been configured ([#13305](https://github.com/remix-run/react-router/pull/13305))

### [](#changes-by-package-1)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/create-react-router/CHANGELOG.md#750)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router/CHANGELOG.md#750)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-architect/CHANGELOG.md#750)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-cloudflare/CHANGELOG.md#750)
*   [`@react-router/dev`](http://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-dev/CHANGELOG.md#750)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-express/CHANGELOG.md#750)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-fs-routes/CHANGELOG.md#750)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-node/CHANGELOG.md#750)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#750)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.5.0/packages/react-router-serve/CHANGELOG.md#750)

**Full Changelog**: [`v7.4.1...v7.5.0`](https://github.com/remix-run/react-router/compare/react-router@7.4.1...react-router@7.5.0)

[](#v741)v7.4.1
---------------

Date: 2025-03-28

### [](#security-notice-1)Security Notice

Fixed a security vulnerability that allowed URL manipulation and potential cache pollution via the `Host` and `X-Forwarded-Host` headers due to inadequate port sanitization ([GHSA-4q56-crqp-v477/CVE-2025-31137](https://github.com/remix-run/react-router/security/advisories/GHSA-4q56-crqp-v477)).

### [](#patch-changes-5)Patch Changes

*   `react-router` - Dedupe calls to `route.lazy` functions ([#13260](https://github.com/remix-run/react-router/pull/13260))
*   `@react-router/dev` - Fix path in prerender error messages ([#13257](https://github.com/remix-run/react-router/pull/13257))
*   `@react-router/dev` - Fix typegen for virtual modules when `moduleDetection` is set to `force` ([#13267](https://github.com/remix-run/react-router/pull/13267))
*   `@react-router/express` - Better validation of `x-forwarded-host` header to prevent potential security issues ([#13309](https://github.com/remix-run/react-router/pull/13309))

### [](#unstable-changes-3)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Fix types on `unstable_MiddlewareFunction` to avoid type errors when a middleware doesn't return a value ([#13311](https://github.com/remix-run/react-router/pull/13311))
*   `react-router` - Add support for `route.unstable_lazyMiddleware` function to allow lazy loading of middleware logic ([#13210](https://github.com/remix-run/react-router/pull/13210))
    *   ⚠️ We do not recommend adoption of this API currently as we are likely going to change it prior to the stable release of middleware
    *   ⚠️ This may be a breaking change if your app is currently returning `unstable_middleware` from `route.lazy`
    *   The `route.unstable_middleware` property is no longer supported in the return value from `route.lazy`
    *   If you want to lazily load middleware, you must use `route.unstable_lazyMiddleware`
*   `@react-router/dev` - When both `future.unstable_middleware` and `future.unstable_splitRouteModules` are enabled, split `unstable_clientMiddleware` route exports into separate chunks when possible ([#13210](https://github.com/remix-run/react-router/pull/13210))
*   `@react-router/dev` - Improve performance of `future.unstable_middleware` by ensuring that route modules are only blocking during the middleware phase when the `unstable_clientMiddleware` has been defined ([#13210](https://github.com/remix-run/react-router/pull/13210))

**Full Changelog**: [`v7.4.0...v7.4.1`](https://github.com/remix-run/react-router/compare/react-router@7.4.0...react-router@7.4.1)

[](#v740)v7.4.0
---------------

Date: 2025-03-19

### [](#minor-changes-2)Minor Changes

*   `@react-router/dev` - Generate types for `virtual:react-router/server-build` module ([#13152](https://github.com/remix-run/react-router/pull/13152))

### [](#patch-changes-6)Patch Changes

*   `react-router` - Fix root loader data on initial load redirects in SPA mode ([#13222](https://github.com/remix-run/react-router/pull/13222))
*   `react-router` - Load ancestor pathless/index routes in lazy route discovery for upwards non-eager-discovery routing ([#13203](https://github.com/remix-run/react-router/pull/13203))
*   `react-router` - Fix `shouldRevalidate` behavior for `clientLoader`\-only routes in `ssr:true` apps ([#13221](https://github.com/remix-run/react-router/pull/13221))
*   `@react-router/dev` - Fix conflicts with other Vite plugins that use the `configureServer` and/or `configurePreviewServer` hooks ([#13184](https://github.com/remix-run/react-router/pull/13184))

### [](#unstable-changes-4)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - If a middleware throws an error, ensure we only bubble the error itself via `next()` and are no longer leaking the `MiddlewareError` implementation detail ([#13180](https://github.com/remix-run/react-router/pull/13180))
    *   ⚠️ This may be a breaking change if you are `catch`\-ing errors thrown by the `next()` function in your middlewares
*   `react-router` - Fix `RequestHandler` `loadContext` parameter type when middleware is enabled ([#13204](https://github.com/remix-run/react-router/pull/13204))
*   `react-router` - Update `Route.unstable_MiddlewareFunction` to have a return value of `Response | undefined` instead of `Response | void` ([#13199](https://github.com/remix-run/react-router/pull/13199))
*   `@react-router/dev` - When `future.unstable_splitRouteModules` is set to `"enforce"`, allow both splittable and unsplittable root route exports since it's always in a single chunk ([#13238](https://github.com/remix-run/react-router/pull/13238))
*   `@react-router/dev` - When `future.unstable_viteEnvironmentApi` is enabled, allow plugins that override the default SSR environment (such as `@cloudflare/vite-plugin`) to be placed before or after the React Router plugin ([#13183](https://github.com/remix-run/react-router/pull/13183))

### [](#changes-by-package-2)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/create-react-router/CHANGELOG.md#740)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router/CHANGELOG.md#740)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-architect/CHANGELOG.md#740)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-cloudflare/CHANGELOG.md#740)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-dev/CHANGELOG.md#740)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-express/CHANGELOG.md#740)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-fs-routes/CHANGELOG.md#740)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-node/CHANGELOG.md#740)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#740)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.4.0/packages/react-router-serve/CHANGELOG.md#740)

**Full Changelog**: [`v7.3.0...v7.4.0`](https://github.com/remix-run/react-router/compare/react-router@7.3.0...react-router@7.4.0)

[](#v730)v7.3.0
---------------

Date: 2025-03-06

### [](#minor-changes-3)Minor Changes

*   Add `fetcherKey` as a parameter to `patchRoutesOnNavigation` ([#13061](https://github.com/remix-run/react-router/pull/13061))

### [](#patch-changes-7)Patch Changes

*   `react-router` - Detect and handle manifest-skew issues on new deploys during active sessions ([#13061](https://github.com/remix-run/react-router/pull/13061))
    *   In framework mode, Lazy Route Discovery will now detect manifest version mismatches in active sessions after a new deploy
    *   On navigations to undiscovered routes, this mismatch will trigger a document reload of the destination path
    *   On `fetcher` calls to undiscovered routes, this mismatch will trigger a document reload of the current path
*   `react-router` - Skip resource route flow in dev server in SPA mode ([#13113](https://github.com/remix-run/react-router/pull/13113))
*   `react-router` - Fix single fetch `_root.data` requests when a `basename` is used ([#12898](https://github.com/remix-run/react-router/pull/12898))
*   `react-router` - Fix types for `loaderData` and `actionData` that contained `Record`s ([#13139](https://github.com/remix-run/react-router/pull/13139))
    *   ⚠️ This is a breaking change for users who have already adopted `unstable_SerializesTo` - see the note in the `Unstable Changes` section below for more information
*   `@react-router/dev` - Fix support for custom client `build.rollupOptions.output.entryFileNames` ([#13098](https://github.com/remix-run/react-router/pull/13098))
*   `@react-router/dev` - Fix usage of `prerender` option when `serverBundles` option has been configured or provided by a preset, e.g. `vercelPreset` from `@vercel/react-router` ([#13082](https://github.com/remix-run/react-router/pull/13082))
*   `@react-router/dev` - Fix support for custom `build.assetsDir` ([#13077](https://github.com/remix-run/react-router/pull/13077))
*   `@react-router/dev` - Remove unused dependencies ([#13134](https://github.com/remix-run/react-router/pull/13134))
*   `@react-router/dev` - Stub all routes except root in "SPA Mode" server builds to avoid issues when route modules or their dependencies import non-SSR-friendly modules ([#13023](https://github.com/remix-run/react-router/pull/13023))
*   `@react-router/dev` - Remove unused Vite file system watcher ([#13133](https://github.com/remix-run/react-router/pull/13133))
*   `@react-router/dev` - Fix support for custom SSR build input when `serverBundles` option has been configured ([#13107](https://github.com/remix-run/react-router/pull/13107))
    *   ⚠️ Note that for consumers using the `future.unstable_viteEnvironmentApi` and `serverBundles` options together, hyphens are no longer supported in server bundle IDs since they also need to be valid Vite environment names.
*   `@react-router/dev` - Fix dev server when using HTTPS by stripping HTTP/2 pseudo headers from dev server requests ([#12830](https://github.com/remix-run/react-router/pull/12830))
*   `@react-router/dev` - Lazy load Cloudflare platform proxy on first dev server request when using the `cloudflareDevProxy` Vite plugin to avoid creating unnecessary `workerd` processes ([#13016](https://github.com/remix-run/react-router/pull/13016))
*   `@react-router/dev` - Fix duplicated entries in typegen for layout routes and their corresponding index route ([#13140](https://github.com/remix-run/react-router/pull/13140))
*   `@react-router/express` - Update `express` `peerDependency` to include v5 ([https://github.com/remix-run/react-router/pull/13064](https://github.com/remix-run/react-router/pull/13064)) ([#12961](https://github.com/remix-run/react-router/pull/12961))

### [](#unstable-changes-5)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Add `context` support to client side data routers (unstable) ([#12941](https://github.com/remix-run/react-router/pull/12941))
*   `react-router` - Support middleware on routes (unstable) ([#12941](https://github.com/remix-run/react-router/pull/12941))
*   `@react-router/dev` - Fix errors with `future.unstable_viteEnvironmentApi` when the `ssr` environment has been configured by another plugin to be a custom `Vite.DevEnvironment` rather than the default `Vite.RunnableDevEnvironment` ([#13008](https://github.com/remix-run/react-router/pull/13008))
*   `@react-router/dev` - When `future.unstable_viteEnvironmentApi` is enabled and the `ssr` environment has `optimizeDeps.noDiscovery` disabled, define `optimizeDeps.entries` and `optimizeDeps.include` ([#13007](https://github.com/remix-run/react-router/pull/13007))

#### [](#client-side-context-unstable)Client-side `context` (unstable)

Your application `clientLoader`/`clientAction` functions (or `loader`/`action` in library mode) will now receive a `context` parameter on the client. This is an instance of `unstable_RouterContextProvider` that you use with type-safe contexts (similar to `React.createContext`) and is most useful with the corresponding `unstable_clientMiddleware` API:

    import { unstable_createContext } from "react-router";
    
    type User = {
      /*...*/
    };
    
    const userContext = unstable_createContext<User>();
    
    const sessionMiddleware: Route.unstable_ClientMiddlewareFunction = async ({
      context,
    }) => {
      let user = await getUser();
      context.set(userContext, user);
    };
    
    export const unstable_clientMiddleware = [sessionMiddleware];
    
    export function clientLoader({ context }: Route.ClientLoaderArgs) {
      let user = context.get(userContext);
      let profile = await getProfile(user.id);
      return { profile };
    }
    

Similar to server-side requests, a fresh `context` will be created per navigation (or `fetcher` call). If you have initial data you'd like to populate in the context for every request, you can provide an `unstable_getContext` function at the root of your app:

*   Library mode - `createBrowserRouter(routes, { unstable_getContext })`
*   Framework mode - `<HydratedRouter unstable_getContext>`

This function should return an value of type `unstable_InitialContext` which is a `Map<unstable_RouterContext, unknown>` of context's and initial values:

    const loggerContext = unstable_createContext<(...args: unknown[]) => void>();
    
    function logger(...args: unknown[]) {
      console.log(new Date.toISOString(), ...args);
    }
    
    function unstable_getContext() {
      let map = new Map();
      map.set(loggerContext, logger);
      return map;
    }
    

#### [](#middleware-unstable)Middleware (unstable)

Middleware is implemented behind a `future.unstable_middleware` flag. To enable, you must enable the flag and the types in your `react-router.config.ts` file:

    import type { Config } from "@react-router/dev/config";
    import type { Future } from "react-router";
    
    declare module "react-router" {
      interface Future {
        unstable_middleware: true; // 👈 Enable middleware types
      }
    }
    
    export default {
      future: {
        unstable_middleware: true, // 👈 Enable middleware
      },
    } satisfies Config;
    

⚠️ Middleware is unstable and should not be adopted in production. There is at least one known de-optimization in route module loading for `clientMiddleware` that we will be addressing this before a stable release.

⚠️ Enabling middleware contains a breaking change to the `context` parameter passed to your `loader`/`action` functions - see below for more information.

Once enabled, routes can define an array of middleware functions that will run sequentially before route handlers run. These functions accept the same parameters as `loader`/`action` plus an additional `next` parameter to run the remaining data pipeline. This allows middlewares to perform logic before and after handlers execute.

    // Framework mode
    export const unstable_middleware = [serverLogger, serverAuth]; // server
    export const unstable_clientMiddleware = [clientLogger]; // client
    
    // Library mode
    const routes = [
      {
        path: "/",
        // Middlewares are client-side for library mode SPA's
        unstable_middleware: [clientLogger, clientAuth],
        loader: rootLoader,
        Component: Root,
      },
    ];
    

Here's a simple example of a client-side logging middleware that can be placed on the root route:

    const clientLogger: Route.unstable_ClientMiddlewareFunction = async (
      { request },
      next
    ) => {
      let start = performance.now();
    
      // Run the remaining middlewares and all route loaders
      await next();
    
      let duration = performance.now() - start;
      console.log(`Navigated to ${request.url} (${duration}ms)`);
    };
    

Note that in the above example, the `next`/`middleware` functions don't return anything. This is by design as on the client there is no "response" to send over the network like there would be for middlewares running on the server. The data is all handled behind the scenes by the stateful `router`.

For a server-side middleware, the `next` function will return the HTTP `Response` that React Router will be sending across the wire, thus giving you a chance to make changes as needed. You may throw a new response to short circuit and respond immediately, or you may return a new or altered response to override the default returned by `next()`.

    const serverLogger: Route.unstable_MiddlewareFunction = async (
      { request, params, context },
      next
    ) => {
      let start = performance.now();
    
      // 👇 Grab the response here
      let res = await next();
    
      let duration = performance.now() - start;
      console.log(`Navigated to ${request.url} (${duration}ms)`);
    
      // 👇 And return it here (optional if you don't modify the response)
      return res;
    };
    

You can throw a `redirect` from a middleware to short circuit any remaining processing:

    import { sessionContext } from "../context";
    const serverAuth: Route.unstable_MiddlewareFunction = (
      { request, params, context },
      next
    ) => {
      let session = context.get(sessionContext);
      let user = session.get("user");
      if (!user) {
        session.set("returnTo", request.url);
        throw redirect("/login", 302);
      }
    };
    

_Note that in cases like this where you don't need to do any post-processing you don't need to call the `next` function or return a `Response`._

Here's another example of using a server middleware to detect 404s and check the CMS for a redirect:

    const redirects: Route.unstable_MiddlewareFunction = async ({
      request,
      next,
    }) => {
      // attempt to handle the request
      let res = await next();
    
      // if it's a 404, check the CMS for a redirect, do it last
      // because it's expensive
      if (res.status === 404) {
        let cmsRedirect = await checkCMSRedirects(request.url);
        if (cmsRedirect) {
          throw redirect(cmsRedirect, 302);
        }
      }
    
      return res;
    };
    

For more information on the `middleware` API/design, please see the [decision doc](https://github.com/remix-run/react-router/blob/release-next/decisions/0014-context-middleware.md).

##### [](#middleware-context-parameter)Middleware `context` parameter

When middleware is enabled, your application will use a different type of `context` parameter in your loaders and actions to provide better type safety. Instead of `AppLoadContext`, `context` will now be an instance of `ContextProvider` that you can use with type-safe contexts (similar to `React.createContext`):

    import { unstable_createContext } from "react-router";
    import { Route } from "./+types/root";
    import type { Session } from "./sessions.server";
    import { getSession } from "./sessions.server";
    
    let sessionContext = unstable_createContext<Session>();
    
    const sessionMiddleware: Route.unstable_MiddlewareFunction = ({
      context,
      request,
    }) => {
      let session = await getSession(request);
      context.set(sessionContext, session);
      //                          ^ must be of type Session
    };
    
    // ... then in some downstream middleware
    const loggerMiddleware: Route.unstable_MiddlewareFunction = ({
      context,
      request,
    }) => {
      let session = context.get(sessionContext);
      //  ^ typeof Session
      console.log(session.get("userId"), request.method, request.url);
    };
    
    // ... or some downstream loader
    export function loader({ context }: Route.LoaderArgs) {
      let session = context.get(sessionContext);
      let profile = await getProfile(session.get("userId"));
      return { profile };
    }
    

If you are using a custom server with a `getLoadContext` function, the return value for initial context values passed from the server adapter layer is no longer an object and should now return an `unstable_InitialContext` (`Map<RouterContext, unknown>`):

    let adapterContext = unstable_createContext<MyAdapterContext>();
    
    function getLoadContext(req, res): unstable_InitialContext {
      let map = new Map();
      map.set(adapterContext, getAdapterContext(req));
      return map;
    }
    

#### [](#unstable_serializesto)`unstable_SerializesTo`

`unstable_SerializesTo` added a way to register custom serialization types in Single Fetch for other library and framework authors like Apollo. It was implemented with branded type whose branded property that was made optional so that casting arbitrary values was easy:

    // without the brand being marked as optional
    let x1 = 42 as unknown as unstable_SerializesTo<number>;
    //          ^^^^^^^^^^
    
    // with the brand being marked as optional
    let x2 = 42 as unstable_SerializesTo<number>;
    

However, this broke type inference in `loaderData` and `actionData` for any `Record` types as those would now (incorrectly) match `unstable_SerializesTo`. This affected all users, not just those that depended on `unstable_SerializesTo`. To fix this, the branded property of `unstable_SerializesTo` is marked as required instead of optional.

For library and framework authors using `unstable_SerializesTo`, you may need to add `as unknown` casts before casting to `unstable_SerializesTo`.

### [](#changes-by-package-3)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/create-react-router/CHANGELOG.md#730)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router/CHANGELOG.md#730)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-architect/CHANGELOG.md#730)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-cloudflare/CHANGELOG.md#730)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-dev/CHANGELOG.md#730)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-express/CHANGELOG.md#730)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-fs-routes/CHANGELOG.md#730)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-node/CHANGELOG.md#730)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#730)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.3.0/packages/react-router-serve/CHANGELOG.md#730)

**Full Changelog**: [`v7.2.0...v7.3.0`](https://github.com/remix-run/react-router/compare/react-router@7.2.0...react-router@7.3.0)

[](#v720)v7.2.0
---------------

Date: 2025-02-18

### [](#whats-changed-2)What's Changed

#### [](#type-safe-href-utility)Type-safe `href` utility

In framework mode, we now provide you with a fully type-safe `href` utility to give you all the warm and fuzzy feelings of path auto-completion and param validation for links in your application:

    import { href } from "react-router";
    
    export default function Component() {
      const link = href("/blog/:slug", { slug: "my-first-post" });
      //                ^ type-safe!     ^ Also type-safe!
    
      return (
        <main>
          <Link to={href("/products/:id", { id: "asdf" })} />
          <NavLink to={href("/:lang?/about", { lang: "en" })} />
        </main>
      );
    }
    

You'll now get type errors if you pass a bad path value or a bad param value:

    const badPath = href("/not/a/valid/path");
    //                   ^ Error!
    
    const badParam = href("/blog/:slug", { oops: "bad param" });
    //                                     ^ Error!
    

#### [](#prerendering-with-a-spa-fallback)Prerendering with a SPA Fallback

This release enhances the ability to use a combination of pre-rendered paths alongside other paths that operate in "SPA Mode" when pre-rendering with `ssr:false`.

*   If you specify `ssr:false` without a `prerender` config, this is considered "SPA Mode" and the generated `index.html` file will only render down to the root route and will be able to hydrate for any valid application path
*   If you specify `ssr:false` with a `prerender` config but _do not_ include the `/` path (i.e., `prerender: ['/blog/post']`), then we still generate a "SPA Mode" `index.html` file that can hydrate for any path in the application
*   If you specify `ssr:false` and include the `/` path in your `prerender` config, the generated `index.html` file will be specific to the root index route, so we will now also generate a separate "SPA Mode" file in `__spa-fallback.html` that you can serve/hydrate for non-prerendered paths

For more info, see the [Pre-rendering](https://reactrouter.com/dev/how-to/pre-rendering#pre-rendering-with-a-spa-fallback) docs for more info.

#### [](#allow-a-root-loader-in-spa-mode)Allow a root `loader` in SPA Mode

SPA Mode used to prohibit the use of loaders in all routes so that we could hydrate for any path in the application. However, because the root route is always rendered at build time, we can lift this restriction for the root route.

In order to use your build-time loader data during pre-rendering, we now also expose the `loaderData` as an optional prop for the `HydrateFallback` component on routes:

*   This will be defined so long as the `HydrateFallback` is rendering because _children_ routes are loading
*   This will be `undefined` if the `HydrateFallback` is rendering because the route itself has it's own hydrating `clientLoader`
    *   In SPA mode, this will allow you to render loader root data into the SPA Mode HTML file

### [](#minor-changes-4)Minor Changes

*   `react-router` - New type-safe `href` utility that guarantees links point to actual paths in your app ([#13012](https://github.com/remix-run/react-router/pull/13012))
*   `@react-router/dev` - Generate a "SPA fallback" HTML file when pre-rendering the `/` route with `ssr:false` ([#12948](https://github.com/remix-run/react-router/pull/12948))
*   `@react-router/dev` - Allow a `loader` in the root route in SPA mode because it can be called/server-rendered at build time ([#12948](https://github.com/remix-run/react-router/pull/12948))
    *   `Route.HydrateFallbackProps` now also receives `loaderData`

### [](#patch-changes-8)Patch Changes

*   `react-router` - Disable Lazy Route Discovery for all `ssr:false` apps and not just "SPA Mode" because there is no runtime server to serve the search-param-configured `__manifest` requests ([#12894](https://github.com/remix-run/react-router/pull/12894))
    *   We previously only disabled this for "SPA Mode" but we realized it should apply to all `ssr:false` apps
    *   In those `prerender` scenarios we would pre-render the `/__manifest` file but that makes some unnecessary assumptions about the static file server behaviors
*   `react-router` - Don't apply Single Fetch revalidation de-optimization when in SPA mode since there is no server HTTP request ([#12948](https://github.com/remix-run/react-router/pull/12948))
*   `react-router` - Properly handle revalidations to across a pre-render/SPA boundary ([#13021](https://github.com/remix-run/react-router/pull/13021))
    *   In "hybrid" applications where some routes are pre-rendered and some are served from a SPA fallback, we need to avoid making `.data` requests if the path wasn't pre-rendered because the request will 404
    *   We don't know all the pre-rendered paths client-side, however:
        *   All `loader` data in `ssr:false` mode is static because it's generated at build time
        *   A route must use a `clientLoader` to do anything dynamic
        *   Therefore, if a route only has a `loader` and not a `clientLoader`, we disable revalidation by default because there is no new data to retrieve
        *   We short circuit and skip single fetch `.data` request logic if there are no server loaders with `shouldLoad=true` in our single fetch `dataStrategy`
        *   This ensures that the route doesn't cause a `.data` request that would 404 after a submission
*   `react-router` - Align dev server behavior with static file server behavior when `ssr:false` is set ([#12948](https://github.com/remix-run/react-router/pull/12948))
    *   When no `prerender` config exists, only SSR down to the root `HydrateFallback` (SPA Mode)
    *   When a `prerender` config exists but the current path is not pre-rendered, only SSR down to the root `HydrateFallback` (SPA Fallback)
    *   Return a 404 on `.data` requests to non-pre-rendered paths
*   `react-router` - Improve prefetch performance of CSS side effects in framework mode ([#12889](https://github.com/remix-run/react-router/pull/12889))
*   `react-router` - Properly handle interrupted manifest requests in lazy route discovery ([#12915](https://github.com/remix-run/react-router/pull/12915))
*   `@react-router/dev` - Handle custom `envDir` in Vite config ([#12969](https://github.com/remix-run/react-router/pull/12969))
*   `@react-router/dev` - Fix CLI parsing to allow argument-less `npx react-router` usage ([#12925](https://github.com/remix-run/react-router/pull/12925))
*   `@react-router/dev` - Skip action-only resource routes when using `prerender:true` ([#13004](https://github.com/remix-run/react-router/pull/13004))
*   `@react-router/dev` - Enhance invalid export detection when using `ssr:false` ([#12948](https://github.com/remix-run/react-router/pull/12948))
    *   `headers`/`action` functions are prohibited in all routes with `ssr:false` because there will be no runtime server on which to run them
    *   `loader` functions are more nuanced and depend on whether a given route is prerendered
        *   When using `ssr:false` without a `prerender` config, only the `root` route can have a `loader`
        *   When using `ssr:false` with a `prerender` config, only routes matched by a `prerender` path can have a `loader`
*   `@react-router/dev` - Error at build time in `ssr:false` + `prerender` apps for the edge case scenario of: ([#13021](https://github.com/remix-run/react-router/pull/13021))
    *   A parent route has only a `loader` (does not have a `clientLoader`)
    *   The parent route is pre-rendered
    *   The parent route has children routes which are not prerendered
    *   This means that when the child paths are loaded via the SPA fallback, the parent won't have any `loaderData` because there is no server on which to run the `loader`
    *   This can be resolved by either adding a parent `clientLoader` or pre-rendering the child paths
    *   If you add a `clientLoader`, calling the `serverLoader()` on non-prerendered paths will throw a 404
*   `@react-router/dev` - Limit prerendered resource route `.data` files to only the target route ([#13004](https://github.com/remix-run/react-router/pull/13004))
*   `@react-router/dev` - Fix pre-rendering of binary files ([#13039](https://github.com/remix-run/react-router/pull/13039))
*   `@react-router/dev` - Fix typegen for repeated params ([#13012](https://github.com/remix-run/react-router/pull/13012))
    *   In React Router, path parameters are keyed by their name, so for a path pattern like `/a/:id/b/:id?/c/:id`, the last `:id` will set the value for `id` in `useParams` and the `params` prop
        *   For example, `/a/1/b/2/c/3` will result in the value `{ id: 3 }` at runtime
    *   Previously, generated types for params incorrectly modeled repeated params with an array
        *   For example, `/a/1/b/2/c/3` generated a type like `{ id: [1,2,3] }`.
    *   To be consistent with runtime behavior, the generated types now correctly model the "last one wins" semantics of path parameters.
        *   For example, `/a/1/b/2/c/3` now generates a type like `{ id: 3 }`.
*   `@react-router/dev` - Fix path to load `package.json` for `react-router --version` ([#13012](https://github.com/remix-run/react-router/pull/13012))

### [](#unstable-changes-6)Unstable Changes

⚠️ _[Unstable features](https://reactrouter.com/community/api-development-strategy#unstable-flags) are not recommended for production use_

*   `react-router` - Add `unstable_SerializesTo` brand type for library authors to register types serializable by React Router's streaming format (`turbo-stream`) ([#12264](https://github.com/remix-run/react-router/pull/12264))
*   `@react-router/dev` - Add unstable support for splitting route modules in framework mode via `future.unstable_splitRouteModules` ([#11871](https://github.com/remix-run/react-router/pull/11871))
*   `@react-router/dev` - Add `future.unstable_viteEnvironmentApi` flag to enable experimental Vite Environment API support ([#12936](https://github.com/remix-run/react-router/pull/12936))

#### [](#split-route-modules-unstable)Split Route Modules (unstable)

> ⚠️ This feature is currently [unstable](https://reactrouter.com/community/api-development-strategy#unstable-flags), enabled by the `future.unstable_splitRouteModules` flag. We’d love any interested users to play with it locally and provide feedback, but we do not recommend using it in production yet.
> 
> If you do choose to adopt this flag in production, please ensure you do sufficient testing against your production build to ensure that the optimization is working as expected.

One of the conveniences of the [Route Module API](https://reactrouter.com/start/framework/route-module) is that everything a route needs is in a single file. Unfortunately this comes with a performance cost in some cases when using the `clientLoader`, `clientAction`, and `HydrateFallback` APIs.

As a basic example, consider this route module:

    import { MassiveComponent } from "~/components";
    
    export async function clientLoader() {
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    
    export default function Component({ loaderData }) {
      return <MassiveComponent data={loaderData} />;
    }
    

In this example we have a minimal `clientLoader` export that makes a basic fetch call, whereas the default component export is much larger. This is a problem for performance because it means that if we want to navigate to this route client-side, the entire route module must be downloaded before the client loader can start running.

To visualize this as a timeline:

In the following timeline diagrams, different characters are used within the Route Module bars to denote the different Route Module APIs being exported.

    Get Route Module:  |--=======|
    Run clientLoader:            |-----|
    Render:                            |-|
    

Instead, we want to optimize this to the following:

    Get clientLoader:  |--|
    Get Component:     |=======|
    Run clientLoader:     |-----|
    Render:                     |-|
    

To achieve this optimization, React Router will split the route module into multiple smaller modules during the production build process. In this case, we'll end up with two separate [virtual modules](https://vite.dev/guide/api-plugin#virtual-modules-convention) — one for the client loader and one for the component and its dependencies.

    export async function clientLoader() {
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    

    import { MassiveComponent } from "~/components";
    
    export default function Component({ loaderData }) {
      return <MassiveComponent data={loaderData} />;
    }
    

> 💡 This optimization is automatically applied in framework mode, but you can also implement it in library mode via `route.lazy` and authoring your route in multiple files as covered in our blog post on [lazy loading route modules.](https://remix.run/blog/lazy-loading-routes#advanced-usage-and-optimizations)

Now that these are available as separate modules, the client loader and the component can be downloaded in parallel. This means that the client loader can be executed as soon as it's ready without having to wait for the component.

This optimization is even more pronounced when more Route Module APIs are used. For example, when using `clientLoader`, `clientAction` and `HydrateFallback`, the timeline for a single route module during a client-side navigation might look like this:

    Get Route Module:     |--~~++++=======|
    Run clientLoader:                     |-----|
    Render:                                     |-|
    

This would instead be optimized to the following:

    Get clientLoader:     |--|
    Get clientAction:     |~~|
    Get HydrateFallback:  SKIPPED
    Get Component:        |=======|
    Run clientLoader:        |-----|
    Render:                        |-|
    

Note that this optimization only works when the Route Module APIs being split don't share code within the same file. For example, the following route module can't be split:

    import { MassiveComponent } from "~/components";
    
    const shared = () => console.log("hello");
    
    export async function clientLoader() {
      shared();
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    
    export default function Component({ loaderData }) {
      shared();
      return <MassiveComponent data={loaderData} />;
    }
    

This route will still work, but since both the client loader and the component depend on the `shared` function defined within the same file, it will be de-optimized into a single route module.

To avoid this, you can extract any code shared between exports into a separate file. For example:

    export const shared = () => console.log("hello");
    

You can then import this shared code in your route module without triggering the de-optimization:

    import { MassiveComponent } from "~/components";
    import { shared } from "./shared";
    
    export async function clientLoader() {
      shared();
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    
    export default function Component({ loaderData }) {
      shared();
      return <MassiveComponent data={loaderData} />;
    }
    

Since the shared code is in its own module, React Router is now able to split this route module into two separate virtual modules:

    import { shared } from "./shared";
    
    export async function clientLoader() {
      shared();
      return await fetch("https://example.com/api").then((response) =>
        response.json()
      );
    }
    

    import { MassiveComponent } from "~/components";
    import { shared } from "./shared";
    
    export default function Component({ loaderData }) {
      shared();
      return <MassiveComponent data={loaderData} />;
    }
    

If your project is particularly performance sensitive, you can set the `unstable_splitRouteModules` future flag to `"enforce"`:

    export default {
      future: {
        unstable_splitRouteModules: "enforce",
      },
    };
    

This setting will raise an error if any route modules can't be split:

    Error splitting route module: routes/example/route.tsx
    
    - clientLoader
    
    This export could not be split into its own chunk because it shares code with other exports. You should extract any shared code into its own module and then import it within the route module.
    

### [](#changes-by-package-4)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/create-react-router/CHANGELOG.md#720)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router/CHANGELOG.md#720)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-architect/CHANGELOG.md#720)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-cloudflare/CHANGELOG.md#720)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-dev/CHANGELOG.md#720)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-express/CHANGELOG.md#720)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-fs-routes/CHANGELOG.md#720)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-node/CHANGELOG.md#720)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#720)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.2.0/packages/react-router-serve/CHANGELOG.md#720)

**Full Changelog**: [`v7.1.5...v7.2.0`](https://github.com/remix-run/react-router/compare/react-router@7.1.5...react-router@7.2.0)

[](#v715)v7.1.5
---------------

Date: 2025-01-31

### [](#patch-changes-9)Patch Changes

*   `react-router` - Fix regression introduced in `7.1.4` via [#12800](https://github.com/remix-run/react-router/pull/12800) that caused issues navigating to hash routes inside splat routes for applications using Lazy Route Discovery (`patchRoutesOnNavigation`) ([#12927](https://github.com/remix-run/react-router/pull/12927))

**Full Changelog**: [`v7.1.4...v7.1.5`](https://github.com/remix-run/react-router/compare/react-router@7.1.4...react-router@7.1.5)

[](#v714)v7.1.4
---------------

Date: 2025-01-30

### [](#patch-changes-10)Patch Changes

*   `@react-router/dev` - Properly resolve Windows file paths to scan for Vite's dependency optimization when using the `unstable_optimizeDeps` future flag ([#12637](https://github.com/remix-run/react-router/pull/12637))
*   `@react-router/dev` - Fix prerendering when using a custom server - previously we ended up trying to import the users custom server when we actually want to import the virtual server build module ([#12759](https://github.com/remix-run/react-router/pull/12759))
*   `react-router` - Properly handle status codes that cannot have a body in single fetch responses (204, etc.) ([#12760](https://github.com/remix-run/react-router/pull/12760))
*   `react-router` - Properly bubble headers as `errorHeaders` when throwing a `data()` result ([#12846](https://github.com/remix-run/react-router/pull/12846))
    *   Avoid duplication of `Set-Cookie` headers if also returned from `headers`
*   `react-router` - Stop erroring on resource routes that return raw strings/objects and instead serialize them as `text/plain` or `application/json` responses ([#12848](https://github.com/remix-run/react-router/pull/12848))
    *   This only applies when accessed as a resource route without the `.data` extension
    *   When accessed from a Single Fetch `.data` request, they will still be encoded via `turbo-stream`
*   `react-router` - Optimize Lazy Route Discovery path discovery to favor a single `querySelectorAll` call at the `body` level instead of many calls at the sub-tree level ([#12731](https://github.com/remix-run/react-router/pull/12731))
*   `react-router` - Optimize route matching by skipping redundant `matchRoutes` calls when possible ([#12800](https://github.com/remix-run/react-router/pull/12800), [#12882](https://github.com/remix-run/react-router/pull/12882))
*   `react-router` - Internal reorg to clean up some duplicated route module types ([#12799](https://github.com/remix-run/react-router/pull/12799))

**Full Changelog**: [`v7.1.3...v7.1.4`](https://github.com/remix-run/react-router/compare/react-router@7.1.3...react-router@7.1.4)

[](#v713)v7.1.3
---------------

Date: 2025-01-17

### [](#patch-changes-11)Patch Changes

*   `@react-router/dev` - Fix `reveal` and `routes` CLI commands ([#12745](https://github.com/remix-run/react-router/pull/12745))

**Full Changelog**: [`v7.1.2...v7.1.3`](https://github.com/remix-run/react-router/compare/react-router@7.1.2...react-router@7.1.3)

[](#v712)v7.1.2
---------------

Date: 2025-01-16

### [](#patch-changes-12)Patch Changes

*   `react-router` - Fix issue with fetcher data cleanup in the data layer on fetcher unmount ([#12681](https://github.com/remix-run/react-router/pull/12681))
*   `react-router` - Do not rely on `symbol` for filtering out `redirect` responses from loader data ([#12694](https://github.com/remix-run/react-router/pull/12694))
    *   Previously, some projects were getting type checking errors like:
        
            error TS4058: Return type of exported function has or is using name 'redirectSymbol' from external module "node_modules/..." but cannot be named.
            
        
    *   Now that `symbol`s are not used for the `redirect` response type, these errors should no longer be present
*   `@react-router/dev` - Fix default external conditions in Vite v6 ([#12644](https://github.com/remix-run/react-router/pull/12644))
    *   This fixes resolution issues with certain npm packages
*   `@react-router/dev` - Fix mismatch in prerendering html/data files when path is missing a leading slash ([#12684](https://github.com/remix-run/react-router/pull/12684))
*   `@react-router/dev` - Use `module-sync` server condition when enabled in the runtime. This fixes React context mismatches (e.g. `useHref() may be used only in the context of a <Router> component.`) during development on Node 22.10.0+ when using libraries that have a peer dependency on React Router ([#12729](https://github.com/remix-run/react-router/pull/12729))
*   `@react-router/dev` - Fix `react-refresh` source maps ([#12686](https://github.com/remix-run/react-router/pull/12686))

**Full Changelog**: [`v7.1.1...v7.1.2`](https://github.com/remix-run/react-router/compare/react-router@7.1.1...react-router@7.1.2)

[](#v711)v7.1.1
---------------

Date: 2024-12-23

### [](#patch-changes-13)Patch Changes

*   `@react-router/dev` - Fix for a crash when optional args are passed to the CLI ([#12609](https://github.com/remix-run/react-router/pull/12609))

**Full Changelog**: [`v7.1.0...v7.1.1`](https://github.com/remix-run/react-router/compare/react-router@7.1.0...react-router@7.1.1)

[](#v710)v7.1.0
---------------

Date: 2024-12-20

### [](#minor-changes-5)Minor Changes

*   Add support for Vite v6 ([#12469](https://github.com/remix-run/react-router/pull/12469))

### [](#patch-changes-14)Patch Changes

*   `react-router` - Throw unwrapped Single Fetch `redirect` to align with pre-Single Fetch behavior ([#12506](https://github.com/remix-run/react-router/pull/12506))
*   `react-router` - Ignore redirects when inferring loader data types ([#12527](https://github.com/remix-run/react-router/pull/12527))
*   `react-router` - Remove `<Link prefetch>` warning which suffers from false positives in a lazy route discovery world ([#12485](https://github.com/remix-run/react-router/pull/12485))
*   `create-react-router` - Fix missing `fs-extra` dependency ([#12556](https://github.com/remix-run/react-router/pull/12556))
*   `@react-router/dev`/`@react-router/serve` - Properly initialize `NODE_ENV` if not already set for compatibility with React 19 ([#12578](https://github.com/remix-run/react-router/pull/12578))
*   `@react-router/dev` - Remove the leftover/unused `abortDelay` prop from `ServerRouter` and update the default `entry.server.tsx` to use the new `streamTimeout` value for Single Fetch ([#12478](https://github.com/remix-run/react-router/pull/12478))
    *   The `abortDelay` functionality was removed in v7 as it was coupled to the `defer` implementation from Remix v2, but this removal of this prop was missed
    *   If you were still using this prop in your `entry.server` file, it's likely your app is not aborting streams as you would expect and you will need to adopt the new [`streamTimeout`](https://reactrouter.com/explanation/special-files#streamtimeout) value introduced with Single Fetch
*   `@react-router/fs-routes` - Throw error in `flatRoutes` if routes directory is missing ([#12407](https://github.com/remix-run/react-router/pull/12407))

### [](#changes-by-package-5)Changes by Package

*   [`create-react-router`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/create-react-router/CHANGELOG.md#710)
*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router/CHANGELOG.md#710)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-architect/CHANGELOG.md#710)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-cloudflare/CHANGELOG.md#710)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-dev/CHANGELOG.md#710)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-express/CHANGELOG.md#710)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-fs-routes/CHANGELOG.md#710)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-node/CHANGELOG.md#710)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#710)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.1.0/packages/react-router-serve/CHANGELOG.md#710)

**Full Changelog**: [`v7.0.2...v7.1.0`](https://github.com/remix-run/react-router/compare/react-router@7.0.2...react-router@7.1.0)

[](#v702)v7.0.2
---------------

Date: 2024-12-02

### [](#patch-changes-15)Patch Changes

*   `react-router` - Temporarily only use one build in export map so packages can have a peer dependency on react router ([#12437](https://github.com/remix-run/react-router/pull/12437))
*   `@react-router/dev` - Support `moduleResolution` `Node16` and `NodeNext` ([#12440](https://github.com/remix-run/react-router/pull/12440))
*   `@react-router/dev` - Generate wide `matches` and `params` types for child routes ([#12397](https://github.com/remix-run/react-router/pull/12397))
    *   At runtime, `matches` includes child route matches and `params` include child route path parameters
    *   But previously, we only generated types for parent routes and the current route in `matches` and `params`
    *   To align our generated types more closely to the runtime behavior, we now generate more permissive, wider types when accessing child route information

**Full Changelog**: [`v7.0.1...v7.0.2`](https://github.com/remix-run/react-router/compare/react-router@7.0.1...react-router@7.0.2)

[](#v701)v7.0.1
---------------

Date: 2024-11-22

### [](#patch-changes-16)Patch Changes

*   `@react-router/dev` - Ensure typegen file watcher is cleaned up when Vite dev server restarts ([#12331](https://github.com/remix-run/react-router/pull/12331))
*   `@react-router/dev` - Pass route `error` to `ErrorBoundary` as a prop ([#12338](https://github.com/remix-run/react-router/pull/12338))

**Full Changelog**: [`v7.0.0...v7.0.1`](https://github.com/remix-run/react-router/compare/react-router@7.0.0...react-router@7.0.1)

[](#v700)v7.0.0
---------------

Date: 2024-11-21

### [](#breaking-changes)Breaking Changes

#### [](#package-restructuring)Package Restructuring

*   The `react-router-dom`, `@remix-run/react`, `@remix-run/server-runtime`, and `@remix-run/router` have been collapsed into the `react-router` package
    *   To ease migration, `react-router-dom` is still published in v7 as a re-export of everything from `react-router`
*   The `@remix-run/cloudflare-pages` and `@remix-run/cloudflare-workers` have been collapsed into `@react-router/cloudflare` package\`
*   The `react-router-dom-v5-compat` and `react-router-native` packages are removed starting with v7

#### [](#removed-adapter-re-exports)Removed Adapter Re-exports

Remix v2 used to re-export all common `@remix-run/server-runtime` APIs through the various runtime packages (`node`, `cloudflare`, `deno`) so that you wouldn't need an additional `@remix-run/server-runtime` dependency in your `package.json`. With the collapsing of packages into `react-router`, these common APIs are now no longer re-exported through the runtime adapters. You should import all common APIs from `react-router`, and only import runtime-specific APIs from the runtime packages:

    // Runtime-specific APIs
    import { createFileSessionStorage } from "@react-router/node";
    // Runtime-agnostic APIs
    import { redirect, useLoaderData } from "react-router";
    

#### [](#removed-apis)Removed APIs

The following APIs have been removed in React Router v7:

*   `json`
*   `defer`
*   `unstable_composeUploadHandlers`
*   `unstable_createMemoryUploadHandler`
*   `unstable_parseMultipartFormData`

#### [](#minimum-versions)Minimum Versions

React Router v7 requires the following minimum versions:

*   `node@20`
    *   React Router no longer provides an `installGlobals` method to [polyfill](https://reactrouter.com/dev/guides/deploying/custom-node#polyfilling-fetch) the `fetch` API
*   `react@18`, `react-dom@18`

#### [](#adopted-future-flag-behaviors)Adopted Future Flag Behaviors

Remix and React Router follow an [API Development Strategy](https://reactrouter.com/en/main/guides/api-development-strategy) leveraging "Future Flags" to avoid introducing a slew of breaking changes in a major release. Instead, breaking changes are introduced in minor releases behind a flag, allowing users to opt-in at their convenience. In the next major release, all future flag behaviors become the default behavior.

The following previously flagged behaviors are now the default in React Router v7:

*   [React Router v6 flags](https://reactrouter.com/en/v6/upgrading/future)
    *   `future.v7_relativeSplatPath`
    *   `future.v7_startTransition`
    *   `future.v7_fetcherPersist`
    *   `future.v7_normalizeFormMethod`
    *   `future.v7_partialHydration`
    *   `future.v7_skipActionStatusRevalidation`
*   [Remix v2 flags](https://remix.run/docs/en/v2/start/future-flags)
    *   `future.v3_fetcherPersist`
    *   `future.v3_relativeSplatPath`
    *   `future.v3_throwAbortReason`
    *   `future.v3_singleFetch`
    *   `future.v3_lazyRouteDiscovery`
    *   `future.v3_optimizeDeps`

#### [](#vite-compiler)Vite Compiler

The [Remix Vite plugin](https://remix.run/docs/en/2.12.1/start/future-flags#vite-plugin) is the proper way to build full-stack SSR apps using React Router v7. The former `esbuild`\-based compiler is no longer available.

**Renamed `vitePlugin` and `cloudflareDevProxyVitePlugin`**

For Remix consumers migrating to React Router, the `vitePlugin` and `cloudflareDevProxyVitePlugin` exports have been renamed and moved ([#11904](https://github.com/remix-run/react-router/pull/11904))

    -import {
    -  vitePlugin as remix,
    -  cloudflareDevProxyVitePlugin,
    -} from "@remix/dev";
    
    +import { reactRouter } from "@react-router/dev/vite";
    +import { cloudflareDevProxy } from "@react-router/dev/vite/cloudflare";
    

**Removed `manifest` option**

For Remix consumers migrating to React Router, the Vite plugin's `manifest` option has been removed. The `manifest` option been superseded by the more powerful `buildEnd` hook since it's passed the `buildManifest` argument. You can still write the build manifest to disk if needed, but you'll most likely find it more convenient to write any logic depending on the build manifest within the `buildEnd` hook itself. ([#11573](https://github.com/remix-run/react-router/pull/11573))

If you were using the `manifest` option, you can replace it with a `buildEnd` hook that writes the manifest to disk like this:

    // react-router.config.ts
    import { type Config } from "@react-router/dev/config";
    import { writeFile } from "node:fs/promises";
    
    export default {
      async buildEnd({ buildManifest }) {
        await writeFile(
          "build/manifest.json",
          JSON.stringify(buildManifest, null, 2),
          "utf-8"
        );
      },
    } satisfies Config;
    

#### [](#exposed-router-promises)Exposed Router Promises

Because React 19 will have first-class support for handling promises in the render pass (via `React.use` and `useAction`), we are now comfortable exposing the promises for the APIs that previously returned `undefined`:

*   `useNavigate()`
*   `useSubmit()`
*   `useFetcher().load`
*   `useFetcher().submit`
*   `useRevalidator().revalidate()`

### [](#other-notable-changes)Other Notable Changes

#### [](#routests)`routes.ts`

When using the React Router Vite plugin, routes are defined in `app/routes.ts`. Route config is exported via the `routes` export, conforming to the `RouteConfig` type. Route helper functions `route`, `index`, and `layout` are provided to make declarative type-safe route definitions easier.

    // app/routes.ts
    import {
      type RouteConfig,
      route,
      index,
      layout,
    } from "@react-router/dev/routes";
    
    export const routes: RouteConfig = [
      index("./home.tsx"),
      route("about", "./about.tsx"),
    
      layout("./auth/layout.tsx", [
        route("login", "./auth/login.tsx"),
        route("register", "./auth/register.tsx"),
      ]),
    
      route("concerts", [
        index("./concerts/home.tsx"),
        route(":city", "./concerts/city.tsx"),
        route("trending", "./concerts/trending.tsx"),
      ]),
    ];
    

For Remix consumers migrating to React Router, you can still configure file system routing within `routes.ts` using the `@react-router/fs-routes` package. A minimal route config that reproduces the default Remix setup looks like this:

    // app/routes.ts
    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export const routes: RouteConfig = flatRoutes();
    

If you want to migrate from file system routing to config-based routes, you can mix and match approaches by spreading the results of the async `flatRoutes` function into the array of config-based routes.

    // app/routes.ts
    import { type RouteConfig, route } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export const routes: RouteConfig = [
      // Example config-based route:
      route("/hello", "./routes/hello.tsx"),
    
      // File system routes scoped to a different directory:
      ...(await flatRoutes({
        rootDirectory: "fs-routes",
      })),
    ];
    

If you were using Remix's `routes` option to use alternative file system routing conventions, you can adapt these to the new `RouteConfig` format using `@react-router/remix-config-routes-adapter`.

For example, if you were using [Remix v1 route conventions](https://remix.run/docs/en/1.19.3/file-conventions/routes-files) in Remix v2, you can combine `@react-router/remix-config-routes-adapter` with `@remix-run/v1-route-convention` to adapt this to React Router:

    // app/routes.ts
    import { type RouteConfig } from "@react-router/dev/routes";
    import { remixConfigRoutes } from "@react-router/remix-config-routes-adapter";
    import { createRoutesFromFolders } from "@remix-run/v1-route-convention";
    
    export const routes: RouteConfig = remixConfigRoutes(async (defineRoutes) => {
      return createRoutesFromFolders(defineRoutes, {
        ignoredFilePatterns: ["**/.*", "**/*.css"],
      });
    });
    

Also note that, if you were using Remix's `routes` option to define config-based routes, you can also adapt these to the new `RouteConfig` format using `@react-router/remix-config-routes-adapter` with minimal code changes. While this makes for a fast migration path, we recommend migrating any config-based routes from Remix to the new `RouteConfig` format since it's a fairly straightforward migration.

    // app/routes.ts
    -import { type RouteConfig } from "@react-router/dev/routes";
    +import { type RouteConfig, route } from "@react-router/dev/routes";
    -import { remixConfigRoutes } from "@react-router/remix-config-routes-adapter";
    
    -export const routes: RouteConfig = remixConfigRoutes(async (defineRoutes) => {
    -  defineRoutes((route) => {
    -    route("/parent", "./routes/parent.tsx", () => [
    -      route("/child", "./routes/child.tsx"),
    -    ]);
    -  });
    -});
    +export const routes: RouteConfig = [
    +  route("/parent", "./routes/parent.tsx", [
    +    route("/child", "./routes/child.tsx"),
    +  ]),
    +];
    

#### [](#typesafety-improvements)Typesafety improvements

React Router now generates types for each of your route modules and passes typed props to route module component exports ([#11961](https://github.com/remix-run/react-router/pull/11961), [#12019](https://github.com/remix-run/react-router/pull/12019)). You can access those types by importing them from `./+types/<route filename without extension>`.

See [_How To > Route Module Type Safety_](https://reactrouter.com/dev/how-to/route-module-type-safety) and [_Explanations > Type Safety_](https://reactrouter.com/dev/explanation/type-safety) for more details.

#### [](#prerendering)Prerendering

React Router v7 includes a new `prerender` config in the vite plugin to support SSG use-cases. This will pre-render your `.html` and `.data` files at build time and so you can serve them statically at runtime from a running server or a CDN ([#11539](https://github.com/remix-run/react-router/pull/11539))

    export default defineConfig({
      plugins: [
        reactRouter({
          async prerender({ getStaticPaths }) {
            let slugs = await fakeGetSlugsFromCms();
            return [
              ...getStaticPaths(),
              ...slugs.map((slug) => `/product/${slug}`),
            ];
          },
        }),
        tsconfigPaths(),
      ],
    });
    
    async function fakeGetSlugsFromCms() {
      await new Promise((r) => setTimeout(r, 1000));
      return ["shirt", "hat"];
    }
    

### [](#major-changes-react-router)Major Changes (`react-router`)

*   Remove the original `defer` implementation in favor of using raw promises via single fetch and `turbo-stream` ([#11744](https://github.com/remix-run/react-router/pull/11744))
    *   This removes these exports from React Router:
        *   `defer`
        *   `AbortedDeferredError`
        *   `type TypedDeferredData`
        *   `UNSAFE_DeferredData`
        *   `UNSAFE_DEFERRED_SYMBOL`
*   Collapse packages into `react-router`([#11505](https://github.com/remix-run/react-router/pull/11505))
    *   `@remix-run/router`
    *   `react-router-dom`
    *   `@remix-run/server-runtime`
    *   `@remix-run/testing`
    *   As a note, the `react-router-dom` package is maintained to ease adoption but it simply re-exports all APIs from `react-router`
*   Drop support for Node 16, React Router SSR now requires Node 18 or higher ([#11391](https://github.com/remix-run/react-router/pull/11391), [#11690](https://github.com/remix-run/react-router/pull/11690))
*   Remove `future.v7_startTransition` flag ([#11696](https://github.com/remix-run/react-router/pull/11696))
*   Expose the underlying router promises from the following APIs for composition in React 19 APIs: ([#11521](https://github.com/remix-run/react-router/pull/11521))
*   Remove `future.v7_normalizeFormMethod` future flag ([#11697](https://github.com/remix-run/react-router/pull/11697))
*   Imports/Exports cleanup ([#11840](https://github.com/remix-run/react-router/pull/11840))
    *   Removed the following exports that were previously public API from `@remix-run/router`
        *   types
            *   `AgnosticDataIndexRouteObject`
            *   `AgnosticDataNonIndexRouteObject`
            *   `AgnosticDataRouteMatch`
            *   `AgnosticDataRouteObject`
            *   `AgnosticIndexRouteObject`
            *   `AgnosticNonIndexRouteObject`
            *   `AgnosticRouteMatch`
            *   `AgnosticRouteObject`
            *   `TrackedPromise`
            *   `unstable_AgnosticPatchRoutesOnMissFunction`
            *   `Action` -> exported as `NavigationType` via `react-router`
            *   `Router` exported as `RemixRouter` to differentiate from RR's `<Router>`
        *   API
            *   `getToPathname` (`@private`)
            *   `joinPaths` (`@private`)
            *   `normalizePathname` (`@private`)
            *   `resolveTo` (`@private`)
            *   `stripBasename` (`@private`)
            *   `createBrowserHistory` -> in favor of `createBrowserRouter`
            *   `createHashHistory` -> in favor of `createHashRouter`
            *   `createMemoryHistory` -> in favor of `createMemoryRouter`
            *   `createRouter`
            *   `createStaticHandler` -> in favor of wrapper `createStaticHandler` in RR Dom
            *   `getStaticContextFromError`
    *   Removed the following exports that were previously public API from `react-router`
        *   `Hash`
        *   `Pathname`
        *   `Search`
*   Remove `future.v7_prependBasename` from the internalized `@remix-run/router` package ([#11726](https://github.com/remix-run/react-router/pull/11726))
*   Remove `future.v7_throwAbortReason` from internalized `@remix-run/router` package ([#11728](https://github.com/remix-run/react-router/pull/11728))
*   Add `exports` field to all packages ([#11675](https://github.com/remix-run/react-router/pull/11675))
*   Renamed `RemixContext` to `FrameworkContext` ([#11705](https://github.com/remix-run/react-router/pull/11705))
*   Update the minimum React version to 18 ([#11689](https://github.com/remix-run/react-router/pull/11689))
*   `PrefetchPageDescriptor` replaced by `PageLinkDescriptor` ([#11960](https://github.com/remix-run/react-router/pull/11960))
*   Remove the `future.v7_partialHydration` flag ([#11725](https://github.com/remix-run/react-router/pull/11725))
    *   This also removes the `<RouterProvider fallbackElement>` prop
        *   To migrate, move the `fallbackElement` to a `hydrateFallbackElement`/`HydrateFallback` on your root route
    *   Also worth nothing there is a related breaking changer with this future flag:
        *   Without `future.v7_partialHydration` (when using `fallbackElement`), `state.navigation` was populated during the initial load
        *   With `future.v7_partialHydration`, `state.navigation` remains in an `"idle"` state during the initial load
*   Remove `future.v7_relativeSplatPath` future flag ([#11695](https://github.com/remix-run/react-router/pull/11695))
*   Remove remaining future flags ([#11820](https://github.com/remix-run/react-router/pull/11820))
    *   React Router `v7_skipActionErrorRevalidation`
    *   Remix `v3_fetcherPersist`, `v3_relativeSplatPath`, `v3_throwAbortReason`
*   Rename `createRemixStub` to `createRoutesStub` ([#11692](https://github.com/remix-run/react-router/pull/11692))
*   Remove `@remix-run/router` deprecated `detectErrorBoundary` option in favor of `mapRouteProperties` ([#11751](https://github.com/remix-run/react-router/pull/11751))
*   Add `react-router/dom` subpath export to properly enable `react-dom` as an optional `peerDependency` ([#11851](https://github.com/remix-run/react-router/pull/11851))
    *   This ensures that we don't blindly `import ReactDOM from "react-dom"` in `<RouterProvider>` in order to access `ReactDOM.flushSync()`, since that would break `createMemoryRouter` use cases in non-DOM environments
    *   DOM environments should import from `react-router/dom` to get the proper component that makes `ReactDOM.flushSync()` available:
        *   If you are using the Vite plugin, use this in your `entry.client.tsx`:
            *   `import { HydratedRouter } from 'react-router/dom'`
        *   If you are not using the Vite plugin and are manually calling `createBrowserRouter`/`createHashRouter`:
            *   `import { RouterProvider } from "react-router/dom"`
*   Remove `future.v7_fetcherPersist` flag ([#11731](https://github.com/remix-run/react-router/pull/11731))
*   Allow returning `undefined` from loaders and actions ([#11680](https://github.com/remix-run/react-router/pull/11680), [#12057](%5Bhttps://github.com/remix-run/react-router/pull/1205))
*   Use `createRemixRouter`/`RouterProvider` in `entry.client` instead of `RemixBrowser` ([#11469](https://github.com/remix-run/react-router/pull/11469))
*   Remove the deprecated `json` utility ([#12146](https://github.com/remix-run/react-router/pull/12146))
    *   You can use [`Response.json`](https://developer.mozilla.org/en-US/docs/Web/API/Response/json_static) if you still need to construct JSON responses in your app

### [](#major-changes-react-router-1)Major Changes (`@react-router/*`)

*   Remove `future.v3_singleFetch` flag ([#11522](https://github.com/remix-run/react-router/pull/11522))
*   Drop support for Node 16 and 18, update minimum Node version to 20 ([#11690](https://github.com/remix-run/react-router/pull/11690), [#12171](https://github.com/remix-run/react-router/pull/12171))
    *   Remove `installGlobals()` as this should no longer be necessary
*   Add `exports` field to all packages ([#11675](https://github.com/remix-run/react-router/pull/11675))
*   No longer re-export APIs from `react-router` through different runtime/adapter packages ([#11702](https://github.com/remix-run/react-router/pull/11702))
*   For Remix consumers migrating to React Router, the `crypto` global from the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) is now required when using cookie and session APIs
    *   This means that the following APIs are provided from `react-router` rather than platform-specific packages: ([#11837](https://github.com/remix-run/react-router/pull/11837))
        *   `createCookie`
        *   `createCookieSessionStorage`
        *   `createMemorySessionStorage`
        *   `createSessionStorage`
    *   For consumers running older versions of Node, the `installGlobals` function from `@remix-run/node` has been updated to define `globalThis.crypto`, using [Node's `require('node:crypto').webcrypto` implementation](https://nodejs.org/api/webcrypto.html)
    *   Since platform-specific packages no longer need to implement this API, the following low-level APIs have been removed:
        *   `createCookieFactory`
        *   `createSessionStorageFactory`
        *   `createCookieSessionStorageFactory`
        *   `createMemorySessionStorageFactory`
*   Consolidate types previously duplicated across `@remix-run/router`, `@remix-run/server-runtime`, and `@remix-run/react` now that they all live in `react-router` ([#12177](https://github.com/remix-run/react-router/pull/12177))
    *   Examples: `LoaderFunction`, `LoaderFunctionArgs`, `ActionFunction`, `ActionFunctionArgs`, `DataFunctionArgs`, `RouteManifest`, `LinksFunction`, `Route`, `EntryRoute`
    *   The `RouteManifest` type used by the "remix" code is now slightly stricter because it is using the former `@remix-run/router` `RouteManifest`
        *   `Record<string, Route> -> Record<string, Route | undefined>`
    *   Removed `AppData` type in favor of inlining `unknown` in the few locations it was used
    *   Removed `ServerRuntimeMeta*` types in favor of the `Meta*` types they were duplicated from
*   Migrate Remix v2 type generics to React Router ([#12180](https://github.com/remix-run/react-router/pull/12180))
    *   These generics are provided for Remix v2 migration purposes
    *   These generics and the APIs they exist on should be considered informally deprecated in favor of the new `Route.*` types
    *   Anyone migrating from React Router v6 should probably not leverage these new generics and should migrate straight to the `Route.*` types
    *   For React Router v6 users, these generics are new and should not impact your app, with one exception
        *   `useFetcher` previously had an optional generic (used primarily by Remix v2) that expected the data type
        *   This has been updated in v7 to expect the type of the function that generates the data (i.e., `typeof loader`/`typeof action`)
        *   Therefore, you should update your usages:
            *   ❌ `useFetcher<LoaderData>()`
            *   ✅ `useFetcher<typeof loader>()`
*   Update `cookie` dependency to `^1.0.1` - please see the [release notes](https://github.com/jshttp/cookie/releases) for any breaking changes ([#12172](https://github.com/remix-run/react-router/pull/12172))
*   `@react-router/cloudflare` - For Remix consumers migrating to React Router, all exports from `@remix-run/cloudflare-pages` are now provided for React Router consumers in the `@react-router/cloudflare` package. There is no longer a separate package for Cloudflare Pages. ([#11801](https://github.com/remix-run/react-router/pull/11801))
*   `@react-router/cloudflare` - The `@remix-run/cloudflare-workers` package has been deprecated. Remix consumers migrating to React Router should use the `@react-router/cloudflare` package directly. For guidance on how to use `@react-router/cloudflare` within a Cloudflare Workers context, refer to the Cloudflare Workers template. ([#11801](https://github.com/remix-run/react-router/pull/11801))
*   `@react-router/dev` - For Remix consumers migrating to React Router, the `vitePlugin` and `cloudflareDevProxyVitePlugin` exports have been renamed and moved. ([#11904](https://github.com/remix-run/react-router/pull/11904))
*   `@react-router/dev` - For Remix consumers migrating to React Router who used the Vite plugin's `buildEnd` hook, the resolved `reactRouterConfig` object no longer contains a `publicPath` property since this belongs to Vite, not React Router ([#11575](https://github.com/remix-run/react-router/pull/11575))
*   `@react-router/dev` - For Remix consumers migrating to React Router, the Vite plugin's `manifest` option has been removed ([#11573](https://github.com/remix-run/react-router/pull/11573))
*   `@react-router/dev` - Update default `isbot` version to v5 and drop support for `isbot@3` ([#11770](https://github.com/remix-run/react-router/pull/11770))
    *   If you have `isbot@4` or `isbot@5` in your `package.json`:
        *   You do not need to make any changes
    *   If you have `isbot@3` in your `package.json` and you have your own `entry.server.tsx` file in your repo
        *   You do not need to make any changes
        *   You can upgrade to `isbot@5` independent of the React Router v7 upgrade
    *   If you have `isbot@3` in your `package.json` and you do not have your own `entry.server.tsx` file in your repo
        *   You are using the internal default entry provided by React Router v7 and you will need to upgrade to `isbot@5` in your `package.json`
*   `@react-router/dev` - For Remix consumers migrating to React Router, Vite manifests (i.e. `.vite/manifest.json`) are now written within each build subdirectory, e.g. `build/client/.vite/manifest.json` and `build/server/.vite/manifest.json` instead of `build/.vite/client-manifest.json` and `build/.vite/server-manifest.json`. This means that the build output is now much closer to what you'd expect from a typical Vite project. ([#11573](https://github.com/remix-run/react-router/pull/11573))
    *   Originally the Remix Vite plugin moved all Vite manifests to a root-level `build/.vite` directory to avoid accidentally serving them in production, particularly from the client build. This was later improved with additional logic that deleted these Vite manifest files at the end of the build process unless Vite's `build.manifest` had been enabled within the app's Vite config. This greatly reduced the risk of accidentally serving the Vite manifests in production since they're only present when explicitly asked for. As a result, we can now assume that consumers will know that they need to manage these additional files themselves, and React Router can safely generate a more standard Vite build output.

### [](#minor-changes-6)Minor Changes

*   `react-router` - Params, loader data, and action data as props for route component exports ([#11961](https://github.com/remix-run/react-router/pull/11961))
*   `react-router` - Add route module type generation ([#12019](https://github.com/remix-run/react-router/pull/12019))
*   `react-router` - Remove duplicate `RouterProvider` implementations ([#11679](https://github.com/remix-run/react-router/pull/11679))
*   `react-router` - Stabilize `unstable_dataStrategy` ([#11969](https://github.com/remix-run/react-router/pull/11969))
*   `react-router` - Stabilize `unstable_patchRoutesOnNavigation` ([#11970](https://github.com/remix-run/react-router/pull/11970))
*   `react-router` - Add prefetching support to `Link`/`NavLink` when using Remix SSR ([#11402](https://github.com/remix-run/react-router/pull/11402))
*   `react-router` - Enhance `ScrollRestoration` so it can restore properly on an SSR'd document load ([#11401](https://github.com/remix-run/react-router/pull/11401))
*   `@react-router/dev` - Add support for the `prerender` config in the React Router vite plugin, to support existing SSG use-cases ([#11539](https://github.com/remix-run/react-router/pull/11539))
*   `@react-router/dev` - Remove internal `entry.server.spa.tsx` implementation which was not compatible with the Single Fetch async hydration approach ([#11681](https://github.com/remix-run/react-router/pull/11681))
*   `@react-router/serve`: Update `express.static` configurations to support new `prerender` API ([#11547](https://github.com/remix-run/react-router/pull/11547))
    *   Assets in the `build/client/assets` folder are served as before, with a 1-year immutable `Cache-Control` header
    *   Static files outside of assets, such as pre-rendered `.html` and `.data` files are not served with a specific `Cache-Control` header
    *   `.data` files are served with `Content-Type: text/x-turbo`
        *   For some reason, when adding this via `express.static`, it seems to also add a `Cache-Control: public, max-age=0` to `.data` files

### [](#patch-changes-17)Patch Changes

*   Replace `substr` with `substring` ([#12080](https://github.com/remix-run/react-router/pull/12080))
*   `react-router` - Fix redirects returned from loaders/actions using `data()` ([#12021](https://github.com/remix-run/react-router/pull/12021))
*   `@react-router/dev` - Enable prerendering for resource routes ([#12200](https://github.com/remix-run/react-router/pull/12200))
*   `@react-router/dev` - resolve config directory relative to flat output file structure ([#12187](https://github.com/remix-run/react-router/pull/12187))

### [](#changes-by-package-6)Changes by Package

*   [`react-router`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router/CHANGELOG.md#700)
*   [`@react-router/architect`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-architect/CHANGELOG.md#700)
*   [`@react-router/cloudflare`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-cloudflare/CHANGELOG.md#700)
*   [`@react-router/dev`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-dev/CHANGELOG.md#700)
*   [`@react-router/express`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-express/CHANGELOG.md#700)
*   [`@react-router/fs-routes`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-fs-routes/CHANGELOG.md#700)
*   [`@react-router/node`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-node/CHANGELOG.md#700)
*   [`@react-router/remix-config-routes-adapter`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-remix-config-routes-adapter/CHANGELOG.md#700)
*   [`@react-router/serve`](https://github.com/remix-run/react-router/blob/react-router%407.0.0/packages/react-router-serve/CHANGELOG.md#700)

**Full Changelog**: [`v6.28.0...v7.0.0`](https://github.com/remix-run/react-router/compare/react-router@6.28.0...react-router@7.0.0)

[](#react-router-v6-releases)React Router v6 Releases
=====================================================

[](#v6301)v6.30.1
-----------------

Date: 2025-05-20

### [](#patch-changes-18)Patch Changes

*   Partially revert optimization added in `6.29.0` to reduce calls to `matchRoutes` because it surfaced other issues ([#13623](https://github.com/remix-run/react-router/pull/13623))
*   Stop logging invalid warning when `v7_relativeSplatPath` is set to `false` ([#13502](https://github.com/remix-run/react-router/pull/13502))

**Full Changelog**: [`v6.30.0...v6.30.1`](https://github.com/remix-run/react-router/compare/react-router@6.30.0...react-router@6.30.1)

[](#v6300)v6.30.0
-----------------

Date: 2025-02-27

### [](#minor-changes-7)Minor Changes

*   Add `fetcherKey` as a parameter to `patchRoutesOnNavigation` ([#13109](https://github.com/remix-run/react-router/pull/13109))

### [](#patch-changes-19)Patch Changes

*   Fix regression introduced in `6.29.0` via [#12169](https://github.com/remix-run/react-router/pull/12169) that caused issues navigating to hash routes inside splat routes for applications using Lazy Route Discovery (`patchRoutesOnNavigation`) ([#13108](https://github.com/remix-run/react-router/pull/13108))

**Full Changelog**: [`v6.29.0...v6.30.0`](https://github.com/remix-run/react-router/compare/react-router@6.29.0...react-router@6.30.0)

[](#v6290)v6.29.0
-----------------

Date: 2025-01-30

### [](#minor-changes-8)Minor Changes

*   Provide the request `signal` as a parameter to `patchRoutesOnNavigation` ([#12900](https://github.com/remix-run/react-router/pull/12900))
    *   This can be used to abort any manifest fetches if the in-flight navigation/fetcher is aborted

### [](#patch-changes-20)Patch Changes

*   Do not log v7 deprecation warnings in production builds ([#12794](https://github.com/remix-run/react-router/pull/12794))
*   Properly bubble headers when throwing a `data()` result ([#12845](https://github.com/remix-run/react-router/pull/12845))
*   Optimize route matching by skipping redundant `matchRoutes` calls when possible ([#12169](https://github.com/remix-run/react-router/pull/12169))
*   Strip search parameters from `patchRoutesOnNavigation` `path` param for fetcher calls ([#12899](https://github.com/remix-run/react-router/pull/12899))

**Full Changelog**: [`v6.28.2...v6.29.0`](https://github.com/remix-run/react-router/compare/react-router@6.28.2...react-router@6.29.0)

[](#v6282)v6.28.2
-----------------

Date: 2025-01-16

### [](#patch-changes-21)Patch Changes

*   Fix manual fetcher `key` usage when not opted into `future.v7_fetcherPersist` ([#12674](https://github.com/remix-run/react-router/pull/12674))
*   Fix issue with fetcher data cleanup in the data layer on fetcher unmount ([#12674](https://github.com/remix-run/react-router/pull/12674))

**Full Changelog**: [`v6.28.1...v6.28.2`](https://github.com/remix-run/react-router/compare/react-router@6.28.1...react-router@6.28.2)

[](#v6281)v6.28.1
-----------------

Date: 2024-12-20

### [](#patch-changes-22)Patch Changes

*   Allow users to opt out of v7 deprecation warnings by setting flags to `false` ([#12441](https://github.com/remix-run/react-router/pull/12441))

**Full Changelog**: [`v6.28.0...v6.28.1`](https://github.com/remix-run/react-router/compare/react-router@6.28.0...react-router@6.28.1)

[](#v6280)v6.28.0
-----------------

Date: 2024-11-06

### [](#whats-changed-3)What's Changed

*   In preparation for v7 we've added deprecation warnings for any future flags that you have not yet opted into. Please use the flags to better prepare for eventually upgrading to v7.

### [](#minor-changes-9)Minor Changes

*   Log deprecation warnings for v7 flags ([#11750](https://github.com/remix-run/react-router/pull/11750))
    *   Add deprecation warnings to `json`/`defer` in favor of returning raw objects
        *   These methods will be removed in React Router v7

### [](#patch-changes-23)Patch Changes

*   Update JSDoc URLs for new website structure (add /v6/ segment) ([#12141](https://github.com/remix-run/react-router/pull/12141))

**Full Changelog**: [`v6.27.0...v6.28.0`](https://github.com/remix-run/react-router/compare/react-router@6.27.0...react-router@6.28.0)

[](#v6270)v6.27.0
-----------------

Date: 2024-10-11

### [](#whats-changed-4)What's Changed

#### [](#stabilized-apis)Stabilized APIs

This release stabilizes a handful of "unstable" APIs in preparation for the [pending](https://x.com/remix_run/status/1841926034868077009) React Router v7 release (see [these](https://remix.run/blog/merging-remix-and-react-router) [posts](https://remix.run/blog/incremental-path-to-react-19) for more info):

*   `unstable_dataStrategy` → `dataStrategy` (`createBrowserRouter` and friends) ([Docs](https://reactrouter.com/v6/routers/create-browser-router#optsdatastrategy))
*   `unstable_patchRoutesOnNavigation` → `patchRoutesOnNavigation` (`createBrowserRouter` and friends) ([Docs](https://reactrouter.com/v6/routers/create-browser-router#optspatchroutesonnavigation))
*   `unstable_flushSync` → `flushSync` (`useSubmit`, `fetcher.load`, `fetcher.submit`) ([Docs](https://reactrouter.com/v6/hooks/use-submit#optionsflushsync))
*   `unstable_viewTransition` → `viewTransition` (`<Link>`, `<Form>`, `useNavigate`, `useSubmit`) ([Docs](https://reactrouter.com/v6/components/link#viewtransition))

### [](#minor-changes-10)Minor Changes

*   Stabilize the `unstable_flushSync` option for navigations and fetchers ([#11989](https://github.com/remix-run/react-router/pull/11989))
*   Stabilize the `unstable_viewTransition` option for navigations and the corresponding `unstable_useViewTransitionState` hook ([#11989](https://github.com/remix-run/react-router/pull/11989))
*   Stabilize `unstable_dataStrategy` ([#11974](https://github.com/remix-run/react-router/pull/11974))
*   Stabilize `unstable_patchRoutesOnNavigation` ([#11973](https://github.com/remix-run/react-router/pull/11973))
    *   Add new `PatchRoutesOnNavigationFunctionArgs` type for convenience ([#11967](https://github.com/remix-run/react-router/pull/11967))

### [](#patch-changes-24)Patch Changes

*   Fix bug when submitting to the current contextual route (parent route with an index child) when an `?index` param already exists from a prior submission ([#12003](https://github.com/remix-run/react-router/pull/12003))
*   Fix `useFormAction` bug - when removing `?index` param it would not keep other non-Remix `index` params ([#12003](https://github.com/remix-run/react-router/pull/12003))
*   Fix bug with fetchers not persisting `preventScrollReset` through redirects during concurrent fetches ([#11999](https://github.com/remix-run/react-router/pull/11999))
*   Avoid unnecessary `console.error` on fetcher abort due to back-to-back revalidation calls ([#12050](https://github.com/remix-run/react-router/pull/12050))
*   Fix bugs with `partialHydration` when hydrating with errors ([#12070](https://github.com/remix-run/react-router/pull/12070))
*   Remove internal cache to fix issues with interrupted `patchRoutesOnNavigation` calls ([#12055](https://github.com/remix-run/react-router/pull/12055))
    *   ⚠️ This may be a breaking change if you were relying on this behavior in the `unstable_` API
    *   We used to cache in-progress calls to `patchRoutesOnNavigation` internally so that multiple navigations with the same start/end would only execute the function once and use the same promise
    *   However, this approach was at odds with `patch` short circuiting if a navigation was interrupted (and the `request.signal` aborted) since the first invocation's `patch` would no-op
    *   This cache also made some assumptions as to what a valid cache key might be - and is oblivious to any other application-state changes that may have occurred
    *   So, the cache has been removed because in _most_ cases, repeated calls to something like `import()` for async routes will already be cached automatically - and if not it's easy enough for users to implement this cache in userland
*   Remove internal `discoveredRoutes` FIFO queue from `unstable_patchRoutesOnNavigation` ([#11977](https://github.com/remix-run/react-router/pull/11977))
    *   ⚠️ This may be a breaking change if you were relying on this behavior in the `unstable_` API
    *   This was originally implemented as an optimization but it proved to be a bit too limiting
    *   If you need this optimization you can implement your own cache inside `patchRoutesOnNavigation`
*   Fix types for `RouteObject` within `PatchRoutesOnNavigationFunction`'s `patch` method so it doesn't expect agnostic route objects passed to `patch` ([#11967](https://github.com/remix-run/react-router/pull/11967))
*   Expose errors thrown from `patchRoutesOnNavigation` directly to `useRouteError` instead of wrapping them in a 400 `ErrorResponse` instance ([#12111](https://github.com/remix-run/react-router/pull/12111))

**Full Changelog**: [`v6.26.2...v6.27.0`](https://github.com/remix-run/react-router/compare/react-router@6.26.2...react-router@6.27.0)

[](#v6262)v6.26.2
-----------------

Date: 2024-09-09

### [](#patch-changes-25)Patch Changes

*   Update the `unstable_dataStrategy` API to allow for more advanced implementations ([#11943](https://github.com/remix-run/react-router/pull/11943))
    *   ⚠️ If you have already adopted `unstable_dataStrategy`, please review carefully as this includes breaking changes to this API
    *   Rename `unstable_HandlerResult` to `unstable_DataStrategyResult`
    *   Change the return signature of `unstable_dataStrategy` from a parallel array of `unstable_DataStrategyResult[]` (parallel to `matches`) to a key/value object of `routeId => unstable_DataStrategyResult`
        *   This allows more advanced control over revalidation behavior because you can opt-into or out-of revalidating data that may not have been revalidated by default (via `match.shouldLoad`)
    *   You should now return/throw a result from your `handlerOverride` instead of returning a `DataStrategyResult`
        *   The return value (or thrown error) from your `handlerOverride` will be wrapped up into a `DataStrategyResult` and returned fromm `match.resolve`
        *   Therefore, if you are aggregating the results of `match.resolve()` into a final results object you should not need to think about the `DataStrategyResult` type
        *   If you are manually filling your results object from within your `handlerOverride`, then you will need to assign a `DataStrategyResult` as the value so React Router knows if it's a successful execution or an error (see examples in the documentation for details)
    *   Added a new `fetcherKey` parameter to `unstable_dataStrategy` to allow differentiation from navigational and fetcher calls
*   Preserve opted-in view transitions through redirects ([#11925](https://github.com/remix-run/react-router/pull/11925))
*   Preserve pending view transitions through a router revalidation call ([#11917](https://github.com/remix-run/react-router/pull/11917))
*   Fix blocker usage when `blocker.proceed` is called quickly/synchronously ([#11930](https://github.com/remix-run/react-router/pull/11930))

**Full Changelog**: [`v6.26.1...v6.26.2`](https://github.com/remix-run/react-router/compare/react-router@6.26.1...react-router@6.26.2)

[](#v6261)v6.26.1
-----------------

Date: 2024-08-15

### [](#patch-changes-26)Patch Changes

*   Rename `unstable_patchRoutesOnMiss` to `unstable_patchRoutesOnNavigation` to match new behavior ([#11888](https://github.com/remix-run/react-router/pull/11888))
*   Update `unstable_patchRoutesOnNavigation` logic so that we call the method when we match routes with dynamic param or splat segments in case there exists a higher-scoring static route that we've not yet discovered ([#11883](https://github.com/remix-run/react-router/pull/11883))
    *   We also now leverage an internal FIFO queue of previous paths we've already called `unstable_patchRoutesOnNavigation` against so that we don't re-call on subsequent navigations to the same path

**Full Changelog**: [`v6.26.0...v6.26.1`](https://github.com/remix-run/react-router/compare/react-router@6.26.0...react-router@6.26.1)

[](#v6260)v6.26.0
-----------------

Date: 2024-08-01

### [](#minor-changes-11)Minor Changes

*   Add a new `replace(url, init?)` alternative to `redirect(url, init?)` that performs a `history.replaceState` instead of a `history.pushState` on client-side navigation redirects ([#11811](https://github.com/remix-run/react-router/pull/11811))
*   Add a new `unstable_data()` API for usage with Remix Single Fetch ([#11836](https://github.com/remix-run/react-router/pull/11836))
    *   This API is not intended for direct usage in React Router SPA applications
    *   It is primarily intended for usage with `createStaticHandler.query()` to allow loaders/actions to return arbitrary data along with custom `status`/`headers` without forcing the serialization of data into a `Response` instance
    *   This allows for more advanced serialization tactics via `unstable_dataStrategy` such as serializing via `turbo-stream` in Remix Single Fetch
    *   ⚠️ This removes the `status` field from `HandlerResult`
        *   If you need to return a specific `status` from `unstable_dataStrategy` you should instead do so via `unstable_data()`

### [](#patch-changes-27)Patch Changes

*   Fix internal cleanup of interrupted fetchers to avoid invalid revalidations on navigations ([#11839](https://github.com/remix-run/react-router/pull/11839))
*   Fix initial hydration behavior when using `future.v7_partialHydration` along with `unstable_patchRoutesOnMiss` ([#11838](https://github.com/remix-run/react-router/pull/11838))
    *   During initial hydration, `router.state.matches` will now include any partial matches so that we can render ancestor `HydrateFallback` components

**Full Changelog**: [`v6.25.1...v6.26.0`](https://github.com/remix-run/react-router/compare/react-router@6.25.1...react-router@6.26.0)

[](#v6251)v6.25.1
-----------------

Date: 2024-07-17

### [](#patch-changes-28)Patch Changes

*   Memoize some `RouterProvider` internals to reduce unnecessary re-renders ([#11803](https://github.com/remix-run/react-router/pull/11803))

**Full Changelog**: [`v6.25.0...v6.25.1`](https://github.com/remix-run/react-router/compare/react-router@6.25.0...react-router@6.25.1)

[](#v6250)v6.25.0
-----------------

Date: 2024-07-16

### [](#whats-changed-5)What's Changed

#### [](#stabilized-v7_skipactionerrorrevalidation)Stabilized `v7_skipActionErrorRevalidation`

This release stabilizes the `future.unstable_skipActionErrorRevalidation` flag into [`future.v7_skipActionErrorRevalidation`](https://reactrouter.com/v6/upgrading/future#v7_skipactionstatusrevalidation) in preparation for the upcoming React Router v7 release.

*   When this flag is enabled, actions that return/throw a `4xx/5xx` `Response` will not trigger a revalidation by default
*   This also stabilizes `shouldRevalidate`'s `unstable_actionStatus` parameter to `actionStatus`

### [](#minor-changes-12)Minor Changes

*   Stabilize `future.unstable_skipActionErrorRevalidation` as `future.v7_skipActionErrorRevalidation` ([#11769](https://github.com/remix-run/react-router/pull/11769))

### [](#patch-changes-29)Patch Changes

*   Fix regression and properly decode paths inside `useMatch` so matches/params reflect decoded params ([#11789](https://github.com/remix-run/react-router/pull/11789))
*   Fix bubbling of errors thrown from `unstable_patchRoutesOnMiss` ([#11786](https://github.com/remix-run/react-router/pull/11786))
*   Fix hydration in SSR apps using `unstable_patchRoutesOnMiss` that matched a splat route on the server ([#11790](https://github.com/remix-run/react-router/pull/11790))

**Full Changelog**: [`v6.24.1...v6.25.0`](https://github.com/remix-run/react-router/compare/react-router@6.24.1...react-router@6.25.0)

[](#v6241)v6.24.1
-----------------

Date: 2024-07-03

### [](#patch-changes-30)Patch Changes

*   Remove `polyfill.io` reference from warning message because the domain was sold and has since been determined to serve malware ([#11741](https://github.com/remix-run/react-router/pull/11741))
    *   See [https://sansec.io/research/polyfill-supply-chain-attack](https://sansec.io/research/polyfill-supply-chain-attack)
*   Export `NavLinkRenderProps` type for easier typing of custom `NavLink` callback ([#11553](https://github.com/remix-run/react-router/pull/11553))
*   When using `future.v7_relativeSplatPath`, properly resolve relative paths in splat routes that are children of pathless routes ([#11633](https://github.com/remix-run/react-router/pull/11633))
*   Fog of War (unstable): Trigger a new `router.routes` identity/reflow during route patching ([#11740](https://github.com/remix-run/react-router/pull/11740))
*   Fog of War (unstable): Fix initial matching when a splat route matches ([#11759](https://github.com/remix-run/react-router/pull/11759))

**Full Changelog**: [`v6.24.0...v6.24.1`](https://github.com/remix-run/react-router/compare/react-router@6.24.0...react-router@6.24.1)

[](#v6240)v6.24.0
-----------------

Date: 2024-06-24

### [](#whats-changed-6)What's Changed

#### [](#lazy-route-discovery-aka-fog-of-war)Lazy Route Discovery (a.k.a. "Fog of War")

We're really excited to release our new API for "Lazy Route Discovery" in `v6.24.0`! For some background information, please check out the original [RFC](https://github.com/remix-run/react-router/discussions/11113). The **tl;dr;** is that ever since we introduced the Data APIs in v6.4 via `<RouterProvider>`, we've been a little bummed that one of the tradeoffs was the lack of a compelling code-splitting story mirroring what we had in the `<BrowserRouter>`/`<Routes>` apps. We took a baby-step towards improving that story with `route.lazy` in `v6.9.0`, but with `v6.24.0` we've gone the rest of the way.

With "Fog of War", you can now load portions of the route tree lazily via the new `unstable_patchRoutesOnMiss` option passed to `createBrowserRouter` (and it's memory/hash counterparts). This gives you a way to hook into spots where React Router is unable to match a given path and patch new routes into the route tree during the navigation (or fetcher call).

Here's a very small example, but please refer to the [documentation](https://reactrouter.com/v6/routers/create-browser-router#optsunstable_patchroutesonmiss) for more information and use cases:

    const router = createBrowserRouter(
      [
        {
          id: "root",
          path: "/",
          Component: RootComponent,
        },
      ],
      {
        async unstable_patchRoutesOnMiss({ path, patch }) {
          if (path === "/a") {
            // Load the `a` route (`{ path: 'a', Component: A }`)
            let route = await getARoute();
            // Patch the `a` route in as a new child of the `root` route
            patch("root", [route]);
          }
        },
      }
    );
    

### [](#minor-changes-13)Minor Changes

*   Add support for Lazy Route Discovery (a.k.a. "Fog of War") ([#11626](https://github.com/remix-run/react-router/pull/11626))

### [](#patch-changes-31)Patch Changes

*   Fix `fetcher.submit` types - remove incorrect `navigate`/`fetcherKey`/`unstable_viewTransition` options because they are only relevant for `useSubmit` ([#11631](https://github.com/remix-run/react-router/pull/11631))
*   Allow falsy `location.state` values passed to `<StaticRouter>` ([#11495](https://github.com/remix-run/react-router/pull/11495))

**Full Changelog**: [`v6.23.1...v6.24.0`](https://github.com/remix-run/react-router/compare/react-router@6.23.1...react-router@6.24.0)

[](#v6231)v6.23.1
-----------------

Date: 2024-05-10

### [](#patch-changes-32)Patch Changes

*   Allow `undefined` to be resolved through `<Await>` ([#11513](https://github.com/remix-run/react-router/pull/11513))
*   Add defensive `document` check when checking for `document.startViewTransition` availability ([#11544](https://github.com/remix-run/react-router/pull/11544))
*   Change the `react-router-dom/server` import back to `react-router-dom` instead of `index.ts` ([#11514](https://github.com/remix-run/react-router/pull/11514))
*   `@remix-run/router` - Support `unstable_dataStrategy` on `staticHandler.queryRoute` ([#11515](https://github.com/remix-run/react-router/pull/11515))

**Full Changelog**: [`v6.23.0...v6.23.1`](https://github.com/remix-run/react-router/compare/react-router@6.23.0...react-router@6.23.1)

[](#v6230)v6.23.0
-----------------

Date: 2024-04-23

### [](#whats-changed-7)What's Changed

#### [](#data-strategy-unstable)Data Strategy (unstable)

The new `unstable_dataStrategy` API is a low-level API designed for advanced use-cases where you need to take control over the data strategy for your `loader`/`action` functions. The default implementation is today's behavior, to fetch all loaders in parallel, but this option allows users to implement more advanced data flows including Remix ["Single Fetch"](https://remix.run/docs/guides/single-fetch), user-land middleware/context APIs, automatic loader caching, and more. Please see the [docs](https://reactrouter.com/v6/routers/create-browser-router#unstable_datastrategy) for more information.

**Note:** This is a low-level API intended for advanced use-cases. This overrides React Router's internal handling of `loader`/`action` execution, and if done incorrectly will break your app code. Please use with caution and perform the appropriate testing.

#### [](#skip-action-error-revalidation-unstable)Skip Action Error Revalidation (unstable)

Currently, all active `loader`'s revalidate after any `action` submission, regardless of the `action` result. However, in the majority of cases a `4xx`/`5xx` response from an `action` means that no data was actually changed and the revalidation is unnecessary. We've introduced a new `future.unstable_skipActionErrorRevalidation` flag that changes the behavior here, and we plan to make this the default in future version of React Router.

With this flag enabled, `action`'s that return/throw a `4xx`/`5xx` response status will no longer automatically revalidate. If you need to revalidate after a `4xx`/`5xx` result with this flag enabled, you can still do that via returning `true` from `shouldRevalidate` - which now also receives a new `unstable_actionStatus` argument alongside `actionResult` so you can make decision based on the status of the `action` response without having to encode it into the action data.

### [](#minor-changes-14)Minor Changes

*   Add a new `unstable_dataStrategy` configuration option ([#11098](https://github.com/remix-run/react-router/pull/11098), [#11377](https://github.com/remix-run/react-router/pull/11377))
*   `@remix-run/router` - Add a new `future.unstable_skipActionRevalidation` future flag ([#11098](https://github.com/remix-run/react-router/pull/11098))
*   `@remix-run/router` - SSR: Added a new `skipLoaderErrorBubbling` options to the `staticHandler.query` method to disable error bubbling by the static handler for use in Remix's Single Fetch implementation ([#11098](https://github.com/remix-run/react-router/pull/11098), ([#11377](https://github.com/remix-run/react-router/pull/11377)))

**Full Changelog**: [`v6.22.3...v6.23.0`](https://github.com/remix-run/react-router/compare/react-router@6.22.3...react-router@6.23.0)

[](#v6223)v6.22.3
-----------------

Date: 2024-03-07

### [](#patch-changes-33)Patch Changes

*   Fix a `future.v7_partialHydration` bug that would re-run loaders below the boundary on hydration if SSR loader errors bubbled to a parent boundary ([#11324](https://github.com/remix-run/react-router/pull/11324))
*   Fix a `future.v7_partialHydration` bug that would consider the router uninitialized if a route did not have a loader ([#11325](https://github.com/remix-run/react-router/pull/11325))

**Full Changelog**: [`v6.22.2...v6.22.3`](https://github.com/remix-run/react-router/compare/react-router@6.22.2...react-router@6.22.3)

[](#v6222)v6.22.2
-----------------

Date: 2024-02-28

### [](#patch-changes-34)Patch Changes

*   Preserve hydrated errors during partial hydration runs ([#11305](https://github.com/remix-run/react-router/pull/11305))

**Full Changelog**: [`v6.22.1...v6.22.2`](https://github.com/remix-run/react-router/compare/react-router@6.22.1...react-router@6.22.2)

[](#v6221)v6.22.1
-----------------

Date: 2024-02-16

### [](#patch-changes-35)Patch Changes

*   Fix encoding/decoding issues with pre-encoded dynamic parameter values ([#11199](https://github.com/remix-run/react-router/pull/11199))

**Full Changelog**: [`v6.22.0...v6.22.1`](https://github.com/remix-run/react-router/compare/react-router@6.22.0...react-router@6.22.1)

[](#v6220)v6.22.0
-----------------

Date: 2024-02-01

### [](#whats-changed-8)What's Changed

#### [](#core-web-vitals-technology-report-flag)Core Web Vitals Technology Report Flag

In 2021, the HTTP Archive launched the [Core Web Vitals Technology Report dashboard](https://discuss.httparchive.org/t/new-dashboard-the-core-web-vitals-technology-report/2178):

> By combining the powers of real-user experiences in the Chrome UX Report 26 (CrUX) dataset with web technology detections in HTTP Archive 30, we can get a glimpse into how architectural decisions like choices of CMS platform or JavaScript framework play a role in sites’ CWV performance.

They use a tool called [`wappalyzer`](https://github.com/HTTPArchive/wappalyzer) to identify what technologies a given website is using by looking for certain scripts, global JS variables, or other identifying characteristics. For example, for Remix applications, they [look for the global `__remixContext`](https://github.com/HTTPArchive/wappalyzer/blob/c2a24ee7c2d07bf9c521f02584ae2dcf603ac0b7/src/technologies/r.json#L1328) variable to identify that a website is using Remix.

It was brought to our attention that React Router was unable to be reliably identified because there are no identifying global aspects. They are currently [looking for external scripts with `react-router`](https://github.com/HTTPArchive/wappalyzer/blob/c2a24ee7c2d07bf9c521f02584ae2dcf603ac0b7/src/technologies/r.json#L637) in the name. This will identify sites using React Router from a CDN such as `unpkg` - but it will miss the **vast** majority of sites that are installing React Router from the npm registry and bundling it into their JS files. This results in [drastically under-reporting](https://lookerstudio.google.com/s/pixHkNmGbN4) the usage of React Router on the web.

Starting with version `6.22.0`, sites using `react-router-dom` will begin adding a `window.__reactRouterVersion` variable that will be set to a string value of the SemVer major version number (i.e., `window.__reactRouterVersion = "6";`) so that they can be properly identified.

### [](#minor-changes-15)Minor Changes

*   Include a `window.__reactRouterVersion` for CWV Report detection ([#11222](https://github.com/remix-run/react-router/pull/11222))
*   Add a `createStaticHandler` `future.v7_throwAbortReason` flag to throw `request.signal.reason` (defaults to a `DOMException`) when a request is aborted instead of an `Error` such as `new Error("query() call aborted: GET /path")` ([#11104](https://github.com/remix-run/react-router/pull/11104))
    *   Please note that `DOMException` was added in Node v17 so you will not get a `DOMException` on Node 16 and below.

### [](#patch-changes-36)Patch Changes

*   Respect the `ErrorResponse` status code if passed to `getStaticContextFormError` ([#11213](https://github.com/remix-run/react-router/pull/11213))

**Full Changelog**: [`v6.21.3...v6.22.0`](https://github.com/remix-run/react-router/compare/react-router@6.21.3...react-router@6.22.0)

[](#v6213)v6.21.3
-----------------

Date: 2024-01-18

### [](#patch-changes-37)Patch Changes

*   Fix `NavLink` `isPending` when a `basename` is used ([#11195](https://github.com/remix-run/react-router/pull/11195))
*   Remove leftover `unstable_` prefix from `Blocker`/`BlockerFunction` types ([#11187](https://github.com/remix-run/react-router/pull/11187))

**Full Changelog**: [`v6.21.2...v6.21.3`](https://github.com/remix-run/react-router/compare/react-router@6.21.2...react-router@6.21.3)

[](#v6212)v6.21.2
-----------------

Date: 2024-01-11

### [](#patch-changes-38)Patch Changes

*   Leverage `useId` for internal fetcher keys when available ([#11166](https://github.com/remix-run/react-router/pull/11166))
*   Fix bug where dashes were not picked up in dynamic parameter names ([#11160](https://github.com/remix-run/react-router/pull/11160))
*   Do not attempt to deserialize empty JSON responses ([#11164](https://github.com/remix-run/react-router/pull/11164))

**Full Changelog**: [`v6.21.1...v6.21.2`](https://github.com/remix-run/react-router/compare/react-router@6.21.1...react-router@6.21.2)

[](#v6211)v6.21.1
-----------------

Date: 2023-12-21

### [](#patch-changes-39)Patch Changes

*   Fix bug with `route.lazy` not working correctly on initial SPA load when `v7_partialHydration` is specified ([#11121](https://github.com/remix-run/react-router/pull/11121))
*   Fix bug preventing revalidation from occurring for persisted fetchers unmounted during the `submitting` phase ([#11102](https://github.com/remix-run/react-router/pull/11102))
*   De-dup relative path logic in `resolveTo` ([#11097](https://github.com/remix-run/react-router/pull/11097))

**Full Changelog**: [`v6.21.0...v6.21.1`](https://github.com/remix-run/react-router/compare/react-router@6.21.0...react-router@6.21.1)

[](#v6210)v6.21.0
-----------------

Date: 2023-12-13

### [](#whats-changed-9)What's Changed

#### [](#futurev7_relativesplatpath)`future.v7_relativeSplatPath`

We fixed a splat route path-resolution bug in `6.19.0`, but later determined a large number of applications were relying on the buggy behavior, so we reverted the fix in `6.20.1` (see [#10983](https://github.com/remix-run/react-router/issues/10983), [#11052](https://github.com/remix-run/react-router/issues/11052), [#11078](https://github.com/remix-run/react-router/issues/11078)).

The buggy behavior is that the default behavior when resolving relative paths inside a splat route would _ignore_ any splat (`*`) portion of the current route path. When the future flag is enabled, splat portions are included in relative path logic within splat routes.

For more information, please refer to the [`useResolvedPath` docs](https://reactrouter.com/v6/hooks/use-resolved-path#splat-paths) and/or the [detailed changelog entry](https://github.com/remix-run/react-router/blob/main/packages/react-router-dom/CHANGELOG.md#6210).

#### [](#partial-hydration)Partial Hydration

We added a new `future.v7_partialHydration` future flag for the `@remix-run/router` that enables partial hydration of a data router when Server-Side Rendering. This allows you to provide `hydrationData.loaderData` that has values for _some_ initially matched route loaders, but not all. When this flag is enabled, the router will call `loader` functions for routes that do not have hydration loader data during `router.initialize()`, and it will render down to the deepest provided `HydrateFallback` (up to the first route without hydration data) while it executes the unhydrated routes. ([#11033](https://github.com/remix-run/react-router/pull/11033))

### [](#minor-changes-16)Minor Changes

*   Add a new `future.v7_relativeSplatPath` flag to implement a breaking bug fix to relative routing when inside a splat route. ([#11087](https://github.com/remix-run/react-router/pull/11087))
*   Add a new `future.v7_partialHydration` future flag that enables partial hydration of a data router when Server-Side Rendering ([#11033](https://github.com/remix-run/react-router/pull/11033))

### [](#patch-changes-40)Patch Changes

*   Properly handle falsy error values in `ErrorBoundary`'s ([#11071](https://github.com/remix-run/react-router/pull/11071))
*   Catch and bubble errors thrown when trying to unwrap responses from `loader`/`action` functions ([#11061](https://github.com/remix-run/react-router/pull/11061))
*   Fix `relative="path"` issue when rendering `Link`/`NavLink` outside of matched routes ([#11062](https://github.com/remix-run/react-router/pull/11062))

**Full Changelog**: [`v6.20.1...v6.21.0`](https://github.com/remix-run/react-router/compare/react-router@6.20.1...react-router@6.21.0)

[](#v6201)v6.20.1
-----------------

Date: 2023-12-01

### [](#patch-changes-41)Patch Changes

*   Revert the `useResolvedPath` fix for splat routes due to a large number of applications that were relying on the buggy behavior (see [#11052](https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329)) ([#11078](https://github.com/remix-run/react-router/pull/11078))
    *   We plan to re-introduce this fix behind a future flag in the next minor version (see [this comment](https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329))
    *   This fix was included in versions `6.19.0` and `6.20.0`. If you are upgrading from `6.18.0` or earlier, you would not have been impacted by this fix.

**Full Changelog**: [`v6.20.0...v6.20.1`](https://github.com/remix-run/react-router/compare/react-router@6.20.0...react-router@6.20.1)

[](#v6200)v6.20.0
-----------------

Date: 2023-11-22

> \[!WARNING\] Please use version `6.20.1` or later instead of `6.20.0`. We discovered that a large number of apps were relying on buggy behavior that was fixed in this release ([#11045](https://github.com/remix-run/react-router/pull/11045)). We reverted the fix in `6.20.1` and will be re-introducing it behind a future flag in a subsequent release. See [#11052](https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329) for more details.

### [](#minor-changes-17)Minor Changes

*   Export the `PathParam` type from the public API ([#10719](https://github.com/remix-run/react-router/pull/10719))

### [](#patch-changes-42)Patch Changes

*   Do not revalidate unmounted fetchers when `v7_fetcherPersist` is enabled ([#11044](https://github.com/remix-run/react-router/pull/11044))
*   Fix bug with `resolveTo` path resolution in splat routes ([#11045](https://github.com/remix-run/react-router/pull/11045))
    *   This is a follow up to [#10983](https://github.com/remix-run/react-router/pull/10983) to handle the few other code paths using `getPathContributingMatches`
    *   This removes the `UNSAFE_getPathContributingMatches` export from `@remix-run/router` since we no longer need this in the `react-router`/`react-router-dom` layers

**Full Changelog**: [`v6.19.0...v6.20.0`](https://github.com/remix-run/react-router/compare/react-router@6.19.0...react-router@6.20.0)

[](#v6190)v6.19.0
-----------------

Date: 2023-11-16

> \[!WARNING\] Please use version `6.20.1` or later instead of `6.19.0`. We discovered that a large number of apps were relying on buggy behavior that was fixed in this release ([#10983](https://github.com/remix-run/react-router/pull/10983)). We reverted the fix in `6.20.1` and will be re-introducing it behind a future flag in a subsequent release. See [#11052](https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329) for more details.

### [](#whats-changed-10)What's Changed

#### [](#unstable_flushsync-api)`unstable_flushSync` API

This release brings a new `unstable_flushSync` option to the imperative APIs (`useSubmit`, `useNavigate`, `fetcher.submit`, `fetcher.load`) to let users opt-into synchronous DOM updates for pending/optimistic UI.

    function handleClick() {
      submit(data, { flushSync: true });
      // Everything is flushed to the DOM so you can focus/scroll to your pending/optimistic UI
      setFocusAndOrScrollToNewlyAddedThing();
    }
    

### [](#minor-changes-18)Minor Changes

*   Add `unstable_flushSync` option to `useNavigate`/`useSubmit`/`fetcher.load`/`fetcher.submit` to opt-out of `React.startTransition` and into `ReactDOM.flushSync` for state updates ([#11005](https://github.com/remix-run/react-router/pull/11005))
*   Remove the `unstable_` prefix from the [`useBlocker`](https://reactrouter.com/v6/hooks/use-blocker) hook as it's been in use for enough time that we are confident in the API ([#10991](https://github.com/remix-run/react-router/pull/10991))
    *   We do not plan to remove the prefix from `unstable_usePrompt` due to differences in how browsers handle `window.confirm` that prevent React Router from guaranteeing consistent/correct behavior

### [](#patch-changes-43)Patch Changes

*   Fix `useActionData` so it returns proper contextual action data and not _any_ action data in the tree ([#11023](https://github.com/remix-run/react-router/pull/11023))
    
*   Fix bug in `useResolvedPath` that would cause `useResolvedPath(".")` in a splat route to lose the splat portion of the URL path. ([#10983](https://github.com/remix-run/react-router/pull/10983))
    
    *   ⚠️ This fixes a quite long-standing bug specifically for `"."` paths inside a splat route which incorrectly dropped the splat portion of the URL. If you are relative routing via `"."` inside a splat route in your application you should double check that your logic is not relying on this buggy behavior and update accordingly.
*   Fix issue where a changing fetcher `key` in a `useFetcher` that remains mounted wasn't getting picked up ([#11009](https://github.com/remix-run/react-router/pull/11009))
    
*   Fix `useFormAction` which was incorrectly inheriting the `?index` query param from child route `action` submissions ([#11025](https://github.com/remix-run/react-router/pull/11025))
    
*   Fix `NavLink` `active` logic when `to` location has a trailing slash ([#10734](https://github.com/remix-run/react-router/pull/10734))
    
*   Fix types so `unstable_usePrompt` can accept a `BlockerFunction` in addition to a `boolean` ([#10991](https://github.com/remix-run/react-router/pull/10991))
    
*   Fix `relative="path"` bug where relative path calculations started from the full location pathname, instead of from the current contextual route pathname. ([#11006](https://github.com/remix-run/react-router/pull/11006))
    
        <Route path="/a">
          <Route path="/b" element={<Component />}>
            <Route path="/c" />
          </Route>
        </Route>;
        
        function Component() {
          return (
            <>
              {/* This is now correctly relative to /a/b, not /a/b/c */}
              <Link to=".." relative="path" />
              <Outlet />
            </>
          );
        }
        
    

**Full Changelog**: [`6.18.0...6.19.0`](https://github.com/remix-run/react-router/compare/react-router@6.18.0...react-router@6.19.0)

[](#v6180)v6.18.0
-----------------

Date: 2023-10-31

### [](#whats-changed-11)What's Changed

#### [](#new-fetcher-apis)New Fetcher APIs

Per this [RFC](https://github.com/remix-run/remix/discussions/7698), we've introduced some new APIs that give you more granular control over your fetcher behaviors.

*   You may now specify your own fetcher identifier via `useFetcher({ key: string })`, which allows you to access the same fetcher instance from different components in your application without prop-drilling
*   Fetcher keys are now exposed on the fetchers returned from `useFetchers` so that they can be looked up by `key`
*   `Form` and `useSubmit` now support optional `navigate`/`fetcherKey` props/params to allow kicking off a fetcher submission under the hood with an optionally user-specified `key`
    *   `<Form method="post" navigate={false} fetcherKey="my-key">`
    *   `submit(data, { method: "post", navigate: false, fetcherKey: "my-key" })`
    *   Invoking a fetcher in this way is ephemeral and stateless
    *   If you need to access the state of one of these fetchers, you will need to leverage `useFetchers()` or `useFetcher({ key })` to look it up elsewhere

#### [](#persistence-future-flag-futurev7_fetcherpersist)Persistence Future Flag (`future.v7_fetcherPersist`)

Per the same [RFC](https://github.com/remix-run/remix/discussions/7698) as above, we've introduced a new `future.v7_fetcherPersist` flag that allows you to opt-into the new fetcher persistence/cleanup behavior. Instead of being immediately cleaned up on unmount, fetchers will persist until they return to an `idle` state. This makes pending/optimistic UI _much_ easier in scenarios where the originating fetcher needs to unmount.

*   This is sort of a long-standing bug fix as the `useFetchers()` API was always supposed to only reflect **in-flight** fetcher information for pending/optimistic UI -- it was not intended to reflect fetcher data or hang onto fetchers after they returned to an `idle` state
*   Keep an eye out for the following specific behavioral changes when opting into this flag and check your app for compatibility:
    *   Fetchers that complete _while still mounted_ will no longer appear in `useFetchers()` after completion - they served no purpose in there since you can access the data via `useFetcher().data`
    *   Fetchers that previously unmounted _while in-flight_ will not be immediately aborted and will instead be cleaned up once they return to an `idle` state
        *   They will remain exposed via `useFetchers` while in-flight so you can still access pending/optimistic data after unmount
        *   If a fetcher is no longer mounted when it completes, then it's result will not be post processed - e.g., redirects will not be followed and errors will not bubble up in the UI
        *   However, if a fetcher was re-mounted elsewhere in the tree using the same `key`, then it's result will be processed, even if the originating fetcher was unmounted

### [](#minor-changes-19)Minor Changes

*   Add fetcher `key` APIs and `navigate=false` options ([#10960](https://github.com/remix-run/react-router/pull/10960))
*   Add `future.v7_fetcherPersist` flag ([#10962](https://github.com/remix-run/react-router/pull/10962))
*   Add support for optional path segments in `matchPath` ([#10768](https://github.com/remix-run/react-router/pull/10768))

### [](#patch-changes-44)Patch Changes

*   Fix the `future` prop on `BrowserRouter`, `HashRouter` and `MemoryRouter` so that it accepts a `Partial<FutureConfig>` instead of requiring all flags to be included ([#10962](https://github.com/remix-run/react-router/pull/10962))
*   Fix `router.getFetcher`/`router.deleteFetcher` type definitions which incorrectly specified `key` as an optional parameter ([#10960](https://github.com/remix-run/react-router/pull/10960))

**Full Changelog**: [`6.17.0...6.18.0`](https://github.com/remix-run/react-router/compare/react-router@6.17.0...react-router@6.18.0)

[](#v6170)v6.17.0
-----------------

Date: 2023-10-16

### [](#whats-changed-12)What's Changed

#### [](#view-transitions-)View Transitions 🚀

We're excited to release experimental support for the [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition) in React Router! You can now trigger navigational DOM updates to be wrapped in `document.startViewTransition` to enable CSS animated transitions on SPA navigations in your application.

The simplest approach to enabling a View Transition in your React Router app is via the new [`<Link unstable_viewTransition>`](https://reactrouter.com/v6/components/link#unstable_viewtransition) prop. This will cause the navigation DOM update to be wrapped in `document.startViewTransition` which will enable transitions for the DOM update. Without any additional CSS styles, you'll get a basic cross-fade animation for your page.

If you need to apply more fine-grained styles for your animations, you can leverage the [`unstable_useViewTransitionState`](https://reactrouter.com/v6/hooks/use-view-transition-state) hook which will tell you when a transition is in progress and you can use that to apply classes or styles:

    function ImageLink(to, src, alt) {
      const isTransitioning = unstable_useViewTransitionState(to);
      return (
        <Link to={to} unstable_viewTransition>
          <img
            src={src}
            alt={alt}
            style={{
              viewTransitionName: isTransitioning ? "image-expand" : "",
            }}
          />
        </Link>
      );
    }
    

You can also use the [`<NavLink unstable_viewTransition>`](https://reactrouter.com/v6/components/nav-link#unstable_viewtransition) shorthand which will manage the hook usage for you and automatically add a `transitioning` class to the `<a>` during the transition:

    a.transitioning img {
      view-transition-name: "image-expand";
    }
    

    <NavLink to={to} unstable_viewTransition>
      <img src={src} alt={alt} />
    </NavLink>
    

For an example usage of View Transitions, check out [our fork](https://github.com/brophdawg11/react-router-records) of the awesome [Astro Records](https://github.com/Charca/astro-records) demo.

For more information on using the View Transitions API, please refer to the [Smooth and simple transitions with the View Transitions API](https://developer.chrome.com/docs/web-platform/view-transitions/) guide from the Google Chrome team.

### [](#minor-changes-20)Minor Changes

*   Add support for view transitions ([#10916](https://github.com/remix-run/react-router/pull/10916))

### [](#patch-changes-45)Patch Changes

*   Log a warning and fail gracefully in `ScrollRestoration` when `sessionStorage` is unavailable ([#10848](https://github.com/remix-run/react-router/pull/10848))
*   Fix `RouterProvider` `future` prop type to be a `Partial<FutureConfig>` so that not all flags must be specified ([#10900](https://github.com/remix-run/react-router/pull/10900))
*   Allow 404 detection to leverage root route error boundary if path contains a URL segment ([#10852](https://github.com/remix-run/react-router/pull/10852))
*   Fix `ErrorResponse` type to avoid leaking internal field ([#10876](https://github.com/remix-run/react-router/pull/10876))

**Full Changelog**: [`6.16.0...6.17.0`](https://github.com/remix-run/react-router/compare/react-router@6.16.0...react-router@6.17.0)

[](#v6160)v6.16.0
-----------------

Date: 2023-09-13

### [](#minor-changes-21)Minor Changes

*   In order to move towards stricter TypeScript support in the future, we're aiming to replace current usages of `any` with `unknown` on exposed typings for user-provided data. To do this in Remix v2 without introducing breaking changes in React Router v6, we have added generics to a number of shared types. These continue to default to `any` in React Router and are overridden with `unknown` in Remix. In React Router v7 we plan to move these to `unknown` as a breaking change. ([#10843](https://github.com/remix-run/react-router/pull/10843))
    *   `Location` now accepts a generic for the `location.state` value
    *   `ActionFunctionArgs`/`ActionFunction`/`LoaderFunctionArgs`/`LoaderFunction` now accept a generic for the `context` parameter (only used in SSR usages via `createStaticHandler`)
    *   The return type of `useMatches` (now exported as `UIMatch`) accepts generics for `match.data` and `match.handle` - both of which were already set to `unknown`
*   Move the `@private` class export `ErrorResponse` to an `UNSAFE_ErrorResponseImpl` export since it is an implementation detail and there should be no construction of `ErrorResponse` instances in userland. This frees us up to export a `type ErrorResponse` which correlates to an instance of the class via `InstanceType`. Userland code should only ever be using `ErrorResponse` as a type and should be type-narrowing via `isRouteErrorResponse`. ([#10811](https://github.com/remix-run/react-router/pull/10811))
*   Export `ShouldRevalidateFunctionArgs` interface ([#10797](https://github.com/remix-run/react-router/pull/10797))
*   Removed private/internal APIs only required for the Remix v1 backwards compatibility layer and no longer needed in Remix v2 (`_isFetchActionRedirect`, `_hasFetcherDoneAnything`) ([#10715](https://github.com/remix-run/react-router/pull/10715))

### [](#patch-changes-46)Patch Changes

*   Properly encode rendered URIs in server rendering to avoid hydration errors ([#10769](https://github.com/remix-run/react-router/pull/10769))
*   Add method/url to error message on aborted `query`/`queryRoute` calls ([#10793](https://github.com/remix-run/react-router/pull/10793))
*   Fix a race-condition with loader/action-thrown errors on `route.lazy` routes ([#10778](https://github.com/remix-run/react-router/pull/10778))
*   Fix type for `actionResult` on the arguments object passed to `shouldRevalidate` ([#10779](https://github.com/remix-run/react-router/pull/10779))

**Full Changelog**: [`v6.15.0...v6.16.0`](https://github.com/remix-run/react-router/compare/react-router@6.15.0...react-router@6.16.0)

[](#v6150)v6.15.0
-----------------

Date: 2023-08-10

### [](#minor-changes-22)Minor Changes

*   Add's a new `redirectDocument()` function which allows users to specify that a redirect from a `loader`/`action` should trigger a document reload (via `window.location`) instead of attempting to navigate to the redirected location via React Router ([#10705](https://github.com/remix-run/react-router/pull/10705))

### [](#patch-changes-47)Patch Changes

*   Ensure `useRevalidator` is referentially stable across re-renders if revalidations are not actively occurring ([#10707](https://github.com/remix-run/react-router/pull/10707))
*   Ensure hash history always includes a leading slash on hash pathnames ([#10753](https://github.com/remix-run/react-router/pull/10753))
*   Fixes an edge-case affecting web extensions in Firefox that use `URLSearchParams` and the `useSearchParams` hook ([#10620](https://github.com/remix-run/react-router/pull/10620))
*   Reorder effects in `unstable_usePrompt` to avoid throwing an exception if the prompt is unblocked and a navigation is performed synchronously ([#10687](https://github.com/remix-run/react-router/pull/10687), [#10718](https://github.com/remix-run/react-router/pull/10718))
*   SSR: Do not include hash in `useFormAction()` for unspecified actions since it cannot be determined on the server and causes hydration issues ([#10758](https://github.com/remix-run/react-router/pull/10758))
*   SSR: Fix an issue in `queryRoute` that was not always identifying thrown `Response` instances ([#10717](https://github.com/remix-run/react-router/pull/10717))
*   `react-router-native`: Update `@ungap/url-search-params` dependency from `^0.1.4` to `^0.2.2` ([#10590](https://github.com/remix-run/react-router/pull/10590))

**Full Changelog**: [`v6.14.2...v6.15.0`](https://github.com/remix-run/react-router/compare/react-router@6.14.2...react-router@6.15.0)

[](#v6142)v6.14.2
-----------------

Date: 2023-07-17

### [](#patch-changes-48)Patch Changes

*   Add missing `<Form state>` prop to populate `history.state` on submission navigations ([#10630](https://github.com/remix-run/react-router/pull/10630))
*   Trigger an error if a `defer` promise resolves/rejects with `undefined` in order to match the behavior of loaders and actions which must return a value or `null` ([#10690](https://github.com/remix-run/react-router/pull/10690))
*   Properly handle fetcher redirects interrupted by normal navigations ([#10674](https://github.com/remix-run/react-router/pull/10674))
*   Initial-load fetchers should not automatically revalidate on GET navigations ([#10688](https://github.com/remix-run/react-router/pull/10688))
*   Properly decode element id when emulating hash scrolling via `<ScrollRestoration>` ([#10682](https://github.com/remix-run/react-router/pull/10682))
*   Typescript: Enhance the return type of `Route.lazy` to prohibit returning an empty object ([#10634](https://github.com/remix-run/react-router/pull/10634))
*   SSR: Support proper hydration of `Error` subclasses such as `ReferenceError`/`TypeError` ([#10633](https://github.com/remix-run/react-router/pull/10633))

**Full Changelog**: [`v6.14.1...v6.14.2`](https://github.com/remix-run/react-router/compare/react-router@6.14.1...react-router@6.14.2)

[](#v6141)v6.14.1
-----------------

Date: 2023-06-30

### [](#patch-changes-49)Patch Changes

*   Fix loop in `unstable_useBlocker` when used with an unstable blocker function ([#10652](https://github.com/remix-run/react-router/pull/10652))
*   Fix issues with reused blockers on subsequent navigations ([#10656](https://github.com/remix-run/react-router/pull/10656))
*   Updated dependencies:
    *   `@remix-run/router@1.7.1`

**Full Changelog**: [`v6.14.0...v6.14.1`](https://github.com/remix-run/react-router/compare/react-router@6.14.0...react-router@6.14.1)

[](#v6140)v6.14.0
-----------------

Date: 2023-06-23

### [](#whats-changed-13)What's Changed

#### [](#jsontext-submissions)JSON/Text Submissions

`6.14.0` adds support for JSON and Text submissions via `useSubmit`/`fetcher.submit` since it's not always convenient to have to serialize into `FormData` if you're working in a client-side SPA. To opt-into these encodings you just need to specify the proper `formEncType`:

**Opt-into `application/json` encoding:**

    function Component() {
      let navigation = useNavigation();
      let submit = useSubmit();
      submit({ key: "value" }, { method: "post", encType: "application/json" });
      // navigation.formEncType => "application/json"
      // navigation.json        => { key: "value" }
    }
    
    async function action({ request }) {
      // request.headers.get("Content-Type") => "application/json"
      // await request.json()                => { key: "value" }
    }
    

**Opt-into `text/plain` encoding:**

    function Component() {
      let navigation = useNavigation();
      let submit = useSubmit();
      submit("Text submission", { method: "post", encType: "text/plain" });
      // navigation.formEncType => "text/plain"
      // navigation.text        => "Text submission"
    }
    
    async function action({ request }) {
      // request.headers.get("Content-Type") => "text/plain"
      // await request.text()                => "Text submission"
    }
    

**⚠️ Default Behavior Will Change in v7**

Please note that to avoid a breaking change, the default behavior will still encode a simple key/value JSON object into a `FormData` instance:

    function Component() {
      let navigation = useNavigation();
      let submit = useSubmit();
      submit({ key: "value" }, { method: "post" });
      // navigation.formEncType => "application/x-www-form-urlencoded"
      // navigation.formData    => FormData instance
    }
    
    async function action({ request }) {
      // request.headers.get("Content-Type") => "application/x-www-form-urlencoded"
      // await request.formData()            => FormData instance
    }
    

This behavior will likely change in v7 so it's best to make any JSON object submissions explicit with `formEncType: "application/x-www-form-urlencoded"` or `formEncType: "application/json"` to ease your eventual v7 migration path.

### [](#minor-changes-23)Minor Changes

*   Add support for `application/json` and `text/plain` encodings for `useSubmit`/`fetcher.submit`. To reflect these additional types, `useNavigation`/`useFetcher` now also contain `navigation.json`/`navigation.text` and `fetcher.json`/`fetcher.text` which include the json/text submission if applicable. ([#10413](https://github.com/remix-run/react-router/pull/10413))

### [](#patch-changes-50)Patch Changes

*   When submitting a form from a `submitter` element, prefer the built-in `new FormData(form, submitter)` instead of the previous manual approach in modern browsers (those that support the new `submitter` parameter) ([#9865](https://github.com/remix-run/react-router/pull/9865))
    *   For browsers that don't support it, we continue to just append the submit button's entry to the end, and we also add rudimentary support for `type="image"` buttons
    *   If developers want full spec-compliant support for legacy browsers, they can use the `formdata-submitter-polyfill`
*   Call `window.history.pushState/replaceState` _before_ updating React Router state (instead of after) so that `window.location` matches `useLocation` during synchronous React 17 rendering ([#10448](https://github.com/remix-run/react-router/pull/10448))
    *   ⚠️ Note: generally apps should not be relying on `window.location` and should always reference `useLocation` when possible, as `window.location` will not be in sync 100% of the time (due to `popstate` events, concurrent mode, etc.)
*   Avoid calling `shouldRevalidate` for fetchers that have not yet completed a data load ([#10623](https://github.com/remix-run/react-router/pull/10623))
*   Strip `basename` from the `location` provided to `<ScrollRestoration getKey>` to match the `useLocation` behavior ([#10550](https://github.com/remix-run/react-router/pull/10550))
*   Strip `basename` from locations provided to `unstable_useBlocker` functions to match the `useLocation` behavior ([#10573](https://github.com/remix-run/react-router/pull/10573))
*   Fix `unstable_useBlocker` key issues in `StrictMode` ([#10573](https://github.com/remix-run/react-router/pull/10573))
*   Fix `generatePath` when passed a numeric `0` value parameter ([#10612](https://github.com/remix-run/react-router/pull/10612))
*   Fix `tsc --skipLibCheck:false` issues on React 17 ([#10622](https://github.com/remix-run/react-router/pull/10622))
*   Upgrade `typescript` to 5.1 ([#10581](https://github.com/remix-run/react-router/pull/10581))

**Full Changelog**: [`v6.13.0...v6.14.0`](https://github.com/remix-run/react-router/compare/react-router@6.13.0...react-router@6.14.0)

[](#v6130)v6.13.0
-----------------

Date: 2023-06-14

### [](#whats-changed-14)What's Changed

`6.13.0` is really a patch release in spirit but comes with a SemVer minor bump since we added a new future flag.

#### [](#futurev7_starttransition)`future.v7_startTransition`

The **tl;dr;** is that `6.13.0` is the same as [`6.12.0`](https://github.com/remix-run/react-router/releases/tag/react-router%406.12.0) bue we've moved the usage of `React.startTransition` behind an opt-in `future.v7_startTransition` [future flag](https://reactrouter.com/v6/guides/api-development-strategy) because we found that there are applications in the wild that are currently using `Suspense` in ways that are incompatible with `React.startTransition`.

Therefore, in `6.13.0` the default behavior will no longer leverage `React.startTransition`:

    <BrowserRouter>
      <Routes>{/*...*/}</Routes>
    </BrowserRouter>
    
    <RouterProvider router={router} />
    

If you wish to enable `React.startTransition`, pass the future flag to your router component:

    <BrowserRouter future={{ v7_startTransition: true }}>
      <Routes>{/*...*/}</Routes>
    </BrowserRouter>
    
    <RouterProvider router={router} future={{ v7_startTransition: true }}/>
    

We recommend folks adopt this flag sooner rather than later to be better compatible with React concurrent mode, but if you run into issues you can continue without the use of `React.startTransition` until v7. Issues usually boil down to creating net-new promises during the render cycle, so if you run into issues when opting into `React.startTransition`, you should either lift your promise creation out of the render cycle or put it behind a `useMemo`.

### [](#minor-changes-24)Minor Changes

*   Move `React.startTransition` usage behinds a future flag ([#10596](https://github.com/remix-run/react-router/pull/10596))

### [](#patch-changes-51)Patch Changes

*   Work around webpack/terser `React.startTransition` minification bug in production mode ([#10588](https://github.com/remix-run/react-router/pull/10588))

**Full Changelog**: [`v6.12.1...v6.13.0`](https://github.com/remix-run/react-router/compare/react-router@6.12.1...react-router@6.13.0)

[](#v6121)v6.12.1
-----------------

Date: 2023-06-08

> \[!WARNING\] Please use version `6.13.0` or later instead of `6.12.0`/`6.12.1`. These versions suffered from some Webpack build/minification issues resulting failed builds or invalid minified code in your production bundles. See [#10569](https://github.com/remix-run/react-router/pull/10569) and [#10579](https://github.com/remix-run/react-router/issues/10579) for more details.

### [](#patch-changes-52)Patch Changes

*   Adjust feature detection of `React.startTransition` to fix webpack + react 17 compilation error ([#10569](https://github.com/remix-run/react-router/pull/10569))

**Full Changelog**: [`v6.12.0...v6.12.1`](https://github.com/remix-run/react-router/compare/react-router@6.12.0...react-router@6.12.1)

[](#v6120)v6.12.0
-----------------

Date: 2023-06-06

> \[!WARNING\] Please use version `6.13.0` or later instead of `6.12.0`/`6.12.1`. These versions suffered from some Webpack build/minification issues resulting failed builds or invalid minified code in your production bundles. See [#10569](https://github.com/remix-run/react-router/pull/10569) and [#10579](https://github.com/remix-run/react-router/issues/10579) for more details.

### [](#whats-changed-15)What's Changed

#### [](#reactstarttransition-support)`React.startTransition` support

With `6.12.0` we've added better support for suspending components by wrapping the internal router state updates in [`React.startTransition`](https://react.dev/reference/react/startTransition). This means that, for example, if one of your components in a destination route suspends and you have not provided a [`Suspense`](https://react.dev/reference/react/Suspense) boundary to show a fallback, React will delay the rendering of the new UI and show the old UI until that asynchronous operation resolves. This could be useful for waiting for things such as waiting for images or CSS files to load (and technically, yes, you could use it for data loading but we'd still recommend using loaders for that 😀). For a quick overview of this usage, check out [Ryan's demo on Twitter](https://twitter.com/remix_run/status/1658976420767604736).

### [](#minor-changes-25)Minor Changes

*   Wrap internal router state updates with `React.startTransition` ([#10438](https://github.com/remix-run/react-router/pull/10438))

### [](#patch-changes-53)Patch Changes

*   Allow fetcher revalidations to complete if submitting fetcher is deleted ([#10535](https://github.com/remix-run/react-router/pull/10535))
*   Re-throw `DOMException` (`DataCloneError`) when attempting to perform a `PUSH` navigation with non-serializable state. ([#10427](https://github.com/remix-run/react-router/pull/10427))
*   Ensure revalidations happen when hash is present ([#10516](https://github.com/remix-run/react-router/pull/10516))
*   Upgrade `jest` and `jsdom` ([#10453](https://github.com/remix-run/react-router/pull/10453))
*   Updated dependencies:
    *   `@remix-run/router@1.6.3` ([Changelog](https://github.com/remix-run/react-router/blob/main/packages/router/CHANGELOG.md#163))

**Full Changelog**: [`v6.11.2...v6.12.0`](https://github.com/remix-run/react-router/compare/react-router@6.11.2...react-router@6.12.0)

[](#v6112)v6.11.2
-----------------

Date: 2023-05-17

### [](#patch-changes-54)Patch Changes

*   Fix `basename` duplication in descendant `<Routes>` inside a `<RouterProvider>` ([#10492](https://github.com/remix-run/react-router/pull/10492))
*   Fix bug where initial data load would not kick off when hash is present ([#10493](https://github.com/remix-run/react-router/pull/10493))
*   Export `SetURLSearchParams` type ([#10444](https://github.com/remix-run/react-router/pull/10444))
*   Fix Remix HMR-driven error boundaries by properly reconstructing new routes and `manifest` in `_internalSetRoutes` ([#10437](https://github.com/remix-run/react-router/pull/10437))

**Full Changelog**: [`v6.11.1...v6.11.2`](https://github.com/remix-run/react-router/compare/react-router@6.11.1...react-router@6.11.2)

[](#v6111)v6.11.1
-----------------

Date: 2023-05-03

### [](#patch-changes-55)Patch Changes

*   Fix usage of `Component` API within descendant `<Routes>` ([#10434](https://github.com/remix-run/react-router/pull/10434))
*   Fix bug when calling `useNavigate` from `<Routes>` inside a `<RouterProvider>` ([#10432](https://github.com/remix-run/react-router/pull/10432))
*   Fix usage of `<Navigate>` in strict mode when using a data router ([#10435](https://github.com/remix-run/react-router/pull/10435))
*   Fix `basename` handling when navigating without a path ([#10433](https://github.com/remix-run/react-router/pull/10433))
*   "Same hash" navigations no longer re-run loaders to match browser behavior (i.e. `/path#hash -> /path#hash`) ([#10408](https://github.com/remix-run/react-router/pull/10408))

**Full Changelog**: [`v6.11.0...v6.11.1`](https://github.com/remix-run/react-router/compare/react-router@6.11.0...react-router@6.11.1)

[](#v6110)v6.11.0
-----------------

Date: 2023-04-28

### [](#minor-changes-26)Minor Changes

*   Enable `basename` support in `useFetcher` ([#10336](https://github.com/remix-run/react-router/pull/10336))
    *   If you were previously working around this issue by manually prepending the `basename` then you will need to remove the manually prepended `basename` from your `fetcher` calls (`fetcher.load('/basename/route') -> fetcher.load('/route')`)
*   Updated dependencies:
    *   `@remix-run/router@1.6.0` ([Changelog](https://github.com/remix-run/react-router/blob/main/packages/router/CHANGELOG.md#160))

### [](#patch-changes-56)Patch Changes

*   When using a `RouterProvider`, `useNavigate`/`useSubmit`/`fetcher.submit` are now stable across location changes, since we can handle relative routing via the `@remix-run/router` instance and get rid of our dependence on `useLocation()` ([#10336](https://github.com/remix-run/react-router/pull/10336))
    *   When using `BrowserRouter`, these hooks remain unstable across location changes because they still rely on `useLocation()`
*   Fetchers should no longer revalidate on search params changes or routing to the same URL, and will only revalidate on `action` submissions or `router.revalidate` calls ([#10344](https://github.com/remix-run/react-router/pull/10344))
*   Fix inadvertent re-renders when using `Component` instead of `element` on a route definition ([#10287](https://github.com/remix-run/react-router/pull/10287))
*   Fail gracefully on `<Link to="//">` and other invalid URL values ([#10367](https://github.com/remix-run/react-router/pull/10367))
*   Switched from `useSyncExternalStore` to `useState` for internal `@remix-run/router` router state syncing in `<RouterProvider>`. We found some [subtle bugs](https://codesandbox.io/s/use-sync-external-store-loop-9g7b81) where router state updates got propagated _before_ other normal `useState` updates, which could lead to foot guns in `useEffect` calls. ([#10377](https://github.com/remix-run/react-router/pull/10377), [#10409](https://github.com/remix-run/react-router/pull/10409))
*   Log loader/action errors caught by the default error boundary to the console in dev for easier stack trace evaluation ([#10286](https://github.com/remix-run/react-router/pull/10286))
*   Fix bug preventing rendering of descendant `<Routes>` when `RouterProvider` errors existed ([#10374](https://github.com/remix-run/react-router/pull/10374))
*   Fix detection of `useNavigate` in the render cycle by setting the `activeRef` in a layout effect, allowing the `navigate` function to be passed to child components and called in a `useEffect` there ([#10394](https://github.com/remix-run/react-router/pull/10394))
*   Allow `useRevalidator()` to resolve a loader-driven error boundary scenario ([#10369](https://github.com/remix-run/react-router/pull/10369))
*   Enhance `LoaderFunction`/`ActionFunction` return type to prevent `undefined` from being a valid return value ([#10267](https://github.com/remix-run/react-router/pull/10267))
*   Ensure proper 404 error on `fetcher.load` call to a route without a `loader` ([#10345](https://github.com/remix-run/react-router/pull/10345))
*   Decouple `AbortController` usage between revalidating fetchers and the thing that triggered them such that the unmount/deletion of a revalidating fetcher doesn't impact the ongoing triggering navigation/revalidation ([#10271](https://github.com/remix-run/react-router/pull/10271))

**Full Changelog**: [`v6.10.0...v6.11.0`](https://github.com/remix-run/react-router/compare/react-router@6.10.0...react-router@6.11.0)

[](#v6100)v6.10.0
-----------------

Date: 2023-03-29

### [](#whats-changed-16)What's Changed

We recently published a post over on the Remix Blog titled ["Future Proofing Your Remix App"](https://remix.run/blog/future-flags) that goes through our strategy to ensure smooth upgrades for your Remix and React Router apps going forward. React Router `6.10.0` adds support for these flags (for data routers) which you can specify when you create your router:

    const router = createBrowserRouter(routes, {
      future: {
        // specify future flags here
      },
    });
    

You can also check out the docs [here](https://reactrouter.com/en/dev/guides/api-development-strategy) and [here](https://reactrouter.com/en/dev/routers/create-browser-router#future).

### [](#minor-changes-27)Minor Changes

#### [](#futurev7_normalizeformmethod)`future.v7_normalizeFormMethod`

The first future flag being introduced is `future.v7_normalizeFormMethod` which will normalize the exposed `useNavigation()/useFetcher()` `formMethod` fields as uppercase HTTP methods to align with the `fetch()` (and some Remix) behavior. ([#10207](https://github.com/remix-run/react-router/pull/10207))

*   When `future.v7_normalizeFormMethod` is unspecified or set to `false` (default v6 behavior),
    *   `useNavigation().formMethod` is lowercase
    *   `useFetcher().formMethod` is lowercase
*   When `future.v7_normalizeFormMethod === true`:
    *   `useNavigation().formMethod` is UPPERCASE
    *   `useFetcher().formMethod` is UPPERCASE

### [](#patch-changes-57)Patch Changes

*   Fix `createStaticHandler` to also check for `ErrorBoundary` on routes in addition to `errorElement` ([#10190](https://github.com/remix-run/react-router/pull/10190))
*   Fix route ID generation when using Fragments in `createRoutesFromElements` ([#10193](https://github.com/remix-run/react-router/pull/10193))
*   Provide fetcher submission to `shouldRevalidate` if the fetcher action redirects ([#10208](https://github.com/remix-run/react-router/pull/10208))
*   Properly handle `lazy()` errors during router initialization ([#10201](https://github.com/remix-run/react-router/pull/10201))
*   Remove `instanceof` check for `DeferredData` to be resilient to ESM/CJS boundaries in SSR bundling scenarios ([#10247](https://github.com/remix-run/react-router/pull/10247))
*   Update to latest `@remix-run/web-fetch@4.3.3` ([#10216](https://github.com/remix-run/react-router/pull/10216))

**Full Changelog**: [`v6.9.0...v6.10.0`](https://github.com/remix-run/react-router/compare/react-router@6.9.0...react-router@6.10.0)

[](#v690)v6.9.0
---------------

Date: 2023-03-10

### [](#whats-changed-17)What's Changed

#### [](#componenterrorboundary-route-properties)`Component`/`ErrorBoundary` route properties

React Router now supports an alternative way to define your route `element` and `errorElement` fields as React Components instead of React Elements. You can instead pass a React Component to the new `Component` and `ErrorBoundary` fields if you choose. There is no functional difference between the two, so use whichever approach you prefer 😀. You shouldn't be defining both, but if you do `Component`/`ErrorBoundary` will "win"

**Example JSON Syntax**

    // Both of these work the same:
    const elementRoutes = [{
      path: '/',
      element: <Home />,
      errorElement: <HomeError />,
    }]
    
    const componentRoutes = [{
      path: '/',
      Component: Home,
      ErrorBoundary: HomeError,
    }]
    
    function Home() { ... }
    function HomeError() { ... }
    

**Example JSX Syntax**

    // Both of these work the same:
    const elementRoutes = createRoutesFromElements(
      <Route path='/' element={<Home />} errorElement={<HomeError /> } />
    );
    
    const componentRoutes = createRoutesFromElements(
      <Route path='/' Component={Home} ErrorBoundary={HomeError} />
    );
    
    function Home() { ... }
    function HomeError() { ... }
    

#### [](#introducing-lazy-route-modules)Introducing Lazy Route Modules

In order to keep your application bundles small and support code-splitting of your routes, we've introduced a new `lazy()` route property. This is an async function that resolves the non-route-matching portions of your route definition (`loader`, `action`, `element`/`Component`, `errorElement`/`ErrorBoundary`, `shouldRevalidate`, `handle`).

Lazy routes are resolved on initial load and during the `loading` or `submitting` phase of a navigation or fetcher call. You cannot lazily define route-matching properties (`path`, `index`, `children`) since we only execute your lazy route functions after we've matched known routes.

Your `lazy` functions will typically return the result of a dynamic import.

    // In this example, we assume most folks land on the homepage so we include that
    // in our critical-path bundle, but then we lazily load modules for /a and /b so
    // they don't load until the user navigates to those routes
    let routes = createRoutesFromElements(
      <Route path="/" element={<Layout />}>
        <Route index element={<Home />} />
        <Route path="a" lazy={() => import("./a")} />
        <Route path="b" lazy={() => import("./b")} />
      </Route>
    );
    

Then in your lazy route modules, export the properties you want defined for the route:

    export async function loader({ request }) {
      let data = await fetchData(request);
      return json(data);
    }
    
    // Export a `Component` directly instead of needing to create a React Element from it
    export function Component() {
      let data = useLoaderData();
    
      return (
        <>
          <h1>You made it!</h1>
          <p>{data}</p>
        </>
      );
    }
    
    // Export an `ErrorBoundary` directly instead of needing to create a React Element from it
    export function ErrorBoundary() {
      let error = useRouteError();
      return isRouteErrorResponse(error) ? (
        <h1>
          {error.status} {error.statusText}
        </h1>
      ) : (
        <h1>{error.message || error}</h1>
      );
    }
    

An example of this in action can be found in the [`examples/lazy-loading-router-provider`](https://github.com/remix-run/react-router/tree/main/examples/lazy-loading-router-provider) directory of the repository. For more info, check out the [`lazy` docs](https://reactrouter.com/v6/route/lazy).

🙌 Huge thanks to @rossipedia for the [Initial Proposal](https://github.com/remix-run/react-router/discussions/9826) and [POC Implementation](https://github.com/remix-run/react-router/pull/9830).

### [](#minor-changes-28)Minor Changes

*   Add support for `route.Component`/`route.ErrorBoundary` properties ([#10045](https://github.com/remix-run/react-router/pull/10045))
*   Add support for `route.lazy` ([#10045](https://github.com/remix-run/react-router/pull/10045))

### [](#patch-changes-58)Patch Changes

*   Improve memoization for context providers to avoid unnecessary re-renders ([#9983](https://github.com/remix-run/react-router/pull/9983))
*   Fix `generatePath` incorrectly applying parameters in some cases ([#10078](https://github.com/remix-run/react-router/pull/10078))
*   `[react-router-dom-v5-compat]` Add missed data router API re-exports ([#10171](https://github.com/remix-run/react-router/pull/10171))

**Full Changelog**: [`v6.8.2...v6.9.0`](https://github.com/remix-run/react-router/compare/react-router@6.8.2...react-router@6.9.0)

[](#v682)v6.8.2
---------------

Date: 2023-02-27

### [](#patch-changes-59)Patch Changes

*   Treat same-origin absolute URLs in `<Link to>` as external if they are outside of the router `basename` ([#10135](https://github.com/remix-run/react-router/pull/10135))
*   Correctly perform a hard redirect for same-origin absolute URLs outside of the router `basename` ([#10076](https://github.com/remix-run/react-router/pull/10076))
*   Fix SSR of absolute `<Link to>` urls ([#10112](https://github.com/remix-run/react-router/pull/10112))
*   Properly escape HTML characters in `StaticRouterProvider` serialized hydration data ([#10068](https://github.com/remix-run/react-router/pull/10068))
*   Fix `useBlocker` to return `IDLE_BLOCKER` during SSR ([#10046](https://github.com/remix-run/react-router/pull/10046))
*   Ensure status code and headers are maintained for `defer` loader responses in `createStaticHandler`'s `query()` method ([#10077](https://github.com/remix-run/react-router/pull/10077))
*   Change `invariant` to an `UNSAFE_invariant` export since it's only intended for internal use ([#10066](https://github.com/remix-run/react-router/pull/10066))

**Full Changelog**: [`v6.8.1...v6.8.2`](https://github.com/remix-run/react-router/compare/react-router@6.8.1...react-router@6.8.2)

[](#v681)v6.8.1
---------------

Date: 2023-02-06

### [](#patch-changes-60)Patch Changes

*   Remove inaccurate console warning for POP navigations and update active blocker logic ([#10030](https://github.com/remix-run/react-router/pull/10030))
*   Only check for differing origin on absolute URL redirects ([#10033](https://github.com/remix-run/react-router/pull/10033))
*   Improved absolute url detection in `Link` component (now also supports `mailto:` urls) ([#9994](https://github.com/remix-run/react-router/pull/9994))
*   Fix partial object (search or hash only) pathnames losing current path value ([#10029](https://github.com/remix-run/react-router/pull/10029))

**Full Changelog**: [`v6.8.0...v6.8.1`](https://github.com/remix-run/react-router/compare/react-router@6.8.0...react-router@6.8.1)

[](#v680)v6.8.0
---------------

Date: 2023-01-26

### [](#minor-changes-29)Minor Changes

Support absolute URLs in `<Link to>`. If the URL is for the current origin, it will still do a client-side navigation. If the URL is for a different origin then it will do a fresh document request for the new origin. ([#9900](https://github.com/remix-run/react-router/pull/9900))

    <Link to="https://neworigin.com/some/path">    {/* Document request */}
    <Link to="//neworigin.com/some/path">          {/* Document request */}
    <Link to="https://www.currentorigin.com/path"> {/* Client-side navigation */}
    

### [](#patch-changes-61)Patch Changes

*   Fixes 2 separate issues for revalidating fetcher `shouldRevalidate` calls ([#9948](https://github.com/remix-run/react-router/pull/9948))
    *   The `shouldRevalidate` function was only being called for _explicit_ revalidation scenarios (after a mutation, manual `useRevalidator` call, or an `X-Remix-Revalidate` header used for cookie setting in Remix). It was not properly being called on _implicit_ revalidation scenarios that also apply to navigation `loader` revalidation, such as a change in search params or clicking a link for the page we're already on. It's now correctly called in those additional scenarios.
    *   The parameters being passed were incorrect and inconsistent with one another since the `current*`/`next*` parameters reflected the static `fetcher.load` URL (and thus were identical). Instead, they should have reflected the navigation that triggered the revalidation (as the `form*` parameters did). These parameters now correctly reflect the triggering navigation.
*   Fix bug with search params removal via `useSearchParams` ([#9969](https://github.com/remix-run/react-router/pull/9969))
*   Respect `preventScrollReset` on `<fetcher.Form>` ([#9963](https://github.com/remix-run/react-router/pull/9963))
*   Fix navigation for hash routers on manual URL changes ([#9980](https://github.com/remix-run/react-router/pull/9980))
*   Use `pagehide` instead of `beforeunload` for `<ScrollRestoration>`. This has better cross-browser support, specifically on Mobile Safari. ([#9945](https://github.com/remix-run/react-router/pull/9945))
*   Do not short circuit on hash change only mutation submissions ([#9944](https://github.com/remix-run/react-router/pull/9944))
*   Remove `instanceof` check from `isRouteErrorResponse` to avoid bundling issues on the server ([#9930](https://github.com/remix-run/react-router/pull/9930))
*   Detect when a `defer` call only contains critical data and remove the `AbortController` ([#9965](https://github.com/remix-run/react-router/pull/9965))
*   Send the name as the value when url-encoding `File` `FormData` entries ([#9867](https://github.com/remix-run/react-router/pull/9867))
*   `react-router-dom-v5-compat` - Fix SSR `useLayoutEffect` `console.error` when using `CompatRouter` ([#9820](https://github.com/remix-run/react-router/pull/9820))

**Full Changelog**: [`v6.7.0...v6.8.0`](https://github.com/remix-run/react-router/compare/react-router@6.7.0...react-router@6.8.0)

[](#v670)v6.7.0
---------------

Date: 2023-01-18

### [](#minor-changes-30)Minor Changes

*   Add `unstable_useBlocker`/`unstable_usePrompt` hooks for blocking navigations within the app's location origin ([#9709](https://github.com/remix-run/react-router/pull/9709), [#9932](https://github.com/remix-run/react-router/pull/9932))
*   Add `preventScrollReset` prop to `<Form>` ([#9886](https://github.com/remix-run/react-router/pull/9886))

### [](#patch-changes-62)Patch Changes

*   Added pass-through event listener options argument to `useBeforeUnload` ([#9709](https://github.com/remix-run/react-router/pull/9709))
*   Fix `generatePath` when optional params are present ([#9764](https://github.com/remix-run/react-router/pull/9764))
*   Update `<Await>` to accept `ReactNode` as children function return result ([#9896](https://github.com/remix-run/react-router/pull/9896))
*   Improved absolute redirect url detection in actions/loaders ([#9829](https://github.com/remix-run/react-router/pull/9829))
*   Fix URL creation with memory histories ([#9814](https://github.com/remix-run/react-router/pull/9814))
*   Fix scroll reset if a submission redirects ([#9886](https://github.com/remix-run/react-router/pull/9886))
*   Fix 404 bug with same-origin absolute redirects ([#9913](https://github.com/remix-run/react-router/pull/9913))
*   Streamline `jsdom` bug workaround in tests ([#9824](https://github.com/remix-run/react-router/pull/9824))

**Full Changelog**: [`v6.6.2...v6.7.0`](https://github.com/remix-run/react-router/compare/react-router@6.6.2...react-router@6.7.0)

[](#v662)v6.6.2
---------------

Date: 2023-01-09

### [](#patch-changes-63)Patch Changes

*   Ensure `useId` consistency during SSR ([#9805](https://github.com/remix-run/react-router/pull/9805))

**Full Changelog**: [`v6.6.1...v6.6.2`](https://github.com/remix-run/react-router/compare/react-router@6.6.1...react-router@6.6.2)

[](#v661)v6.6.1
---------------

Date: 2022-12-23

### [](#patch-changes-64)Patch Changes

*   Include submission info in `shouldRevalidate` on action redirects ([#9777](https://github.com/remix-run/react-router/pull/9777), [#9782](https://github.com/remix-run/react-router/pull/9782))
*   Reset `actionData` on action redirect to current location ([#9772](https://github.com/remix-run/react-router/pull/9772))

**Full Changelog**: [`v6.6.0...v6.6.1`](https://github.com/remix-run/react-router/compare/react-router@6.6.0...react-router@6.6.1)

[](#v660)v6.6.0
---------------

Date: 2022-12-21

### [](#whats-changed-18)What's Changed

This minor release is primarily to stabilize our SSR APIs for Data Routers now that we've wired up the new `RouterProvider` in Remix as part of the [React Router-ing Remix](https://remix.run/blog/react-routering-remix) work.

### [](#minor-changes-31)Minor Changes

*   Remove `unstable_` prefix from `createStaticHandler`/`createStaticRouter`/`StaticRouterProvider` ([#9738](https://github.com/remix-run/react-router/pull/9738))
*   Add `useBeforeUnload()` hook ([#9664](https://github.com/remix-run/react-router/pull/9664))

### [](#patch-changes-65)Patch Changes

*   Support uppercase `<Form method>` and `useSubmit` method values ([#9664](https://github.com/remix-run/react-router/pull/9664))
*   Fix `<button formmethod>` form submission overriddes ([#9664](https://github.com/remix-run/react-router/pull/9664))
*   Fix explicit `replace` on submissions and `PUSH` on submission to new paths ([#9734](https://github.com/remix-run/react-router/pull/9734))
*   Prevent `useLoaderData` usage in `errorElement` ([#9735](https://github.com/remix-run/react-router/pull/9735))
*   Proper hydration of `Error` objects from `StaticRouterProvider` ([#9664](https://github.com/remix-run/react-router/pull/9664))
*   Skip initial scroll restoration for SSR apps with `hydrationData` ([#9664](https://github.com/remix-run/react-router/pull/9664))
*   Fix a few bugs where loader/action data wasn't properly cleared on errors ([#9735](https://github.com/remix-run/react-router/pull/9735))

**Full Changelog**: [`v6.5.0...v6.6.0`](https://github.com/remix-run/react-router/compare/react-router@6.5.0...react-router@6.6.0)

[](#v650)v6.5.0
---------------

Date: 2022-12-16

### [](#whats-changed-19)What's Changed

This release introduces support for [Optional Route Segments](https://github.com/remix-run/react-router/issues/9546). Now, adding a `?` to the end of any path segment will make that entire segment optional. This works for both static segments and dynamic parameters.

**Optional Params Examples**

*   `<Route path=":lang?/about>` will match:
    *   `/:lang/about`
    *   `/about`
*   `<Route path="/multistep/:widget1?/widget2?/widget3?">` will match:
    *   `/multistep`
    *   `/multistep/:widget1`
    *   `/multistep/:widget1/:widget2`
    *   `/multistep/:widget1/:widget2/:widget3`

**Optional Static Segment Example**

*   `<Route path="/home?">` will match:
    *   `/`
    *   `/home`
*   `<Route path="/fr?/about">` will match:
    *   `/about`
    *   `/fr/about`

### [](#minor-changes-32)Minor Changes

*   Allows optional routes and optional static segments ([#9650](https://github.com/remix-run/react-router/pull/9650))

### [](#patch-changes-66)Patch Changes

*   Stop incorrectly matching on partial named parameters, i.e. `<Route path="prefix-:param">`, to align with how splat parameters work. If you were previously relying on this behavior then it's recommended to extract the static portion of the path at the `useParams` call site: ([#9506](https://github.com/remix-run/react-router/pull/9506))

    // Old behavior at URL /prefix-123
    <Route path="prefix-:id" element={<Comp /> }>
    
    function Comp() {
      let params = useParams(); // { id: '123' }
      let id = params.id; // "123"
      ...
    }
    
    // New behavior at URL /prefix-123
    <Route path=":id" element={<Comp /> }>
    
    function Comp() {
      let params = useParams(); // { id: 'prefix-123' }
      let id = params.id.replace(/^prefix-/, ''); // "123"
      ...
    }
    

*   Persist `headers` on `loader` `request`'s after SSR document `action` request ([#9721](https://github.com/remix-run/react-router/pull/9721))
*   Fix requests sent to revalidating loaders so they reflect a GET request ([#9660](https://github.com/remix-run/react-router/pull/9660))
*   Fix issue with deeply nested optional segments ([#9727](https://github.com/remix-run/react-router/pull/9727))
*   GET forms now expose a submission on the loading navigation ([#9695](https://github.com/remix-run/react-router/pull/9695))
*   Fix error boundary tracking for multiple errors bubbling to the same boundary ([#9702](https://github.com/remix-run/react-router/pull/9702))

**Full Changelog**: [`v6.4.5...v6.5.0`](https://github.com/remix-run/react-router/compare/react-router@6.4.5...react-router@6.5.0)

[](#v645)v6.4.5
---------------

Date: 2022-12-07

### [](#patch-changes-67)Patch Changes

*   Fix requests sent to revalidating loaders so they reflect a `GET` request ([#9680](https://github.com/remix-run/react-router/pull/9680))
*   Remove `instanceof Response` checks in favor of `isResponse` ([#9690](https://github.com/remix-run/react-router/pull/9690))
*   Fix `URL` creation in Cloudflare Pages or other non-browser-environments ([#9682](https://github.com/remix-run/react-router/pull/9682), [#9689](https://github.com/remix-run/react-router/pull/9689))
*   Add `requestContext` support to static handler `query`/`queryRoute` ([#9696](https://github.com/remix-run/react-router/pull/9696))
    *   Note that the unstable API of `queryRoute(path, routeId)` has been changed to `queryRoute(path, { routeId, requestContext })`

**Full Changelog**: [`v6.4.4...v6.4.5`](https://github.com/remix-run/react-router/compare/react-router@6.4.4...react-router@6.4.5)

[](#v644)v6.4.4
---------------

Date: 2022-11-30

### [](#patch-changes-68)Patch Changes

*   Throw an error if an `action`/`loader` function returns `undefined` as revalidations need to know whether the loader has previously been executed. `undefined` also causes issues during SSR stringification for hydration. You should always ensure your `loader`/`action` returns a value, and you may return `null` if you don't wish to return anything. ([#9511](https://github.com/remix-run/react-router/pull/9511))
*   Properly handle redirects to external domains ([#9590](https://github.com/remix-run/react-router/pull/9590), [#9654](https://github.com/remix-run/react-router/pull/9654))
*   Preserve the HTTP method on 307/308 redirects ([#9597](https://github.com/remix-run/react-router/pull/9597))
*   Support `basename` in static data routers ([#9591](https://github.com/remix-run/react-router/pull/9591))
*   Enhanced `ErrorResponse` bodies to contain more descriptive text in internal 403/404/405 scenarios
*   Fix issues with encoded characters in `NavLink` and descendant `<Routes>` ([#9589](https://github.com/remix-run/react-router/pull/9589), [#9647](https://github.com/remix-run/react-router/pull/9647))
*   Properly serialize/deserialize `ErrorResponse` instances when using built-in hydration ([#9593](https://github.com/remix-run/react-router/pull/9593))
*   Support `basename` in static data routers ([#9591](https://github.com/remix-run/react-router/pull/9591))
*   Updated dependencies:
    *   `@remix-run/router@1.0.4`
    *   `react-router@6.4.4`

**Full Changelog**: [`v6.4.3...v6.4.4`](https://github.com/remix-run/react-router/compare/react-router-dom@6.4.3...react-router-dom@6.4.4)

[](#v643)v6.4.3
---------------

Date: 2022-11-01

### [](#patch-changes-69)Patch Changes

*   Generate correct `<a href>` values when using `createHashRouter` ([#9409](https://github.com/remix-run/react-router/pull/9409))
*   Better handle encoding/matching with special characters in URLs and route paths ([#9477](https://github.com/remix-run/react-router/pull/9477), [#9496](https://github.com/remix-run/react-router/pull/9496))
*   Generate correct `formAction` pathnames when an `index` route also has a `path` ([#9486](https://github.com/remix-run/react-router/pull/9486))
*   Respect `relative=path` prop on `NavLink` ([#9453](https://github.com/remix-run/react-router/pull/9453))
*   Fix `NavLink` behavior for root urls ([#9497](https://github.com/remix-run/react-router/pull/9497))
*   `useRoutes` should be able to return `null` when passing `locationArg` ([#9485](https://github.com/remix-run/react-router/pull/9485))
*   Fix `initialEntries` type in `createMemoryRouter` ([#9498](https://github.com/remix-run/react-router/pull/9498))
*   Support `basename` and relative routing in `loader`/`action` redirects ([#9447](https://github.com/remix-run/react-router/pull/9447))
*   Ignore pathless layout routes when looking for proper submission `action` function ([#9455](https://github.com/remix-run/react-router/pull/9455))
*   Add UMD build for `@remix-run/router` ([#9446](https://github.com/remix-run/react-router/pull/9446))
*   Fix `createURL` in local file execution in Firefox ([#9464](https://github.com/remix-run/react-router/pull/9464))

**Full Changelog**: [`v6.4.2...v6.4.3`](https://github.com/remix-run/react-router/compare/react-router@6.4.2...react-router@6.4.3)

[](#v642)v6.4.2
---------------

Date: 2022-10-06

### [](#patch-changes-70)Patch Changes

*   Respect `basename` in `useFormAction` ([#9352](https://github.com/remix-run/react-router/pull/9352))
*   Fix `IndexRouteObject` and `NonIndexRouteObject` types to make `hasErrorElement` optional ([#9394](https://github.com/remix-run/react-router/pull/9394))
*   Enhance console error messages for invalid usage of data router hooks ([#9311](https://github.com/remix-run/react-router/pull/9311))
*   If an index route has children, it will result in a runtime error. We have strengthened our `RouteObject`/`RouteProps` types to surface the error in TypeScript. ([#9366](https://github.com/remix-run/react-router/pull/9366))

**Full Changelog**: [`v6.4.1...v6.4.2`](https://github.com/remix-run/react-router/compare/react-router@6.4.1...react-router@6.4.2)

[](#v641)v6.4.1
---------------

Date: 2022-09-22

### [](#patch-changes-71)Patch Changes

*   Preserve state from `initialEntries` ([#9288](https://github.com/remix-run/react-router/pull/9288))
*   Preserve `?index` for fetcher get submissions to index routes ([#9312](https://github.com/remix-run/react-router/pull/9312))

**Full Changelog**: [`v6.4.0...v6.4.1`](https://github.com/remix-run/react-router/compare/react-router@6.4.0...react-router@6.4.1)

[](#v640)v6.4.0
---------------

Date: 2022-09-13

### [](#whats-changed-20)What's Changed

#### [](#remix-data-apis)Remix Data APIs

Whoa this is a big one! `6.4.0` brings all the data loading and mutation APIs over from Remix. Here's a quick high level overview, but it's recommended you go check out the [docs](https://reactrouter.com/), especially the [feature overview](https://reactrouter.com/en/6.4.0/start/overview) and the [tutorial](https://reactrouter.com/en/6.4.0/start/tutorial).

**New `react-router` APIs**

*   Create your router with `createMemoryRouter`
*   Render your router with `<RouterProvider>`
*   Load data with a Route `loader` and mutate with a Route `action`
*   Handle errors with Route `errorElement`
*   Defer non-critical data with `defer` and `Await`

**New `react-router-dom` APIs**

*   Create your router with `createBrowserRouter`/`createHashRouter`
*   Submit data with the new `<Form>` component
*   Perform in-page data loads and mutations with `useFetcher()`
*   Defer non-critical data with `defer` and `Await`
*   Manage scroll position with `<ScrollRestoration>`
*   Perform path-relative navigations with `<Link relative="path">` ([#9160](https://github.com/remix-run/react-router/pull/9160))

### [](#patch-changes-72)Patch Changes

*   Path resolution is now trailing slash agnostic ([#8861](https://github.com/remix-run/react-router/pull/8861))
*   `useLocation` returns the scoped location inside a `<Routes location>` component ([#9094](https://github.com/remix-run/react-router/pull/9094))
*   Respect the `<Link replace>` prop if it is defined ([#8779](https://github.com/remix-run/react-router/pull/8779))

**Full Changelog**: [`v6.3.0...v6.4.0`](https://github.com/remix-run/react-router/compare/v6.3.0...react-router%406.4.0)

[](#v630)v6.3.0
---------------

Date: 2022-03-31

### [](#minor-changes-33)Minor Changes

*   Added the v5 to v6 backwards compatibility package 💜 ([#8752](https://github.com/remix-run/react-router/pull/8752)). The official guide can be found [in this discussion](https://github.com/remix-run/react-router/discussions/8753)

**Full Changelog**: [`v6.2.2...v6.3.0`](https://github.com/remix-run/react-router/compare/v6.2.2...v6.3.0)

[](#v622)v6.2.2
---------------

Date: 2022-02-28

### [](#patch-changes-73)Patch Changes

*   Fixed nested splat routes that begin with special URL-safe characters ([#8563](https://github.com/remix-run/react-router/pull/8563))
*   Fixed a bug where index routes were missing route context in some cases ([#8497](https://github.com/remix-run/react-router/pull/8497))

**Full Changelog**: [`v6.2.1...v6.2.2`](https://github.com/remix-run/react-router/compare/v6.2.1...v6.2.2)

[](#v621)v6.2.1
---------------

Date: 2021-12-17

### [](#patch-changes-74)Patch Changes

*   This release updates the internal `history` dependency to `5.2.0`.

**Full Changelog**: [`v6.2.0...v6.2.1`](https://github.com/remix-run/react-router/compare/v6.2.0...v6.2.1)

[](#v620)v6.2.0
---------------

Date: 2021-12-17

### [](#minor-changes-34)Minor Changes

*   We now use statically analyzable CJS exports. This enables named imports in Node ESM scripts ([See the commit](https://github.com/remix-run/react-router/commit/29c7fc8b5f853b0b06ecd0f5682a9bbe6eca0715)).

### [](#patch-changes-75)Patch Changes

*   Fixed the `RouteProps` `element` type, which should be a `ReactNode` ([#8473](https://github.com/remix-run/react-router/pull/8473))
*   Fixed a bug with `useOutlet` for top-level routes ([#8483](https://github.com/remix-run/react-router/pull/8483))

**Full Changelog**: [`v6.1.1...v6.2.0`](https://github.com/remix-run/react-router/compare/v6.1.1...v6.2.0)

[](#v611)v6.1.1
---------------

Date: 2021-12-11

### [](#patch-changes-76)Patch Changes

*   In v6.1.0 we inadvertently shipped a new, undocumented API that will likely introduce bugs ([#7586](https://github.com/remix-run/react-router/pull/7586)). We have flagged `HistoryRouter` as `unstable_HistoryRouter`, as this API will likely need to change before a new major release.

**Full Changelog**: [`v6.1.0...v6.1.1`](https://github.com/remix-run/react-router/compare/v6.1.0...v6.1.1)

[](#v610)v6.1.0
---------------

Date: 2021-12-10

### [](#minor-changes-35)Minor Changes

*   `<Outlet>` can now receive a `context` prop. This value is passed to child routes and is accessible via the new `useOutletContext` hook. See [the API docs](https://reactrouter.com/docs/en/v6/api#useoutletcontext) for details. ([#8461](https://github.com/remix-run/react-router/pull/8461))
*   `<NavLink>` can now receive a child function for access to its props. ([#8164](https://github.com/remix-run/react-router/pull/8164))
*   Improved TypeScript signature for `useMatch` and `matchPath`. For example, when you call `useMatch("foo/:bar/:baz")`, the path is parsed and the return type will be `PathMatch<"bar" | "baz">`. ([#8030](https://github.com/remix-run/react-router/pull/8030))

### [](#patch-changes-77)Patch Changes

*   Fixed a bug that broke support for base64 encoded IDs on nested routes ([#8291](https://github.com/remix-run/react-router/pull/8291))
*   A few error message improvements ([#8202](https://github.com/remix-run/react-router/pull/8202))

**Full Changelog**: [`v6.0.2...v6.1.0`](https://github.com/remix-run/react-router/compare/v6.0.2...v6.1.0)

[](#v602)v6.0.2
---------------

Date: 2021-11-09

### [](#patch-changes-78)Patch Changes

*   Added the `reloadDocument` prop to `<Link>`. This allows `<Link>` to function like a normal anchor tag by reloading the document after navigation while maintaining the relative `to` resolution ([#8283](https://github.com/remix-run/react-router/pull/8283))

**Full Changelog**: [`v6.0.1...v6.0.2`](https://github.com/remix-run/react-router/compare/v6.0.1...v6.0.2)

[](#v601)v6.0.1
---------------

Date: 2021-11-05

### [](#patch-changes-79)Patch Changes

*   Add a default `<StaticRouter location>` value ([#8243](https://github.com/remix-run/react-router/pull/8243))
*   Add invariant for using `<Route>` inside `<Routes>` to help people make the change ([#8238](https://github.com/remix-run/react-router/pull/8238))

**Full Changelog**: [`v6.0.0...v6.0.1`](https://github.com/remix-run/react-router/compare/v6.0.0...v6.0.1)

[](#v600)v6.0.0
---------------

Date: 2021-11-03

React Router v6 is here!

Please go read [our blog post for more information on all the great stuff in v6](https://remix.run/blog/react-router-v6) including [notes about how to upgrade from React Router v5](https://remix.run/blog/react-router-v6#upgrading-to-react-router-v6) and Reach Router.

[](#picking-a-mode)Picking a Mode
=================================

React Router is a multi-strategy router for React. There are three primary ways, or "modes", to use it in your app. Across the docs you'll see these icons indicating which mode the content is relevant to:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

The features available in each mode are additive, so moving from Declarative to Data to Framework simply adds more features at the cost of architectural control. So pick your mode based on how much control or how much help you want from React Router.

The mode depends on which "top level" router API you're using:

**Declarative**

Declarative mode enables basic routing features like matching URLs to components, navigating around the app, and providing active states with APIs like `<Link>`, `useNavigate`, and `useLocation`.

    import { BrowserRouter } from "react-router";
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    

**Data**

By moving route configuration outside of React rendering, Data Mode adds data loading, actions, pending states and more with APIs like `loader`, `action`, and `useFetcher`.

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    
    let router = createBrowserRouter([
      {
        path: "/",
        Component: Root,
        loader: loadRootData,
      },
    ]);
    
    ReactDOM.createRoot(root).render(
      <RouterProvider router={router} />
    );
    

**Framework**

Framework Mode wraps Data Mode with a Vite plugin to add the full React Router experience with:

*   typesafe `href`
*   typesafe Route Module API
*   intelligent code splitting
*   SPA, SSR, and static rendering strategies
*   and more

    import { index, route } from "@react-router/dev/routes";
    
    export default [
      index("./home.tsx"),
      route("products/:pid", "./product.tsx"),
    ];
    

You'll then have access to the Route Module API with typesafe params, loaderData, code splitting, SPA/SSR/SSG strategies, and more.

    import { Route } from "+./types/product.tsx";
    
    export async function loader({ params }: Route.LoaderArgs) {
      let product = await getProduct(params.pid);
      return { product };
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      return <div>{loaderData.product.name}</div>;
    }
    

[](#decision-advice)Decision Advice
-----------------------------------

Every mode supports any architecture and deployment target, so the question isn't really about if you want SSR, SPA, etc. It's about how much you want to do yourself.

**Use Framework Mode if you:**

*   are too new to have an opinion
*   are considering Next.js, Solid Start, SvelteKit, Astro, TanStack Start, etc. and want to compare
*   just want to build something with React
*   might want to server render, might not
*   are coming from Remix (React Router v7 is the "next version" after Remix v2)
*   are migrating from Next.js

[→ Get Started with Framework Mode](./framework/installation).

**Use Data Mode if you:**

*   want data features but also want to have control over bundling, data, and server abstractions
*   started a data router in v6.4 and are happy with it

[→ Get Started with Data Mode](./data/custom).

**Use Declarative Mode if you:**

*   want to use React Router as simply as possible
*   are coming from v6 and are happy with the `<BrowserRouter>`
*   have a data layer that either skips pending states (like local first, background data replication/sync) or has its own abstractions for them
*   are coming from Create React App (you may want to consider framework mode though)

[→ Get Started with Declarative Mode](./declarative/installation).

[](#api--mode-availability-table)API + Mode Availability Table
--------------------------------------------------------------

This is mostly for the LLMs, but knock yourself out:

API

Framework

Data

Declarative

Await

✅

✅

Form

✅

✅

Link

✅

✅

✅

`<Link discover>`

✅

`<Link prefetch>`

✅

`<Link preventScrollReset>`

✅

✅

Links

✅

Meta

✅

NavLink

✅

✅

✅

`<NavLink discover>`

✅

`<NavLink prefetch>`

✅

`<NavLink preventScrollReset>`

✅

✅

NavLink `isPending`

✅

✅

Navigate

✅

✅

✅

Outlet

✅

✅

✅

PrefetchPageLinks

✅

Route

✅

✅

✅

Routes

✅

✅

✅

Scripts

✅

ScrollRestoration

✅

✅

ServerRouter

✅

usePrompt

✅

✅

✅

useActionData

✅

✅

useAsyncError

✅

✅

useAsyncValue

✅

✅

useBeforeUnload

✅

✅

✅

useBlocker

✅

✅

useFetcher

✅

✅

useFetchers

✅

✅

useFormAction

✅

✅

useHref

✅

✅

✅

useInRouterContext

✅

✅

✅

useLinkClickHandler

✅

✅

✅

useLoaderData

✅

✅

useLocation

✅

✅

✅

useMatch

✅

✅

✅

useMatches

✅

✅

useNavigate

✅

✅

✅

useNavigation

✅

✅

useNavigationType

✅

✅

✅

useOutlet

✅

✅

✅

useOutletContext

✅

✅

✅

useParams

✅

✅

✅

useResolvedPath

✅

✅

✅

useRevalidator

✅

✅

useRouteError

✅

✅

useRouteLoaderData

✅

✅

useRoutes

✅

✅

✅

useSearchParams

✅

✅

✅

useSubmit

✅

✅

useViewTransitionState

✅

✅

isCookieFunction

✅

✅

isSessionFunction

✅

✅

createCookie

✅

✅

createCookieSessionStorage

✅

✅

createMemorySessionStorage

✅

✅

createPath

✅

✅

✅

createRoutesStub

✅

✅

createSearchParams

✅

✅

✅

data

✅

✅

generatePath

✅

✅

✅

href

✅

isCookie

✅

✅

isRouteErrorResponse

✅

✅

isSession

✅

✅

matchPath

✅

✅

✅

matchRoutes

✅

✅

✅

parsePath

✅

✅

✅

redirect

✅

✅

redirectDocument

✅

✅

renderMatches

✅

✅

✅

replace

✅

✅

resolvePath

✅

✅

✅

[](#installation)Installation
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Most projects start with a template. Let's use a basic template maintained by React Router:

    npx create-react-router@latest my-react-router-app
    

Now change into the new directory and start the app

    cd my-react-router-app
    npm i
    npm run dev
    

You can now open your browser to `http://localhost:5173`

You can [view the template on GitHub](https://github.com/remix-run/react-router-templates/tree/main/default) to see how to manually set up your project.

We also have a number of [ready to deploy templates](https://github.com/remix-run/react-router-templates) available for you to get started with:

    npx create-react-router@latest --template remix-run/react-router-templates/<template-name>
    

* * *

Next: [Routing](./routing)

[](#routing)Routing
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#configuring-routes)Configuring Routes
-----------------------------------------

Routes are configured in `app/routes.ts`. Each route has two required parts: a URL pattern to match the URL, and a file path to the route module that defines its behavior.

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("some/path", "./some/file.tsx"),
      // pattern ^           ^ module file
    ] satisfies RouteConfig;
    

Here is a larger sample route config:

    import {
      type RouteConfig,
      route,
      index,
      layout,
      prefix,
    } from "@react-router/dev/routes";
    
    export default [
      index("./home.tsx"),
      route("about", "./about.tsx"),
    
      layout("./auth/layout.tsx", [
        route("login", "./auth/login.tsx"),
        route("register", "./auth/register.tsx"),
      ]),
    
      ...prefix("concerts", [
        index("./concerts/home.tsx"),
        route(":city", "./concerts/city.tsx"),
        route("trending", "./concerts/trending.tsx"),
      ]),
    ] satisfies RouteConfig;
    

If you prefer to define your routes via file naming conventions rather than configuration, the `@react-router/fs-routes` package provides a [file system routing convention](../../how-to/file-route-conventions). You can even combine different routing conventions if you like:

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default [
      route("/", "./home.tsx"),
    
      ...(await flatRoutes()),
    ] satisfies RouteConfig;
    

[](#route-modules)Route Modules
-------------------------------

The files referenced in `routes.ts` define each route's behavior:

    route("teams/:teamId", "./team.tsx"),
    //           route module ^^^^^^^^
    

Here's a sample route module:

    // provides type safety/inference
    import type { Route } from "./+types/team";
    
    // provides `loaderData` to the component
    export async function loader({ params }: Route.LoaderArgs) {
      let team = await fetchTeam(params.teamId);
      return { name: team.name };
    }
    
    // renders after the loader is done
    export default function Component({
      loaderData,
    }: Route.ComponentProps) {
      return <h1>{loaderData.name}</h1>;
    }
    

Route modules have more features like actions, headers, and error boundaries, but they will be covered in the next guide: [Route Modules](./route-module)

[](#nested-routes)Nested Routes
-------------------------------

Routes can be nested inside parent routes.

    import {
      type RouteConfig,
      route,
      index,
    } from "@react-router/dev/routes";
    
    export default [
      // parent route
      route("dashboard", "./dashboard.tsx", [
        // child routes
        index("./home.tsx"),
        route("settings", "./settings.tsx"),
      ]),
    ] satisfies RouteConfig;
    

The path of the parent is automatically included in the child, so this config creates both `"/dashboard"` and `"/dashboard/settings"` URLs.

Child routes are rendered through the `<Outlet/>` in the parent route.

    import { Outlet } from "react-router";
    
    export default function Dashboard() {
      return (
        <div>
          <h1>Dashboard</h1>
          {/* will either be home.tsx or settings.tsx */}
          <Outlet />
        </div>
      );
    }
    

[](#root-route)Root Route
-------------------------

Every route in `routes.ts` is nested inside the special `app/root.tsx` module.

[](#layout-routes)Layout Routes
-------------------------------

Using `layout`, layout routes create new nesting for their children, but they don't add any segments to the URL. It's like the root route but they can be added at any level.

    import {
      type RouteConfig,
      route,
      layout,
      index,
      prefix,
    } from "@react-router/dev/routes";
    
    export default [
      layout("./marketing/layout.tsx", [
        index("./marketing/home.tsx"),
        route("contact", "./marketing/contact.tsx"),
      ]),
      ...prefix("projects", [
        index("./projects/home.tsx"),
        layout("./projects/project-layout.tsx", [
          route(":pid", "./projects/project.tsx"),
          route(":pid/edit", "./projects/edit-project.tsx"),
        ]),
      ]),
    ] satisfies RouteConfig;
    

Note that:

*   `home.tsx` and `contact.tsx` will be rendered into the `marketing/layout.tsx` outlet without creating any new URL paths
*   `project.tsx` and `edit-project.tsx` will be rendered into the `projects/project-layout.tsx` outlet at `/projects/:pid` and `/projects/:pid/edit` while `projects/home.tsx` will not.

[](#index-routes)Index Routes
-----------------------------

    index(componentFile),
    

Index routes render into their parent's [Outlet](https://api.reactrouter.com/v7/functions/react_router.Outlet.html) at their parent's URL (like a default child route).

    import {
      type RouteConfig,
      route,
      index,
    } from "@react-router/dev/routes";
    
    export default [
      // renders into the root.tsx Outlet at /
      index("./home.tsx"),
      route("dashboard", "./dashboard.tsx", [
        // renders into the dashboard.tsx Outlet at /dashboard
        index("./dashboard-home.tsx"),
        route("settings", "./dashboard-settings.tsx"),
      ]),
    ] satisfies RouteConfig;
    

Note that index routes can't have children.

[](#route-prefixes)Route Prefixes
---------------------------------

Using `prefix`, you can add a path prefix to a set of routes without needing to introduce a parent route file.

    import {
      type RouteConfig,
      route,
      layout,
      index,
      prefix,
    } from "@react-router/dev/routes";
    
    export default [
      layout("./marketing/layout.tsx", [
        index("./marketing/home.tsx"),
        route("contact", "./marketing/contact.tsx"),
      ]),
      ...prefix("projects", [
        index("./projects/home.tsx"),
        layout("./projects/project-layout.tsx", [
          route(":pid", "./projects/project.tsx"),
          route(":pid/edit", "./projects/edit-project.tsx"),
        ]),
      ]),
    ] satisfies RouteConfig;
    

[](#dynamic-segments)Dynamic Segments
-------------------------------------

If a path segment starts with `:` then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as `params` to other router APIs.

    route("teams/:teamId", "./team.tsx"),
    

    import type { Route } from "./+types/team";
    
    export async function loader({ params }: Route.LoaderArgs) {
      //                           ^? { teamId: string }
    }
    
    export default function Component({
      params,
    }: Route.ComponentProps) {
      params.teamId;
      //        ^ string
    }
    

You can have multiple dynamic segments in one route path:

    route("c/:categoryId/p/:productId", "./product.tsx"),
    

    import type { Route } from "./+types/product";
    
    async function loader({ params }: LoaderArgs) {
      //                    ^? { categoryId: string; productId: string }
    }
    

[](#optional-segments)Optional Segments
---------------------------------------

You can make a route segment optional by adding a `?` to the end of the segment.

    route(":lang?/categories", "./categories.tsx"),
    

You can have optional static segments, too:

    route("users/:userId/edit?", "./user.tsx");
    

[](#splats)Splats
-----------------

Also known as "catchall" and "star" segments. If a route path pattern ends with `/*` then it will match any characters following the `/`, including other `/` characters.

    route("files/*", "./files.tsx"),
    

    export async function loader({ params }: Route.LoaderArgs) {
      // params["*"] will contain the remaining URL after files/
    }
    

You can destructure the `*`, you just have to assign it a new name. A common name is `splat`:

    const { "*": splat } = params;
    

[](#component-routes)Component Routes
-------------------------------------

You can also use components that match the URL to elements anywhere in the component tree:

    import { Routes, Route } from "react-router";
    
    function Wizard() {
      return (
        <div>
          <h1>Some Wizard with Steps</h1>
          <Routes>
            <Route index element={<StepOne />} />
            <Route path="step-2" element={<StepTwo />} />
            <Route path="step-3" element={<StepThree />} />
          </Routes>
        </div>
      );
    }
    

Note that these routes do not participate in data loading, actions, code splitting, or any other route module features, so their use cases are more limited than those of the route module.

* * *

Next: [Route Module](./route-module)

[](#route-module)Route Module
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

The files referenced in `routes.ts` are called Route Modules.

    route("teams/:teamId", "./team.tsx"),
    //           route module ^^^^^^^^
    

Route modules are the foundation of React Router's framework features, they define:

*   automatic code-splitting
*   data loading
*   actions
*   revalidation
*   error boundaries
*   and more

This guide is a quick overview of every route module feature. The rest of the getting started guides will cover these features in more detail.

[](#component-default)Component (`default`)
-------------------------------------------

The `default` export in a route module defines the component that will render when the route matches.

    export default function MyRouteComponent() {
      return (
        <div>
          <h1>Look ma!</h1>
          <p>
            I'm still using React Router after like 10 years.
          </p>
        </div>
      );
    }
    

### [](#props-passed-to-the-component)Props passed to the Component

When the component is rendered, it is provided the props defined in `Route.ComponentProps` that React Router will automatically generate for you. These props include:

1.  `loaderData`: The data returned from the `loader` function in this route module
2.  `actionData`: The data returned from the `action` function in this route module
3.  `params`: An object containing the route parameters (if any).
4.  `matches`: An array of all the matches in the current route tree.

You can use these props in place of hooks like `useLoaderData` or `useParams`. This may be preferrable because they will be automatically typed correctly for the route.

### [](#using-props)Using props

    import type { Route } from "./+types/route-name";
    
    export default function MyRouteComponent({
      loaderData,
      actionData,
      params,
      matches,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>Welcome to My Route with Props!</h1>
          <p>Loader Data: {JSON.stringify(loaderData)}</p>
          <p>Action Data: {JSON.stringify(actionData)}</p>
          <p>Route Parameters: {JSON.stringify(params)}</p>
          <p>Matched Routes: {JSON.stringify(matches)}</p>
        </div>
      );
    }
    

[](#loader)`loader`
-------------------

Route loaders provide data to route components before they are rendered. They are only called on the server when server rendering or during the build with pre-rendering.

    export async function loader() {
      return { message: "Hello, world!" };
    }
    
    export default function MyRoute({ loaderData }) {
      return <h1>{loaderData.message}</h1>;
    }
    

See also:

*   [`loader` params](https://api.reactrouter.com/v7/interfaces/react_router.LoaderFunctionArgs)

[](#clientloader)`clientLoader`
-------------------------------

Called only in the browser, route client loaders provide data to route components in addition to, or in place of, route loaders.

    export async function clientLoader({ serverLoader }) {
      // call the server loader
      const serverData = await serverLoader();
      // And/or fetch data on the client
      const data = getDataFromClient();
      // Return the data to expose through useLoaderData()
      return data;
    }
    

Client loaders can participate in initial page load hydration of server rendered pages by setting the `hydrate` property on the function:

    export async function clientLoader() {
      // ...
    }
    clientLoader.hydrate = true as const;
    

By using `as const`, TypeScript will infer that the type for `clientLoader.hydrate` is `true` instead of `boolean`. That way, React Router can derive types for `loaderData` based on the value of `clientLoader.hydrate`.

See also:

*   [`clientLoader` params](https://api.reactrouter.com/v7/types/react_router.ClientLoaderFunctionArgs)

[](#action)`action`
-------------------

Route actions allow server-side data mutations with automatic revalidation of all loader data on the page when called from `<Form>`, `useFetcher`, and `useSubmit`.

    // route("/list", "./list.tsx")
    import { Form } from "react-router";
    import { TodoList } from "~/components/TodoList";
    
    // this data will be loaded after the action completes...
    export async function loader() {
      const items = await fakeDb.getItems();
      return { items };
    }
    
    // ...so that the list here is updated automatically
    export default function Items({ loaderData }) {
      return (
        <div>
          <List items={loaderData.items} />
          <Form method="post" navigate={false} action="/list">
            <input type="text" name="title" />
            <button type="submit">Create Todo</button>
          </Form>
        </div>
      );
    }
    
    export async function action({ request }) {
      const data = await request.formData();
      const todo = await fakeDb.addItem({
        title: data.get("title"),
      });
      return { ok: true };
    }
    

[](#clientaction)`clientAction`
-------------------------------

Like route actions but only called in the browser.

    export async function clientAction({ serverAction }) {
      fakeInvalidateClientSideCache();
      // can still call the server action if needed
      const data = await serverAction();
      return data;
    }
    

See also:

*   [`clientAction` params](https://api.reactrouter.com/v7/types/react_router.ClientActionFunctionArgs)

[](#errorboundary)`ErrorBoundary`
---------------------------------

When other route module APIs throw, the route module `ErrorBoundary` will render instead of the route component.

    import {
      isRouteErrorResponse,
      useRouteError,
    } from "react-router";
    
    export function ErrorBoundary() {
      const error = useRouteError();
    
      if (isRouteErrorResponse(error)) {
        return (
          <div>
            <h1>
              {error.status} {error.statusText}
            </h1>
            <p>{error.data}</p>
          </div>
        );
      } else if (error instanceof Error) {
        return (
          <div>
            <h1>Error</h1>
            <p>{error.message}</p>
            <p>The stack trace is:</p>
            <pre>{error.stack}</pre>
          </div>
        );
      } else {
        return <h1>Unknown Error</h1>;
      }
    }
    

[](#hydratefallback)`HydrateFallback`
-------------------------------------

On initial page load, the route component renders only after the client loader is finished. If exported, a `HydrateFallback` can render immediately in place of the route component.

    export async function clientLoader() {
      const data = await fakeLoadLocalGameData();
      return data;
    }
    
    export function HydrateFallback() {
      return <p>Loading Game...</p>;
    }
    
    export default function Component({ loaderData }) {
      return <Game data={loaderData} />;
    }
    

[](#headers)`headers`
---------------------

Route headers define HTTP headers to be sent with the response when server rendering.

    export function headers() {
      return {
        "X-Stretchy-Pants": "its for fun",
        "Cache-Control": "max-age=300, s-maxage=3600",
      };
    }
    

[](#handle)`handle`
-------------------

Route handle allows apps to add anything to a route match in `useMatches` to create abstractions (like breadcrumbs, etc.).

    export const handle = {
      its: "all yours",
    };
    

[](#links)`links`
-----------------

Route links define [`<link>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link)s to be rendered in the document `<head>`.

    export function links() {
      return [
        {
          rel: "icon",
          href: "/favicon.png",
          type: "image/png",
        },
        {
          rel: "stylesheet",
          href: "https://example.com/some/styles.css",
        },
        {
          rel: "preload",
          href: "/images/banner.jpg",
          as: "image",
        },
      ];
    }
    

All routes links will be aggregated and rendered through the `<Links />` component, usually rendered in your app root:

    import { Links } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head>
            <Links />
          </head>
    
          <body />
        </html>
      );
    }
    

[](#meta)`meta`
---------------

Route meta defines meta tags to be rendered in the `<Meta />` component, usually placed in the `<head>`.

    export function meta() {
      return [
        { title: "Very cool app" },
        {
          property: "og:title",
          content: "Very cool app",
        },
        {
          name: "description",
          content: "This app is the best",
        },
      ];
    }
    

    import { Meta } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head>
            <Meta />
          </head>
    
          <body />
        </html>
      );
    }
    

The meta of the last matching route is used, allowing you to override parent routes' meta. It's important to note that the entire meta descriptor array is replaced, not merged. This gives you the flexibility to build your own meta composition logic across pages at different levels.

**See also**

*   [`meta` params](https://api.reactrouter.com/v7/interfaces/react_router.MetaArgs)

[](#shouldrevalidate)`shouldRevalidate`
---------------------------------------

In framework mode, route loaders are automatically revalidated after all navigations and form submissions (this is different from [Data Mode](../data/route-object#shouldrevalidate)). This enables middleware and loaders to share a request context and optimize in different ways than then they would be in Data Mode.

Defining this function allows you to opt out of revalidation for a route loader for navigations and form submissions.

    import type { ShouldRevalidateFunctionArgs } from "react-router";
    
    export function shouldRevalidate(
      arg: ShouldRevalidateFunctionArgs
    ) {
      return true;
    }
    

[`ShouldRevalidateFunctionArgs` Reference Documentation ↗](https://api.reactrouter.com/v7/interfaces/react_router.ShouldRevalidateFunctionArgs.html)

* * *

Next: [Rendering Strategies](./rendering)

[](#rendering-strategies)Rendering Strategies
=============================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

There are three rendering strategies in React Router:

*   Client Side Rendering
*   Server Side Rendering
*   Static Pre-rendering

[](#client-side-rendering)Client Side Rendering
-----------------------------------------------

Routes are always client side rendered as the user navigates around the app. If you're looking to build a Single Page App, disable server rendering:

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
    } satisfies Config;
    

[](#server-side-rendering)Server Side Rendering
-----------------------------------------------

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: true,
    } satisfies Config;
    

Server side rendering requires a deployment that supports it. Though it's a global setting, individual routes can still be statically pre-rendered. Routes can also use client data loading with `clientLoader` to avoid server rendering/fetching for their portion of the UI.

[](#static-pre-rendering)Static Pre-rendering
---------------------------------------------

    import type { Config } from "@react-router/dev/config";
    
    export default {
      // return a list of URLs to prerender at build time
      async prerender() {
        return ["/", "/about", "/contact"];
      },
    } satisfies Config;
    

Pre-rendering is a build-time operation that generates static HTML and client navigation data payloads for a list of URLs. This is useful for SEO and performance, especially for deployments without server rendering. When pre-rendering, route module loaders are used to fetch data at build time.

* * *

Next: [Data Loading](./data-loading)

[](#data-loading)Data Loading
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Data is provided to the route component from `loader` and `clientLoader`.

Loader data is automatically serialized from loaders and deserialized in components. In addition to primitive values like strings and numbers, loaders can return promises, maps, sets, dates and more.

The type for the `loaderData` prop is [automatically generated](../../explanation/type-safety).

[](#client-data-loading)Client Data Loading
-------------------------------------------

`clientLoader` is used to fetch data on the client. This is useful for pages or full projects that you'd prefer to fetch data from the browser only.

    // route("products/:pid", "./product.tsx");
    import type { Route } from "./+types/product";
    
    export async function clientLoader({
      params,
    }: Route.ClientLoaderArgs) {
      const res = await fetch(`/api/products/${params.pid}`);
      const product = await res.json();
      return product;
    }
    
    // HydrateFallback is rendered while the client loader is running
    export function HydrateFallback() {
      return <div>Loading...</div>;
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      const { name, description } = loaderData;
      return (
        <div>
          <h1>{name}</h1>
          <p>{description}</p>
        </div>
      );
    }
    

[](#server-data-loading)Server Data Loading
-------------------------------------------

When server rendering, `loader` is used for both initial page loads and client navigations. Client navigations call the loader through an automatic `fetch` by React Router from the browser to your server.

    // route("products/:pid", "./product.tsx");
    import type { Route } from "./+types/product";
    import { fakeDb } from "../db";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const product = await fakeDb.getProduct(params.pid);
      return product;
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      const { name, description } = loaderData;
      return (
        <div>
          <h1>{name}</h1>
          <p>{description}</p>
        </div>
      );
    }
    

Note that the `loader` function is removed from client bundles so you can use server only APIs without worrying about them being included in the browser.

[](#static-data-loading)Static Data Loading
-------------------------------------------

When pre-rendering, loaders are used to fetch data during the production build.

    // route("products/:pid", "./product.tsx");
    import type { Route } from "./+types/product";
    
    export async function loader({ params }: Route.LoaderArgs) {
      let product = await getProductFromCSVFile(params.pid);
      return product;
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      const { name, description } = loaderData;
      return (
        <div>
          <h1>{name}</h1>
          <p>{description}</p>
        </div>
      );
    }
    

The URLs to pre-render are specified in react-router.config.ts:

    import type { Config } from "@react-router/dev/config";
    
    export default {
      async prerender() {
        let products = await readProductsFromCSVFile();
        return products.map(
          (product) => `/products/${product.id}`
        );
      },
    } satisfies Config;
    

Note that when server rendering, any URLs that aren't pre-rendered will be server rendered as usual, allowing you to pre-render some data at a single route while still server rendering the rest.

[](#using-both-loaders)Using Both Loaders
-----------------------------------------

`loader` and `clientLoader` can be used together. The `loader` will be used on the server for initial SSR (or pre-rendering) and the `clientLoader` will be used on subsequent client-side navigations.

    // route("products/:pid", "./product.tsx");
    import type { Route } from "./+types/product";
    import { fakeDb } from "../db";
    
    export async function loader({ params }: Route.LoaderArgs) {
      return fakeDb.getProduct(params.pid);
    }
    
    export async function clientLoader({
      serverLoader,
      params,
    }: Route.ClientLoaderArgs) {
      const res = await fetch(`/api/products/${params.pid}`);
      const serverData = await serverLoader();
      return { ...serverData, ...res.json() };
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      const { name, description } = loaderData;
    
      return (
        <div>
          <h1>{name}</h1>
          <p>{description}</p>
        </div>
      );
    }
    

You can also force the client loader to run during hydration and before the page renders by setting the `hydrate` property on the function. In this situation you will want to render a `HydrateFallback` component to show a fallback UI while the client loader runs.

    export async function loader() {
      /* ... */
    }
    
    export async function clientLoader() {
      /* ... */
    }
    
    // force the client loader to run during hydration
    clientLoader.hydrate = true as const; // `as const` for type inference
    
    export function HydrateFallback() {
      return <div>Loading...</div>;
    }
    
    export default function Product() {
      /* ... */
    }
    

* * *

Next: [Actions](./actions)

See also:

*   [Streaming with Suspense](../../how-to/suspense)
*   [Client Data](../../how-to/client-data)
*   [Using Fetchers](../../how-to/fetchers#loading-data)

[](#actions)Actions
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Data mutations are done through Route actions. When the action completes, all loader data on the page is revalidated to keep your UI in sync with the data without writing any code to do it.

Route actions defined with `action` are only called on the server while actions defined with `clientAction` are run in the browser.

[](#client-actions)Client Actions
---------------------------------

Client actions only run in the browser and take priority over a server action when both are defined.

    // route('/projects/:projectId', './project.tsx')
    import type { Route } from "./+types/project";
    import { Form } from "react-router";
    import { someApi } from "./api";
    
    export async function clientAction({
      request,
    }: Route.ClientActionArgs) {
      let formData = await request.formData();
      let title = formData.get("title");
      let project = await someApi.updateProject({ title });
      return project;
    }
    
    export default function Project({
      actionData,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>Project</h1>
          <Form method="post">
            <input type="text" name="title" />
            <button type="submit">Submit</button>
          </Form>
          {actionData ? (
            <p>{actionData.title} updated</p>
          ) : null}
        </div>
      );
    }
    

[](#server-actions)Server Actions
---------------------------------

Server actions only run on the server and are removed from client bundles.

    // route('/projects/:projectId', './project.tsx')
    import type { Route } from "./+types/project";
    import { Form } from "react-router";
    import { fakeDb } from "../db";
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      let formData = await request.formData();
      let title = formData.get("title");
      let project = await fakeDb.updateProject({ title });
      return project;
    }
    
    export default function Project({
      actionData,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>Project</h1>
          <Form method="post">
            <input type="text" name="title" />
            <button type="submit">Submit</button>
          </Form>
          {actionData ? (
            <p>{actionData.title} updated</p>
          ) : null}
        </div>
      );
    }
    

[](#calling-actions)Calling Actions
-----------------------------------

Actions are called declaratively through `<Form>` and imperatively through `useSubmit` (or `<fetcher.Form>` and `fetcher.submit`) by referencing the route's path and a "post" method.

### [](#calling-actions-with-a-form)Calling actions with a Form

    import { Form } from "react-router";
    
    function SomeComponent() {
      return (
        <Form action="/projects/123" method="post">
          <input type="text" name="title" />
          <button type="submit">Submit</button>
        </Form>
      );
    }
    

This will cause a navigation and a new entry will be added to the browser history.

### [](#calling-actions-with-usesubmit)Calling actions with useSubmit

You can submit form data to an action imperatively with `useSubmit`.

    import { useCallback } from "react";
    import { useSubmit } from "react-router";
    import { useFakeTimer } from "fake-lib";
    
    function useQuizTimer() {
      let submit = useSubmit();
    
      let cb = useCallback(() => {
        submit(
          { quizTimedOut: true },
          { action: "/end-quiz", method: "post" }
        );
      }, []);
    
      let tenMinutes = 10 * 60 * 1000;
      useFakeTimer(tenMinutes, cb);
    }
    

This will cause a navigation and a new entry will be added to the browser history.

### [](#calling-actions-with-a-fetcher)Calling actions with a fetcher

Fetchers allow you to submit data to actions (and loaders) without causing a navigation (no new entries in the browser history).

    import { useFetcher } from "react-router";
    
    function Task() {
      let fetcher = useFetcher();
      let busy = fetcher.state !== "idle";
    
      return (
        <fetcher.Form method="post" action="/update-task/123">
          <input type="text" name="title" />
          <button type="submit">
            {busy ? "Saving..." : "Save"}
          </button>
        </fetcher.Form>
      );
    }
    

They also have the imperative `submit` method.

    fetcher.submit(
      { title: "New Title" },
      { action: "/update-task/123", method: "post" }
    );
    

See the [Using Fetchers](../../how-to/fetchers) guide for more information.

* * *

Next: [Navigating](./navigating)

[](#navigating)Navigating
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Users navigate your application with `<Link>`, `<NavLink>`, `<Form>`, `redirect`, and `useNavigate`.

[](#navlink)NavLink
-------------------

This component is for navigation links that need to render active and pending states.

    import { NavLink } from "react-router";
    
    export function MyAppNav() {
      return (
        <nav>
          <NavLink to="/" end>
            Home
          </NavLink>
          <NavLink to="/trending" end>
            Trending Concerts
          </NavLink>
          <NavLink to="/concerts">All Concerts</NavLink>
          <NavLink to="/account">Account</NavLink>
        </nav>
      );
    }
    

`NavLink` renders default class names for different states for easy styling with CSS:

    a.active {
      color: red;
    }
    
    a.pending {
      animate: pulse 1s infinite;
    }
    
    a.transitioning {
      /* css transition is running */
    }
    

It also has callback props on `className`, `style`, and `children` with the states for inline styling or conditional rendering:

    // className
    <NavLink
      to="/messages"
      className={({ isActive, isPending, isTransitioning }) =>
        [
          isPending ? "pending" : "",
          isActive ? "active" : "",
          isTransitioning ? "transitioning" : "",
        ].join(" ")
      }
    >
      Messages
    </NavLink>
    

    // style
    <NavLink
      to="/messages"
      style={({ isActive, isPending, isTransitioning }) => {
        return {
          fontWeight: isActive ? "bold" : "",
          color: isPending ? "red" : "black",
          viewTransitionName: isTransitioning ? "slide" : "",
        };
      }}
    >
      Messages
    </NavLink>
    

    // children
    <NavLink to="/tasks">
      {({ isActive, isPending, isTransitioning }) => (
        <span className={isActive ? "active" : ""}>Tasks</span>
      )}
    </NavLink>
    

[](#link)Link
-------------

Use `<Link>` when the link doesn't need active styling:

    import { Link } from "react-router";
    
    export function LoggedOutMessage() {
      return (
        <p>
          You've been logged out.{" "}
          <Link to="/login">Login again</Link>
        </p>
      );
    }
    

[](#form)Form
-------------

The form component can be used to navigate with `URLSearchParams` provided by the user.

    <Form action="/search">
      <input type="text" name="q" />
    </Form>
    

If the user enters "journey" into the input and submits it, they will navigate to:

    /search?q=journey
    

Forms with `<Form method="post" />` will also navigate to the action prop but will submit the data as `FormData` instead of `URLSearchParams`. However, it is more common to `useFetcher()` to POST form data. See [Using Fetchers](../../how-to/fetchers).

[](#redirect)redirect
---------------------

Inside of route loaders and actions, you can return a `redirect` to another URL.

    import { redirect } from "react-router";
    
    export async function loader({ request }) {
      let user = await getUser(request);
      if (!user) {
        return redirect("/login");
      }
      return { userName: user.name };
    }
    

It is common to redirect to a new record after it has been created:

    import { redirect } from "react-router";
    
    export async function action({ request }) {
      let formData = await request.formData();
      let project = await createProject(formData);
      return redirect(`/projects/${project.id}`);
    }
    

[](#usenavigate)useNavigate
---------------------------

This hook allows the programmer to navigate the user to a new page without the user interacting. Usage of this hook should be uncommon. It's recommended to use the other APIs in this guide when possible.

Reserve usage of `useNavigate` to situations where the user is _not_ interacting but you need to navigate, for example:

*   Logging them out after inactivity
*   Timed UIs like quizzes, etc.

    import { useNavigate } from "react-router";
    
    export function useLogoutAfterInactivity() {
      let navigate = useNavigate();
    
      useFakeInactivityHook(() => {
        navigate("/logout");
      });
    }
    

* * *

Next: [Pending UI](./pending-ui)

[](#pending-ui)Pending UI
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

When the user navigates to a new route, or submits data to an action, the UI should immediately respond to the user's actions with a pending or optimistic state. Application code is responsible for this.

[](#global-pending-navigation)Global Pending Navigation
-------------------------------------------------------

When the user navigates to a new url, the loaders for the next page are awaited before the next page renders. You can get the pending state from `useNavigation`.

    import { useNavigation } from "react-router";
    
    export default function Root() {
      const navigation = useNavigation();
      const isNavigating = Boolean(navigation.location);
    
      return (
        <html>
          <body>
            {isNavigating && <GlobalSpinner />}
            <Outlet />
          </body>
        </html>
      );
    }
    

[](#local-pending-navigation)Local Pending Navigation
-----------------------------------------------------

Pending indicators can also be localized to the link. NavLink's children, className, and style props can be functions that receive the pending state.

    import { NavLink } from "react-router";
    
    function Navbar() {
      return (
        <nav>
          <NavLink to="/home">
            {({ isPending }) => (
              <span>Home {isPending && <Spinner />}</span>
            )}
          </NavLink>
          <NavLink
            to="/about"
            style={({ isPending }) => ({
              color: isPending ? "gray" : "black",
            })}
          >
            About
          </NavLink>
        </nav>
      );
    }
    

[](#pending-form-submission)Pending Form Submission
---------------------------------------------------

When a form is submitted, the UI should immediately respond to the user's actions with a pending state. This is easiest to do with a [fetcher](https://api.reactrouter.com/v7/functions/react_router.useFetcher.html) form because it has it's own independent state (whereas normal forms cause a global navigation).

    import { useFetcher } from "react-router";
    
    function NewProjectForm() {
      const fetcher = useFetcher();
    
      return (
        <fetcher.Form method="post">
          <input type="text" name="title" />
          <button type="submit">
            {fetcher.state !== "idle"
              ? "Submitting..."
              : "Submit"}
          </button>
        </fetcher.Form>
      );
    }
    

For non-fetcher form submissions, pending states are available on `useNavigation`.

    import { useNavigation, Form } from "react-router";
    
    function NewProjectForm() {
      const navigation = useNavigation();
    
      return (
        <Form method="post" action="/projects/new">
          <input type="text" name="title" />
          <button type="submit">
            {navigation.formAction === "/projects/new"
              ? "Submitting..."
              : "Submit"}
          </button>
        </Form>
      );
    }
    

[](#optimistic-ui)Optimistic UI
-------------------------------

When the future state of the UI is known by the form submission data, an optimistic UI can be implemented for instant UX.

    function Task({ task }) {
      const fetcher = useFetcher();
    
      let isComplete = task.status === "complete";
      if (fetcher.formData) {
        isComplete =
          fetcher.formData.get("status") === "complete";
      }
    
      return (
        <div>
          <div>{task.title}</div>
          <fetcher.Form method="post">
            <button
              name="status"
              value={isComplete ? "incomplete" : "complete"}
            >
              {isComplete ? "Mark Incomplete" : "Mark Complete"}
            </button>
          </fetcher.Form>
        </div>
      );
    }
    

* * *

Next: [Testing](./testing)

[](#testing)Testing
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

When components use things like `useLoaderData`, `<Link>`, etc, they are required to be rendered in context of a React Router app. The `createRoutesStub` function creates that context to test components in isolation.

Consider a login form component that relies on `useActionData`

    import { useActionData } from "react-router";
    
    export function LoginForm() {
      const { errors } = useActionData();
      return (
        <Form method="post">
          <label>
            <input type="text" name="username" />
            {errors?.username && <div>{errors.username}</div>}
          </label>
    
          <label>
            <input type="password" name="password" />
            {errors?.password && <div>{errors.password}</div>}
          </label>
    
          <button type="submit">Login</button>
        </Form>
      );
    }
    

We can test this component with `createRoutesStub`. It takes an array of objects that resemble route modules with loaders, actions, and components.

    import { createRoutesStub } from "react-router";
    import {
      render,
      screen,
      waitFor,
    } from "@testing-library/react";
    import userEvent from "@testing-library/user-event";
    import { LoginForm } from "./LoginForm";
    
    test("LoginForm renders error messages", async () => {
      const USER_MESSAGE = "Username is required";
      const PASSWORD_MESSAGE = "Password is required";
    
      const Stub = createRoutesStub([
        {
          path: "/login",
          Component: LoginForm,
          action() {
            return {
              errors: {
                username: USER_MESSAGE,
                password: PASSWORD_MESSAGE,
              },
            };
          },
        },
      ]);
    
      // render the app stub at "/login"
      render(<Stub initialEntries={["/login"]} />);
    
      // simulate interactions
      userEvent.click(screen.getByText("Login"));
      await waitFor(() => screen.findByText(USER_MESSAGE));
      await waitFor(() => screen.findByText(PASSWORD_MESSAGE));
    });
    

[](#deploying)Deploying
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

React Router can be deployed two ways:

*   Fullstack Hosting
*   Static Hosting

The official [React Router templates](https://github.com/remix-run/react-router-templates) can help you bootstrap an application or be used as a reference for your own application.

When deploying to static hosting, you can deploy React Router the same as any other single page application with React.

[](#templates)Templates
-----------------------

After running the `create-react-router` command, make sure to follow the instructions in the README.

### [](#nodejs-with-docker)Node.js with Docker

    npx create-react-router@latest --template remix-run/react-router-templates/default
    

*   Server Rendering
*   Tailwind CSS

The containerized application can be deployed to any platform that supports Docker, including:

*   AWS ECS
*   Google Cloud Run
*   Azure Container Apps
*   Digital Ocean App Platform
*   Fly.io
*   Railway

### [](#node-with-docker-custom-server)Node with Docker (Custom Server)

    npx create-react-router@latest --template remix-run/react-router-templates/node-custom-server
    

*   Server Rendering
*   Tailwind CSS
*   Custom express server for more control

The containerized application can be deployed to any platform that supports Docker, including:

*   AWS ECS
*   Google Cloud Run
*   Azure Container Apps
*   Digital Ocean App Platform
*   Fly.io
*   Railway

### [](#node-with-docker-and-postgres)Node with Docker and Postgres

    npx create-react-router@latest --template remix-run/react-router-templates/node-postgres
    

*   Server Rendering
*   Postgres Database with Drizzle
*   Tailwind CSS
*   Custom express server for more control

The containerized application can be deployed to any platform that supports Docker, including:

*   AWS ECS
*   Google Cloud Run
*   Azure Container Apps
*   Digital Ocean App Platform
*   Fly.io
*   Railway

### [](#vercel)Vercel

    npx create-react-router@latest --template remix-run/react-router-templates/vercel
    

*   Server Rendering
*   Tailwind CSS

### [](#cloudflare-workers-w-d1)Cloudflare Workers w/ D1

    npx create-react-router@latest --template remix-run/react-router-templates/cloudflare-d1
    

*   Server Rendering
*   D1 Database with Drizzle ORM
*   Tailwind CSS

### [](#cloudflare-workers)Cloudflare Workers

    npx create-react-router@latest --template remix-run/react-router-templates/cloudflare
    

*   Server Rendering
*   Tailwind CSS

### [](#netlify)Netlify

    npx create-react-router@latest --template remix-run/react-router-templates/netlify
    

*   Server Rendering
*   Tailwind CSS

[](#installation)Installation
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#bootstrap-with-a-bundler-template)Bootstrap with a Bundler Template
-----------------------------------------------------------------------

You can start with a React template from Vite and choose "React", otherwise bootstrap your application however you prefer (Parcel, Webpack, etc).

    npx create-vite@latest
    

[](#install-react-router)Install React Router
---------------------------------------------

Next install React Router from npm:

    npm i react-router
    

[](#create-a-router-and-render)Create a Router and Render
---------------------------------------------------------

Create a router and pass it to `RouterProvider`:

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    
    import React from "react";
    import ReactDOM from "react-dom/client";
    
    const router = createBrowserRouter([
      {
        path: "/",
        element: <div>Hello World</div>,
      },
    ]);
    
    const root = document.getElementById("root");
    
    ReactDOM.createRoot(root).render(
      <RouterProvider router={router} />
    );
    

* * *

Next: [Routing](./routing)

[](#routing)Routing
===================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#configuring-routes)Configuring Routes
-----------------------------------------

Routes are configured as the first argument to `createBrowserRouter`. At a minimum, you need a path and component:

    import { createBrowserRouter } from "react-router";
    
    function Root() {
      return <h1>Hello world</h1>;
    }
    
    const router = createBrowserRouter([
      { path: "/", Component: Root },
    ]);
    

Here is a larger sample route config:

    createBrowserRouter([
      {
        path: "/",
        Component: Root,
        children: [
          { index: true, Component: Home },
          { path: "about", Component: About },
          {
            path: "auth",
            Component: AuthLayout,
            children: [
              { path: "login", Component: Login },
              { path: "register", Component: Register },
            ],
          },
          {
            path: "concerts",
            children: [
              { index: true, Component: ConcertsHome },
              { path: ":city", Component: ConcertsCity },
              { path: "trending", Component: ConcertsTrending },
            ],
          },
        ],
      },
    ]);
    

[](#route-objects)Route Objects
-------------------------------

Route objects define the behavior of a route beyond just the path and component, like data loading and actions. We'll go into more detail in the [Route Object guide](./route-object), but here's a quick example of a loader.

    import {
      createBrowserRouter,
      useLoaderData,
    } from "react-router";
    
    createBrowserRouter([
      {
        path: "/teams/:teamId",
        loader: async ({ params }) => {
          let team = await fetchTeam(params.teamId);
          return { name: team.name };
        },
        Component: Team,
      },
    ]);
    
    function Team() {
      let data = useLoaderData();
      return <h1>{data.name}</h1>;
    }
    

[](#nested-routes)Nested Routes
-------------------------------

Routes can be nested inside parent routes through `children`.

    createBrowserRouter([
      {
        path: "/dashboard",
        Component: Dashboard,
        children: [
          { index: true, Component: Home },
          { path: "settings", Component: Settings },
        ],
      },
    ]);
    

The path of the parent is automatically included in the child, so this config creates both `"/dashboard"` and `"/dashboard/settings"` URLs.

Child routes are rendered through the `<Outlet/>` in the parent route.

    import { Outlet } from "react-router";
    
    export default function Dashboard() {
      return (
        <div>
          <h1>Dashboard</h1>
          {/* will either be <Home> or <Settings> */}
          <Outlet />
        </div>
      );
    }
    

[](#layout-routes)Layout Routes
-------------------------------

Omitting the `path` in a route creates new [Nested Routes](#nested-routes) for its children without adding any segments to the URL.

    createBrowserRouter([
      {
        // no path on this parent route, just the component
        Component: MarketingLayout,
        children: [
          { index: true, Component: Home },
          { path: "contact", Component: Contact },
        ],
      },
    
      {
        path: "projects",
        children: [
          { index: true, Component: ProjectsHome },
          {
            // again, no path, just a component for the layout
            Component: ProjectLayout,
            children: [
              { path: ":pid", Component: Project },
              { path: ":pid/edit", Component: EditProject },
            ],
          },
        ],
      },
    ]);
    

Note that:

*   `Home` and `Contact` will be rendered into the `MarketingLayout` outlet
*   `Project` and `EditProject` will be rendered into the `ProjectLayout` outlet while `ProjectsHome` will not.

[](#index-routes)Index Routes
-----------------------------

Index routes are defined by setting `index: true` on a route object without a path.

    { index: true, Component: Home }
    

Index routes render into their parent's [Outlet](https://api.reactrouter.com/v7/functions/react_router.Outlet.html) at their parent's URL (like a default child route).

    import { createBrowserRouter } from "react-router";
    
    createBrowserRouter([
      // renders at "/"
      { index: true, Component: Home },
      {
        Component: Dashboard,
        path: "/dashboard",
        children: [
          // renders at "/dashboard"
          { index: true, Component: DashboardHome },
          { path: "settings", Component: DashboardSettings },
        ],
      },
    ]);
    

Note that index routes can't have children.

[](#prefix-route)Prefix Route
-----------------------------

A route with just a path and no component creates a group of routes with a path prefix.

    createBrowserRouter([
      {
        // no component, just a path
        path: "/projects",
        children: [
          { index: true, Component: ProjectsHome },
          { path: ":pid", Component: Project },
          { path: ":pid/edit", Component: EditProject },
        ],
      },
    ]);
    

This creates the routes `/projects`, `/projects/:pid`, and `/projects/:pid/edit` without introducing a layout component.

[](#dynamic-segments)Dynamic Segments
-------------------------------------

If a path segment starts with `:` then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as `params` to other router APIs.

    {
      path: "teams/:teamId",
      loader: async ({ params }) => {
        // params are available in loaders/actions
        let team = await fetchTeam(params.teamId);
        return { name: team.name };
      },
      Component: Team,
    }
    

    import { useParams } from "react-router";
    
    function Team() {
      // params are available in components through useParams
      let params = useParams();
      // ...
    }
    

You can have multiple dynamic segments in one route path:

    {
      path: "c/:categoryId/p/:productId";
    }
    

[](#optional-segments)Optional Segments
---------------------------------------

You can make a route segment optional by adding a `?` to the end of the segment.

    {
      path: ":lang?/categories";
    }
    

You can have optional static segments, too:

    {
      path: "users/:userId/edit?";
    }
    

[](#splats)Splats
-----------------

Also known as "catchall" and "star" segments. If a route path pattern ends with `/*` then it will match any characters following the `/`, including other `/` characters.

    {
      path: "files/*";
      loader: async ({ params }) => {
        params["*"]; // will contain the remaining URL after files/
      };
    }
    

You can destructure the `*`, you just have to assign it a new name. A common name is `splat`:

    const { "*": splat } = params;
    

* * *

Next: [Route Object](./route-object)

[](#route-object)Route Object
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

The objects passed to `createBrowserRouter` are called Route Objects.

    createBrowserRouter([
      {
        path: "/",
        Component: App,
      },
    ]);
    

Route modules are the foundation of React Router's data features, they define:

*   data loading
*   actions
*   revalidation
*   error boundaries
*   and more

This guide is a quick overview of every route object feature.

[](#component)Component
-----------------------

The `Component` property in a route object defines the component that will render when the route matches.

    createBrowserRouter([
      {
        path: "/",
        Component: MyRouteComponent,
      },
    ]);
    
    function MyRouteComponent() {
      return (
        <div>
          <h1>Look ma!</h1>
          <p>
            I'm still using React Router after like 10 years.
          </p>
        </div>
      );
    }
    

[](#loader)`loader`
-------------------

Route loaders provide data to route components before they are rendered.

    import {
      useLoaderData,
      createBrowserRouter,
    } from "react-router";
    
    createBrowserRouter([
      {
        path: "/",
        loader: loader,
        Component: MyRoute,
      },
    ]);
    
    async function loader({ params }) {
      return { message: "Hello, world!" };
    }
    
    function MyRoute() {
      let data = useLoaderData();
      return <h1>{data.message}</h1>;
    }
    

See also:

*   [`loader` params](https://api.reactrouter.com/v7/interfaces/react_router.LoaderFunctionArgs)

[](#action)`action`
-------------------

Route actions allow server-side data mutations with automatic revalidation of all loader data on the page when called from `<Form>`, `useFetcher`, and `useSubmit`.

    import {
      createBrowserRouter,
      useLoaderData,
      useActionData,
      Form,
    } from "react-router";
    import { TodoList } from "~/components/TodoList";
    
    createBrowserRouter([
      {
        path: "/items",
        action: action,
        loader: loader,
        Component: Items,
      },
    ]);
    
    async function action({ request }) {
      const data = await request.formData();
      const todo = await fakeDb.addItem({
        title: data.get("title"),
      });
      return { ok: true };
    }
    
    // this data will be revalidated after the action completes...
    async function loader() {
      const items = await fakeDb.getItems();
      return { items };
    }
    
    // ...so that the list here is updated automatically
    export default function Items() {
      let data = useLoaderData();
      return (
        <div>
          <List items={data.items} />
          <Form method="post" navigate={false}>
            <input type="text" name="title" />
            <button type="submit">Create Todo</button>
          </Form>
        </div>
      );
    }
    

[](#shouldrevalidate)`shouldRevalidate`
---------------------------------------

Loader data is automatically revalidated after certain events like navigations and form submissions.

This hook enables you to opt in or out of the default revalidation behavior. The default behavior is nuanced to avoid calling loaders unnecessarily.

A route loader is revalidated when:

*   its own route params change
*   any change to URL search params
*   after any actions are called

By defining this function, you opt out of the default behavior completely and can manually control when loader data is revalidated for navigations and form submissions.

    import type { ShouldRevalidateFunctionArgs } from "react-router";
    
    function shouldRevalidate(
      arg: ShouldRevalidateFunctionArgs
    ) {
      return true; // false
    }
    
    createBrowserRouter([
      {
        path: "/",
        shouldRevalidate: shouldRevalidate,
        Component: MyRoute,
      },
    ]);
    

[`ShouldRevalidateFunctionArgs` Reference Documentation ↗](https://api.reactrouter.com/v7/interfaces/react_router.ShouldRevalidateFunctionArgs.html)

Please note the default behavior is different in [Framework Mode](../modes).

[](#lazy)`lazy`
---------------

Most properties can be lazily imported to reduce the initial bundle size.

    createBrowserRouter([
      {
        path: "/app",
        lazy: async () => {
          // load component and loader in parallel before rendering
          const [Component, loader] = await Promise.all([
            import("./app"),
            import("./app-loader"),
          ]);
          return { Component, loader };
        },
      },
    ]);
    

* * *

Next: [Data Loading](./data-loading)

[](#data-loading)Data Loading
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#providing-data)Providing Data
---------------------------------

Data is provided to route components from route loaders:

    createBrowserRouter([
      {
        path: "/",
        loader: async () => {
          // return data from here
          return { records: await getSomeRecords() };
        },
        Component: MyRoute,
      },
    ]);
    

[](#accessing-data)Accessing Data
---------------------------------

The data is available in route components with `useLoaderData`.

    import { useLoaderData } from "react-router";
    
    function MyRoute() {
      const { records } = useLoaderData();
      return <div>{records.length}</div>;
    }
    

As the user navigates between routes, the loaders are called before the route component is rendered.

* * *

Next: [Actions](./actions)

[](#actions)Actions
===================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#defining-actions)Defining Actions
-------------------------------------

Data mutations are done through Route actions defined on the `action` property of a route object. When the action completes, all loader data on the page is revalidated to keep your UI in sync with the data without writing any code to do it.

    import { createBrowserRouter } from "react-router";
    import { someApi } from "./api";
    
    let router = createBrowserRouter([
      {
        path: "/projects/:projectId",
        Component: Project,
        action: async ({ request }) => {
          let formData = await request.formData();
          let title = formData.get("title");
          let project = await someApi.updateProject({ title });
          return project;
        },
      },
    ]);
    

[](#calling-actions)Calling Actions
-----------------------------------

Actions are called declaratively through `<Form>` and imperatively through `useSubmit` (or `<fetcher.Form>` and `fetcher.submit`) by referencing the route's path and a "post" method.

### [](#calling-actions-with-a-form)Calling actions with a Form

    import { Form } from "react-router";
    
    function SomeComponent() {
      return (
        <Form action="/projects/123" method="post">
          <input type="text" name="title" />
          <button type="submit">Submit</button>
        </Form>
      );
    }
    

This will cause a navigation and a new entry will be added to the browser history.

### [](#calling-actions-with-usesubmit)Calling actions with useSubmit

You can submit form data to an action imperatively with `useSubmit`.

    import { useCallback } from "react";
    import { useSubmit } from "react-router";
    import { useFakeTimer } from "fake-lib";
    
    function useQuizTimer() {
      let submit = useSubmit();
    
      let cb = useCallback(() => {
        submit(
          { quizTimedOut: true },
          { action: "/end-quiz", method: "post" }
        );
      }, []);
    
      let tenMinutes = 10 * 60 * 1000;
      useFakeTimer(tenMinutes, cb);
    }
    

This will cause a navigation and a new entry will be added to the browser history.

### [](#calling-actions-with-a-fetcher)Calling actions with a fetcher

Fetchers allow you to submit data to actions (and loaders) without causing a navigation (no new entries in the browser history).

    import { useFetcher } from "react-router";
    
    function Task() {
      let fetcher = useFetcher();
      let busy = fetcher.state !== "idle";
    
      return (
        <fetcher.Form method="post" action="/update-task/123">
          <input type="text" name="title" />
          <button type="submit">
            {busy ? "Saving..." : "Save"}
          </button>
        </fetcher.Form>
      );
    }
    

They also have the imperative `submit` method.

    fetcher.submit(
      { title: "New Title" },
      { action: "/update-task/123", method: "post" }
    );
    

See the [Using Fetchers](../../how-to/fetchers) guide for more information.

[](#accessing-action-data)Accessing Action Data
-----------------------------------------------

Actions can return data available through `useActionData` in the route component or `fetcher.data` when using a fetcher.

    function Project() {
      let actionData = useActionData();
      return (
        <div>
          <h1>Project</h1>
          <Form method="post">
            <input type="text" name="title" />
            <button type="submit">Submit</button>
          </Form>
          {actionData ? (
            <p>{actionData.title} updated</p>
          ) : null}
        </div>
      );
    }
    

* * *

Next: [Navigating](./navigating)

[](#navigating)Navigating
=========================

Navigating in Data Mode is the same as Framework Mode, please see the [Navigating](../framework/navigating) guide for more information.

* * *

Next: [Pending UI](./pending-ui)

[](#pending-ui)Pending UI
=========================

Pending UI is the same as Framework Mode, please see the [Pending UI](../framework/pending-ui) guide for more information.

* * *

Next: [Custom Framework](./custom)

[](#custom-framework)Custom Framework
=====================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Instead of using `@react-router/dev`, you can integrate React Router's framework features (like loaders, actions, fetchers, etc.) into your own bundler and server abstractions with Data Mode.

[](#client-rendering)Client Rendering
-------------------------------------

### [](#1-create-a-router)1\. Create a Router

The browser runtime API that enables route module APIs (loaders, actions, etc.) is `createBrowserRouter`.

It takes an array of route objects that support loaders, actions, error boundaries and more. The React Router Vite plugin creates one of these from `routes.ts`, but you can create one manually (or with an abstraction) and use your own bundler.

    import { createBrowserRouter } from "react-router";
    
    let router = createBrowserRouter([
      {
        path: "/",
        Component: Root,
        children: [
          {
            path: "shows/:showId",
            Component: Show,
            loader: ({ request, params }) =>
              fetch(`/api/show/${params.id}.json`, {
                signal: request.signal,
              }),
          },
        ],
      },
    ]);
    

### [](#2-render-the-router)2\. Render the Router

To render the router in the browser, use `<RouterProvider>`.

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    import { createRoot } from "react-dom/client";
    
    createRoot(document.getElementById("root")).render(
      <RouterProvider router={router} />
    );
    

### [](#3-lazy-loading)3\. Lazy Loading

Routes can take most of their definition lazily with the `lazy` property.

    createBrowserRouter([
      {
        path: "/show/:showId",
        lazy: {
          loader: async () =>
            (await import("./show.loader.js")).loader,
          action: async () =>
            (await import("./show.action.js")).action,
          Component: async () =>
            (await import("./show.component.js")).Component,
        },
      },
    ]);
    

[](#server-rendering)Server Rendering
-------------------------------------

To server render a custom setup, there are a few server APIs available for rendering and data loading.

This guide simply gives you some ideas about how it works. For deeper understanding, please see the [Custom Framework Example Repo](https://github.com/remix-run/custom-react-router-framework-example)

### [](#1-define-your-routes)1\. Define Your Routes

Routes are the same kinds of objects on the server as the client.

    export default [
      {
        path: "/",
        Component: Root,
        children: [
          {
            path: "shows/:showId",
            Component: Show,
            loader: ({ params }) => {
              return db.loadShow(params.id);
            },
          },
        ],
      },
    ];
    

### [](#2-create-a-static-handler)2\. Create a static handler

Turn your routes into a request handler with `createStaticHandler`:

    import { createStaticHandler } from "react-router";
    import routes from "./some-routes";
    
    let { query, dataRoutes } = createStaticHandler(routes);
    

### [](#3-get-routing-context-and-render)3\. Get Routing Context and Render

React Router works with web fetch [Requests](https://developer.mozilla.org/en-US/docs/Web/API/Request), so if your server doesn't, you'll need to adapt whatever objects it uses to a web fetch `Request` object.

This step assumes your server receives `Request` objects.

    import { renderToString } from "react-dom/server";
    import {
      createStaticHandler,
      createStaticRouter,
      StaticRouterProvider,
    } from "react-router";
    
    import routes from "./some-routes.js";
    
    let { query, dataRoutes } = createStaticHandler(routes);
    
    export async function handler(request: Request) {
      // 1. run actions/loaders to get the routing context with `query`
      let context = await query(request);
    
      // If `query` returns a Response, send it raw (a route probably a redirected)
      if (context instanceof Response) {
        return context;
      }
    
      // 2. Create a static router for SSR
      let router = createStaticRouter(dataRoutes, context);
    
      // 3. Render everything with StaticRouterProvider
      let html = renderToString(
        <StaticRouterProvider
          router={router}
          context={context}
        />
      );
    
      // Setup headers from action and loaders from deepest match
      let leaf = context.matches[context.matches.length - 1];
      let actionHeaders = context.actionHeaders[leaf.route.id];
      let loaderHeaders = context.loaderHeaders[leaf.route.id];
      let headers = new Headers(actionHeaders);
      if (loaderHeaders) {
        for (let [key, value] of loaderHeaders.entries()) {
          headers.append(key, value);
        }
      }
    
      headers.set("Content-Type", "text/html; charset=utf-8");
    
      // 4. send a response
      return new Response(`<!DOCTYPE html>${html}`, {
        status: context.statusCode,
        headers,
      });
    }
    

### [](#4-hydrate-in-the-browser)4\. Hydrate in the browser

Hydration data is embedded onto `window.__staticRouterHydrationData`, use that to initialize your client side router and render a `<RouterProvider>`.

    import { StrictMode } from "react";
    import { hydrateRoot } from "react-dom/client";
    import { RouterProvider } from "react-router/dom";
    import routes from "./app/routes.js";
    import { createBrowserRouter } from "react-router";
    
    let router = createBrowserRouter(routes, {
      hydrationData: window.__staticRouterHydrationData,
    });
    
    hydrateRoot(
      document,
      <StrictMode>
        <RouterProvider router={router} />
      </StrictMode>
    );
    

[](#testing)Testing
===================

You can use `createRoutesStub` in data and framework modes. Please refer to the [Testing Guide](../framework/testing).

[](#installation)Installation
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#introduction)Introduction
-----------------------------

You can start with a React template from Vite and choose "React", otherwise bootstrap your application however you prefer.

    npx create-vite@latest
    

Next install React Router from npm:

    npm i react-router
    

Finally, render a `<BrowserRouter>` around your application:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { BrowserRouter } from "react-router";
    import App from "./app";
    
    const root = document.getElementById("root");
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    

* * *

Next: [Routing](./routing)

[](#routing)Routing
===================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#configuring-routes)Configuring Routes
-----------------------------------------

Routes are configured by rendering `<Routes>` and `<Route>` that couple URL segments to UI elements.

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { BrowserRouter, Routes, Route } from "react-router";
    import App from "./app";
    
    const root = document.getElementById("root");
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<App />} />
        </Routes>
      </BrowserRouter>
    );
    

Here's a larger sample config:

    <Routes>
      <Route index element={<Home />} />
      <Route path="about" element={<About />} />
    
      <Route element={<AuthLayout />}>
        <Route path="login" element={<Login />} />
        <Route path="register" element={<Register />} />
      </Route>
    
      <Route path="concerts">
        <Route index element={<ConcertsHome />} />
        <Route path=":city" element={<City />} />
        <Route path="trending" element={<Trending />} />
      </Route>
    </Routes>
    

[](#nested-routes)Nested Routes
-------------------------------

Routes can be nested inside parent routes.

    <Routes>
      <Route path="dashboard" element={<Dashboard />}>
        <Route index element={<Home />} />
        <Route path="settings" element={<Settings />} />
      </Route>
    </Routes>
    

The path of the parent is automatically included in the child, so this config creates both `"/dashboard"` and `"/dashboard/settings"` URLs.

Child routes are rendered through the `<Outlet/>` in the parent route.

    import { Outlet } from "react-router";
    
    export default function Dashboard() {
      return (
        <div>
          <h1>Dashboard</h1>
          {/* will either be <Home/> or <Settings/> */}
          <Outlet />
        </div>
      );
    }
    

[](#layout-routes)Layout Routes
-------------------------------

Routes _without_ a `path` create new nesting for their children, but they don't add any segments to the URL.

    <Routes>
      <Route element={<MarketingLayout />}>
        <Route index element={<MarketingHome />} />
        <Route path="contact" element={<Contact />} />
      </Route>
    
      <Route path="projects">
        <Route index element={<ProjectsHome />} />
        <Route element={<ProjectsLayout />}>
          <Route path=":pid" element={<Project />} />
          <Route path=":pid/edit" element={<EditProject />} />
        </Route>
      </Route>
    </Routes>
    

[](#index-routes)Index Routes
-----------------------------

Index routes render into their parent's `<Outlet/>` at their parent's URL (like a default child route). They are configured with the `index` prop:

    <Routes>
      <Route path="/" element={<Root />}>
        {/* renders into the outlet in <Root> at "/" */}
        <Route index element={<Home />} />
    
        <Route path="dashboard" element={<Dashboard />}>
          {/* renders into the outlet in <Dashboard> at "/dashboard" */}
          <Route index element={<DashboardHome />} />
          <Route path="settings" element={<Settings />} />
        </Route>
      </Route>
    </Routes>
    

Note that index routes can't have children. If you're expecting that behavior, you probably want a [layout route](#layout-routes).

[](#route-prefixes)Route Prefixes
---------------------------------

A `<Route path>` _without_ an `element` prop adds a path prefix to its child routes, without introducing a parent layout.

    <Route path="projects">
      <Route index element={<ProjectsHome />} />
      <Route element={<ProjectsLayout />}>
        <Route path=":pid" element={<Project />} />
        <Route path=":pid/edit" element={<EditProject />} />
      </Route>
    </Route>
    

[](#dynamic-segments)Dynamic Segments
-------------------------------------

If a path segment starts with `:` then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as `params` to other router APIs like `useParams`.

    <Route path="teams/:teamId" element={<Team />} />
    

    import { useParams } from "react-router";
    
    export default function Team() {
      let params = useParams();
      // params.teamId
    }
    

You can have multiple dynamic segments in one route path:

    <Route
      path="/c/:categoryId/p/:productId"
      element={<Product />}
    />
    

    import { useParams } from "react-router";
    
    export default function CategoryProduct() {
      let { categoryId, productId } = useParams();
      // ...
    }
    

You should ensure that all dynamic segments in a given path are unique. Otherwise, as the `params` object is populated - latter dynamic segment values will override earlier values.

[](#optional-segments)Optional Segments
---------------------------------------

You can make a route segment optional by adding a `?` to the end of the segment.

    <Route path=":lang?/categories" element={<Categories />} />
    

You can have optional static segments, too:

    <Route path="users/:userId/edit?" element={<User />} />
    

[](#splats)Splats
-----------------

Also known as "catchall" and "star" segments. If a route path pattern ends with `/*` then it will match any characters following the `/`, including other `/` characters.

    <Route path="files/*" element={<File />} />
    

    let params = useParams();
    // params["*"] will contain the remaining URL after files/
    let filePath = params["*"];
    

You can destructure the `*`, you just have to assign it a new name. A common name is `splat`:

    let { "*": splat } = useParams();
    

[](#linking)Linking
-------------------

Link to routes from your UI with `Link` and `NavLink`

    import { NavLink, Link } from "react-router";
    
    function Header() {
      return (
        <nav>
          {/* NavLink makes it easy to show active states */}
          <NavLink
            to="/"
            className={({ isActive }) =>
              isActive ? "active" : ""
            }
          >
            Home
          </NavLink>
    
          <Link to="/concerts/salt-lake-city">Concerts</Link>
        </nav>
      );
    }
    

* * *

Next: [Navigating](./navigating)

[](#navigating)Navigating
=========================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#introduction)Introduction
-----------------------------

Users navigate your application with `<Link>`, `<NavLink>`, and `useNavigate`.

[](#navlink)NavLink
-------------------

This component is for navigation links that need to render an active state.

    import { NavLink } from "react-router";
    
    export function MyAppNav() {
      return (
        <nav>
          <NavLink to="/" end>
            Home
          </NavLink>
          <NavLink to="/trending" end>
            Trending Concerts
          </NavLink>
          <NavLink to="/concerts">All Concerts</NavLink>
          <NavLink to="/account">Account</NavLink>
        </nav>
      );
    }
    

Whenever a `NavLink` is active, it will automatically have an `.active` class name for easy styling with CSS:

    a.active {
      color: red;
    }
    

It also has callback props on `className`, `style`, and `children` with the active state for inline styling or conditional rendering:

    // className
    <NavLink
      to="/messages"
      className={({ isActive }) =>
        isActive ? "text-red-500" : "text-black"
      }
    >
      Messages
    </NavLink>
    

    // style
    <NavLink
      to="/messages"
      style={({ isActive }) => ({
        color: isActive ? "red" : "black",
      })}
    >
      Messages
    </NavLink>
    

    // children
    <NavLink to="/message">
      {({ isActive }) => (
        <span className={isActive ? "active" : ""}>
          {isActive ? "👉" : ""} Tasks
        </span>
      )}
    </NavLink>
    

[](#link)Link
-------------

Use `<Link>` when the link doesn't need active styling:

    import { Link } from "react-router";
    
    export function LoggedOutMessage() {
      return (
        <p>
          You've been logged out.{" "}
          <Link to="/login">Login again</Link>
        </p>
      );
    }
    

[](#usenavigate)useNavigate
---------------------------

This hook allows the programmer to navigate the user to a new page without the user interacting.

For normal navigation, it's best to use `Link` or `NavLink`. They provide a better default user experience like keyboard events, accessibility labeling, "open in new window", right click context menus, etc.

Reserve usage of `useNavigate` to situations where the user is _not_ interacting but you need to navigate, for example:

*   After a form submission completes
*   Logging them out after inactivity
*   Timed UIs like quizzes, etc.

    import { useNavigate } from "react-router";
    
    export function LoginPage() {
      let navigate = useNavigate();
    
      return (
        <>
          <MyHeader />
          <MyLoginForm
            onSuccess={() => {
              navigate("/dashboard");
            }}
          />
          <MyFooter />
        </>
      );
    }
    

* * *

Next: [Url values](./url-values)

[](#url-values)URL Values
=========================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#route-params)Route Params
-----------------------------

Route params are the parsed values from a dynamic segment.

    <Route path="/concerts/:city" element={<City />} />
    

In this case, `:city` is the dynamic segment. The parsed value for that city will be available from `useParams`

    import { useParams } from "react-router";
    
    function City() {
      let { city } = useParams();
      let data = useFakeDataLibrary(`/api/v2/cities/${city}`);
      // ...
    }
    

[](#url-search-params)URL Search Params
---------------------------------------

Search params are the values after a `?` in the URL. They are accessible from `useSearchParams`, which returns an instance of [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)

    function SearchResults() {
      let [searchParams] = useSearchParams();
      return (
        <div>
          <p>
            You searched for <i>{searchParams.get("q")}</i>
          </p>
          <FakeSearchResults />
        </div>
      );
    }
    

[](#location-object)Location Object
-----------------------------------

React Router creates a custom `location` object with some useful information on it accessible with `useLocation`.

    function useAnalytics() {
      let location = useLocation();
      useEffect(() => {
        sendFakeAnalytics(location.pathname);
      }, [location]);
    }
    
    function useScrollRestoration() {
      let location = useLocation();
      useEffect(() => {
        fakeRestoreScroll(location.key);
      }, [location]);
    }
    

[](#upgrading-from-v6)Upgrading from v6
=======================================

React Router v7 requires the following minimum versions:

*   `node@20`
*   `react@18`
*   `react-dom@18`

The v7 upgrade has no breaking changes if you have enabled all future flags. These flags allow you to update your app one change at a time. We highly recommend you make a commit after each step and ship it instead of doing everything all at once.

[](#update-to-latest-v6x)Update to latest v6.x
----------------------------------------------

First update to the latest minor version of v6.x to have the latest future flags and console warnings.

👉 **Update to latest v6**

    npm install react-router-dom@6
    

### [](#v7_relativesplatpath)v7\_relativeSplatPath

**Background**

Changes the relative path matching and linking for multi-segment splats paths like `dashboard/*` (vs. just `*`). [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#futurev7_relativesplatpath) for more information.

👉 **Enable the flag**

Enabling the flag depends on the type of router:

    <BrowserRouter
      future={{
        v7_relativeSplatPath: true,
      }}
    />
    

    createBrowserRouter(routes, {
      future: {
        v7_relativeSplatPath: true,
      },
    });
    

**Update your Code**

If you have any routes with a path + a splat like `<Route path="dashboard/*">` that have relative links like `<Link to="relative">` or `<Link to="../relative">` beneath them, you will need to update your code.

👉 **Split the `<Route>` into two**

Split any multi-segment splat `<Route>` into a parent route with the path and a child route with the splat:

    <Routes>
      <Route path="/" element={<Home />} />
    -  <Route path="dashboard/*" element={<Dashboard />} />
    +  <Route path="dashboard">
    +    <Route path="*" element={<Dashboard />} />
    +  </Route>
    </Routes>
    
    // or
    createBrowserRouter([
      { path: "/", element: <Home /> },
      {
    -    path: "dashboard/*",
    -    element: <Dashboard />,
    +    path: "dashboard",
    +    children: [{ path: "*", element: <Dashboard /> }],
      },
    ]);
    

👉 **Update relative links**

Update any `<Link>` elements within that route tree to include the extra `..` relative segment to continue linking to the same place:

    function Dashboard() {
      return (
        <div>
          <h2>Dashboard</h2>
          <nav>
    -        <Link to="/">Dashboard Home</Link>
    -        <Link to="team">Team</Link>
    -        <Link to="projects">Projects</Link>
    +        <Link to="../">Dashboard Home</Link>
    +        <Link to="../team">Team</Link>
    +        <Link to="../projects">Projects</Link>
          </nav>
    
          <Routes>
            <Route path="/" element={<DashboardHome />} />
            <Route path="team" element={<DashboardTeam />} />
            <Route
              path="projects"
              element={<DashboardProjects />}
            />
          </Routes>
        </div>
      );
    }
    

### [](#v7_starttransition)v7\_startTransition

**Background**

This uses `React.useTransition` instead of `React.useState` for Router state updates. View the [CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#futurev7_starttransition) for more information.

👉 **Enable the flag**

    <BrowserRouter
      future={{
        v7_startTransition: true,
      }}
    />
    
    // or
    <RouterProvider
      future={{
        v7_startTransition: true,
      }}
    />
    

👉 **Update your Code**

You don't need to update anything unless you are using `React.lazy` _inside_ of a component.

Using `React.lazy` inside of a component is incompatible with `React.useTransition` (or other code that makes promises inside of components). Move `React.lazy` to the module scope and stop making promises inside of components. This is not a limitation of React Router but rather incorrect usage of React.

### [](#v7_fetcherpersist)v7\_fetcherPersist

If you are not using a `<RouterProvider>` you can skip this

**Background**

The fetcher lifecycle is now based on when it returns to an idle state rather than when its owner component unmounts: [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#persistence-future-flag-futurev7_fetcherpersist) for more information.

**Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_fetcherPersist: true,
      },
    });
    

**Update your Code**

It's unlikely to affect your app. You may want to check any usage of `useFetchers` as they may persist longer than they did before. Depending on what you're doing, you may render something longer than before.

### [](#v7_normalizeformmethod)v7\_normalizeFormMethod

If you are not using a `<RouterProvider>` you can skip this

This normalizes `formMethod` fields as uppercase HTTP methods to align with the `fetch()` behavior. [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#futurev7_normalizeformmethod) for more information.

👉 **Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_normalizeFormMethod: true,
      },
    });
    

**Update your Code**

If any of your code is checking for lowercase HTTP methods, you will need to update it to check for uppercase HTTP methods (or call `toLowerCase()` on it).

👉 **Compare `formMethod` to UPPERCASE**

    -useNavigation().formMethod === "post"
    -useFetcher().formMethod === "get";
    +useNavigation().formMethod === "POST"
    +useFetcher().formMethod === "GET";
    

### [](#v7_partialhydration)v7\_partialHydration

If you are not using a `<RouterProvider>` you can skip this

This enables partial hydration of a data router which is primarily used for SSR frameworks, but it is also useful if you are using `lazy` to load your route modules. It's unlikely you need to worry about this, just turn the flag on. [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#partial-hydration) for more information.

👉 **Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_partialHydration: true,
      },
    });
    

**Update your Code**

With partial hydration, you need to provide a `HydrateFallback` component to render during initial hydration. Additionally, if you were using `fallbackElement` before, you need to remove it as it is now deprecated. In most cases, you will want to reuse the `fallbackElement` as the `HydrateFallback`.

👉 **Replace `fallbackElement` with `HydrateFallback`**

    const router = createBrowserRouter(
      [
        {
          path: "/",
          Component: Layout,
    +      HydrateFallback: Fallback,
          // or
    +      hydrateFallbackElement: <Fallback />,
          children: [],
        },
      ],
    );
    
    
    <RouterProvider
      router={router}
    -  fallbackElement={<Fallback />}
    />
    

### [](#v7_skipactionerrorrevalidation)v7\_skipActionErrorRevalidation

If you are not using a `createBrowserRouter` you can skip this

When this flag is enabled, loaders will no longer revalidate by default after an action throws/returns a `Response` with a `4xx`/`5xx` status code. You may opt-into revalidation in these scenarios via `shouldRevalidate` and the `actionStatus` parameter.

👉 **Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_skipActionErrorRevalidation: true,
      },
    });
    

**Update your Code**

In most cases, you probably won't have to make changes to your app code. Usually, if an action errors, it's unlikely data was mutated and needs revalidation. If any of your code _does_ mutate data in action error scenarios you have 2 options:

👉 **Option 1: Change the `action` to avoid mutations in error scenarios**

    // Before
    async function action() {
      await mutateSomeData();
      if (detectError()) {
        throw new Response(error, { status: 400 });
      }
      await mutateOtherData();
      // ...
    }
    
    // After
    async function action() {
      if (detectError()) {
        throw new Response(error, { status: 400 });
      }
      // All data is now mutated after validations
      await mutateSomeData();
      await mutateOtherData();
      // ...
    }
    

👉 **Option 2: Opt-into revalidation via `shouldRevalidate` and `actionStatus`**

    async function action() {
      await mutateSomeData();
      if (detectError()) {
        throw new Response(error, { status: 400 });
      }
      await mutateOtherData();
    }
    
    async function loader() { ... }
    
    function shouldRevalidate({ actionStatus, defaultShouldRevalidate }) {
      if (actionStatus != null && actionStatus >= 400) {
        // Revalidate this loader when actions return a 4xx/5xx status
        return true;
      }
      return defaultShouldRevalidate;
    }
    

[](#deprecations)Deprecations
-----------------------------

The `json` and `defer` methods are deprecated in favor of returning raw objects.

    async function loader() {
    - return json({ data });
    + return { data };
    

If you were using `json` to serialize your data to JSON, you can use the native [Response.json()](https://developer.mozilla.org/en-US/docs/Web/API/Response/json) method instead.

[](#upgrade-to-v7)Upgrade to v7
-------------------------------

Now that your app is caught up, you can simply update to v7 (theoretically!) without issue.

👉 **Install v7**

    npm install react-router-dom@latest
    

👉 **Replace react-router-dom with react-router**

In v7 we no longer need `"react-router-dom"` as the packages have been simplified. You can import everything from `"react-router"`:

    npm uninstall react-router-dom
    npm install react-router@latest
    

Note you only need `"react-router"` in your package.json.

👉 **Update imports**

Now you should update your imports to use `react-router`:

    -import { useLocation } from "react-router-dom";
    +import { useLocation } from "react-router";
    

Instead of manually updating imports, you can use this command. Make sure your git working tree is clean though so you can revert if it doesn't work as expected.

    find ./path/to/src \( -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.jsx" \) -type f -exec sed -i '' 's|from "react-router-dom"|from "react-router"|g' {} +
    

If you have GNU `sed` installed (most Linux distributions), use this command instead:

    find ./path/to/src \( -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.jsx" \) -type f -exec sed -i 's|from "react-router-dom"|from "react-router"|g' {} +
    

👉 **Update DOM-specific imports**

`RouterProvider` and `HydratedRouter` come from a deep import because they depend on `"react-dom"`:

    -import { RouterProvider } from "react-router-dom";
    +import { RouterProvider } from "react-router/dom";
    

Note you should use a top-level import for non-DOM contexts, such as Jest tests:

    -import { RouterProvider } from "react-router-dom";
    +import { RouterProvider } from "react-router";
    

Congratulations, you're now on v7!

[](#upgrading-from-remix)Upgrading from Remix
=============================================

React Router v7 requires the following minimum versions:

*   `node@20`
*   `react@18`
*   `react-dom@18`

React Router v7 is the next major version of Remix after v2 (see our ["Incremental Path to React 19" blog post](https://remix.run/blog/incremental-path-to-react-19) for more information).

If you have enabled all [Remix v2 future flags](https://remix.run/docs/start/future-flags), upgrading from Remix v2 to React Router v7 mainly involves updating dependencies.

The majority of steps 2-8 can be automatically updated using a [codemod](https://codemod.com/registry/remix-2-react-router-upgrade) created by community member [James Restall](https://github.com/jrestall).

[](#1-adopt-future-flags)1\. Adopt future flags
-----------------------------------------------

**👉 Adopt future flags**

Adopt all existing [future flags](https://remix.run/docs/start/future-flags) in your Remix v2 application.

[](#2-update-dependencies)2\. Update dependencies
-------------------------------------------------

Most of the "shared" APIs that used to be re-exported through the runtime-specific packages (`@remix-run/node`, `@remix-run/cloudflare`, etc.) have all been collapsed into `react-router` in v7. So instead of importing from `@react-router/node` or `@react-router/cloudflare`, you'll import those directly from `react-router`.

    -import { redirect } from "@remix-run/node";
    +import { redirect } from "react-router";
    

The only APIs you should be importing from the runtime-specific packages in v7 are APIs that are specific to that runtime, such as `createFileSessionStorage` for Node and `createWorkersKVSessionStorage` for Cloudflare.

**👉 Run the codemod (automated)**

You can automatically update your packages and imports with the following [codemod](https://codemod.com/registry/remix-2-react-router-upgrade). This codemod updates all of your packages and imports. Be sure to commit any pending changes before running the codemod, in case you need to revert.

    npx codemod remix/2/react-router/upgrade
    

**👉 Install the new dependencies**

After the codemod updates your dependencies, you need to install the dependencies to remove Remix packages and add the new React Router packages.

    npm install
    

**👉 Update your dependencies (manual)**

If you prefer not to use the codemod, you can manually update your dependencies.

Expand to see a table of package name changes in alphabetical order

Remix v2 Package

React Router v7 Package

`@remix-run/architect`

➡️

`@react-router/architect`

`@remix-run/cloudflare`

➡️

`@react-router/cloudflare`

`@remix-run/dev`

➡️

`@react-router/dev`

`@remix-run/express`

➡️

`@react-router/express`

`@remix-run/fs-routes`

➡️

`@react-router/fs-routes`

`@remix-run/node`

➡️

`@react-router/node`

`@remix-run/react`

➡️

`react-router`

`@remix-run/route-config`

➡️

`@react-router/dev`

`@remix-run/routes-option-adapter`

➡️

`@react-router/remix-routes-option-adapter`

`@remix-run/serve`

➡️

`@react-router/serve`

`@remix-run/server-runtime`

➡️

`react-router`

`@remix-run/testing`

➡️

`react-router`

[](#3-change-scripts-in-packagejson)3\. Change `scripts` in `package.json`
--------------------------------------------------------------------------

If you used the codemod you can skip this step as it was automatically completed.

**👉 Update the scripts in your `package.json`**

Script

Remix v2

React Router v7

`dev`

`remix vite:dev`

➡️

`react-router dev`

`build`

`remix vite:build`

➡️

`react-router build`

`start`

`remix-serve build/server/index.js`

➡️

`react-router-serve build/server/index.js`

`typecheck`

`tsc`

➡️

`react-router typegen && tsc`

[](#4-add-a-routests-file)4\. Add a `routes.ts` file
----------------------------------------------------

If you used the codemod _and_ Remix v2 `v3_routeConfig` flag, you can skip this step as it was automatically completed.

In React Router v7 you define your routes using the `app/routes.ts` file. View the [routing documentation](../start/framework/routing) for more information.

**👉 Update dependencies (if using Remix v2 `v3_routeConfig` flag)**

    // app/routes.ts
    -import { type RouteConfig } from "@remix-run/route-config";
    -import { flatRoutes } from "@remix-run/fs-routes";
    -import { remixRoutesOptionAdapter } from "@remix-run/routes-option-adapter";
    +import { type RouteConfig } from "@react-router/dev/routes";
    +import { flatRoutes } from "@react-router/fs-routes";
    +import { remixRoutesOptionAdapter } from "@react-router/remix-routes-option-adapter";
    
    export default [
      // however your routes are defined
    ] satisfies RouteConfig;
    
    

**👉 Add a `routes.ts` file (if _not_ using Remix v2 `v3_routeConfig` flag)**

    touch app/routes.ts
    

For backwards-compatibility and for folks who prefer [file-based conventions](../how-to/file-route-conventions), you can opt-into the same "flat routes" convention you are using in Remix v2 via the new `@react-router/fs-routes` package:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default flatRoutes() satisfies RouteConfig;
    

Or, if you were using the `routes` option to define config-based routes:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { remixRoutesOptionAdapter } from "@react-router/remix-routes-option-adapter";
    
    export default remixRoutesOptionAdapter((defineRoutes) => {
      return defineRoutes((route) => {
        route("/", "home/route.tsx", { index: true });
        route("about", "about/route.tsx");
        route("", "concerts/layout.tsx", () => {
          route("trending", "concerts/trending.tsx");
          route(":city", "concerts/city.tsx");
        });
      });
    }) satisfies RouteConfig;
    

If you were using the `routes` option in your `vite.config.ts`, be sure to remove it.

    export default defineConfig({
      plugins: [
        remix({
          ssr: true,
    -     ignoredRouteFiles: ['**/*'],
    -     routes(defineRoutes) {
    -       return defineRoutes((route) => {
    -         route("/somewhere/cool/*", "catchall.tsx");
    -       });
    -     },
        })
        tsconfigPaths(),
      ],
    });
    

[](#5-add-a-react-router-config)5\. Add a React Router config
-------------------------------------------------------------

**👉 Add `react-router.config.ts` your project**

The config that was previously passed to the `remix` plugin in `vite.config.ts` is now exported from `react-router.config.ts`.

Note: At this point you should remove the v3 future flags you added in step 1.

    touch react-router.config.ts
    

    // vite.config.ts
    export default defineConfig({
      plugins: [
    -   remix({
    -     ssr: true,
    -     future: {/* all the v3 flags */}
    -   }),
    +   reactRouter(),
        tsconfigPaths(),
      ],
    });
    
    // react-router.config.ts
    +import type { Config } from "@react-router/dev/config";
    +export default {
    +  ssr: true,
    +} satisfies Config;
    

[](#6-add-react-router-plugin-to-viteconfig)6\. Add React Router plugin to `vite.config`
----------------------------------------------------------------------------------------

If you used the codemod you can skip this step as it was automatically completed.

**👉 Add `reactRouter` plugin to `vite.config`**

Change `vite.config.ts` to import and use the new `reactRouter` plugin from `@react-router/dev/vite`:

    -import { vitePlugin as remix } from "@remix-run/dev";
    +import { reactRouter } from "@react-router/dev/vite";
    import { defineConfig } from "vite";
    import tsconfigPaths from "vite-tsconfig-paths";
    
    export default defineConfig({
      plugins: [
    -   remix(),
    +   reactRouter(),
        tsconfigPaths(),
      ],
    });
    

[](#7-enable-type-safety)7\. Enable type safety
-----------------------------------------------

If you are not using TypeScript, you can skip this step.

React Router automatically generates types for your route modules into a `.react-router/` directory at the root of your app. This directory is fully managed by React Router and should be gitignore'd. Learn more about the [new type safety features](../explanation/type-safety).

**👉 Add `.react-router/` to `.gitignore`**

    .react-router/
    

**👉 Update `tsconfig.json`**

Update the `types` field in your `tsconfig.json` to include:

*   `.react-router/types/**/*` path in the `include` field
*   The appropriate `@react-router/*` package in the `types` field
*   `rootDirs` for simplified relative imports

    {
      "include": [
        /* ... */
    +   ".react-router/types/**/*"
      ],
      "compilerOptions": {
    -   "types": ["@remix-run/node", "vite/client"],
    +   "types": ["@react-router/node", "vite/client"],
        /* ... */
    +   "rootDirs": [".", "./.react-router/types"]
      }
    }
    

[](#8-rename-components-in-entry-files)8\. Rename components in entry files
---------------------------------------------------------------------------

If you used the codemod you can skip this step as it was automatically completed.

If you have an `entry.server.tsx` and/or an `entry.client.tsx` file in your application, you will need to update the main components in these files:

    -import { RemixServer } from "@remix-run/react";
    +import { ServerRouter } from "react-router";
    
    -<RemixServer context={remixContext} url={request.url} />,
    +<ServerRouter context={remixContext} url={request.url} />,
    

    -import { RemixBrowser } from "@remix-run/react";
    +import { HydratedRouter } from "react-router/dom";
    
    hydrateRoot(
      document,
      <StrictMode>
    -   <RemixBrowser />
    +   <HydratedRouter />
      </StrictMode>,
    );
    

[](#9-update-types-for-apploadcontext)9\. Update types for `AppLoadContext`
---------------------------------------------------------------------------

If you were using `remix-serve` you can skip this step. This is only applicable if you were using a custom server in Remix v2.

Since React Router can be used as both a React framework _and_ a stand-alone routing library, the `context` argument for `LoaderFunctionArgs` and `ActionFunctionArgs` is now optional and typed as `any` by default. You can register types for your load context to get type safety for your loaders and actions.

👉 **Register types for your load context**

Before you migrate to the new `Route.LoaderArgs` and `Route.ActionArgs` types, you can temporarily augment `LoaderFunctionArgs` and `ActionFunctionArgs` with your load context type to ease migration.

    declare module "react-router" {
      // Your AppLoadContext used in v2
      interface AppLoadContext {
        whatever: string;
      }
    
      // TODO: remove this once we've migrated to `Route.LoaderArgs` instead for our loaders
      interface LoaderFunctionArgs {
        context: AppLoadContext;
      }
    
      // TODO: remove this once we've migrated to `Route.ActionArgs` instead for our actions
      interface ActionFunctionArgs {
        context: AppLoadContext;
      }
    }
    
    export {}; // necessary for TS to treat this as a module
    

Using `declare module` to register types is a standard TypeScript technique called [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation). You can do this in any TypeScript file covered by your `tsconfig.json`'s `include` field, but we recommend a dedicated `env.ts` within your app directory.

👉 **Use the new types**

Once you adopt the [new type generation](../explanation/type-safety), you can remove the `LoaderFunctionArgs`/`ActionFunctionArgs` augmentations and use the `context` argument from [`Route.LoaderArgs`](../start/framework/data-loading#server-data-loading) and [`Route.ActionArgs`](../start/framework/actions#server-actions) instead.

    declare module "react-router" {
      // Your AppLoadContext used in v2
      interface AppLoadContext {
        whatever: string;
      }
    }
    
    export {}; // necessary for TS to treat this as a module
    

    import type { Route } from "./+types/my-route";
    
    export function loader({ context }: Route.LoaderArgs) {}
    // { whatever: string }  ^^^^^^^
    
    export function action({ context }: Route.ActionArgs) {}
    // { whatever: string }  ^^^^^^^
    

Congratulations! You are now on React Router v7. Go ahead and run your application to make sure everything is working as expected.

[](#framework-adoption-from-component-routes)Framework Adoption from Component Routes
=====================================================================================

If you are using `<RouterProvider>` please see [Framework Adoption from RouterProvider](./router-provider) instead.

If you are using `<Routes>` this is the right place.

The React Router Vite plugin adds framework features to React Router. This guide will help you adopt the plugin in your app. If you run into any issues, please reach out for help on [Twitter](https://x.com/remix_run) or [Discord](https://rmx.as/discord).

[](#features)Features
---------------------

The Vite plugin adds:

*   Route loaders, actions, and automatic data revalidation
*   Typesafe Routes Modules
*   Automatic route code-splitting
*   Automatic scroll restoration across navigations
*   Optional Static pre-rendering
*   Optional Server rendering

The initial setup requires the most work. However, once complete, you can adopt new features incrementally, one route at a time.

[](#prerequisites)Prerequisites
-------------------------------

To use the Vite plugin, your project requires:

*   Node.js 20+ (if using Node as your runtime)
*   Vite 5+

[](#1-install-the-vite-plugin)1\. Install the Vite plugin
---------------------------------------------------------

**👉 Install the React Router Vite plugin**

    npm install -D @react-router/dev
    

**👉 Install a runtime adapter**

We will assume you are using Node as your runtime.

    npm install @react-router/node
    

**👉 Swap out the React plugin for React Router.**

    -import react from '@vitejs/plugin-react'
    +import { reactRouter } from "@react-router/dev/vite";
    import { defineConfig } from "vite";
    
    
    export default defineConfig({
      plugins: [
    -    react()
    +    reactRouter()
      ],
    });
    

[](#2-add-the-react-router-config)2\. Add the React Router config
-----------------------------------------------------------------

**👉 Create a `react-router.config.ts` file**

Add the following to the root of your project. In this config you can tell React Router about your project, like where to find the app directory and to not use SSR (server-side rendering) for now.

    touch react-router.config.ts
    

    import type { Config } from "@react-router/dev/config";
    
    export default {
      appDirectory: "src",
      ssr: false,
    } satisfies Config;
    

[](#3-add-the-root-entry-point)3\. Add the Root entry point
-----------------------------------------------------------

In a typical Vite app, the `index.html` file is the entry point for bundling. The React Router Vite plugin moves the entry point to a `root.tsx` file so you can use React to render the shell of your app instead of static HTML, and eventually upgrade to Server Rendering if you want.

**👉 Move your existing `index.html` to `root.tsx`**

For example, if your current `index.html` looks like this:

    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1.0"
        />
        <title>My App</title>
      </head>
      <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
      </body>
    </html>
    

You would move that markup into `src/root.tsx` and delete `index.html`:

    touch src/root.tsx
    

    import {
      Links,
      Meta,
      Outlet,
      Scripts,
      ScrollRestoration,
    } from "react-router";
    
    export function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <head>
            <meta charSet="UTF-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1.0"
            />
            <title>My App</title>
            <Meta />
            <Links />
          </head>
          <body>
            {children}
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    
    export default function Root() {
      return <Outlet />;
    }
    

[](#4-add-client-entry-module)4\. Add client entry module
---------------------------------------------------------

In the typical Vite app the `index.html` file points to `src/main.tsx` as the client entry point. React Router uses a file named `src/entry.client.tsx` instead.

**👉 Make `src/entry.client.tsx` your entry point**

If your current `src/main.tsx` looks like this:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { BrowserRouter } from "react-router";
    import "./index.css";
    import App from "./App";
    
    ReactDOM.createRoot(
      document.getElementById("root")!
    ).render(
      <React.StrictMode>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </React.StrictMode>
    );
    

You would rename it to `entry.client.tsx` and change it to this:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { HydratedRouter } from "react-router/dom";
    import "./index.css";
    
    ReactDOM.hydrateRoot(
      document,
      <React.StrictMode>
        <HydratedRouter />
      </React.StrictMode>
    );
    

*   Use `hydrateRoot` instead of `createRoot`
*   Render a `<HydratedRouter>` instead of your `<App/>` component
*   Note: we stopped rendering the `<App/>` component. We'll bring it back in a later step, but first we want to get the app to boot with the new entry point.

[](#5-shuffle-stuff-around)5\. Shuffle stuff around
---------------------------------------------------

Between `root.tsx` and `entry.client.tsx`, you may want to shuffle some stuff around between them.

In general:

*   `root.tsx` contains any rendering things like context providers, layouts, styles, etc.
*   `entry.client.tsx` should be as minimal as possible
*   Remember to _not_ try to render your existing `<App/>` component yet, we'll do that in a later step

Note that your `root.tsx` file will be statically generated and served as the entry point of your app, so just that module will need to be compatible with server rendering. This is where most of your trouble will come.

[](#6-set-up-your-routes)6\. Set up your routes
-----------------------------------------------

The React Router Vite plugin uses a `routes.ts` file to configure your routes. For now we'll add a simple catchall route to get things going.

**👉 Set up a `catchall.tsx` route**

    touch src/routes.ts src/catchall.tsx
    

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      // * matches all URLs, the ? makes it optional so it will match / as well
      route("*?", "catchall.tsx"),
    ] satisfies RouteConfig;
    

**👉 Render a placeholder route**

Eventually we'll replace this with our original `App` component, but for now we'll just render something simple to make sure we can boot the app.

    export default function Component() {
      return <div>Hello, world!</div>;
    }
    

[View our guide on configuring routes](../start/framework/routing) to learn more about the `routes.ts` file.

[](#7-boot-the-app)7\. Boot the app
-----------------------------------

At this point you should be able to to boot the app and see the root layout.

**👉 Add `dev` script and run the app**

    "scripts": {
      "dev": "react-router dev"
    }
    

Now make sure you can boot your app at this point before moving on:

    npm run dev
    

You will probably want to add `.react-router/` to your `.gitignore` file to avoid tracking unnecessary files in your repository.

    .react-router/
    

You can check out [Type Safety](../how-to/route-module-type-safety) to learn how to fully set up and use autogenerated type safety for params, loader data, and more.

[](#8-render-your-app)8\. Render your app
-----------------------------------------

To get back to rendering your app, we'll update the "catchall" route we set up earlier that matches all URLs so that your existing `<Routes>` get a chance to render.

**👉 Update the catchall route to render your app**

    import App from "./App";
    
    export default function Component() {
      return <App />;
    }
    

Your app should be back on the screen and working as usual!

[](#9-migrate-a-route-to-a-route-module)9\. Migrate a route to a Route Module
-----------------------------------------------------------------------------

You can now incrementally migrate your routes to route modules.

Given an existing route like this:

    // ...
    import About from "./containers/About";
    
    export default function App() {
      return (
        <Routes>
          <Route path="/about" element={<About />} />
        </Routes>
      );
    }
    

**👉 Add the route definition to `routes.ts`**

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("/about", "./pages/about.tsx"),
      route("*?", "catchall.tsx"),
    ] satisfies RouteConfig;
    

**👉 Add the route module**

Edit the route module to use the [Route Module API](../start/framework/route-module):

    export async function clientLoader() {
      // you can now fetch data here
      return {
        title: "About page",
      };
    }
    
    export default function Component({ loaderData }) {
      return <h1>{loaderData.title}</h1>;
    }
    

See [Type Safety](../how-to/route-module-type-safety) to set up autogenerated type safety for params, loader data, and more.

The first few routes you migrate are the hardest because you often have to access various abstractions a bit differently than before (like in a loader instead of from a hook or context). But once the trickiest bits get dealt with, you get into an incremental groove.

[](#enable-ssr-andor-pre-rendering)Enable SSR and/or Pre-rendering
------------------------------------------------------------------

If you want to enable server rendering and static pre-rendering, you can do so with the `ssr` and `prerender` options in the bundler plugin. For SSR you'll need to also deploy the server build to a server.

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: true,
      async prerender() {
        return ["/", "/about", "/contact"];
      },
    } satisfies Config;
    

[](#future-flags-and-deprecations)Future Flags and Deprecations
===============================================================

This guide walks you through the process of adopting future flags in your React Router app. By following this strategy, you will be able to upgrade to the next major version of React Router with minimal changes. To read more about future flags see [API Development Strategy](../community/api-development-strategy).

We highly recommend you make a commit after each step and ship it instead of doing everything all at once. Most flags can be adopted in any order, with exceptions noted below.

**There are no current future flags in React Router v7**

[](#framework-adoption-from-routerprovider)Framework Adoption from RouterProvider
=================================================================================

If you are not using `<RouterProvider>` please see [Framework Adoption from Component Routes](./component-routes) instead.

The React Router Vite plugin adds framework features to React Router. This guide will help you adopt the plugin in your app. If you run into any issues, please reach out for help on [Twitter](https://x.com/remix_run) or [Discord](https://rmx.as/discord).

[](#features)Features
---------------------

The Vite plugin adds:

*   Route loaders, actions, and automatic data revalidation
*   Typesafe Routes Modules
*   Automatic route code-splitting
*   Automatic scroll restoration across navigations
*   Optional Static pre-rendering
*   Optional Server rendering

The initial setup requires the most work. However, once complete, you can adopt new features incrementally.

[](#prerequisites)Prerequisites
-------------------------------

To use the Vite plugin, your project requires:

*   Node.js 20+ (if using Node as your runtime)
*   Vite 5+

[](#1-move-route-definitions-into-route-modules)1\. Move route definitions into route modules
---------------------------------------------------------------------------------------------

The React Router Vite plugin renders its own `RouterProvider`, so you can't render an existing `RouterProvider` within it. Instead, you will need to format all of your route definitions to match the [Route Module API](../start/framework/route-module).

This step will take the longest, however there are several benefits to doing this regardless of adopting the React Router Vite plugin:

*   Route modules will be lazy loaded, decreasing the initial bundle size of your app
*   Route definitions will be uniform, simplifying your app's architecture
*   Moving to route modules is incremental, you can migrate one route at a time

**👉 Move your route definitions into route modules**

Export each piece of your route definition as a separate named export, following the [Route Module API](../start/framework/route-module).

    export async function clientLoader() {
      return {
        title: "About",
      };
    }
    
    export default function About() {
      let data = useLoaderData();
      return <div>{data.title}</div>;
    }
    
    // clientAction, ErrorBoundary, etc.
    

**👉 Create a convert function**

Create a helper function to convert route module definitions into the format expected by your data router:

    function convert(m: any) {
      let {
        clientLoader,
        clientAction,
        default: Component,
        ...rest
      } = m;
      return {
        ...rest,
        loader: clientLoader,
        action: clientAction,
        Component,
      };
    }
    

**👉 Lazy load and convert your route modules**

Instead of importing your route modules directly, lazy load and convert them to the format expected by your data router.

Not only does your route definition now conform to the Route Module API, but you also get the benefits of code-splitting your routes.

    let router = createBrowserRouter([
      // ... other routes
      {
        path: "about",
    -   loader: aboutLoader,
    -   Component: About,
    +   lazy: () => import("./routes/about").then(convert),
      },
      // ... other routes
    ]);
    

Repeat this process for each route in your app.

[](#2-install-the-vite-plugin)2\. Install the Vite plugin
---------------------------------------------------------

Once all of your route definitions are converted to route modules, you can adopt the React Router Vite plugin.

**👉 Install the React Router Vite plugin**

    npm install -D @react-router/dev
    

**👉 Install a runtime adapter**

We will assume you are using Node as your runtime.

    npm install @react-router/node
    

**👉 Swap out the React plugin for React Router**

    -import react from '@vitejs/plugin-react'
    +import { reactRouter } from "@react-router/dev/vite";
    import { defineConfig } from "vite";
    
    
    export default defineConfig({
      plugins: [
    -    react()
    +    reactRouter()
      ],
    });
    

[](#3-add-the-react-router-config)3\. Add the React Router config
-----------------------------------------------------------------

**👉 Create a `react-router.config.ts` file**

Add the following to the root of your project. In this config you can tell React Router about your project, like where to find the app directory and to not use SSR (server-side rendering) for now.

    touch react-router.config.ts
    

    import type { Config } from "@react-router/dev/config";
    
    export default {
      appDirectory: "src",
      ssr: false,
    } satisfies Config;
    

[](#4-add-the-root-entry-point)4\. Add the Root entry point
-----------------------------------------------------------

In a typical Vite app, the `index.html` file is the entry point for bundling. The React Router Vite plugin moves the entry point to a `root.tsx` file so you can use React to render the shell of your app instead of static HTML, and eventually upgrade to Server Rendering if you want.

**👉 Move your existing `index.html` to `root.tsx`**

For example, if your current `index.html` looks like this:

    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1.0"
        />
        <title>My App</title>
      </head>
      <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
      </body>
    </html>
    

You would move that markup into `src/root.tsx` and delete `index.html`:

    touch src/root.tsx
    

    import {
      Links,
      Meta,
      Outlet,
      Scripts,
      ScrollRestoration,
    } from "react-router";
    
    export function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <head>
            <meta charSet="UTF-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1.0"
            />
            <title>My App</title>
            <Meta />
            <Links />
          </head>
          <body>
            {children}
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    
    export default function Root() {
      return <Outlet />;
    }
    

**👉 Move everything above `RouterProvider` to `root.tsx`**

Any global styles, context providers, etc. should be moved into `root.tsx` so they can be shared across all routes.

For example, if your `App.tsx` looks like this:

    import "./index.css";
    
    export default function App() {
      return (
        <OtherProviders>
          <AppLayout>
            <RouterProvider router={router} />
          </AppLayout>
        </OtherProviders>
      );
    }
    

You would move everything above the `RouterProvider` into `root.tsx`.

    +import "./index.css";
    
    // ... other imports and Layout
    
    export default function Root() {
      return (
    +   <OtherProviders>
    +     <AppLayout>
            <Outlet />
    +     </AppLayout>
    +   </OtherProviders>
      );
    }
    

[](#5-add-client-entry-module-optional)5\. Add client entry module (optional)
-----------------------------------------------------------------------------

In the typical Vite app the `index.html` file points to `src/main.tsx` as the client entry point. React Router uses a file named `src/entry.client.tsx` instead.

If no `entry.client.tsx` exists, the React Router Vite plugin will use a default, hidden one.

**👉 Make `src/entry.client.tsx` your entry point**

If your current `src/main.tsx` looks like this:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { BrowserRouter } from "react-router";
    import App from "./App";
    
    const router = createBrowserRouter([
      // ... route definitions
    ]);
    
    ReactDOM.createRoot(
      document.getElementById("root")!
    ).render(
      <React.StrictMode>
        <RouterProvider router={router} />;
      </React.StrictMode>
    );
    

You would rename it to `entry.client.tsx` and change it to this:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { HydratedRouter } from "react-router/dom";
    
    ReactDOM.hydrateRoot(
      document,
      <React.StrictMode>
        <HydratedRouter />
      </React.StrictMode>
    );
    

*   Use `hydrateRoot` instead of `createRoot`
*   Render a `<HydratedRouter>` instead of your `<App/>` component
*   Note: We are no longer creating the routes and manually passing them to `<RouterProvider />`. We will migrate our route definitions in the next step.

[](#6-migrate-your-routes)6\. Migrate your routes
-------------------------------------------------

The React Router Vite plugin uses a `routes.ts` file to configure your routes. The format will be pretty similar to the definitions of your data router.

**👉 Move definitions to a `routes.ts` file**

    touch src/routes.ts src/catchall.tsx
    

Move your route definitions to `routes.ts`. Note that the schemas don't match exactly, so you will get type errors; we'll fix this next.

    +import type { RouteConfig } from "@react-router/dev/routes";
    
    -const router = createBrowserRouter([
    +export default [
      {
        path: "/",
        lazy: () => import("./routes/layout").then(convert),
        children: [
          {
            index: true,
            lazy: () => import("./routes/home").then(convert),
          },
          {
            path: "about",
            lazy: () => import("./routes/about").then(convert),
          },
          {
            path: "todos",
            lazy: () => import("./routes/todos").then(convert),
            children: [
              {
                path: ":id",
                lazy: () =>
                  import("./routes/todo").then(convert),
              },
            ],
          },
        ],
      },
    -]);
    +] satisfies RouteConfig;
    

**👉 Replace the `lazy` loader with a `file` loader**

    export default [
      {
        path: "/",
    -   lazy: () => import("./routes/layout").then(convert),
    +   file: "./routes/layout.tsx",
        children: [
          {
            index: true,
    -       lazy: () => import("./routes/home").then(convert),
    +       file: "./routes/home.tsx",
          },
          {
            path: "about",
    -       lazy: () => import("./routes/about").then(convert),
    +       file: "./routes/about.tsx",
          },
          {
            path: "todos",
    -       lazy: () => import("./routes/todos").then(convert),
    +       file: "./routes/todos.tsx",
            children: [
              {
                path: ":id",
    -           lazy: () => import("./routes/todo").then(convert),
    +           file: "./routes/todo.tsx",
              },
            ],
          },
        ],
      },
    ] satisfies RouteConfig;
    

[View our guide on configuring routes](../start/framework/routing) to learn more about the `routes.ts` file and helper functions to further simplify the route definitions.

[](#7-boot-the-app)7\. Boot the app
-----------------------------------

At this point you should be fully migrated to the React Router Vite plugin. Go ahead and update your `dev` script and run the app to make sure everything is working.

**👉 Add `dev` script and run the app**

    "scripts": {
      "dev": "react-router dev"
    }
    

Now make sure you can boot your app at this point before moving on:

    npm run dev
    

You will probably want to add `.react-router/` to your `.gitignore` file to avoid tracking unnecessary files in your repository.

    .react-router/
    

You can checkout [Type Safety](../how-to/route-module-type-safety) to learn how to fully setup and use autogenerated type safety for params, loader data, and more.

[](#enable-ssr-andor-pre-rendering)Enable SSR and/or Pre-rendering
------------------------------------------------------------------

If you want to enable server rendering and static pre-rendering, you can do so with the `ssr` and `prerender` options in the bundler plugin. For SSR you'll need to also deploy the server build to a server.

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: true,
      async prerender() {
        return ["/", "/about", "/contact"];
      },
    } satisfies Config;
    

[](#await)Await
===============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Await.html)

Used to render promise values with automatic error handling.

    import { Await, useLoaderData } from "react-router";
    
    export function loader() {
      // not awaited
      const reviews = getReviews();
      // awaited (blocks the transition)
      const book = await fetch("/api/book").then((res) =>
        res.json()
      );
      return { book, reviews };
    }
    
    function Book() {
      const { book, reviews } = useLoaderData();
      return (
        <div>
          <h1>{book.title}</h1>
          <p>{book.description}</p>
          <React.Suspense fallback={<ReviewsSkeleton />}>
            <Await
              resolve={reviews}
              errorElement={
                <div>Could not load reviews 😬</div>
              }
              children={(resolvedReviews) => (
                <Reviews items={resolvedReviews} />
              )}
            />
          </React.Suspense>
        </div>
      );
    }
    

`<Await>` expects to be rendered inside of a `<React.Suspense>`

[](#props)Props
---------------

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

When using a function, the resolved value is provided as the parameter.

    <Await resolve={reviewsPromise}>
      {(resolvedReviews) => <Reviews items={resolvedReviews} />}
    </Await>
    

When using React elements, [useAsyncValue](../hooks/useAsyncValue) will provide the resolved value:

    <Await resolve={reviewsPromise}>
      <Reviews />
    </Await>;
    
    function Reviews() {
      const resolvedReviews = useAsyncValue();
      return <div>...</div>;
    }
    

### [](#errorelement)errorElement

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The error element renders instead of the children when the promise rejects.

    <Await
      errorElement={<div>Oops</div>}
      resolve={reviewsPromise}
    >
      <Reviews />
    </Await>
    

To provide a more contextual error, you can use the [useAsyncError](../hooks/useAsyncError) in a child component

    <Await
      errorElement={<ReviewsError />}
      resolve={reviewsPromise}
    >
      <Reviews />
    </Await>;
    
    function ReviewsError() {
      const error = useAsyncError();
      return <div>Error loading reviews: {error.message}</div>;
    }
    

If you do not provide an errorElement, the rejected value will bubble up to the nearest route-level ErrorBoundary and be accessible via [useRouteError](../hooks/useRouteError) hook.

### [](#resolve)resolve

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Takes a promise returned from a [LoaderFunction](../Other/LoaderFunction) value to be resolved and rendered.

    import { useLoaderData, Await } from "react-router";
    
    export async function loader() {
      let reviews = getReviews(); // not awaited
      let book = await getBook();
      return {
        book,
        reviews, // this is a promise
      };
    }
    
    export default function Book() {
      const {
        book,
        reviews, // this is the same promise
      } = useLoaderData();
    
      return (
        <div>
          <h1>{book.title}</h1>
          <p>{book.description}</p>
          <React.Suspense fallback={<ReviewsSkeleton />}>
            <Await
              // and is the promise we pass to Await
              resolve={reviews}
            >
              <Reviews />
            </Await>
          </React.Suspense>
        </div>
      );
    }
    

[](#form)Form
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Form.html)

A progressively enhanced HTML [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) that submits data to actions via `fetch`, activating pending states in `useNavigation` which enables advanced user interfaces beyond a basic HTML form. After a form's action completes, all data on the page is automatically revalidated to keep the UI in sync with the data.

Because it uses the HTML form API, server rendered pages are interactive at a basic level before JavaScript loads. Instead of React Router managing the submission, the browser manages the submission as well as the pending states (like the spinning favicon). After JavaScript loads, React Router takes over enabling web application user experiences.

Form is most useful for submissions that should also change the URL or otherwise add an entry to the browser history stack. For forms that shouldn't manipulate the browser history stack, use \[`<fetcher.Form>`\]\[fetcher\_form\].

    import { Form } from "react-router";
    
    function NewEvent() {
      return (
        <Form action="/events" method="post">
          <input name="title" type="text" />
          <input name="description" type="text" />
        </Form>
      );
    }
    

[](#props)Props
---------------

### [](#action)action

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The URL to submit the form data to. If `undefined`, this defaults to the closest route in context.

### [](#discover)discover

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Determines application manifest discovery behavior.

### [](#enctype)encType

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The encoding type to use for the form submission.

### [](#fetcherkey)fetcherKey

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Indicates a specific fetcherKey to use when using `navigate={false}` so you can pick up the fetcher's state in a different component in a [useFetcher](../hooks/useFetcher).

### [](#method)method

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The HTTP verb to use when the form is submitted. Supports "get", "post", "put", "delete", and "patch".

Native `<form>` only supports `get` and `post`, avoid the other verbs if you'd like to support progressive enhancement

### [](#navigate)navigate

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Skips the navigation and uses a [useFetcher](../hooks/useFetcher) internally when `false`. This is essentially a shorthand for `useFetcher()` + `<fetcher.Form>` where you don't care about the resulting data in this component.

### [](#onsubmit)onSubmit

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

A function to call when the form is submitted. If you call `event.preventDefault()` then this form will not do anything.

### [](#preventscrollreset)preventScrollReset

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Prevent the scroll position from resetting to the top of the viewport on completion of the navigation when using the component

### [](#relative)relative

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Determines whether the form action is relative to the route hierarchy or the pathname. Use this if you want to opt out of navigating the route hierarchy and want to instead route based on /-delimited URL segments

### [](#reloaddocument)reloadDocument

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Forces a full document navigation instead of client side routing + data fetch.

### [](#replace)replace

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Replaces the current entry in the browser history stack when the form navigates. Use this if you don't want the user to be able to click "back" to the page with the form on it.

### [](#state)state

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

State object to add to the history stack entry for this navigation

### [](#viewtransition)viewTransition

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Enables a [View Transition](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) for this navigation. To apply specific styles during the transition see [useViewTransitionState](../hooks/useViewTransitionState).

[](#link)Link
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Link.html)

A progressively enhanced `<a href>` wrapper to enable navigation with client-side routing.

    import { Link } from "react-router";
    
    <Link to="/dashboard">Dashboard</Link>;
    
    <Link
      to={{
        pathname: "/some/path",
        search: "?query=string",
        hash: "#hash",
      }}
    />;
    

[](#props)Props
---------------

### [](#discover)discover

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Defines the link discovery behavior

    <Link discover="render" />
    

*   **render** - default, discover the route when the link renders
*   **none** - don't eagerly discover, only discover if the link is clicked

### [](#prefetch)prefetch

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Defines the data and module prefetching behavior for the link.

    <Link prefetch="intent" />
    

*   **none** - default, no prefetching
*   **intent** - prefetches when the user hovers or focuses the link
*   **render** - prefetches when the link renders
*   **viewport** - prefetches when the link is in the viewport, very useful for mobile

Prefetching is done with HTML `<link rel="prefetch">` tags. They are inserted after the link.

    <a href="..." />
    <a href="..." />
    <link rel="prefetch" /> // might conditionally render
    

Because of this, if you are using `nav :last-child` you will need to use `nav :last-of-type` so the styles don't conditionally fall off your last link (and any other similar selectors).

### [](#preventscrollreset)preventScrollReset

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Prevents the scroll position from being reset to the top of the window when the link is clicked and the app is using [ScrollRestoration](../components/ScrollRestoration). This only prevents new locations reseting scroll to the top, scroll position will be restored for back/forward button navigation.

    <Link to="?tab=one" preventScrollReset />
    

### [](#relative)relative

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Defines the relative path behavior for the link.

    <Link to=".." /> // default: "route"
    <Link relative="route" />
    <Link relative="path" />
    

Consider a route hierarchy where a parent route pattern is "blog" and a child route pattern is "blog/:slug/edit".

*   **route** - default, resolves the link relative to the route pattern. In the example above a relative link of `".."` will remove both `:slug/edit` segments back to "/blog".
*   **path** - relative to the path so `..` will only remove one URL segment up to "/blog/:slug"

Note that index routes and layout routes have no paths so they are not included in the relative path calculation.

### [](#reloaddocument)reloadDocument

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Will use document navigation instead of client side routing when the link is clicked: the browser will handle the transition normally (as if it were an `<a href>`).

    <Link to="/logout" reloadDocument />
    

### [](#replace)replace

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Replaces the current entry in the history stack instead of pushing a new one onto it.

    <Link replace />
    

    # with a history stack like this
    A -> B
    
    # normal link click pushes a new entry
    A -> B -> C
    
    # but with `replace`, B is replaced by C
    A -> C
    

### [](#state)state

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Adds persistent client side routing state to the next location.

    <Link to="/somewhere/else" state={{ some: "value" }} />
    

The location state is accessed from the `location`.

    function SomeComp() {
      const location = useLocation();
      location.state; // { some: "value" }
    }
    

This state is inaccessible on the server as it is implemented on top of [`history.state`](https://developer.mozilla.org/en-US/docs/Web/API/History/state)

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Can be a string or a partial [Path](../Other/Path):

    <Link to="/some/path" />
    
    <Link
      to={{
        pathname: "/some/path",
        search: "?query=string",
        hash: "#hash",
      }}
    />
    

### [](#viewtransition)viewTransition

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Enables a [View Transition](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) for this navigation.

    <Link to={to} viewTransition>
      Click me
    </Link>
    

To apply specific styles for the transition, see [useViewTransitionState](../hooks/useViewTransitionState)

[](#links)Links
===============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Links.html)

Renders all of the `<link>` tags created by route module [`links`](../../start/framework/route-module#links) export. You should render it inside the `<head>` of your document.

    import { Links } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head>
            <Links />
          </head>
          <body></body>
        </html>
      );
    }
    

[](#props)Props
---------------

None

[](#meta)Meta
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Meta.html)

Renders all the `<meta>` tags created by route module [`meta`](../../start/framework/route-module#meta) export. You should render it inside the `<head>` of your HTML.

    import { Meta } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head>
            <Meta />
          </head>
        </html>
      );
    }
    

[](#props)Props
---------------

None

[](#navlink)NavLink
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.NavLink.html)

Wraps [Link](../components/Link) with additional props for styling active and pending states.

*   Automatically applies classes to the link based on its active and pending states, see NavLinkProps.className.
*   Automatically applies `aria-current="page"` to the link when the link is active. See [`aria-current`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current) on MDN.

    import { NavLink } from "react-router";
    <NavLink to="/message" />;
    

States are available through the className, style, and children render props. See [NavLinkRenderProps](../Other/NavLinkRenderProps).

    <NavLink
      to="/messages"
      className={({ isActive, isPending }) =>
        isPending ? "pending" : isActive ? "active" : ""
      }
    >
      Messages
    </NavLink>
    

[](#props)Props
---------------

### [](#casesensitive)caseSensitive

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Changes the matching logic to make it case-sensitive:

Link

URL

isActive

`<NavLink to="/SpOnGe-bOB" />`

`/sponge-bob`

true

`<NavLink to="/SpOnGe-bOB" caseSensitive />`

`/sponge-bob`

false

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Can be regular React children or a function that receives an object with the active and pending states of the link.

    <NavLink to="/tasks">
      {({ isActive }) => (
        <span className={isActive ? "active" : ""}>Tasks</span>
      )}
    </NavLink>
    

### [](#classname)className

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Classes are automatically applied to NavLink that correspond to the state.

    a.active {
      color: red;
    }
    a.pending {
      color: blue;
    }
    a.transitioning {
      view-transition-name: my-transition;
    }
    

Note that `pending` is only available with Framework and Data modes.

### [](#discover)discover

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Defines the link discovery behavior

    <Link discover="render" />
    

*   **render** - default, discover the route when the link renders
*   **none** - don't eagerly discover, only discover if the link is clicked

### [](#end)end

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Changes the matching logic for the `active` and `pending` states to only match to the "end" of the NavLinkProps.to. If the URL is longer, it will no longer be considered active.

Link

URL

isActive

`<NavLink to="/tasks" />`

`/tasks`

true

`<NavLink to="/tasks" />`

`/tasks/123`

true

`<NavLink to="/tasks" end />`

`/tasks`

true

`<NavLink to="/tasks" end />`

`/tasks/123`

false

`<NavLink to="/">` is an exceptional case because _every_ URL matches `/`. To avoid this matching every single route by default, it effectively ignores the `end` prop and only matches when you're at the root route.

### [](#prefetch)prefetch

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Defines the data and module prefetching behavior for the link.

    <Link prefetch="intent" />
    

*   **none** - default, no prefetching
*   **intent** - prefetches when the user hovers or focuses the link
*   **render** - prefetches when the link renders
*   **viewport** - prefetches when the link is in the viewport, very useful for mobile

Prefetching is done with HTML `<link rel="prefetch">` tags. They are inserted after the link.

    <a href="..." />
    <a href="..." />
    <link rel="prefetch" /> // might conditionally render
    

Because of this, if you are using `nav :last-child` you will need to use `nav :last-of-type` so the styles don't conditionally fall off your last link (and any other similar selectors).

### [](#preventscrollreset)preventScrollReset

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

Prevents the scroll position from being reset to the top of the window when the link is clicked and the app is using [ScrollRestoration](../components/ScrollRestoration). This only prevents new locations reseting scroll to the top, scroll position will be restored for back/forward button navigation.

    <Link to="?tab=one" preventScrollReset />
    

### [](#relative)relative

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Defines the relative path behavior for the link.

    <Link to=".." /> // default: "route"
    <Link relative="route" />
    <Link relative="path" />
    

Consider a route hierarchy where a parent route pattern is "blog" and a child route pattern is "blog/:slug/edit".

*   **route** - default, resolves the link relative to the route pattern. In the example above a relative link of `".."` will remove both `:slug/edit` segments back to "/blog".
*   **path** - relative to the path so `..` will only remove one URL segment up to "/blog/:slug"

### [](#reloaddocument)reloadDocument

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Will use document navigation instead of client side routing when the link is clicked: the browser will handle the transition normally (as if it were an `<a href>`).

    <Link to="/logout" reloadDocument />
    

### [](#replace)replace

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Replaces the current entry in the history stack instead of pushing a new one onto it.

    <Link replace />
    

    # with a history stack like this
    A -> B
    
    # normal link click pushes a new entry
    A -> B -> C
    
    # but with `replace`, B is replaced by C
    A -> C
    

### [](#state)state

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Adds persistent client side routing state to the next location.

    <Link to="/somewhere/else" state={{ some: "value" }} />
    

The location state is accessed from the `location`.

    function SomeComp() {
      const location = useLocation();
      location.state; // { some: "value" }
    }
    

This state is inaccessible on the server as it is implemented on top of [`history.state`](https://developer.mozilla.org/en-US/docs/Web/API/History/state)

### [](#style)style

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Regular React style object or a function that receives an object with the active and pending states of the link.

    <NavLink to="/tasks" style={{ color: "red" }} />
    <NavLink to="/tasks" style={({ isActive, isPending }) => ({
      color:
        isActive ? "red" :
        isPending ? "blue" : "black"
    })} />
    

Note that `pending` is only available with Framework and Data modes.

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Can be a string or a partial [Path](../Other/Path):

    <Link to="/some/path" />
    
    <Link
      to={{
        pathname: "/some/path",
        search: "?query=string",
        hash: "#hash",
      }}
    />
    

### [](#viewtransition)viewTransition

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Enables a [View Transition](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) for this navigation.

    <Link to={to} viewTransition>
      Click me
    </Link>
    

To apply specific styles for the transition, see [useViewTransitionState](../hooks/useViewTransitionState)

[](#navigate)Navigate
=====================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Navigate.html)

A component-based version of [useNavigate](../hooks/useNavigate) to use in a [`React.Component Class`](https://reactjs.org/docs/react-component.html) where hooks are not able to be used.

It's recommended to avoid using this component in favor of [useNavigate](../hooks/useNavigate)

    <Navigate to="/tasks" />
    

[](#props)Props
---------------

### [](#relative)relative

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#replace)replace

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#state)state

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#outlet)Outlet
=================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Outlet.html)

Renders the matching child route of a parent route or nothing if no child route matches.

    import { Outlet } from "react-router";
    
    export default function SomeParent() {
      return (
        <div>
          <h1>Parent Content</h1>
          <Outlet />
        </div>
      );
    }
    

[](#props)Props
---------------

### [](#context)context

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Provides a context value to the element tree below the outlet. Use when the parent route needs to provide values to child routes.

    <Outlet context={myContextValue} />
    

Access the context with [useOutletContext](../hooks/useOutletContext).

[](#prefetchpagelinks)PrefetchPageLinks
=======================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.PrefetchPageLinks.html)

Renders `<link rel=prefetch|modulepreload>` tags for modules and data of another page to enable an instant navigation to that page. `<Link prefetch>` uses this internally, but you can render it to prefetch a page for any other reason.

    import { PrefetchPageLinks } from "react-router";
    
    <PrefetchPageLinks page="/absolute/path" />;
    

For example, you may render one of this as the user types into a search field to prefetch search results before they click through to their selection.

[](#props)Props
---------------

### [](#crossorigin)crossOrigin

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

How the element handles crossorigin requests

### [](#disabled)disabled

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Whether the link is disabled

### [](#hreflang)hrefLang

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Language of the linked resource

### [](#integrity)integrity

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Integrity metadata used in Subresource Integrity checks

### [](#media)media

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Applicable media: "screen", "print", "(max-width: 764px)"

### [](#page)page

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

The absolute path of the page to prefetch.

### [](#referrerpolicy)referrerPolicy

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

Referrer policy for fetches initiated by the element

[](#route)Route
===============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Route.html)

Configures an element to render when a pattern matches the current location. It must be rendered within a [Routes](../components/Routes) element. Note that these routes do not participate in data loading, actions, code splitting, or any other route module features.

[](#props)Props
---------------

### [](#casesensitive)caseSensitive

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Whether the path should be matched in a case-sensitive manner.

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#component)Component

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#element)element

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#path)path

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

The path to match against the current location.

[](#routes)Routes
=================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Routes.html)

Renders a branch of [Route](../components/Route) that best matches the current location. Note that these routes do not participate in data loading, actions, code splitting, or any other route module features.

    import { Routes, Route } from "react-router"
    
    <Routes>
     <Route index element={<StepOne />} />
     <Route path="step-2" element={<StepTwo />} />
     <Route path="step-3" element={<StepThree />} />
    </Routes>
    

[](#props)Props
---------------

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

Nested [Route](../components/Route) elements

### [](#location)location

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

The location to match against. Defaults to the current location.

[](#scripts)Scripts
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Scripts.html)

Renders the client runtime of your app. It should be rendered inside the `<body>` of the document.

    import { Scripts } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <head />
          <body>
            <Scripts />
          </body>
        </html>
      );
    }
    

If server rendering, you can omit `<Scripts/>` and the app will work as a traditional web app without JavaScript, relying solely on HTML and browser behaviors.

[](#props)Props
---------------

### [](#scriptsprops)ScriptsProps

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

A couple common attributes:

*   `<Scripts crossOrigin>` for hosting your static assets on a different server than your app.
*   `<Scripts nonce>` to support a [content security policy for scripts](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src) with [nonce-sources](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources) for your `<script>` tags.

You cannot pass through attributes such as `async`, `defer`, `src`, `type`, `noModule` because they are managed by React Router internally.

[](#scrollrestoration)ScrollRestoration
=======================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.ScrollRestoration.html)

Emulates the browser's scroll restoration on location changes. Apps should only render one of these, right before the [Scripts](../components/Scripts) component.

    import { ScrollRestoration } from "react-router";
    
    export default function Root() {
      return (
        <html>
          <body>
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    

This component renders an inline `<script>` to prevent scroll flashing. The `nonce` prop will be passed down to the script tag to allow CSP nonce usage.

    <ScrollRestoration nonce={cspNonce} />
    

[](#props)Props
---------------

### [](#scriptsprops)ScriptsProps

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

A couple common attributes:

*   `<Scripts crossOrigin>` for hosting your static assets on a different server than your app.
*   `<Scripts nonce>` to support a [content security policy for scripts](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src) with [nonce-sources](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources) for your `<script>` tags.

You cannot pass through attributes such as `async`, `defer`, `src`, `type`, `noModule` because they are managed by React Router internally.

[](#serverrouter)ServerRouter
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.ServerRouter.html)

Rendered at the top of the app in a custom entry.server.tsx.

[](#props)Props
---------------

### [](#context)context

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#nonce)nonce

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#url)url

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#unstable_useprompt)unstable\_usePrompt
==========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.unstable_usePrompt.html)

Wrapper around useBlocker to show a window.confirm prompt to users instead of building a custom UI with [useBlocker](../hooks/useBlocker).

The `unstable_` flag will not be removed because this technique has a lot of rough edges and behaves very differently (and incorrectly sometimes) across browsers if users click addition back/forward navigations while the confirmation is open. Use at your own risk.

    function ImportantForm() {
      let [value, setValue] = React.useState("");
    
      // Block navigating elsewhere when data has been entered into the input
      unstable_usePrompt({
        message: "Are you sure?",
        when: ({ currentLocation, nextLocation }) =>
          value !== "" &&
          currentLocation.pathname !== nextLocation.pathname,
      });
    
      return (
        <Form method="post">
          <label>
            Enter some important data:
            <input
              name="data"
              value={value}
              onChange={(e) => setValue(e.target.value)}
            />
          </label>
          <button type="submit">Save</button>
        </Form>
      );
    }
    

[](#signature)Signature
-----------------------

    unstable_usePrompt(options): void
    

[](#params)Params
-----------------

### [](#options)options

_No documentation_

[](#useactiondata)useActionData
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useActionData.html)

Returns the action data from the most recent POST navigation form submission or `undefined` if there hasn't been one.

    import { Form, useActionData } from "react-router";
    
    export async function action({ request }) {
      const body = await request.formData();
      const name = body.get("visitorsName");
      return { message: `Hello, ${name}` };
    }
    
    export default function Invoices() {
      const data = useActionData();
      return (
        <Form method="post">
          <input type="text" name="visitorsName" />
          {data ? data.message : "Waiting..."}
        </Form>
      );
    }
    

[](#signature)Signature
-----------------------

    useActionData(): undefined
    

[](#useasyncerror)useAsyncError
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useAsyncError.html)

Returns the rejection value from the closest [Await](../components/Await).

    import { Await, useAsyncError } from "react-router";
    
    function ErrorElement() {
      const error = useAsyncError();
      return (
        <p>Uh Oh, something went wrong! {error.message}</p>
      );
    }
    
    // somewhere in your app
    <Await
      resolve={promiseThatRejects}
      errorElement={<ErrorElement />}
    />;
    

[](#signature)Signature
-----------------------

    useAsyncError(): unknown
    

[](#useasyncvalue)useAsyncValue
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useAsyncValue.html)

Returns the resolved promise value from the closest [Await](../components/Await).

    function SomeDescendant() {
      const value = useAsyncValue();
      // ...
    }
    
    // somewhere in your app
    <Await resolve={somePromise}>
      <SomeDescendant />
    </Await>;
    

[](#signature)Signature
-----------------------

    useAsyncValue(): unknown
    

[](#usebeforeunload)useBeforeUnload
===================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useBeforeUnload.html)

Setup a callback to be fired on the window's `beforeunload` event.

[](#signature)Signature
-----------------------

    useBeforeUnload(callback, options): void
    

[](#params)Params
-----------------

### [](#callback)callback

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#options)options

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#useblocker)useBlocker
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useBlocker.html)

Allow the application to block navigations within the SPA and present the user a confirmation dialog to confirm the navigation. Mostly used to avoid using half-filled form data. This does not handle hard-reloads or cross-origin navigations.

[](#signature)Signature
-----------------------

    useBlocker(shouldBlock): Blocker
    

[](#params)Params
-----------------

### [](#shouldblock)shouldBlock

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#examples)Examples
---------------------

### [](#basic)Basic

    import { useCallback, useState } from "react";
    import { BlockerFunction, useBlocker } from "react-router";
    
    export function ImportantForm() {
      const [value, setValue] = useState("");
    
      const shouldBlock = useCallback<BlockerFunction>(
        () => value !== "",
        [value]
      );
      const blocker = useBlocker(shouldBlock);
    
      return (
        <form
          onSubmit={(e) => {
            e.preventDefault();
            setValue("");
            if (blocker.state === "blocked") {
              blocker.proceed();
            }
          }}
        >
          <input
            name="data"
            value={value}
            onChange={(e) => setValue(e.target.value)}
          />
    
          <button type="submit">Save</button>
    
          {blocker.state === "blocked" ? (
            <>
              <p style={{ color: "red" }}>
                Blocked the last navigation to
              </p>
              <button
                type="button"
                onClick={() => blocker.proceed()}
              >
                Let me through
              </button>
              <button
                type="button"
                onClick={() => blocker.reset()}
              >
                Keep me here
              </button>
            </>
          ) : blocker.state === "proceeding" ? (
            <p style={{ color: "orange" }}>
              Proceeding through blocked navigation
            </p>
          ) : (
            <p style={{ color: "green" }}>
              Blocker is currently unblocked
            </p>
          )}
        </form>
      );
    }
    

[](#usefetcher)useFetcher
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useFetcher.html)

Useful for creating complex, dynamic user interfaces that require multiple, concurrent data interactions without causing a navigation.

Fetchers track their own, independent state and can be used to load data, submit forms, and generally interact with loaders and actions.

    import { useFetcher } from "react-router"
    
    function SomeComponent() {
      let fetcher = useFetcher()
    
      // states are available on the fetcher
      fetcher.state // "idle" | "loading" | "submitting"
      fetcher.data // the data returned from the action or loader
    
      // render a form
      <fetcher.Form method="post" />
    
      // load data
      fetcher.load("/some/route")
    
      // submit data
      fetcher.submit(someFormRef, { method: "post" })
      fetcher.submit(someData, {
        method: "post",
        encType: "application/json"
      })
    }
    

[](#signature)Signature
-----------------------

    useFetcher(options): FetcherWithComponents
    

[](#params)Params
-----------------

### [](#options)options

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#usefetchers)useFetchers
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useFetchers.html)

Returns an array of all in-flight fetchers. This is useful for components throughout the app that didn't create the fetchers but want to use their submissions to participate in optimistic UI.

    import { useFetchers } from "react-router";
    
    function SomeComponent() {
      const fetchers = useFetchers();
      fetchers[0].formData; // FormData
      fetchers[0].state; // etc.
      // ...
    }
    

[](#signature)Signature
-----------------------

    useFetchers(): undefined
    

[](#useformaction)useFormAction
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useFormAction.html)

Resolves the URL to the closest route in the component hierarchy instead of the current URL of the app.

This is used internally by [Form](../components/Form) resolve the action to the closest route, but can be used generically as well.

    import { useFormAction } from "react-router";
    
    function SomeComponent() {
      // closest route URL
      let action = useFormAction();
    
      // closest route URL + "destroy"
      let destroyAction = useFormAction("destroy");
    }
    

[](#signature)Signature
-----------------------

    useFormAction(action, __namedParameters): string
    

[](#params)Params
-----------------

### [](#action)action

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

The action to append to the closest route URL.

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#usehref)useHref
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useHref.html)

Resolves a URL against the current location.

    import { useHref } from "react-router";
    
    function SomeComponent() {
      let href = useHref("some/where");
      // "/resolved/some/where"
    }
    

[](#signature)Signature
-----------------------

    useHref(to, __namedParameters): string
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#useinroutercontext)useInRouterContext
=========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useInRouterContext.html)

Returns true if this component is a descendant of a Router, useful to ensure a component is used within a Router.

[](#signature)Signature
-----------------------

    useInRouterContext(): boolean
    

[](#uselinkclickhandler)useLinkClickHandler
===========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useLinkClickHandler.html)

Handles the click behavior for router `<Link>` components. This is useful if you need to create custom `<Link>` components with the same click behavior we use in our exported `<Link>`.

[](#signature)Signature
-----------------------

    useLinkClickHandler(to, __namedParameters): undefined
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#useloaderdata)useLoaderData
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useLoaderData.html)

Returns the data from the closest route [LoaderFunction](../Other/LoaderFunction) or [ClientLoaderFunction](../Other/ClientLoaderFunction).

    import { useLoaderData } from "react-router";
    
    export async function loader() {
      return await fakeDb.invoices.findAll();
    }
    
    export default function Invoices() {
      let invoices = useLoaderData<typeof loader>();
      // ...
    }
    

[](#signature)Signature
-----------------------

    useLoaderData(): SerializeFrom
    

[](#uselocation)useLocation
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useLocation.html)

Returns the current [Location](%5B../Other/Location%5D\(https://api.reactrouter.com/v7/interfaces/react_router.Location.html\)). This can be useful if you'd like to perform some side effect whenever it changes.

    import * as React from 'react'
    import { useLocation } from 'react-router'
    
    function SomeComponent() {
      let location = useLocation()
    
      React.useEffect(() => {
        // Google Analytics
        ga('send', 'pageview')
      }, [location]);
    
      return (
        // ...
      );
    }
    

[](#signature)Signature
-----------------------

    useLocation(): Location
    

[](#usematch)useMatch
=====================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useMatch.html)

Returns a PathMatch object if the given pattern matches the current URL. This is useful for components that need to know "active" state, e.g. `<NavLink>`.

[](#signature)Signature
-----------------------

    useMatch(pattern): undefined
    

[](#params)Params
-----------------

### [](#pattern)pattern

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#usematches)useMatches
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useMatches.html)

Returns the active route matches, useful for accessing loaderData for parent/child routes or the route "handle" property

[](#signature)Signature
-----------------------

    useMatches(): undefined
    

[](#usenavigate)useNavigate
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useNavigate.html)

Returns a function that lets you navigate programmatically in the browser in response to user interactions or effects.

    import { useNavigate } from "react-router";
    
    function SomeComponent() {
      let navigate = useNavigate();
      return (
        <button
          onClick={() => {
            navigate(-1);
          }}
        />
      );
    }
    

It's often better to use [redirect](../utils/redirect) in [ActionFunction](../Other/ActionFunction) and [LoaderFunction](../Other/LoaderFunction) than this hook.

[](#signature)Signature
-----------------------

    navigate(
      to: To,
      options?: {
        flushSync?: boolean;
        preventScrollReset?: boolean;
        relative?: RelativeRoutingType;
        replace?: boolean;
        state?: any;
        viewTransition?: boolean;
      }
    ): void | Promise<void>;
    

[](#examples)Examples
---------------------

### [](#navigate-to-another-path)Navigate to another path:

    navigate("/some/route");
    navigate("/some/route?search=param");
    

### [](#navigate-with-a-to-object)Navigate with a `To` object:

All properties are optional.

    navigate({
      pathname: "/some/route",
      search: "?search=param",
      hash: "#hash",
      state: { some: "state" },
    });
    

If you use `state`, that will be available on the `location` object on the next page. Access it with `useLocation().state` (see [useLocation](./useLocation)).

### [](#navigate-back-or-forward-in-the-history-stack)Navigate back or forward in the history stack:

    // back
    // often used to close modals
    navigate(-1);
    
    // forward
    // often used in a multi-step wizard workflows
    navigate(1);
    

Be cautions with `navigate(number)`. If your application can load up to a route that has a button that tries to navigate forward/back, there may not be a history entry to go back or forward to, or it can go somewhere you don't expect (like a different domain).

Only use this if you're sure they will have an entry in the history stack to navigate to.

### [](#replace-the-current-entry-in-the-history-stack)Replace the current entry in the history stack:

This will remove the current entry in the history stack, replacing it with a new one, similar to a server side redirect.

    navigate("/some/route", { replace: true });
    

### [](#prevent-scroll-reset)Prevent Scroll Reset

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

To prevent `<ScrollRestoration>` from resetting the scroll position, use the `preventScrollReset` option.

    navigate("?some-tab=1", { preventScrollReset: true });
    

For example, if you have a tab interface connected to search params in the middle of a page and you don't want it to scroll to the top when a tab is clicked.

[](#usenavigation)useNavigation
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useNavigation.html)

Returns the current navigation, defaulting to an "idle" navigation when no navigation is in progress. You can use this to render pending UI (like a global spinner) or read FormData from a form navigation.

    import { useNavigation } from "react-router";
    
    function SomeComponent() {
      let navigation = useNavigation();
      navigation.state;
      navigation.formData;
      // etc.
    }
    

[](#signature)Signature
-----------------------

    useNavigation(): Navigation
    

[](#usenavigationtype)useNavigationType
=======================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useNavigationType.html)

Returns the current navigation action which describes how the router came to the current location, either by a pop, push, or replace on the history stack.

[](#signature)Signature
-----------------------

    useNavigationType(): NavigationType
    

[](#useoutlet)useOutlet
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useOutlet.html)

Returns the element for the child route at this level of the route hierarchy. Used internally by `<Outlet>` to render child routes.

[](#signature)Signature
-----------------------

    useOutlet(context): undefined
    

[](#params)Params
-----------------

### [](#context)context

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#useoutletcontext)useOutletContext
=====================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useOutletContext.html)

Returns the parent route `<Outlet context>`.

[](#signature)Signature
-----------------------

    useOutletContext(): Context
    

[](#useparams)useParams
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useParams.html)

Returns an object of key/value pairs of the dynamic params from the current URL that were matched by the routes. Child routes inherit all params from their parent routes.

    import { useParams } from "react-router";
    
    function SomeComponent() {
      let params = useParams();
      params.postId;
    }
    

Assuming a route pattern like `/posts/:postId` is matched by `/posts/123` then `params.postId` will be `"123"`.

[](#examples)Examples
---------------------

### [](#basic-usage)Basic Usage

    import { useParams } from "react-router";
    
    // given a route like:
    <Route path="/posts/:postId" element={<Post />} />;
    
    // or a data route like:
    createBrowserRouter([
      {
        path: "/posts/:postId",
        component: Post,
      },
    ]);
    
    // or in routes.ts
    route("/posts/:postId", "routes/post.tsx");
    

Access the params in a component:

    import { useParams } from "react-router";
    
    export default function Post() {
      let params = useParams();
      return <h1>Post: {params.postId}</h1>;
    }
    

### [](#multiple-params)Multiple Params

Patterns can have multiple params:

    "/posts/:postId/comments/:commentId";
    

All will be available in the params object:

    import { useParams } from "react-router";
    
    export default function Post() {
      let params = useParams();
      return (
        <h1>
          Post: {params.postId}, Comment: {params.commentId}
        </h1>
      );
    }
    

### [](#catchall-params)Catchall Params

Catchall params are defined with `*`:

    "/files/*";
    

The matched value will be available in the params object as follows:

    import { useParams } from "react-router";
    
    export default function File() {
      let params = useParams();
      let catchall = params["*"];
      // ...
    }
    

You can destructure the catchall param:

    export default function File() {
      let { "*": catchall } = useParams();
      console.log(catchall);
    }
    

[](#useresolvedpath)useResolvedPath
===================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useResolvedPath.html)

Resolves the pathname of the given `to` value against the current location. Similar to [useHref](../hooks/useHref), but returns a [Path](../Other/Path) instead of a string.

    import { useResolvedPath } from "react-router";
    
    function SomeComponent() {
      // if the user is at /dashboard/profile
      let path = useResolvedPath("../accounts");
      path.pathname; // "/dashboard/accounts"
      path.search; // ""
      path.hash; // ""
    }
    

[](#signature)Signature
-----------------------

    useResolvedPath(to, __namedParameters): Path
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#userevalidator)useRevalidator
=================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useRevalidator.html)

Revalidate the data on the page for reasons outside of normal data mutations like window focus or polling on an interval.

    import { useRevalidator } from "react-router";
    
    function WindowFocusRevalidator() {
      const revalidator = useRevalidator();
    
      useFakeWindowFocus(() => {
        revalidator.revalidate();
      });
    
      return (
        <div hidden={revalidator.state === "idle"}>
          Revalidating...
        </div>
      );
    }
    

Note that page data is already revalidated automatically after actions. If you find yourself using this for normal CRUD operations on your data in response to user interactions, you're probably not taking advantage of the other APIs like [useFetcher](../hooks/useFetcher), [Form](../components/Form), [useSubmit](../hooks/useSubmit) that do this automatically.

[](#signature)Signature
-----------------------

    useRevalidator(): undefined
    

[](#userouteerror)useRouteError
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useRouteError.html)

Accesses the error thrown during an [ActionFunction](../Other/ActionFunction), [LoaderFunction](../Other/LoaderFunction), or component render to be used in a route module Error Boundary.

    export function ErrorBoundary() {
      const error = useRouteError();
      return <div>{error.message}</div>;
    }
    

[](#signature)Signature
-----------------------

    useRouteError(): unknown
    

[](#userouteloaderdata)useRouteLoaderData
=========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useRouteLoaderData.html)

Returns the loader data for a given route by route ID.

    import { useRouteLoaderData } from "react-router";
    
    function SomeComponent() {
      const { user } = useRouteLoaderData("root");
    }
    

Route IDs are created automatically. They are simply the path of the route file relative to the app folder without the extension.

Route Filename

Route ID

`app/root.tsx`

`"root"`

`app/routes/teams.tsx`

`"routes/teams"`

`app/whatever/teams.$id.tsx`

`"whatever/teams.$id"`

If you created an ID manually, you can use that instead:

    route("/", "containers/app.tsx", { id: "app" }})
    

[](#signature)Signature
-----------------------

    useRouteLoaderData(routeId): undefined
    

[](#params)Params
-----------------

### [](#routeid)routeId

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#useroutes)useRoutes
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useRoutes.html)

Hook version of [Routes](../components/Routes) that uses objects instead of components. These objects have the same properties as the component props.

The return value of `useRoutes` is either a valid React element you can use to render the route tree, or `null` if nothing matched.

    import * as React from "react";
    import { useRoutes } from "react-router";
    
    function App() {
      let element = useRoutes([
        {
          path: "/",
          element: <Dashboard />,
          children: [
            {
              path: "messages",
              element: <DashboardMessages />,
            },
            { path: "tasks", element: <DashboardTasks /> },
          ],
        },
        { path: "team", element: <AboutPage /> },
      ]);
    
      return element;
    }
    

[](#signature)Signature
-----------------------

    useRoutes(routes, locationArg): undefined
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#locationarg)locationArg

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#usesearchparams)useSearchParams
===================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useSearchParams.html)

Returns a tuple of the current URL's URLSearchParams and a function to update them. Setting the search params causes a navigation.

    import { useSearchParams } from "react-router";
    
    export function SomeComponent() {
      const [searchParams, setSearchParams] = useSearchParams();
      // ...
    }
    

[](#signature)Signature
-----------------------

    useSearchParams(defaultInit): undefined
    

[](#params)Params
-----------------

### [](#defaultinit)defaultInit

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

You can initialize the search params with a default value, though it **will not** change the URL on the first render.

    // a search param string
    useSearchParams("?tab=1");
    
    // a short-hand object
    useSearchParams({ tab: "1" });
    
    // object keys can be arrays for multiple values on the key
    useSearchParams({ brand: ["nike", "reebok"] });
    
    // an array of tuples
    useSearchParams([["tab", "1"]]);
    
    // a URLSearchParams object
    useSearchParams(new URLSearchParams("?tab=1"));
    

[](#setsearchparams-function)SetSearchParams Function
-----------------------------------------------------

The second element of the tuple is a function that can be used to update the search params. It accepts the same types as `defaultInit` and will cause a navigation to the new URL.

    let [searchParams, setSearchParams] = useSearchParams();
    
    // a search param string
    setSearchParams("?tab=1");
    
    // a short-hand object
    setSearchParams({ tab: "1" });
    
    // object keys can be arrays for multiple values on the key
    setSearchParams({ brand: ["nike", "reebok"] });
    
    // an array of tuples
    setSearchParams([["tab", "1"]]);
    
    // a URLSearchParams object
    setSearchParams(new URLSearchParams("?tab=1"));
    

It also supports a function callback like `setState`:

    setSearchParams((searchParams) => {
      searchParams.set("tab", "2");
      return searchParams;
    });
    

[](#notes)Notes
---------------

Note that `searchParams` is a stable reference, so you can reliably use it as a dependency in `useEffect` hooks.

    useEffect(() => {
      console.log(searchParams.get("tab"));
    }, [searchParams]);
    

However, this also means it's mutable. If you change the object without calling `setSearchParams`, its values will change between renders if some other state causes the component to re-render and URL will not reflect the values.

[](#usesubmit)useSubmit
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useSubmit.html)

The imperative version of [Form](../components/Form) that lets you submit a form from code instead of a user interaction.

    import { useSubmit } from "react-router";
    
    function SomeComponent() {
      const submit = useSubmit();
      return (
        <Form
          onChange={(event) => {
            submit(event.currentTarget);
          }}
        />
      );
    }
    

[](#signature)Signature
-----------------------

    useSubmit(): SubmitFunction
    

[](#useviewtransitionstate)useViewTransitionState
=================================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.useViewTransitionState.html)

This hook returns `true` when there is an active [View Transition](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) to the specified location. This can be used to apply finer-grained styles to elements to further customize the view transition. This requires that view transitions have been enabled for the given navigation via LinkProps.viewTransition (or the `Form`, `submit`, or `navigate` call)

[](#signature)Signature
-----------------------

    useViewTransitionState(to, opts): boolean
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#hydratedrouter)HydratedRouter
=================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.HydratedRouter.html)

Hydrates a server rendered StaticRouterProvider.

[](#props)Props
---------------

None

[](#routerprovider)RouterProvider
=================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.RouterProvider.html)

Initializes a data router, subscribes to its changes, and renders the matching components. Should typically be at the top of an app's element tree.

    import {
      RouterProvider,
      createBrowserRouter,
    } from "react-router";
    import { createRoot } from "react-dom/client";
    let router = createBrowserRouter();
    createRoot(document.getElementById("root")).render(
      <RouterProvider router={router} />
    );
    

[](#props)Props
---------------

### [](#flushsync)flushSync

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#router)router

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#staticrouterprovider)StaticRouterProvider
=============================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.StaticRouterProvider.html)

A Data Router that may not navigate to any other location. This is useful on the server where there is no stateful UI.

[](#props)Props
---------------

### [](#context)context

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#hydrate)hydrate

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#nonce)nonce

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#router)router

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#createbrowserrouter)createBrowserRouter
===========================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createBrowserRouter.html)

[](#signature)Signature
-----------------------

    createBrowserRouter(routes, opts): DataRouter
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#createhashrouter)createHashRouter
=====================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createHashRouter.html)

[](#signature)Signature
-----------------------

    createHashRouter(routes, opts): DataRouter
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#creatememoryrouter)createMemoryRouter
=========================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createMemoryRouter.html)

[](#signature)Signature
-----------------------

    createMemoryRouter(routes, opts): DataRouter
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#createstaticrouter)createStaticRouter
=========================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createStaticRouter.html)

[](#signature)Signature
-----------------------

    createStaticRouter(routes, context, opts): DataRouter
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#context)context

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#browserrouter)BrowserRouter
===============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.BrowserRouter.html)

A declarative router using the browser history API for client side routing.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#window)window

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#hashrouter)HashRouter
=========================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.HashRouter.html)

A `<Router>` for use in web browsers. Stores the location in the hash portion of the URL.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#window)window

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#memoryrouter)MemoryRouter
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.MemoryRouter.html)

A `<Router>` that stores all entries in memory.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#initialentries)initialEntries

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#initialindex)initialIndex

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#router)Router
=================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.Router.html)

Provides location context for the rest of the app.

Note: You usually won't render a `<Router>` directly. Instead, you'll render a router that is more specific to your environment such as a `<BrowserRouter>` in web browsers or a `<StaticRouter>` for server rendering.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#location)location

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#navigationtype)navigationType

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#navigator)navigator

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#static)static

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#staticrouter)StaticRouter
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.StaticRouter.html)

A `<Router>` that may not navigate to any other location. This is useful on the server where there is no stateful UI.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#location)location

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#historyrouter)HistoryRouter
===============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.unstable_HistoryRouter.html)

A `<Router>` that accepts a pre-instantiated history object. It's important to note that using your own history object is highly discouraged and may add two versions of the history library to your bundles unless you use the same version of the history library that React Router uses internally.

[](#props)Props
---------------

### [](#basename)basename

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#children)children

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#history)history

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Not available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#iscookiefunction)IsCookieFunction
=====================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.IsCookieFunction.html)

[](#issessionfunction)IsSessionFunction
=======================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.IsSessionFunction.html)

[](#createcookie)createCookie
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createCookie.html)

Creates a logical container for managing a browser cookie from the server.

[](#createcookiesessionstorage)createCookieSessionStorage
=========================================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createCookieSessionStorage.html)

Creates and returns a SessionStorage object that stores all session data directly in the session cookie itself.

This has the advantage that no database or other backend services are needed, and can help to simplify some load-balanced scenarios. However, it also has the limitation that serialized session data may not exceed the browser's maximum cookie size. Trade-offs!

[](#creatememorysessionstorage)createMemorySessionStorage
=========================================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createMemorySessionStorage.html)

Creates and returns a simple in-memory SessionStorage object, mostly useful for testing and as a reference implementation.

Note: This storage does not scale beyond a single process, so it is not suitable for most production scenarios.

[](#createpath)createPath
=========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createPath.html)

Creates a string URL path from the given pathname, search, and hash components.

[](#signature)Signature
-----------------------

    createPath(__namedParameters): string
    

[](#params)Params
-----------------

### [](#__namedparameters)\_\_namedParameters

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#createroutesfromelements)createRoutesFromElements
=====================================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createRoutesFromElements.html)

Create route objects from JSX elements instead of arrays of objects

[](#signature)Signature
-----------------------

    createRoutesFromElements(children, parentPath): undefined
    

[](#params)Params
-----------------

### [](#children)children

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#parentpath)parentPath

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#createroutesstub)createRoutesStub
=====================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createRoutesStub.html)

[](#signature)Signature
-----------------------

    createRoutesStub(routes, context): undefined
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#context)context

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#createsearchparams)createSearchParams
=========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createSearchParams.html)

Creates a URLSearchParams object using the given initializer.

This is identical to `new URLSearchParams(init)` except it also supports arrays as values in the object form of the initializer instead of just strings. This is convenient when you need multiple values for a given key, but don't want to use an array initializer.

For example, instead of:

    let searchParams = new URLSearchParams([
      ["sort", "name"],
      ["sort", "price"],
    ]);
    

you can do:

    let searchParams = createSearchParams({
      sort: ['name', 'price']
    });
    

[](#signature)Signature
-----------------------

    createSearchParams(init): URLSearchParams
    

[](#params)Params
-----------------

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#createstatichandler)createStaticHandler
===========================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.createStaticHandler.html)

[](#signature)Signature
-----------------------

    createStaticHandler(routes, opts): StaticHandler
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#opts)opts

*   [](../../start/modes "Not available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#data)data
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.data.html)

Create "responses" that contain `status`/`headers` without forcing serialization into an actual `Response` - used by Remix single fetch

[](#signature)Signature
-----------------------

    data(data, init): DataWithResponseInit
    

[](#params)Params
-----------------

### [](#data-1)data

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#generatepath)generatePath
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.generatePath.html)

Returns a path with params interpolated.

[](#signature)Signature
-----------------------

    generatePath(originalPath, params): string
    

[](#params)Params
-----------------

### [](#originalpath)originalPath

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#params-1)params

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#href)href
=============

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.href.html)

Returns a resolved URL path for the specified route.

    const h = href("/:lang?/about", { lang: "en" })
    // -> `/en/about`
    
    <Link to={href("/products/:id", { id: "abc123" })} />
    

[](#iscookie)isCookie
=====================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.isCookie.html)

Returns true if an object is a Remix cookie container.

[](#isrouteerrorresponse)isRouteErrorResponse
=============================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.isRouteErrorResponse.html)

Check if the given error is an ErrorResponse generated from a 4xx/5xx Response thrown from an action/loader

[](#signature)Signature
-----------------------

    isRouteErrorResponse(error): error
    

[](#params)Params
-----------------

### [](#error)error

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#issession)isSession
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.isSession.html)

Returns true if an object is a React Router session.

[](#matchpath)matchPath
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.matchPath.html)

Performs pattern matching on a URL pathname and returns information about the match.

[](#signature)Signature
-----------------------

    matchPath(pattern, pathname): undefined
    

[](#params)Params
-----------------

### [](#pattern)pattern

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#pathname)pathname

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#matchroutes)matchRoutes
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.matchRoutes.html)

Matches the given routes to a location and returns the match data.

[](#signature)Signature
-----------------------

    matchRoutes(routes, locationArg, basename): undefined
    

[](#params)Params
-----------------

### [](#routes)routes

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#locationarg)locationArg

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#basename)basename

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#parsepath)parsePath
=======================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.parsePath.html)

Parses a string URL path into its separate pathname, search, and hash components.

[](#signature)Signature
-----------------------

    parsePath(path): Partial
    

[](#params)Params
-----------------

### [](#path)path

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#redirect)redirect
=====================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.redirect.html)

A redirect response. Sets the status code and the `Location` header. Defaults to "302 Found".

[](#signature)Signature
-----------------------

    redirect(url, init): Response
    

[](#params)Params
-----------------

### [](#url)url

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#redirectdocument)redirectDocument
=====================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.redirectDocument.html)

A redirect response that will force a document reload to the new location. Sets the status code and the `Location` header. Defaults to "302 Found".

[](#signature)Signature
-----------------------

    redirectDocument(url, init): Response
    

[](#params)Params
-----------------

### [](#url)url

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#rendermatches)renderMatches
===============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.renderMatches.html)

Renders the result of `matchRoutes()` into a React element.

[](#signature)Signature
-----------------------

    renderMatches(matches): undefined
    

[](#params)Params
-----------------

### [](#matches)matches

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#replace)replace
===================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.replace.html)

A redirect response that will perform a `history.replaceState` instead of a `history.pushState` for client-side navigation redirects. Sets the status code and the `Location` header. Defaults to "302 Found".

[](#signature)Signature
-----------------------

    replace(url, init): Response
    

[](#params)Params
-----------------

### [](#url)url

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

### [](#init)init

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Not available with Declarative")

_No documentation_

[](#resolvepath)resolvePath
===========================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#summary)Summary
-------------------

[Reference Documentation ↗](https://api.reactrouter.com/v7/functions/react_router.resolvePath.html)

Returns a resolved path object relative to the given pathname.

[](#signature)Signature
-----------------------

    resolvePath(to, fromPathname): Path
    

[](#params)Params
-----------------

### [](#to)to

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

### [](#frompathname)fromPathname

*   [](../../start/modes "Available with Framework")
*   [](../../start/modes "Available with Data")
*   [](../../start/modes "Available with Declarative")

_No documentation_

[](#address-book)Address Book
=============================

We'll be building a small, but feature-rich address book app that lets you keep track of your contacts. There's no database or other "production ready" things, so we can stay focused on the features React Router gives you. We expect it to take 30-45m if you're following along, otherwise it's a quick read.

You can also watch our [walkthrough of the React Router Tutorial](https://www.youtube.com/watch?v=pw8FAg07kdo) if you prefer 🎥

👉 **Every time you see this it means you need to do something in the app!**

The rest is just there for your information and deeper understanding. Let's get to it.

[](#setup)Setup
---------------

👉 **Generate a basic template**

    npx create-react-router@latest --template remix-run/react-router/tutorials/address-book
    

This uses a pretty bare-bones template but includes our css and data model, so we can focus on React Router.

👉 **Start the app**

    # cd into the app directory
    cd {wherever you put the app}
    
    # install dependencies if you haven't already
    npm install
    
    # start the server
    npm run dev
    

You should be able to open up [http://localhost:5173](http://localhost:5173) and see an unstyled screen that looks like this:

[](#the-root-route)The Root Route
---------------------------------

Note the file at `app/root.tsx`. This is what we call the ["Root Route"](../explanation/special-files#roottsx). It's the first component in the UI that renders, so it typically contains the global layout for the page, as well as a the default [Error Boundary](../how-to/error-boundary).

Expand here to see the root component code

    import {
      Form,
      Scripts,
      ScrollRestoration,
      isRouteErrorResponse,
    } from "react-router";
    import type { Route } from "./+types/root";
    
    import appStylesHref from "./app.css?url";
    
    export default function App() {
      return (
        <>
          <div id="sidebar">
            <h1>React Router Contacts</h1>
            <div>
              <Form id="search-form" role="search">
                <input
                  aria-label="Search contacts"
                  id="q"
                  name="q"
                  placeholder="Search"
                  type="search"
                />
                <div
                  aria-hidden
                  hidden={true}
                  id="search-spinner"
                />
              </Form>
              <Form method="post">
                <button type="submit">New</button>
              </Form>
            </div>
            <nav>
              <ul>
                <li>
                  <a href={`/contacts/1`}>Your Name</a>
                </li>
                <li>
                  <a href={`/contacts/2`}>Your Friend</a>
                </li>
              </ul>
            </nav>
          </div>
        </>
      );
    }
    
    // The Layout component is a special export for the root route.
    // It acts as your document's "app shell" for all route components, HydrateFallback, and ErrorBoundary
    // For more information, see https://reactrouter.com/explanation/special-files#layout-export
    export function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <head>
            <meta charSet="utf-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1"
            />
            <link rel="stylesheet" href={appStylesHref} />
          </head>
          <body>
            {children}
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    
    // The top most error boundary for the app, rendered when your app throws an error
    // For more information, see https://reactrouter.com/start/framework/route-module#errorboundary
    export function ErrorBoundary({
      error,
    }: Route.ErrorBoundaryProps) {
      let message = "Oops!";
      let details = "An unexpected error occurred.";
      let stack: string | undefined;
    
      if (isRouteErrorResponse(error)) {
        message = error.status === 404 ? "404" : "Error";
        details =
          error.status === 404
            ? "The requested page could not be found."
            : error.statusText || details;
      } else if (
        import.meta.env.DEV &&
        error &&
        error instanceof Error
      ) {
        details = error.message;
        stack = error.stack;
      }
    
      return (
        <main id="error-page">
          <h1>{message}</h1>
          <p>{details}</p>
          {stack && (
            <pre>
              <code>{stack}</code>
            </pre>
          )}
        </main>
      );
    }

[](#the-contact-route-ui)The Contact Route UI
---------------------------------------------

If you click on one of the sidebar items you'll get the default 404 page. Let's create a route that matches the url `/contacts/1`.

👉 **Create a contact route module**

    mkdir app/routes
    touch app/routes/contact.tsx
    

We could put this file anywhere we want, but to make things a bit more organized, we'll put all our routes inside the `app/routes` directory.

You can also use [file-based routing if you prefer](../how-to/file-route-conventions).

👉 **Configure the route**

We need to tell React Router about our new route. `routes.ts` is a special file where we can configure all our routes.

    import type { RouteConfig } from "@react-router/dev/routes";
    import { route } from "@react-router/dev/routes";
    
    export default [
      route("contacts/:contactId", "routes/contact.tsx"),
    ] satisfies RouteConfig;
    

In React Router, `:` makes a segment dynamic. We just made the following urls match the `routes/contact.tsx` route module:

*   `/contacts/123`
*   `/contacts/abc`

👉 **Add the contact component UI**

It's just a bunch of elements, feel free to copy/paste.

    import { Form } from "react-router";
    
    import type { ContactRecord } from "../data";
    
    export default function Contact() {
      const contact = {
        first: "Your",
        last: "Name",
        avatar: "https://placecats.com/200/200",
        twitter: "your_handle",
        notes: "Some notes",
        favorite: true,
      };
    
      return (
        <div id="contact">
          <div>
            <img
              alt={`${contact.first} ${contact.last} avatar`}
              key={contact.avatar}
              src={contact.avatar}
            />
          </div>
    
          <div>
            <h1>
              {contact.first || contact.last ? (
                <>
                  {contact.first} {contact.last}
                </>
              ) : (
                <i>No Name</i>
              )}
              <Favorite contact={contact} />
            </h1>
    
            {contact.twitter ? (
              <p>
                <a
                  href={`https://twitter.com/${contact.twitter}`}
                >
                  {contact.twitter}
                </a>
              </p>
            ) : null}
    
            {contact.notes ? <p>{contact.notes}</p> : null}
    
            <div>
              <Form action="edit">
                <button type="submit">Edit</button>
              </Form>
    
              <Form
                action="destroy"
                method="post"
                onSubmit={(event) => {
                  const response = confirm(
                    "Please confirm you want to delete this record."
                  );
                  if (!response) {
                    event.preventDefault();
                  }
                }}
              >
                <button type="submit">Delete</button>
              </Form>
            </div>
          </div>
        </div>
      );
    }
    
    function Favorite({
      contact,
    }: {
      contact: Pick<ContactRecord, "favorite">;
    }) {
      const favorite = contact.favorite;
    
      return (
        <Form method="post">
          <button
            aria-label={
              favorite
                ? "Remove from favorites"
                : "Add to favorites"
            }
            name="favorite"
            value={favorite ? "false" : "true"}
          >
            {favorite ? "★" : "☆"}
          </button>
        </Form>
      );
    }
    

Now if we click one of the links or visit [`/contacts/1`](http://localhost:5173/contacts/1) we get ... nothing new?

[](#nested-routes-and-outlets)Nested Routes and Outlets
-------------------------------------------------------

React Router supports nested routing. In order for child routes to render inside of parent layouts, we need to render an [`Outlet`](https://api.reactrouter.com/v7/functions/react_router.Outlet) in the parent. Let's fix it, open up `app/root.tsx` and render an outlet inside.

👉 **Render an [`<Outlet />`](https://api.reactrouter.com/v7/functions/react_router.Outlet)**

    import {
      Form,
      Outlet,
      Scripts,
      ScrollRestoration,
      isRouteErrorResponse,
    } from "react-router";
    
    // existing imports & exports
    
    export default function App() {
      return (
        <>
          <div id="sidebar">{/* other elements */}</div>
          <div id="detail">
            <Outlet />
          </div>
        </>
      );
    }
    

Now the child route should be rendering through the outlet.

[](#client-side-routing)Client Side Routing
-------------------------------------------

You may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of client side routing, which completely remounts our app.

Client side routing allows our app to update the URL without reloading the entire page. Instead, the app can immediately render new UI. Let's make it happen with [`<Link>`](https://api.reactrouter.com/v7/functions/react_router.Link).

👉 **Change the sidebar `<a href>` to `<Link to>`**

    import {
      Form,
      Link,
      Outlet,
      Scripts,
      ScrollRestoration,
      isRouteErrorResponse,
    } from "react-router";
    
    // existing imports & exports
    
    export default function App() {
      return (
        <>
          <div id="sidebar">
            {/* other elements */}
            <nav>
              <ul>
                <li>
                  <Link to={`/contacts/1`}>Your Name</Link>
                </li>
                <li>
                  <Link to={`/contacts/2`}>Your Friend</Link>
                </li>
              </ul>
            </nav>
          </div>
          {/* other elements */}
        </>
      );
    }
    

You can open the network tab in the browser devtools to see that it's not requesting documents anymore.

[](#loading-data)Loading Data
-----------------------------

URL segments, layouts, and data are more often than not coupled (tripled?) together. We can see it in this app already:

URL Segment

Component

Data

/

`<App>`

list of contacts

contacts/:contactId

`<Contact>`

individual contact

Because of this natural coupling, React Router has data conventions to get data into your route components easily.

First we'll create and export a [`clientLoader`](../start/framework/route-module#clientloader) function in the root route and then render the data.

👉 **Export a `clientLoader` function from `app/root.tsx` and render the data**

The following code has a type error in it, we'll fix it in the next section

    // existing imports
    import { getContacts } from "./data";
    
    // existing exports
    
    export async function clientLoader() {
      const contacts = await getContacts();
      return { contacts };
    }
    
    export default function App({ loaderData }) {
      const { contacts } = loaderData;
    
      return (
        <>
          <div id="sidebar">
            {/* other elements */}
            <nav>
              {contacts.length ? (
                <ul>
                  {contacts.map((contact) => (
                    <li key={contact.id}>
                      <Link to={`contacts/${contact.id}`}>
                        {contact.first || contact.last ? (
                          <>
                            {contact.first} {contact.last}
                          </>
                        ) : (
                          <i>No Name</i>
                        )}
                        {contact.favorite ? (
                          <span>★</span>
                        ) : null}
                      </Link>
                    </li>
                  ))}
                </ul>
              ) : (
                <p>
                  <i>No contacts</i>
                </p>
              )}
            </nav>
          </div>
          {/* other elements */}
        </>
      );
    }
    

That's it! React Router will now automatically keep that data in sync with your UI. The sidebar should now look like this:

You may be wondering why we're "client" loading data instead of loading the data on the server so we can do server-side rendering (SSR). Right now our contacts site is a [Single Page App](../how-to/spa), so there's no server-side rendering. This makes it really easy to deploy to any static hosting provider, but we'll talk more about how to enable SSR in a bit so you can learn about all the different [rendering strategies](../start/framework/rendering) React Router offers.

[](#type-safety)Type Safety
---------------------------

You probably noticed that we didn't assign a type to the `loaderData` prop. Let's fix that.

👉 **Add the `ComponentProps` type to the `App` component**

    // existing imports
    import type { Route } from "./+types/root";
    // existing imports & exports
    
    export default function App({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts } = loaderData;
    
      // existing code
    }
    

Wait, what? Where did these types come from?!

We didn't define them, yet somehow they already know about the `contacts` property we returned from our `clientLoader`.

That's because React Router [generates types for each route in your app](../explanation/type-safety) to provide automatic type safety.

[](#adding-a-hydratefallback)Adding a `HydrateFallback`
-------------------------------------------------------

We mentioned earlier that we are working on a [Single Page App](../how-to/spa) with no server-side rendering. If you look inside of [`react-router.config.ts`](../explanation/special-files#react-routerconfigts) you'll see that this is configured with a simple boolean:

    import { type Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
    } satisfies Config;
    

You might have started noticing that whenever you refresh the page you get a flash of white before the app loads. Since we're only rendering on the client, there's nothing to show the user while the app is loading.

👉 **Add a `HydrateFallback` export**

We can provide a fallback that will show up before the app is hydrated (rendering on the client for the first time) with a [`HydrateFallback`](../start/framework/route-module#hydratefallback) export.

    // existing imports & exports
    
    export function HydrateFallback() {
      return (
        <div id="loading-splash">
          <div id="loading-splash-spinner" />
          <p>Loading, please wait...</p>
        </div>
      );
    }
    

Now if you refresh the page, you'll briefly see the loading splash before the app is hydrated.

[](#index-routes)Index Routes
-----------------------------

When you load the app and aren't yet on a contact page, you'll notice a big blank page on the right side of the list.

When a route has children, and you're at the parent route's path, the `<Outlet>` has nothing to render because no children match. You can think of [index routes](../start/framework/routing#index-routes) as the default child route to fill in that space.

👉 **Create an index route for the root route**

    touch app/routes/home.tsx
    

    import type { RouteConfig } from "@react-router/dev/routes";
    import { index, route } from "@react-router/dev/routes";
    
    export default [
      index("routes/home.tsx"),
      route("contacts/:contactId", "routes/contact.tsx"),
    ] satisfies RouteConfig;
    

👉 **Fill in the index component's elements**

Feel free to copy/paste, nothing special here.

    export default function Home() {
      return (
        <p id="index-page">
          This is a demo for React Router.
          <br />
          Check out{" "}
          <a href="https://reactrouter.com">
            the docs at reactrouter.com
          </a>
          .
        </p>
      );
    }
    

Voilà! No more blank space. It's common to put dashboards, stats, feeds, etc. at index routes. They can participate in data loading as well.

[](#adding-an-about-route)Adding an About Route
-----------------------------------------------

Before we move on to working with dynamic data that the user can interact with, let's add a page with static content we expect to rarely change. An about page will be perfect for this.

👉 **Create the about route**

    touch app/routes/about.tsx
    

Don't forget to add the route to `app/routes.ts`:

    export default [
      index("routes/home.tsx"),
      route("contacts/:contactId", "routes/contact.tsx"),
      route("about", "routes/about.tsx"),
    ] satisfies RouteConfig;
    

👉 **Add the about page UI**

Nothing too special here, just copy and paste:

    import { Link } from "react-router";
    
    export default function About() {
      return (
        <div id="about">
          <Link to="/">← Go to demo</Link>
          <h1>About React Router Contacts</h1>
    
          <div>
            <p>
              This is a demo application showing off some of the
              powerful features of React Router, including
              dynamic routing, nested routes, loaders, actions,
              and more.
            </p>
    
            <h2>Features</h2>
            <p>
              Explore the demo to see how React Router handles:
            </p>
            <ul>
              <li>
                Data loading and mutations with loaders and
                actions
              </li>
              <li>
                Nested routing with parent/child relationships
              </li>
              <li>URL-based routing with dynamic segments</li>
              <li>Pending and optimistic UI</li>
            </ul>
    
            <h2>Learn More</h2>
            <p>
              Check out the official documentation at{" "}
              <a href="https://reactrouter.com">
                reactrouter.com
              </a>{" "}
              to learn more about building great web
              applications with React Router.
            </p>
          </div>
        </div>
      );
    }
    

👉 **Add a link to the about page in the sidebar**

    export default function App() {
      return (
        <>
          <div id="sidebar">
            <h1>
              <Link to="about">React Router Contacts</Link>
            </h1>
            {/* other elements */}
          </div>
          {/* other elements */}
        </>
      );
    }
    

Now navigate to the [about page](http://localhost:5173/about) and it should look like this:

[](#layout-routes)Layout Routes
-------------------------------

We don't actually want the about page to be nested inside of the sidebar layout. Let's move the sidebar to a layout so we can avoid rendering it on the about page. Additionally, we want to avoid loading all the contacts data on the about page.

👉 **Create a layout route for the sidebar**

You can name and put this layout route wherever you want, but putting it inside of a `layouts` directory will help keep things organized for our simple app.

    mkdir app/layouts
    touch app/layouts/sidebar.tsx
    

For now just return an [`<Outlet>`](https://api.reactrouter.com/v7/functions/react_router.Outlet).

    import { Outlet } from "react-router";
    
    export default function SidebarLayout() {
      return <Outlet />;
    }
    

👉 **Move route definitions under the sidebar layout**

We can define a `layout` route to automatically render the sidebar for all matched routes within it. This is basically what our `root` was, but now we can scope it to specific routes.

    import type { RouteConfig } from "@react-router/dev/routes";
    import {
      index,
      layout,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      layout("layouts/sidebar.tsx", [
        index("routes/home.tsx"),
        route("contacts/:contactId", "routes/contact.tsx"),
      ]),
      route("about", "routes/about.tsx"),
    ] satisfies RouteConfig;
    

👉 **Move the layout and data fetching to the sidebar layout**

We want to move the `clientLoader` and everything inside the `App` component to the sidebar layout. It should look like this:

    import { Form, Link, Outlet } from "react-router";
    import { getContacts } from "../data";
    import type { Route } from "./+types/sidebar";
    
    export async function clientLoader() {
      const contacts = await getContacts();
      return { contacts };
    }
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts } = loaderData;
    
      return (
        <>
          <div id="sidebar">
            <h1>
              <Link to="about">React Router Contacts</Link>
            </h1>
            <div>
              <Form id="search-form" role="search">
                <input
                  aria-label="Search contacts"
                  id="q"
                  name="q"
                  placeholder="Search"
                  type="search"
                />
                <div
                  aria-hidden
                  hidden={true}
                  id="search-spinner"
                />
              </Form>
              <Form method="post">
                <button type="submit">New</button>
              </Form>
            </div>
            <nav>
              {contacts.length ? (
                <ul>
                  {contacts.map((contact) => (
                    <li key={contact.id}>
                      <Link to={`contacts/${contact.id}`}>
                        {contact.first || contact.last ? (
                          <>
                            {contact.first} {contact.last}
                          </>
                        ) : (
                          <i>No Name</i>
                        )}
                        {contact.favorite ? (
                          <span>★</span>
                        ) : null}
                      </Link>
                    </li>
                  ))}
                </ul>
              ) : (
                <p>
                  <i>No contacts</i>
                </p>
              )}
            </nav>
          </div>
          <div id="detail">
            <Outlet />
          </div>
        </>
      );
    }
    

And inside `app/root.tsx`, `App` should just return an [`<Outlet>`](https://api.reactrouter.com/v7/functions/react_router.Outlet), and all unused imports can be removed. Make sure there is no `clientLoader` in `root.tsx`.

    // existing imports and exports
    
    export default function App() {
      return <Outlet />;
    }
    

Now with that shuffling around done, our about page no longer loads contacts data nor is it nested inside of the sidebar layout:

[](#pre-rendering-a-static-route)Pre-rendering a Static Route
-------------------------------------------------------------

If you refresh the about page, you still see the loading spinner for just a split second before the page render on the client. This is really not a good experience, plus the page is just static information, we should be able to pre-render it as static HTML at build time.

👉 **Pre-render the about page**

Inside of `react-router.config.ts`, we can add a [`prerender`](../how-to/pre-rendering) array to the config to tell React Router to pre-render certain urls at build time. In this case we just want to pre-render the about page.

    import { type Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
      prerender: ["/about"],
    } satisfies Config;
    

Now if you go to the [about page](http://localhost:5173/about) and refresh, you won't see the loading spinner!

If you're still seeing a spinner when you refresh, make sure you deleted the `clientLoader` in `root.tsx`.

[](#server-side-rendering)Server-Side Rendering
-----------------------------------------------

React Router is a great framework for building [Single Page Apps](../how-to/spa). Many applications are served well by only client-side rendering, and _maybe_ statically pre-rendering a few pages at build time.

If you ever do want to introduce server-side rendering into your React Router application, it's incredibly easy (remember that `ssr: false` boolean from earlier?).

👉 **Enable server-side rendering**

    export default {
      ssr: true,
      prerender: ["/about"],
    } satisfies Config;
    

And now... nothing is different? We're still getting our spinner for a split second before the page renders on the client? Plus, aren't we using `clientLoader`, so our data is still being fetched on the client?

That's right! With React Router you can still use `clientLoader` (and `clientAction`) to do client-side data fetching where you see fit. React Router gives you a lot of flexibility to use the right tool for the job.

Let's switch to using [`loader`](../start/framework/route-module#loader), which (you guessed it) is used to fetch data on the server.

👉 **Switch to using `loader` to fetch data**

    // existing imports
    
    export async function loader() {
      const contacts = await getContacts();
      return { contacts };
    }
    

Whether you set `ssr` to `true` or `false` depends on you and your users needs. Both strategies are perfectly valid. For the remainder of this tutorial we're going to use server-side rendering, but know that all rendering strategies are first class citizens in React Router.

[](#url-params-in-loaders)URL Params in Loaders
-----------------------------------------------

👉 **Click on one of the sidebar links**

We should be seeing our old static contact page again, with one difference: the URL now has a real ID for the record.

Remember the `:contactId` part of the route definition in `app/routes.ts`? These dynamic segments will match dynamic (changing) values in that position of the URL. We call these values in the URL "URL Params", or just "params" for short.

These `params` are passed to the loader with keys that match the dynamic segment. For example, our segment is named `:contactId` so the value will be passed as `params.contactId`.

These params are most often used to find a record by ID. Let's try it out.

👉 **Add a `loader` function to the contact page and access data with `loaderData`**

The following code has type errors in it, we'll fix them in the next section

    // existing imports
    import { getContact } from "../data";
    import type { Route } from "./+types/contact";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const contact = await getContact(params.contactId);
      return { contact };
    }
    
    export default function Contact({
      loaderData,
    }: Route.ComponentProps) {
      const { contact } = loaderData;
    
      // existing code
    }
    
    // existing code
    

[](#throwing-responses)Throwing Responses
-----------------------------------------

You'll notice that the type of `loaderData.contact` is `ContactRecord | null`. Based on our automatic type safety, TypeScript already knows that `params.contactId` is a string, but we haven't done anything to make sure it's a valid ID. Since the contact might not exist, `getContact` could return `null`, which is why we have type errors.

We could account for the possibility of the contact being not found in component code, but the webby thing to do is send a proper 404. We can do that in the loader and solve all of our problems at once.

    // existing imports
    
    export async function loader({ params }: Route.LoaderArgs) {
      const contact = await getContact(params.contactId);
      if (!contact) {
        throw new Response("Not Found", { status: 404 });
      }
      return { contact };
    }
    
    // existing code
    

Now, if the user isn't found, code execution down this path stops and React Router renders the error path instead. Components in React Router can focus only on the happy path 😁

[](#data-mutations)Data Mutations
---------------------------------

We'll create our first contact in a second, but first let's talk about HTML.

React Router emulates HTML Form navigation as the data mutation primitive, which used to be the only way prior to the JavaScript cambrian explosion. Don't be fooled by the simplicity! Forms in React Router give you the UX capabilities of client rendered apps with the simplicity of the "old school" web model.

While unfamiliar to some web developers, HTML `form`s actually cause a navigation in the browser, just like clicking a link. The only difference is in the request: links can only change the URL while `form`s can also change the request method (`GET` vs. `POST`) and the request body (`POST` form data).

Without client side routing, the browser will serialize the `form`'s data automatically and send it to the server as the request body for `POST`, and as [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) for `GET`. React Router does the same thing, except instead of sending the request to the server, it uses client side routing and sends it to the route's [`action`](../start/framework/route-module#action) function.

We can test this out by clicking the "New" button in our app.

React Router sends a 405 because there is no code on the server to handle this form navigation.

[](#creating-contacts)Creating Contacts
---------------------------------------

We'll create new contacts by exporting an `action` function in our root route. When the user clicks the "new" button, the form will `POST` to the root route action.

👉 **Export an `action` function from `app/root.tsx`**

    // existing imports
    
    import { createEmptyContact } from "./data";
    
    export async function action() {
      const contact = await createEmptyContact();
      return { contact };
    }
    
    // existing code
    

That's it! Go ahead and click the "New" button, and you should see a new record pop into the list 🥳

The `createEmptyContact` method just creates an empty contact with no name or data or anything. But it does still create a record, promise!

> 🧐 Wait a sec ... How did the sidebar update? Where did we call the `action` function? Where's the code to re-fetch the data? Where are `useState`, `onSubmit` and `useEffect`?!

This is where the "old school web" programming model shows up. [`<Form>`](https://api.reactrouter.com/v7/functions/react_router.Form) prevents the browser from sending the request to the server and sends it to your route's `action` function instead with [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch).

In web semantics, a `POST` usually means some data is changing. By convention, React Router uses this as a hint to automatically revalidate the data on the page after the `action` finishes.

In fact, since it's all just HTML and HTTP, you could disable JavaScript and the whole thing will still work. Instead of React Router serializing the form and making a [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) request to your server, the browser will serialize the form and make a document request. From there React Router will render the page server side and send it down. It's the same UI in the end either way.

We'll keep JavaScript around though because we're going to make a better user experience than spinning favicons and static documents.

[](#updating-data)Updating Data
-------------------------------

Let's add a way to fill the information for our new record.

Just like creating data, you update data with [`<Form>`](https://api.reactrouter.com/v7/functions/react_router.Form). Let's make a new route module inside `app/routes/edit-contact.tsx`.

👉 **Create the edit contact route**

    touch app/routes/edit-contact.tsx
    

Don't forget to add the route to `app/routes.ts`:

    export default [
      layout("layouts/sidebar.tsx", [
        index("routes/home.tsx"),
        route("contacts/:contactId", "routes/contact.tsx"),
        route(
          "contacts/:contactId/edit",
          "routes/edit-contact.tsx"
        ),
      ]),
      route("about", "routes/about.tsx"),
    ] satisfies RouteConfig;
    

👉 **Add the edit page UI**

Nothing we haven't seen before, feel free to copy/paste:

    import { Form } from "react-router";
    import type { Route } from "./+types/edit-contact";
    
    import { getContact } from "../data";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const contact = await getContact(params.contactId);
      if (!contact) {
        throw new Response("Not Found", { status: 404 });
      }
      return { contact };
    }
    
    export default function EditContact({
      loaderData,
    }: Route.ComponentProps) {
      const { contact } = loaderData;
    
      return (
        <Form key={contact.id} id="contact-form" method="post">
          <p>
            <span>Name</span>
            <input
              aria-label="First name"
              defaultValue={contact.first}
              name="first"
              placeholder="First"
              type="text"
            />
            <input
              aria-label="Last name"
              defaultValue={contact.last}
              name="last"
              placeholder="Last"
              type="text"
            />
          </p>
          <label>
            <span>Twitter</span>
            <input
              defaultValue={contact.twitter}
              name="twitter"
              placeholder="@jack"
              type="text"
            />
          </label>
          <label>
            <span>Avatar URL</span>
            <input
              aria-label="Avatar URL"
              defaultValue={contact.avatar}
              name="avatar"
              placeholder="https://example.com/avatar.jpg"
              type="text"
            />
          </label>
          <label>
            <span>Notes</span>
            <textarea
              defaultValue={contact.notes}
              name="notes"
              rows={6}
            />
          </label>
          <p>
            <button type="submit">Save</button>
            <button type="button">Cancel</button>
          </p>
        </Form>
      );
    }
    

Now click on your new record, then click the "Edit" button. We should see the new route.

[](#updating-contacts-with-formdata)Updating Contacts with `FormData`
---------------------------------------------------------------------

The edit route we just created already renders a `form`. All we need to do is add the `action` function. React Router will serialize the `form`, `POST` it with [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch), and automatically revalidate all the data.

👉 **Add an `action` function to the edit route**

    import { Form, redirect } from "react-router";
    // existing imports
    
    import { getContact, updateContact } from "../data";
    
    export async function action({
      params,
      request,
    }: Route.ActionArgs) {
      const formData = await request.formData();
      const updates = Object.fromEntries(formData);
      await updateContact(params.contactId, updates);
      return redirect(`/contacts/${params.contactId}`);
    }
    
    // existing code
    

Fill out the form, hit save, and you should see something like this! (Except easier on the eyes and maybe with the patience to cut watermelon.)

[](#mutation-discussion)Mutation Discussion
-------------------------------------------

> 😑 It worked, but I have no idea what is going on here...

Let's dig in a bit...

Open up `app/routes/edit-contact.tsx` and look at the `form` elements. Notice how they each have a name:

    <input
      aria-label="First name"
      defaultValue={contact.first}
      name="first"
      placeholder="First"
      type="text"
    />
    

Without JavaScript, when a form is submitted, the browser will create [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) and set it as the body of the request when it sends it to the server. As mentioned before, React Router prevents that and emulates the browser by sending the request to your `action` function with [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) instead, including the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

Each field in the `form` is accessible with `formData.get(name)`. For example, given the input field from above, you could access the first and last names like this:

    export const action = async ({
      params,
      request,
    }: ActionFunctionArgs) => {
      const formData = await request.formData();
      const firstName = formData.get("first");
      const lastName = formData.get("last");
      // ...
    };
    

Since we have a handful of form fields, we used [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) to collect them all into an object, which is exactly what our `updateContact` function wants.

    const updates = Object.fromEntries(formData);
    updates.first; // "Some"
    updates.last; // "Name"
    

Aside from the `action` function, none of these APIs we're discussing are provided by React Router: [`request`](https://developer.mozilla.org/en-US/docs/Web/API/Request), [`request.formData`](https://developer.mozilla.org/en-US/docs/Web/API/Request/formData), [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) are all provided by the web platform.

After we finished the `action`, note the [`redirect`](https://api.reactrouter.com/v7/functions/react_router.redirect) at the end:

    export async function action({
      params,
      request,
    }: Route.ActionArgs) {
      invariant(params.contactId, "Missing contactId param");
      const formData = await request.formData();
      const updates = Object.fromEntries(formData);
      await updateContact(params.contactId, updates);
      return redirect(`/contacts/${params.contactId}`);
    }
    

`action` and `loader` functions can both return a `Response` (makes sense, since they received a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)!). The [`redirect`](https://api.reactrouter.com/v7/functions/react_router.redirect) helper just makes it easier to return a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) that tells the app to change locations.

Without client side routing, if a server redirected after a `POST` request, the new page would fetch the latest data and render. As we learned before, React Router emulates this model and automatically revalidates the data on the page after the `action` call. That's why the sidebar automatically updates when we save the form. The extra revalidation code doesn't exist without client side routing, so it doesn't need to exist with client side routing in React Router either!

One last thing. Without JavaScript, the [`redirect`](https://api.reactrouter.com/v7/functions/react_router.redirect) would be a normal redirect. However, with JavaScript it's a client-side redirect, so the user doesn't lose client state like scroll positions or component state.

[](#redirecting-new-records-to-the-edit-page)Redirecting new records to the edit page
-------------------------------------------------------------------------------------

Now that we know how to redirect, let's update the action that creates new contacts to redirect to the edit page:

👉 **Redirect to the new record's edit page**

    import {
      Outlet,
      Scripts,
      ScrollRestoration,
      isRouteErrorResponse,
      redirect,
    } from "react-router";
    // existing imports
    
    export async function action() {
      const contact = await createEmptyContact();
      return redirect(`/contacts/${contact.id}/edit`);
    }
    
    // existing code
    

Now when we click "New", we should end up on the edit page:

[](#active-link-styling)Active Link Styling
-------------------------------------------

Now that we have a bunch of records, it's not clear which one we're looking at in the sidebar. We can use [`NavLink`](https://api.reactrouter.com/v7/functions/react_router.NavLink) to fix this.

👉 **Replace `<Link>` with `<NavLink>` in the sidebar**

    import { Form, Link, NavLink, Outlet } from "react-router";
    
    // existing imports and exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts } = loaderData;
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <ul>
              {contacts.map((contact) => (
                <li key={contact.id}>
                  <NavLink
                    className={({ isActive, isPending }) =>
                      isActive
                        ? "active"
                        : isPending
                        ? "pending"
                        : ""
                    }
                    to={`contacts/${contact.id}`}
                  >
                    {/* existing elements */}
                  </NavLink>
                </li>
              ))}
            </ul>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

Note that we are passing a function to `className`. When the user is at the URL that matches `<NavLink to>`, then `isActive` will be true. When it's _about_ to be active (the data is still loading) then `isPending` will be true. This allows us to easily indicate where the user is and also provide immediate feedback when links are clicked but data needs to be loaded.

[](#global-pending-ui)Global Pending UI
---------------------------------------

As the user navigates the app, React Router will _leave the old page up_ as data is loading for the next page. You may have noticed the app feels a little unresponsive as you click between the list. Let's provide the user with some feedback so the app doesn't feel unresponsive.

React Router is managing all the state behind the scenes and reveals the pieces you need to build dynamic web apps. In this case, we'll use the [`useNavigation`](https://api.reactrouter.com/v7/functions/react_router.useNavigation) hook.

👉 **Use `useNavigation` to add global pending UI**

    import {
      Form,
      Link,
      NavLink,
      Outlet,
      useNavigation,
    } from "react-router";
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts } = loaderData;
      const navigation = useNavigation();
    
      return (
        <>
          {/* existing elements */}
          <div
            className={
              navigation.state === "loading" ? "loading" : ""
            }
            id="detail"
          >
            <Outlet />
          </div>
        </>
      );
    }
    

[`useNavigation`](https://api.reactrouter.com/v7/functions/react_router.useNavigation) returns the current navigation state: it can be one of `"idle"`, `"loading"` or `"submitting"`.

In our case, we add a `"loading"` class to the main part of the app if we're not idle. The CSS then adds a nice fade after a short delay (to avoid flickering the UI for fast loads). You could do anything you want though, like show a spinner or loading bar across the top.

[](#deleting-records)Deleting Records
-------------------------------------

If we review code in the contact route, we can find the delete button looks like this:

    <Form
      action="destroy"
      method="post"
      onSubmit={(event) => {
        const response = confirm(
          "Please confirm you want to delete this record."
        );
        if (!response) {
          event.preventDefault();
        }
      }}
    >
      <button type="submit">Delete</button>
    </Form>
    

Note the `action` points to `"destroy"`. Like `<Link to>`, `<Form action>` can take a _relative_ value. Since the form is rendered in the route `contacts/:contactId`, then a relative action with `destroy` will submit the form to `contacts/:contactId/destroy` when clicked.

At this point you should know everything you need to know to make the delete button work. Maybe give it a shot before moving on? You'll need:

1.  A new route
2.  An `action` at that route
3.  `deleteContact` from `app/data.ts`
4.  `redirect` to somewhere after

👉 **Configure the "destroy" route module**

    touch app/routes/destroy-contact.tsx
    

    export default [
      // existing routes
      route(
        "contacts/:contactId/destroy",
        "routes/destroy-contact.tsx"
      ),
      // existing routes
    ] satisfies RouteConfig;
    

👉 **Add the destroy action**

    import { redirect } from "react-router";
    import type { Route } from "./+types/destroy-contact";
    
    import { deleteContact } from "../data";
    
    export async function action({ params }: Route.ActionArgs) {
      await deleteContact(params.contactId);
      return redirect("/");
    }
    

Alright, navigate to a record and click the "Delete" button. It works!

> 😅 I'm still confused why this all works

When the user clicks the submit button:

1.  `<Form>` prevents the default browser behavior of sending a new document `POST` request to the server, but instead emulates the browser by creating a `POST` request with client side routing and [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)
2.  The `<Form action="destroy">` matches the new route at `contacts/:contactId/destroy` and sends it the request
3.  After the `action` redirects, React Router calls all the `loader`s for the data on the page to get the latest values (this is "revalidation"). `loaderData` in `routes/contact.tsx` now has new values and causes the components to update!

Add a `Form`, add an `action`, React Router does the rest.

[](#cancel-button)Cancel Button
-------------------------------

On the edit page we've got a cancel button that doesn't do anything yet. We'd like it to do the same thing as the browser's back button.

We'll need a click handler on the button as well as [`useNavigate`](https://api.reactrouter.com/v7/functions/react_router.useNavigate).

👉 **Add the cancel button click handler with `useNavigate`**

    import { Form, redirect, useNavigate } from "react-router";
    // existing imports & exports
    
    export default function EditContact({
      loaderData,
    }: Route.ComponentProps) {
      const { contact } = loaderData;
      const navigate = useNavigate();
    
      return (
        <Form key={contact.id} id="contact-form" method="post">
          {/* existing elements */}
          <p>
            <button type="submit">Save</button>
            <button onClick={() => navigate(-1)} type="button">
              Cancel
            </button>
          </p>
        </Form>
      );
    }
    

Now when the user clicks "Cancel", they'll be sent back one entry in the browser's history.

> 🧐 Why is there no `event.preventDefault()` on the button?

A `<button type="button">`, while seemingly redundant, is the HTML way of preventing a button from submitting its form.

Two more features to go. We're on the home stretch!

[](#urlsearchparams-and-get-submissions)`URLSearchParams` and `GET` Submissions
-------------------------------------------------------------------------------

All of our interactive UI so far have been either links that change the URL or `form`s that post data to `action` functions. The search field is interesting because it's a mix of both: it's a `form`, but it only changes the URL, it doesn't change data.

Let's see what happens when we submit the search form:

👉 **Type a name into the search field and hit the enter key**

Note the browser's URL now contains your query in the URL as [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams):

    http://localhost:5173/?q=ryan
    

Since it's not `<Form method="post">`, React Router emulates the browser by serializing the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) into the [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) instead of the request body.

`loader` functions have access to the search params from the `request`. Let's use it to filter the list:

👉 **Filter the list if there are `URLSearchParams`**

    // existing imports & exports
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const url = new URL(request.url);
      const q = url.searchParams.get("q");
      const contacts = await getContacts(q);
      return { contacts };
    }
    
    // existing code
    

Because this is a `GET`, not a `POST`, React Router _does not_ call the `action` function. Submitting a `GET` `form` is the same as clicking a link: only the URL changes.

This also means it's a normal page navigation. You can click the back button to get back to where you were.

[](#synchronizing-urls-to-form-state)Synchronizing URLs to Form State
---------------------------------------------------------------------

There are a couple of UX issues here that we can take care of quickly.

1.  If you click back after a search, the form field still has the value you entered even though the list is no longer filtered.
2.  If you refresh the page after searching, the form field no longer has the value in it, even though the list is filtered

In other words, the URL and our input's state are out of sync.

Let's solve (2) first and start the input with the value from the URL.

👉 **Return `q` from your `loader`, set it as the input's default value**

    // existing imports & exports
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const url = new URL(request.url);
      const q = url.searchParams.get("q");
      const contacts = await getContacts(q);
      return { contacts, q };
    }
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form id="search-form" role="search">
                <input
                  aria-label="Search contacts"
                  defaultValue={q || ""}
                  id="q"
                  name="q"
                  placeholder="Search"
                  type="search"
                />
                {/* existing elements */}
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

The input field will show the query if you refresh the page after a search now.

Now for problem (1), clicking the back button and updating the input. We can bring in `useEffect` from React to manipulate the input's value in the DOM directly.

👉 **Synchronize input value with the `URLSearchParams`**

    // existing imports
    import { useEffect } from "react";
    
    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
    
      useEffect(() => {
        const searchField = document.getElementById("q");
        if (searchField instanceof HTMLInputElement) {
          searchField.value = q || "";
        }
      }, [q]);
    
      // existing code
    }
    

> 🤔 Shouldn't you use a controlled component and React State for this?

You could certainly do this as a controlled component. You will have more synchronization points, but it's up to you.

Expand this to see what it would look like

    // existing imports
    import { useEffect, useState } from "react";
    
    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
      // the query now needs to be kept in state
      const [query, setQuery] = useState(q || "");
    
      // we still have a `useEffect` to synchronize the query
      // to the component state on back/forward button clicks
      useEffect(() => {
        setQuery(q || "");
      }, [q]);
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form id="search-form" role="search">
                <input
                  aria-label="Search contacts"
                  id="q"
                  name="q"
                  // synchronize user's input to component state
                  onChange={(event) =>
                    setQuery(event.currentTarget.value)
                  }
                  placeholder="Search"
                  type="search"
                  // switched to `value` from `defaultValue`
                  value={query}
                />
                {/* existing elements */}
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }

Alright, you should now be able to click the back/forward/refresh buttons and the input's value should be in sync with the URL and results.

[](#submitting-forms-onchange)Submitting `Form`'s `onChange`
------------------------------------------------------------

We've got a product decision to make here. Sometimes you want the user to submit the `form` to filter some results, other times you want to filter as the user types. We've already implemented the first, so let's see what it's like for the second.

We've seen `useNavigate` already, we'll use its cousin, [`useSubmit`](https://api.reactrouter.com/v7/functions/react_router.useSubmit), for this.

    import {
      Form,
      Link,
      NavLink,
      Outlet,
      useNavigation,
      useSubmit,
    } from "react-router";
    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
      const submit = useSubmit();
    
      // existing code
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form
                id="search-form"
                onChange={(event) =>
                  submit(event.currentTarget)
                }
                role="search"
              >
                {/* existing elements */}
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

As you type, the `form` is automatically submitted now!

Note the argument to [`submit`](https://api.reactrouter.com/v7/functions/react_router.useSubmit). The `submit` function will serialize and submit any form you pass to it. We're passing in `event.currentTarget`. The `currentTarget` is the DOM node the event is attached to (the `form`).

[](#adding-search-spinner)Adding Search Spinner
-----------------------------------------------

In a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side. That's why this demo has some faked network latency.

Without any loading indicator, the search feels kinda sluggish. Even if we could make our database faster, we'll always have the user's network latency in the way and out of our control.

For a better user experience, let's add some immediate UI feedback for the search. We'll use [`useNavigation`](https://api.reactrouter.com/v7/functions/react_router.useNavigation) again.

👉 **Add a variable to know if we're searching**

    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      const { contacts, q } = loaderData;
      const navigation = useNavigation();
      const submit = useSubmit();
      const searching =
        navigation.location &&
        new URLSearchParams(navigation.location.search).has(
          "q"
        );
    
      // existing code
    }
    

When nothing is happening, `navigation.location` will be `undefined`, but when the user navigates it will be populated with the next location while data loads. Then we check if they're searching with `location.search`.

👉 **Add classes to search form elements using the new `searching` state**

    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      // existing code
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form
                id="search-form"
                onChange={(event) =>
                  submit(event.currentTarget)
                }
                role="search"
              >
                <input
                  aria-label="Search contacts"
                  className={searching ? "loading" : ""}
                  defaultValue={q || ""}
                  id="q"
                  name="q"
                  placeholder="Search"
                  type="search"
                />
                <div
                  aria-hidden
                  hidden={!searching}
                  id="search-spinner"
                />
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

Bonus points, avoid fading out the main screen when searching:

    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      // existing code
    
      return (
        <>
          {/* existing elements */}
          <div
            className={
              navigation.state === "loading" && !searching
                ? "loading"
                : ""
            }
            id="detail"
          >
            <Outlet />
          </div>
          {/* existing elements */}
        </>
      );
    }
    

You should now have a nice spinner on the left side of the search input.

[](#managing-the-history-stack)Managing the History Stack
---------------------------------------------------------

Since the form is submitted for every keystroke, typing the characters "alex" and then deleting them with backspace results in a huge history stack 😂. We definitely don't want this:

We can avoid this by _replacing_ the current entry in the history stack with the next page, instead of pushing into it.

👉 **Use `replace` in `submit`**

    // existing imports & exports
    
    export default function SidebarLayout({
      loaderData,
    }: Route.ComponentProps) {
      // existing code
    
      return (
        <>
          <div id="sidebar">
            {/* existing elements */}
            <div>
              <Form
                id="search-form"
                onChange={(event) => {
                  const isFirstSearch = q === null;
                  submit(event.currentTarget, {
                    replace: !isFirstSearch,
                  });
                }}
                role="search"
              >
                {/* existing elements */}
              </Form>
              {/* existing elements */}
            </div>
            {/* existing elements */}
          </div>
          {/* existing elements */}
        </>
      );
    }
    

After a quick check if this is the first search or not, we decide to replace. Now the first search will add a new entry, but every keystroke after that will replace the current entry. Instead of clicking back 7 times to remove the search, users only have to click back once.

[](#forms-without-navigation)`Form`s Without Navigation
-------------------------------------------------------

So far all of our forms have changed the URL. While these user flows are common, it's equally common to want to submit a form _without_ causing a navigation.

For these cases, we have [`useFetcher`](https://api.reactrouter.com/v7/functions/react_router.useFetcher). It allows us to communicate with `action`s and `loader`s without causing a navigation.

The ★ button on the contact page makes sense for this. We aren't creating or deleting a new record, and we don't want to change pages. We simply want to change the data on the page we're looking at.

👉 **Change the `<Favorite>` form to a fetcher form**

    import { Form, useFetcher } from "react-router";
    
    // existing imports & exports
    
    function Favorite({
      contact,
    }: {
      contact: Pick<ContactRecord, "favorite">;
    }) {
      const fetcher = useFetcher();
      const favorite = contact.favorite;
    
      return (
        <fetcher.Form method="post">
          <button
            aria-label={
              favorite
                ? "Remove from favorites"
                : "Add to favorites"
            }
            name="favorite"
            value={favorite ? "false" : "true"}
          >
            {favorite ? "★" : "☆"}
          </button>
        </fetcher.Form>
      );
    }
    

This form will no longer cause a navigation, but simply fetch to the `action`. Speaking of which ... this won't work until we create the `action`.

👉 **Create the `action`**

    // existing imports
    import { getContact, updateContact } from "../data";
    // existing imports
    
    export async function action({
      params,
      request,
    }: Route.ActionArgs) {
      const formData = await request.formData();
      return updateContact(params.contactId, {
        favorite: formData.get("favorite") === "true",
      });
    }
    
    // existing code
    

Alright, we're ready to click the star next to the user's name!

Check that out, both stars automatically update. Our new `<fetcher.Form method="post">` works almost exactly like the `<Form>` we've been using: it calls the action and then all data is revalidated automatically — even your errors will be caught the same way.

There is one key difference though, it's not a navigation, so the URL doesn't change and the history stack is unaffected.

[](#optimistic-ui)Optimistic UI
-------------------------------

You probably noticed the app felt kind of unresponsive when we clicked the favorite button from the last section. Once again, we added some network latency because you're going to have it in the real world.

To give the user some feedback, we could put the star into a loading state with `fetcher.state` (a lot like `navigation.state` from before), but we can do something even better this time. We can use a strategy called "Optimistic UI".

The fetcher knows the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) being submitted to the `action`, so it's available to you on `fetcher.formData`. We'll use that to immediately update the star's state, even though the network hasn't finished. If the update eventually fails, the UI will revert to the real data.

👉 **Read the optimistic value from `fetcher.formData`**

    // existing code
    
    function Favorite({
      contact,
    }: {
      contact: Pick<ContactRecord, "favorite">;
    }) {
      const fetcher = useFetcher();
      const favorite = fetcher.formData
        ? fetcher.formData.get("favorite") === "true"
        : contact.favorite;
    
      return (
        <fetcher.Form method="post">
          <button
            aria-label={
              favorite
                ? "Remove from favorites"
                : "Add to favorites"
            }
            name="favorite"
            value={favorite ? "false" : "true"}
          >
            {favorite ? "★" : "☆"}
          </button>
        </fetcher.Form>
      );
    }
    

Now the star _immediately_ changes to the new state when you click it.

* * *

That's it! Thanks for giving React Router a shot. We hope this tutorial gives you a solid start to build great user experiences. There's a lot more you can do, so make sure to check out all the [APIs](https://api.reactrouter.com/v7/modules/react_router) 😀

[](#client-data)Client Data
===========================

You can fetch and mutate data directly in the browser using `clientLoader` and `clientAction` functions.

These functions are the primary mechanism for data handling when using [SPA mode](../how-to/spa). This guide demonstrates common use cases for leveraging client data in Server-Side Rendering (SSR).

[](#skip-the-server-hop)Skip the Server Hop
-------------------------------------------

When using React Router with a Backend-For-Frontend (BFF) architecture, you might want to bypass the React Router server and communicate directly with your backend API. This approach requires proper authentication handling and assumes no CORS restrictions. Here's how to implement this:

1.  Load the data from server `loader` on the document load
2.  Load the data from the `clientLoader` on all subsequent loads

In this scenario, React Router will _not_ call the `clientLoader` on hydration - and will only call it on subsequent navigations.

    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const data = await fetchApiFromServer({ request }); // (1)
      return data;
    }
    
    export async function clientLoader({
      request,
    }: Route.ClientLoaderArgs) {
      const data = await fetchApiFromClient({ request }); // (2)
      return data;
    }
    

[](#fullstack-state)Fullstack State
-----------------------------------

Sometimes you need to combine data from both the server and browser (like IndexedDB or browser SDKs) before rendering a component. Here's how to implement this pattern:

1.  Load the partial data from server `loader` on the document load
2.  Export a [`HydrateFallback`](../start/framework/route-module#hydratefallback) component to render during SSR because we don't yet have a full set of data
3.  Set `clientLoader.hydrate = true`, this instructs React Router to call the clientLoader as part of initial document hydration
4.  Combine the server data with the client data in `clientLoader`

    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const partialData = await getPartialDataFromDb({
        request,
      }); // (1)
      return partialData;
    }
    
    export async function clientLoader({
      request,
      serverLoader,
    }: Route.ClientLoaderArgs) {
      const [serverData, clientData] = await Promise.all([
        serverLoader(),
        getClientData(request),
      ]);
      return {
        ...serverData, // (4)
        ...clientData, // (4)
      };
    }
    clientLoader.hydrate = true as const; // (3)
    
    export function HydrateFallback() {
      return <p>Skeleton rendered during SSR</p>; // (2)
    }
    
    export default function Component({
      // This will always be the combined set of server + client data
      loaderData,
    }: Route.ComponentProps) {
      return <>...</>;
    }
    

[](#choosing-server-or-client-data-loading)Choosing Server or Client Data Loading
---------------------------------------------------------------------------------

You can mix data loading strategies across your application, choosing between server-only or client-only data loading for each route. Here's how to implement both approaches:

1.  Export a `loader` when you want to use server data
2.  Export `clientLoader` and a `HydrateFallback` when you want to use client data

A route that only depends on a server loader looks like this:

    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const data = await getServerData(request);
      return data;
    }
    
    export default function Component({
      loaderData, // (1) - server data
    }: Route.ComponentProps) {
      return <>...</>;
    }
    

A route that only depends on a client loader looks like this.

    export async function clientLoader({
      request,
    }: Route.ClientLoaderArgs) {
      const clientData = await getClientData(request);
      return clientData;
    }
    // Note: you do not have to set this explicitly - it is implied if there is no `loader`
    clientLoader.hydrate = true;
    
    // (2)
    export function HydrateFallback() {
      return <p>Skeleton rendered during SSR</p>;
    }
    
    export default function Component({
      loaderData, // (2) - client data
    }: Route.ComponentProps) {
      return <>...</>;
    }
    

[](#client-side-caching)Client-Side Caching
-------------------------------------------

You can implement client-side caching (using memory, localStorage, etc.) to optimize server requests. Here's a pattern that demonstrates cache management:

1.  Load the data from server `loader` on the document load
2.  Set `clientLoader.hydrate = true` to prime the cache
3.  Load subsequent navigations from the cache via `clientLoader`
4.  Invalidate the cache in your `clientAction`

Note that since we are not exporting a `HydrateFallback` component, we will SSR the route component and then run the `clientLoader` on hydration, so it's important that your `loader` and `clientLoader` return the same data on initial load to avoid hydration errors.

    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const data = await getDataFromDb({ request }); // (1)
      return data;
    }
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      await saveDataToDb({ request });
      return { ok: true };
    }
    
    let isInitialRequest = true;
    
    export async function clientLoader({
      request,
      serverLoader,
    }: Route.ClientLoaderArgs) {
      const cacheKey = generateKey(request);
    
      if (isInitialRequest) {
        isInitialRequest = false;
        const serverData = await serverLoader();
        cache.set(cacheKey, serverData); // (2)
        return serverData;
      }
    
      const cachedData = await cache.get(cacheKey);
      if (cachedData) {
        return cachedData; // (3)
      }
    
      const serverData = await serverLoader();
      cache.set(cacheKey, serverData);
      return serverData;
    }
    clientLoader.hydrate = true; // (2)
    
    export async function clientAction({
      request,
      serverAction,
    }: Route.ClientActionArgs) {
      const cacheKey = generateKey(request);
      cache.delete(cacheKey); // (4)
      const serverData = await serverAction();
      return serverData;
    }
    

[](#error-boundaries)Error Boundaries
=====================================

To avoid rendering an empty page to users, route modules will automatically catch errors in your code and render the closest `ErrorBoundary`.

Error boundaries are not intended for error reporting or rendering form validation errors. Please see [Form Validation](./form-validation) and [Error Reporting](./error-reporting) instead.

[](#1-add-a-root-error-boundary)1\. Add a root error boundary
-------------------------------------------------------------

All applications should at a minimum export a root error boundary. This one handles the three main cases:

*   Thrown `data` with a status code and text
*   Instances of errors with a stack trace
*   Randomly thrown values

    import { Route } from "./+types/root";
    
    export function ErrorBoundary({
      error,
    }: Route.ErrorBoundaryProps) {
      if (isRouteErrorResponse(error)) {
        return (
          <>
            <h1>
              {error.status} {error.statusText}
            </h1>
            <p>{error.data}</p>
          </>
        );
      } else if (error instanceof Error) {
        return (
          <div>
            <h1>Error</h1>
            <p>{error.message}</p>
            <p>The stack trace is:</p>
            <pre>{error.stack}</pre>
          </div>
        );
      } else {
        return <h1>Unknown Error</h1>;
      }
    }
    

[](#2-write-a-bug)2\. Write a bug
---------------------------------

It's not recommended to intentionally throw errors to force the error boundary to render as a means of control flow. Error Boundaries are primarily for catching unintentional errors in your code.

    export async function loader() {
      return undefined();
    }
    

This will render the `instanceof Error` branch of the UI from step 1.

This is not just for loaders, but for all route module APIs: loaders, actions, components, headers, links, and meta.

[](#3-throw-data-in-loadersactions)3\. Throw data in loaders/actions
--------------------------------------------------------------------

There are exceptions to the rule in #2, especially 404s. You can intentionally `throw data()` (with a proper status code) to the closest error boundary when your loader can't find what it needs to render the page. Throw a 404 and move on.

    import { data } from "react-router";
    
    export async function loader({ params }) {
      let record = await fakeDb.getRecord(params.id);
      if (!record) {
        throw data("Record Not Found", { status: 404 });
      }
      return record;
    }
    

This will render the `isRouteErrorResponse` branch of the UI from step 1.

[](#4-nested-error-boundaries)4\. Nested error boundaries
---------------------------------------------------------

When an error is thrown, the "closest error boundary" will be rendered. Consider these nested routes:

    // ✅ has error boundary
    route("/app", "app.tsx", [
      // ❌ no error boundary
      route("invoices", "invoices.tsx", [
        // ✅ has error boundary
        route("invoices/:id", "invoice-page.tsx", [
          // ❌ no error boundary
          route("payments", "payments.tsx"),
        ]),
      ]),
    ]);
    

The following table shows which error boundary will render given the origin of the error:

error origin

rendered boundary

app.tsx

app.tsx

invoices.tsx

app.tsx

invoice-page.tsx

invoice-page.tsx

payments.tsx

invoice-page.tsx

[](#error-sanitization)Error Sanitization
-----------------------------------------

In production mode, any errors that happen on the server are automatically sanitized before being sent to the browser to prevent leaking any sensitive server information (like stack traces).

This means that a thrown `Error` will have a generic message and no stack trace in production in the browser. The original error is untouched on the server.

Also note that data sent with `throw data(yourData)` is not sanitized as the data there is intended to be rendered.

[](#error-reporting)Error Reporting
===================================

React Router catches errors in your route modules and sends them to [error boundaries](./error-boundary) to prevent blank pages when errors occur. However, ErrorBoundary isn't sufficient for logging and reporting errors. To access these caught errors, use the handleError export of the server entry module.

[](#1-reveal-the-server-entry)1\. Reveal the server entry
---------------------------------------------------------

If you don't see `entry.server.tsx` in your app directory, you're using a default entry. Reveal it with this cli command:

    react-router reveal
    

[](#2-export-your-error-handler)2\. Export your error handler
-------------------------------------------------------------

This function is called whenever React Router catches an error in your application on the server.

    import { type HandleErrorFunction } from "react-router";
    
    export const handleError: HandleErrorFunction = (
      error,
      { request }
    ) => {
      // React Router may abort some interrupted requests, don't log those
      if (!request.signal.aborted) {
        myReportError(error);
    
        // make sure to still log the error so you can see it
        console.error(error);
      }
    };
    

[](#using-fetchers)Using Fetchers
=================================

Fetchers are useful for creating complex, dynamic user interfaces that require multiple, concurrent data interactions without causing a navigation.

Fetchers track their own, independent state and can be used to load data, mutate data, submit forms, and generally interact with loaders and actions.

[](#calling-actions)Calling Actions
-----------------------------------

The most common case for a fetcher is to submit data to an action, triggering a revalidation of route data. Consider the following route module:

    import { useLoaderData } from "react-router";
    
    export async function clientLoader({ request }) {
      let title = localStorage.getItem("title") || "No Title";
      return { title };
    }
    
    export default function Component() {
      let data = useLoaderData();
      return (
        <div>
          <h1>{data.title}</h1>
        </div>
      );
    }
    

### [](#1-add-an-action)1\. Add an action

First we'll add an action to the route for the fetcher to call:

    import { useLoaderData } from "react-router";
    
    export async function clientLoader({ request }) {
      // ...
    }
    
    export async function clientAction({ request }) {
      await new Promise((res) => setTimeout(res, 1000));
      let data = await request.formData();
      localStorage.setItem("title", data.get("title"));
      return { ok: true };
    }
    
    export default function Component() {
      let data = useLoaderData();
      // ...
    }
    

### [](#2-create-a-fetcher)2\. Create a fetcher

Next create a fetcher and render a form with it:

    import { useLoaderData, useFetcher } from "react-router";
    
    // ...
    
    export default function Component() {
      let data = useLoaderData();
      let fetcher = useFetcher();
      return (
        <div>
          <h1>{data.title}</h1>
    
          <fetcher.Form method="post">
            <input type="text" name="title" />
          </fetcher.Form>
        </div>
      );
    }
    

### [](#3-submit-the-form)3\. Submit the form

If you submit the form now, the fetcher will call the action and revalidate the route data automatically.

### [](#4-render-pending-state)4\. Render pending state

Fetchers make their state available during the async work so you can render pending UI the moment the user interacts:

    export default function Component() {
      let data = useLoaderData();
      let fetcher = useFetcher();
      return (
        <div>
          <h1>{data.title}</h1>
    
          <fetcher.Form method="post">
            <input type="text" name="title" />
            {fetcher.state !== "idle" && <p>Saving...</p>}
          </fetcher.Form>
        </div>
      );
    }
    

### [](#5-optimistic-ui)5\. Optimistic UI

Sometimes there's enough information in the form to render the next state immediately. You can access the form data with `fetcher.formData`:

    export default function Component() {
      let data = useLoaderData();
      let fetcher = useFetcher();
      let title = fetcher.formData?.get("title") || data.title;
    
      return (
        <div>
          <h1>{title}</h1>
    
          <fetcher.Form method="post">
            <input type="text" name="title" />
            {fetcher.state !== "idle" && <p>Saving...</p>}
          </fetcher.Form>
        </div>
      );
    }
    

### [](#6-fetcher-data-and-validation)6\. Fetcher Data and Validation

Data returned from an action is available in the fetcher's `data` property. This is primarily useful for returning error messages to the user for a failed mutation:

    // ...
    
    export async function clientAction({ request }) {
      await new Promise((res) => setTimeout(res, 1000));
      let data = await request.formData();
    
      let title = data.get("title") as string;
      if (title.trim() === "") {
        return { ok: false, error: "Title cannot be empty" };
      }
    
      localStorage.setItem("title", title);
      return { ok: true, error: null };
    }
    
    export default function Component() {
      let data = useLoaderData();
      let fetcher = useFetcher();
      let title = fetcher.formData?.get("title") || data.title;
    
      return (
        <div>
          <h1>{title}</h1>
    
          <fetcher.Form method="post">
            <input type="text" name="title" />
            {fetcher.state !== "idle" && <p>Saving...</p>}
            {fetcher.data?.error && (
              <p style={{ color: "red" }}>
                {fetcher.data.error}
              </p>
            )}
          </fetcher.Form>
        </div>
      );
    }
    

[](#loading-data)Loading Data
-----------------------------

Another common use case for fetchers is to load data from a route for something like a combobox.

### [](#1-create-a-search-route)1\. Create a search route

Consider the following route with a very basic search:

    // { path: '/search-users', filename: './search-users.tsx' }
    const users = [
      { id: 1, name: "Ryan" },
      { id: 2, name: "Michael" },
      // ...
    ];
    
    export async function loader({ request }) {
      await new Promise((res) => setTimeout(res, 300));
      let url = new URL(request.url);
      let query = url.searchParams.get("q");
      return users.filter((user) =>
        user.name.toLowerCase().includes(query.toLowerCase())
      );
    }
    

### [](#2-render-a-fetcher-in-a-combobox-component)2\. Render a fetcher in a combobox component

    import { useFetcher } from "react-router";
    
    export function UserSearchCombobox() {
      let fetcher = useFetcher();
      return (
        <div>
          <fetcher.Form method="get" action="/search-users">
            <input type="text" name="q" />
          </fetcher.Form>
        </div>
      );
    }
    

*   The action points to the route we created above: "/search-users"
*   The name of the input is "q" to match the query parameter

### [](#3-add-type-inference)3\. Add type inference

    import { useFetcher } from "react-router";
    import type { loader } from "./search-users";
    
    export function UserSearchCombobox() {
      let fetcher = useFetcher<typeof loader>();
      // ...
    }
    

Ensure you use `import type` so you only import the types.

### [](#4-render-the-data)4\. Render the data

    import { useFetcher } from "react-router";
    
    export function UserSearchCombobox() {
      let fetcher = useFetcher<typeof loader>();
      return (
        <div>
          <fetcher.Form method="get" action="/search-users">
            <input type="text" name="q" />
          </fetcher.Form>
          {fetcher.data && (
            <ul>
              {fetcher.data.map((user) => (
                <li key={user.id}>{user.name}</li>
              ))}
            </ul>
          )}
        </div>
      );
    }
    

Note you will need to hit "enter" to submit the form and see the results.

### [](#5-render-a-pending-state)5\. Render a pending state

    import { useFetcher } from "react-router";
    
    export function UserSearchCombobox() {
      let fetcher = useFetcher<typeof loader>();
      return (
        <div>
          <fetcher.Form method="get" action="/search-users">
            <input type="text" name="q" />
          </fetcher.Form>
          {fetcher.data && (
            <ul
              style={{
                opacity: fetcher.state === "idle" ? 1 : 0.25,
              }}
            >
              {fetcher.data.map((user) => (
                <li key={user.id}>{user.name}</li>
              ))}
            </ul>
          )}
        </div>
      );
    }
    

### [](#6-search-on-user-input)6\. Search on user input

Fetchers can be submitted programmatically with `fetcher.submit`:

    <fetcher.Form method="get" action="/search-users">
      <input
        type="text"
        name="q"
        onChange={(event) => {
          fetcher.submit(event.currentTarget.form);
        }}
      />
    </fetcher.Form>
    

Note the input event's form is passed as the first argument to `fetcher.submit`. The fetcher will use that form to submit the request, reading its attributes and serializing the data from its elements.

[](#file-route-conventions)File Route Conventions
=================================================

The `@react-router/fs-routes` package enables file-convention based route config.

[](#setting-up)Setting up
-------------------------

First install the `@react-router/fs-routes` package:

    npm i @react-router/fs-routes
    

Then use it to provide route config in your `app/routes.ts` file:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default flatRoutes() satisfies RouteConfig;
    

Any modules in the `app/routes` directory will become routes in your application by default. The `ignoredRouteFiles` option allows you to specify files that should not be included as routes:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default flatRoutes({
      ignoredRouteFiles: ["home.tsx"],
    }) satisfies RouteConfig;
    

This will look for routes in the `app/routes` directory by default, but this can be configured via the `rootDirectory` option which is relative to your app directory:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default flatRoutes({
      rootDirectory: "file-routes",
    }) satisfies RouteConfig;
    

The rest of this guide will assume you're using the default `app/routes` directory.

[](#basic-routes)Basic Routes
-----------------------------

The filename maps to the route's URL pathname, except for `_index.tsx` which is the [index route](../start/framework/routing#index-routes) for the [root route](../start/framework/route-module). You can use `.js`, `.jsx`, `.ts` or `.tsx` file extensions.

    app/
    ├── routes/
    │   ├── _index.tsx
    │   └── about.tsx
    └── root.tsx
    

URL

Matched Routes

`/`

`app/routes/_index.tsx`

`/about`

`app/routes/about.tsx`

Note that these routes will be rendered in the outlet of `app/root.tsx` because of [nested routing](../start/framework/routing#nested-routes).

[](#dot-delimiters)Dot Delimiters
---------------------------------

Adding a `.` to a route filename will create a `/` in the URL.

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── about.tsx
    │   ├── concerts.trending.tsx
    │   ├── concerts.salt-lake-city.tsx
    │   └── concerts.san-diego.tsx
    └── root.tsx
    

URL

Matched Route

`/`

`app/routes/_index.tsx`

`/about`

`app/routes/about.tsx`

`/concerts/trending`

`app/routes/concerts.trending.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.salt-lake-city.tsx`

`/concerts/san-diego`

`app/routes/concerts.san-diego.tsx`

The dot delimiter also creates nesting, see the [nesting section](#nested-routes) for more information.

[](#dynamic-segments)Dynamic Segments
-------------------------------------

Usually your URLs aren't static but data-driven. Dynamic segments allow you to match segments of the URL and use that value in your code. You create them with the `$` prefix.

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── about.tsx
    │   ├── concerts.$city.tsx
    │   └── concerts.trending.tsx
    └── root.tsx
    

URL

Matched Route

`/`

`app/routes/_index.tsx`

`/about`

`app/routes/about.tsx`

`/concerts/trending`

`app/routes/concerts.trending.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.$city.tsx`

`/concerts/san-diego`

`app/routes/concerts.$city.tsx`

The value will be parsed from the URL and passed to various APIs. We call these values "URL Parameters". The most useful places to access the URL params are in [loaders](../start/framework/data-loading) and [actions](../start/framework/actions).

    export async function serverLoader({ params }) {
      return fakeDb.getAllConcertsForCity(params.city);
    }
    

You'll note the property name on the `params` object maps directly to the name of your file: `$city.tsx` becomes `params.city`.

Routes can have multiple dynamic segments, like `concerts.$city.$date`, both are accessed on the params object by name:

    export async function serverLoader({ params }) {
      return fake.db.getConcerts({
        date: params.date,
        city: params.city,
      });
    }
    

See the [routing guide](../start/framework/routing) for more information.

[](#nested-routes)Nested Routes
-------------------------------

Nested Routing is the general idea of coupling segments of the URL to component hierarchy and data. You can read more about it in the [Routing Guide](../start/framework/routing#nested-routes).

You create nested routes with [dot delimiters](#dot-delimiters). If the filename before the `.` matches another route filename, it automatically becomes a child route to the matching parent. Consider these routes:

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── about.tsx
    │   ├── concerts._index.tsx
    │   ├── concerts.$city.tsx
    │   ├── concerts.trending.tsx
    │   └── concerts.tsx
    └── root.tsx
    

All the routes that start with `app/routes/concerts.` will be child routes of `app/routes/concerts.tsx` and render inside the [parent route's outlet](../start/framework/routing#nested-routes).

URL

Matched Route

Layout

`/`

`app/routes/_index.tsx`

`app/root.tsx`

`/about`

`app/routes/about.tsx`

`app/root.tsx`

`/concerts`

`app/routes/concerts._index.tsx`

`app/routes/concerts.tsx`

`/concerts/trending`

`app/routes/concerts.trending.tsx`

`app/routes/concerts.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.$city.tsx`

`app/routes/concerts.tsx`

Note you typically want to add an index route when you add nested routes so that something renders inside the parent's outlet when users visit the parent URL directly.

For example, if the URL is `/concerts/salt-lake-city` then the UI hierarchy will look like this:

    <Root>
      <Concerts>
        <City />
      </Concerts>
    </Root>
    

[](#nested-urls-without-layout-nesting)Nested URLs without Layout Nesting
-------------------------------------------------------------------------

Sometimes you want the URL to be nested, but you don't want the automatic layout nesting. You can opt out of nesting with a trailing underscore on the parent segment:

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── about.tsx
    │   ├── concerts.$city.tsx
    │   ├── concerts.trending.tsx
    │   ├── concerts.tsx
    │   └── concerts_.mine.tsx
    └── root.tsx
    

URL

Matched Route

Layout

`/`

`app/routes/_index.tsx`

`app/root.tsx`

`/about`

`app/routes/about.tsx`

`app/root.tsx`

`/concerts/mine`

`app/routes/concerts_.mine.tsx`

`app/root.tsx`

`/concerts/trending`

`app/routes/concerts.trending.tsx`

`app/routes/concerts.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.$city.tsx`

`app/routes/concerts.tsx`

Note that `/concerts/mine` does not nest with `app/routes/concerts.tsx` anymore, but `app/root.tsx`. The `trailing_` underscore creates a path segment, but it does not create layout nesting.

Think of the `trailing_` underscore as the long bit at the end of your parent's signature, writing you out of the will, removing the segment that follows from the layout nesting.

[](#nested-layouts-without-nested-urls)Nested Layouts without Nested URLs
-------------------------------------------------------------------------

We call these **Pathless Routes**

Sometimes you want to share a layout with a group of routes without adding any path segments to the URL. A common example is a set of authentication routes that have a different header/footer than the public pages or the logged in app experience. You can do this with a `_leading` underscore.

     app/
    ├── routes/
    │   ├── _auth.login.tsx
    │   ├── _auth.register.tsx
    │   ├── _auth.tsx
    │   ├── _index.tsx
    │   ├── concerts.$city.tsx
    │   └── concerts.tsx
    └── root.tsx
    

URL

Matched Route

Layout

`/`

`app/routes/_index.tsx`

`app/root.tsx`

`/login`

`app/routes/_auth.login.tsx`

`app/routes/_auth.tsx`

`/register`

`app/routes/_auth.register.tsx`

`app/routes/_auth.tsx`

`/concerts`

`app/routes/concerts.tsx`

`app/routes/concerts.tsx`

`/concerts/salt-lake-city`

`app/routes/concerts.$city.tsx`

`app/routes/concerts.tsx`

Think of the `_leading` underscore as a blanket you're pulling over the filename, hiding the filename from the URL.

[](#optional-segments)Optional Segments
---------------------------------------

Wrapping a route segment in parentheses will make the segment optional.

     app/
    ├── routes/
    │   ├── ($lang)._index.tsx
    │   ├── ($lang).$productId.tsx
    │   └── ($lang).categories.tsx
    └── root.tsx
    

URL

Matched Route

`/`

`app/routes/($lang)._index.tsx`

`/categories`

`app/routes/($lang).categories.tsx`

`/en/categories`

`app/routes/($lang).categories.tsx`

`/fr/categories`

`app/routes/($lang).categories.tsx`

`/american-flag-speedo`

`app/routes/($lang)._index.tsx`

`/en/american-flag-speedo`

`app/routes/($lang).$productId.tsx`

`/fr/american-flag-speedo`

`app/routes/($lang).$productId.tsx`

You may wonder why `/american-flag-speedo` is matching the `($lang)._index.tsx` route instead of `($lang).$productId.tsx`. This is because when you have an optional dynamic param segment followed by another dynamic param, it cannot reliably be determined if a single-segment URL such as `/american-flag-speedo` should match `/:lang` `/:productId`. Optional segments match eagerly and thus it will match `/:lang`. If you have this type of setup it's recommended to look at `params.lang` in the `($lang)._index.tsx` loader and redirect to `/:lang/american-flag-speedo` for the current/default language if `params.lang` is not a valid language code.

[](#splat-routes)Splat Routes
-----------------------------

While [dynamic segments](#dynamic-segments) match a single path segment (the stuff between two `/` in a URL), a splat route will match the rest of a URL, including the slashes.

     app/
    ├── routes/
    │   ├── _index.tsx
    │   ├── $.tsx
    │   ├── about.tsx
    │   └── files.$.tsx
    └── root.tsx
    

URL

Matched Route

`/`

`app/routes/_index.tsx`

`/about`

`app/routes/about.tsx`

`/beef/and/cheese`

`app/routes/$.tsx`

`/files`

`app/routes/files.$.tsx`

`/files/talks/react-conf_old.pdf`

`app/routes/files.$.tsx`

`/files/talks/react-conf_final.pdf`

`app/routes/files.$.tsx`

`/files/talks/react-conf-FINAL-MAY_2024.pdf`

`app/routes/files.$.tsx`

Similar to dynamic route parameters, you can access the value of the matched path on the splat route's `params` with the `"*"` key.

    export async function serverLoader({ params }) {
      const filePath = params["*"];
      return fake.getFileInfo(filePath);
    }
    

[](#escaping-special-characters)Escaping Special Characters
-----------------------------------------------------------

If you want one of the special characters used for these route conventions to actually be a part of the URL, you can escape the conventions with `[]` characters. This can be especially helpful for [resource routes](../how-to/resource-routes) that include an extension in the URL.

Filename

URL

`app/routes/sitemap[.]xml.tsx`

`/sitemap.xml`

`app/routes/[sitemap.xml].tsx`

`/sitemap.xml`

`app/routes/weird-url.[_index].tsx`

`/weird-url/_index`

`app/routes/dolla-bills-[$].tsx`

`/dolla-bills-$`

`app/routes/[[so-weird]].tsx`

`/[so-weird]`

`app/routes/reports.$id[.pdf].ts`

`/reports/123.pdf`

[](#folders-for-organization)Folders for Organization
-----------------------------------------------------

Routes can also be folders with a `route.tsx` file inside defining the route module. The rest of the files in the folder will not become routes. This allows you to organize your code closer to the routes that use them instead of repeating the feature names across other folders.

The files inside a folder have no meaning for the route paths, the route path is completely defined by the folder name.

Consider these routes:

     app/
    ├── routes/
    │   ├── _landing._index.tsx
    │   ├── _landing.about.tsx
    │   ├── _landing.tsx
    │   ├── app._index.tsx
    │   ├── app.projects.tsx
    │   ├── app.tsx
    │   └── app_.projects.$id.roadmap.tsx
    └── root.tsx
    

Some, or all of them can be folders holding their own `route` module inside.

    app/
    ├── routes/
    │   ├── _landing._index/
    │   │   ├── route.tsx
    │   │   └── scroll-experience.tsx
    │   ├── _landing.about/
    │   │   ├── employee-profile-card.tsx
    │   │   ├── get-employee-data.server.ts
    │   │   ├── route.tsx
    │   │   └── team-photo.jpg
    │   ├── _landing/
    │   │   ├── footer.tsx
    │   │   ├── header.tsx
    │   │   └── route.tsx
    │   ├── app._index/
    │   │   ├── route.tsx
    │   │   └── stats.tsx
    │   ├── app.projects/
    │   │   ├── get-projects.server.ts
    │   │   ├── project-buttons.tsx
    │   │   ├── project-card.tsx
    │   │   └── route.tsx
    │   ├── app/
    │   │   ├── footer.tsx
    │   │   ├── primary-nav.tsx
    │   │   └── route.tsx
    │   ├── app_.projects.$id.roadmap/
    │   │   ├── chart.tsx
    │   │   ├── route.tsx
    │   │   └── update-timeline.server.ts
    │   └── contact-us.tsx
    └── root.tsx
    

Note that when you turn a route module into a folder, the route module becomes `folder/route.tsx`, all other modules in the folder will not become routes. For example:

    # these are the same route:
    app/routes/app.tsx
    app/routes/app/route.tsx
    
    # as are these
    app/routes/app._index.tsx
    app/routes/app._index/route.tsx
    

[](#file-uploads)File Uploads
=============================

Handle file uploads in your React Router applications. This guide uses some packages from the [Remix The Web](https://github.com/mjackson/remix-the-web) project to make file uploads easier.

_Thank you to David Adams for [writing an original guide](https://programmingarehard.com/2024/09/06/remix-file-uploads-updated.html/) on which this doc is based. You can refer to it for even more examples._

[](#basic-file-upload)Basic File Upload
---------------------------------------

### [](#1-setup-some-routes)1\. Setup some routes

You can setup your routes however you like. This example uses the following structure:

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      // ... other routes
      route("user/:id", "pages/user-profile.tsx", [
        route("avatar", "api/avatar.tsx"),
      ]),
    ] satisfies RouteConfig;
    

### [](#2-add-the-form-data-parser)2\. Add the form data parser

`form-data-parser` is a wrapper around `request.formData()` that provides streaming support for handling file uploads.

    npm i @mjackson/form-data-parser
    

[See the `form-data-parser` docs for more information](https://github.com/mjackson/remix-the-web/tree/main/packages/form-data-parser)

### [](#3-create-a-route-with-an-upload-action)3\. Create a route with an upload action

The `parseFormData` function takes an `uploadHandler` function as an argument. This function will be called for each file upload in the form.

You must set the form's `enctype` to `multipart/form-data` for file uploads to work.

    import {
      type FileUpload,
      parseFormData,
    } from "@mjackson/form-data-parser";
    
    export async function action({
      request,
    }: ActionFunctionArgs) {
      const uploadHandler = async (fileUpload: FileUpload) => {
        if (fileUpload.fieldName === "avatar") {
          // process the upload and return a File
        }
      };
    
      const formData = await parseFormData(
        request,
        uploadHandler
      );
      // 'avatar' has already been processed at this point
      const file = formData.get("avatar");
    }
    
    export default function Component() {
      return (
        <form method="post" encType="multipart/form-data">
          <input type="file" name="avatar" />
          <button>Submit</button>
        </form>
      );
    }
    

[](#local-storage-implementation)Local Storage Implementation
-------------------------------------------------------------

### [](#1-add-the-storage-package)1\. Add the storage package

`file-storage` is a key/value interface for storing [File objects](https://developer.mozilla.org/en-US/docs/Web/API/File) in JavaScript. Similar to how `localStorage` allows you to store key/value pairs of strings in the browser, file-storage allows you to store key/value pairs of files on the server.

    npm i @mjackson/file-storage
    

[See the `file-storage` docs for more information](https://github.com/mjackson/remix-the-web/tree/main/packages/file-storage)

### [](#2-create-a-storage-configuration)2\. Create a storage configuration

Create a file that exports a `LocalFileStorage` instance to be used by different routes.

    import { LocalFileStorage } from "@mjackson/file-storage/local";
    
    export const fileStorage = new LocalFileStorage(
      "./uploads/avatars"
    );
    
    export function getStorageKey(userId: string) {
      return `user-${userId}-avatar`;
    }
    

### [](#3-implement-the-upload-handler)3\. Implement the upload handler

Update the form's `action` to store files in the `fileStorage` instance.

    import {
      type FileUpload,
      parseFormData,
    } from "@mjackson/form-data-parser";
    import {
      fileStorage,
      getStorageKey,
    } from "~/avatar-storage.server";
    import type { Route } from "./+types/user-profile";
    
    export async function action({
      request,
      params,
    }: Route.ActionArgs) {
      async function uploadHandler(fileUpload: FileUpload) {
        if (
          fileUpload.fieldName === "avatar" &&
          fileUpload.type.startsWith("image/")
        ) {
          let storageKey = getStorageKey(params.id);
    
          // FileUpload objects are not meant to stick around for very long (they are
          // streaming data from the request.body); store them as soon as possible.
          await fileStorage.set(storageKey, fileUpload);
    
          // Return a File for the FormData object. This is a LazyFile that knows how
          // to access the file's content if needed (using e.g. file.stream()) but
          // waits until it is requested to actually read anything.
          return fileStorage.get(storageKey);
        }
      }
    
      const formData = await parseFormData(
        request,
        uploadHandler
      );
    }
    
    export default function UserPage({
      actionData,
      params,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>User {params.id}</h1>
          <form
            method="post"
            // The form's enctype must be set to "multipart/form-data" for file uploads
            encType="multipart/form-data"
          >
            <input type="file" name="avatar" accept="image/*" />
            <button>Submit</button>
          </form>
    
          <img
            src={`/user/${params.id}/avatar`}
            alt="user avatar"
          />
        </div>
      );
    }
    

### [](#4-add-a-route-to-serve-the-uploaded-file)4\. Add a route to serve the uploaded file

Create a [resource route](../how-to/resource-routes) that streams the file as a response.

    import {
      fileStorage,
      getStorageKey,
    } from "~/avatar-storage.server";
    import type { Route } from "./+types/avatar";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const storageKey = getStorageKey(params.id);
      const file = await fileStorage.get(storageKey);
    
      if (!file) {
        throw new Response("User avatar not found", {
          status: 404,
        });
      }
    
      return new Response(file.stream(), {
        headers: {
          "Content-Type": file.type,
          "Content-Disposition": `attachment; filename=${file.name}`,
        },
      });
    }
    

[](#form-validation)Form Validation
===================================

This guide walks through a simple signup form implementation. You will likely want to pair these concepts with third-party validation libraries and error components, but this guide only focuses on the moving pieces for React Router.

[](#1-setting-up)1\. Setting Up
-------------------------------

We'll start by creating a basic signup route with form.

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("signup", "signup.tsx"),
    ] satisfies RouteConfig;
    

    import type { Route } from "./+types/signup";
    import { useFetcher } from "react-router";
    
    export default function Signup(_: Route.ComponentProps) {
      let fetcher = useFetcher();
      return (
        <fetcher.Form method="post">
          <p>
            <input type="email" name="email" />
          </p>
    
          <p>
            <input type="password" name="password" />
          </p>
    
          <button type="submit">Sign Up</button>
        </fetcher.Form>
      );
    }
    

[](#2-defining-the-action)2\. Defining the Action
-------------------------------------------------

In this step, we'll define a server `action` in the same file as our `Signup` component. Note that the aim here is to provide a broad overview of the mechanics involved rather than digging deep into form validation rules or error object structures. We'll use rudimentary checks for the email and password to demonstrate the core concepts.

    import type { Route } from "./+types/signup";
    import { redirect, useFetcher, data } from "react-router";
    
    export default function Signup(_: Route.ComponentProps) {
      // omitted for brevity
    }
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      const formData = await request.formData();
      const email = String(formData.get("email"));
      const password = String(formData.get("password"));
    
      const errors = {};
    
      if (!email.includes("@")) {
        errors.email = "Invalid email address";
      }
    
      if (password.length < 12) {
        errors.password =
          "Password should be at least 12 characters";
      }
    
      if (Object.keys(errors).length > 0) {
        return data({ errors }, { status: 400 });
      }
    
      // Redirect to dashboard if validation is successful
      return redirect("/dashboard");
    }
    

If any validation errors are found, they are returned from the `action` to the fetcher. This is our way of signaling to the UI that something needs to be corrected, otherwise the user will be redirected to the dashboard.

Note the `data({ errors }, { status: 400 })` call. Setting a 400 status is the web standard way to signal to the client that there was a validation error (Bad Request). In React Router, only 200 status codes trigger page data revalidation so a 400 prevent that.

[](#3-displaying-validation-errors)3\. Displaying Validation Errors
-------------------------------------------------------------------

Finally, we'll modify the `Signup` component to display validation errors, if any, from `fetcher.data`.

    export default function Signup(_: Route.ComponentProps) {
      let fetcher = useFetcher();
      let errors = fetcher.data?.errors;
      return (
        <fetcher.Form method="post">
          <p>
            <input type="email" name="email" />
            {errors?.email ? <em>{errors.email}</em> : null}
          </p>
    
          <p>
            <input type="password" name="password" />
            {errors?.password ? (
              <em>{errors.password}</em>
            ) : null}
          </p>
    
          <button type="submit">Sign Up</button>
        </fetcher.Form>
      );
    }
    

[](#http-headers)HTTP Headers
=============================

Headers are primarily defined with the route module `headers` export. You can also set headers in `entry.server.tsx`.

[](#from-route-modules)From Route Modules
-----------------------------------------

    import { Route } from "./+types/some-route";
    
    export function headers(_: Route.HeadersArgs) {
      return {
        "Content-Security-Policy": "default-src 'self'",
        "X-Frame-Options": "DENY",
        "X-Content-Type-Options": "nosniff",
        "Cache-Control": "max-age=3600, s-maxage=86400",
      };
    }
    

You can return either a [`Headers`](https://developer.mozilla.org/en-US/docs/Web/API/Headers) instance or `HeadersInit`.

[](#from-loaders-and-actions)From loaders and actions
-----------------------------------------------------

When the header is dependent on loader data, loaders and actions can also set headers.

### [](#1-wrap-your-return-value-in-data)1\. Wrap your return value in `data`

    import { data } from "react-router";
    
    export async function loader({ params }: LoaderArgs) {
      let [page, ms] = await fakeTimeCall(
        await getPage(params.id)
      );
    
      return data(page, {
        headers: {
          "Server-Timing": `page;dur=${ms};desc="Page query"`,
        },
      });
    }
    

### [](#2-return-from-headers-export)2\. Return from `headers` export

Headers from loaders and actions are not sent automatically. You must explicitly return them from the `headers` export.

    export function headers({
      actionHeaders,
      loaderHeaders,
    }: HeadersArgs) {
      return actionHeaders ? actionHeaders : loaderHeaders;
    }
    

One notable exception is `Set-Cookie` headers, which are automatically preserved from `headers`, `loader`, and `action` in parent routes, even without exporting `headers` from the child route.

[](#merging-with-parent-headers)Merging with parent headers
-----------------------------------------------------------

Consider these nested routes

    route("pages", "pages-layout-with-nav.tsx", [
      route(":slug", "page.tsx"),
    ]);
    

If both route modules want to set headers, the headers from the deepest matching route will be sent.

When you need to keep both the parent and the child headers, you need to merge them in the child route.

### [](#appending)Appending

The easiest way is to simply append to the parent headers. This avoids overwriting a header the parent may have set and both are important.

    export function headers({ parentHeaders }: HeadersArgs) {
      parentHeaders.append(
        "Permissions-Policy: geolocation=()"
      );
      return parentHeaders;
    }
    

### [](#setting)Setting

Sometimes it's important to overwrite the parent header. Do this with `set` instead of `append`:

    export function headers({ parentHeaders }: HeadersArgs) {
      parentHeaders.set(
        "Cache-Control",
        "max-age=3600, s-maxage=86400"
      );
      return parentHeaders;
    }
    

You can avoid the need to merge headers by only defining headers in "leaf routes" (index routes and child routes without children) and not in parent routes.

[](#from-entryservertsx)From `entry.server.tsx`
-----------------------------------------------

The `handleRequest` export receives the headers from the route module as an argument. You can append global headers here.

    export default function handleRequest(
      request,
      responseStatusCode,
      responseHeaders,
      routerContext,
      loadContext
    ) {
      // set, append global headers
      responseHeaders.set(
        "X-App-Version",
        routerContext.manifest.version
      );
    
      return new Response(await getStream(), {
        headers: responseHeaders,
        status: responseStatusCode,
      });
    }
    

If you don't have an `entry.server.tsx` run the `reveal` command:

    react-router reveal
    

[](#navigation-blocking)Navigation Blocking
===========================================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#overview)Overview
---------------------

When users are in the middle of a workflow, like filling out an important form, you may want to prevent them from navigating away from the page.

This example will show:

*   Setting up a route with a form and action called with a fetcher
*   Blocking navigation when the form is dirty
*   Showing a confirmation when the user tries to leave the page

[](#1-set-up-a-route-with-a-form)1\. Set up a route with a form
---------------------------------------------------------------

Add a route with the form, we'll use a "contact" route for this example:

    import {
      type RouteConfig,
      index,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      index("routes/home.tsx"),
      route("contact", "routes/contact.tsx"),
    ] satisfies RouteConfig;
    

Add the form to the contact route module:

    import { useFetcher } from "react-router";
    import type { Route } from "./+types/contact";
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      let formData = await request.formData();
      let email = formData.get("email");
      let message = formData.get("message");
      console.log(email, message);
      return { ok: true };
    }
    
    export default function Contact() {
      let fetcher = useFetcher();
    
      return (
        <fetcher.Form method="post">
          <p>
            <label>
              Email: <input name="email" type="email" />
            </label>
          </p>
          <p>
            <textarea name="message" />
          </p>
          <p>
            <button type="submit">
              {fetcher.state === "idle" ? "Send" : "Sending..."}
            </button>
          </p>
        </fetcher.Form>
      );
    }
    

[](#2-add-dirty-state-and-onchange-handler)2\. Add dirty state and onChange handler
-----------------------------------------------------------------------------------

To track the dirty state of the form, we'll use a single boolean and a quick form onChange handler. You may want to track the dirty state differently but this works for this guide.

    export default function Contact() {
      let [isDirty, setIsDirty] = useState(false);
      let fetcher = useFetcher();
    
      return (
        <fetcher.Form
          method="post"
          onChange={(event) => {
            let email = event.currentTarget.email.value;
            let message = event.currentTarget.message.value;
            setIsDirty(Boolean(email || message));
          }}
        >
          {/* existing code */}
        </fetcher.Form>
      );
    }
    

[](#3-block-navigation-when-the-form-is-dirty)3\. Block navigation when the form is dirty
-----------------------------------------------------------------------------------------

    import { useBlocker } from "react-router";
    
    export default function Contact() {
      let [isDirty, setIsDirty] = useState(false);
      let fetcher = useFetcher();
      let blocker = useBlocker(
        useCallback(() => isDirty, [isDirty])
      );
    
      // ... existing code
    }
    

While this will now block a navigation, there's no way for the user to confirm it.

[](#4-show-confirmation-ui)4\. Show confirmation UI
---------------------------------------------------

This uses a simple div, but you may want to use a modal dialog.

    export default function Contact() {
      let [isDirty, setIsDirty] = useState(false);
      let fetcher = useFetcher();
      let blocker = useBlocker(
        useCallback(() => isDirty, [isDirty])
      );
    
      return (
        <fetcher.Form
          method="post"
          onChange={(event) => {
            let email = event.currentTarget.email.value;
            let message = event.currentTarget.message.value;
            setIsDirty(Boolean(email || message));
          }}
        >
          {/* existing code */}
    
          {blocker.state === "blocked" && (
            <div>
              <p>Wait! You didn't send the message yet:</p>
              <p>
                <button
                  type="button"
                  onClick={() => blocker.proceed()}
                >
                  Leave
                </button>{" "}
                <button
                  type="button"
                  onClick={() => blocker.reset()}
                >
                  Stay here
                </button>
              </p>
            </div>
          )}
        </fetcher.Form>
      );
    }
    

If the user clicks "leave" then `blocker.proceed()` will proceed with the navigation. If they click "stay here" then `blocker.reset()` will clear the blocker and keep them on the current page.

[](#5-reset-the-blocker-when-the-action-resolves)5\. Reset the blocker when the action resolves
-----------------------------------------------------------------------------------------------

If the user doesn't click either "leave" or "stay here", then then submits the form, the blocker will still be active. Let's reset the blocker when the action resolves with an effect.

    useEffect(() => {
      if (fetcher.data?.ok) {
        if (blocker.state === "blocked") {
          blocker.reset();
        }
      }
    }, [fetcher.data]);
    

[](#6-clear-the-form-when-the-action-resolves)6\. Clear the form when the action resolves
-----------------------------------------------------------------------------------------

While unrelated to navigation blocking, let's clear the form when the action resolves with a ref.

    let formRef = useRef<HTMLFormElement>(null);
    
    // put it on the form
    <fetcher.Form
      ref={formRef}
      method="post"
      onChange={(event) => {
        // ... existing code
      }}
    >
      {/* existing code */}
    </fetcher.Form>;
    

    useEffect(() => {
      if (fetcher.data?.ok) {
        // clear the form in the effect
        formRef.current?.reset();
        if (blocker.state === "blocked") {
          blocker.reset();
        }
      }
    }, [fetcher.data]);
    

Alternatively, if a navigation is currently blocked, instead of resetting the blocker, you can proceed through to the blocked navigation.

    useEffect(() => {
      if (fetcher.data?.ok) {
        if (blocker.state === "blocked") {
          // proceed with the blocked navigation
          blocker.proceed();
        } else {
          formRef.current?.reset();
        }
      }
    }, [fetcher.data]);
    

In this case the user flow is:

*   User fills out the form
*   User forgets to click "send" and clicks a link instead
*   The navigation is blocked, and the confirmation message is shown
*   Instead of clicking "leave" or "stay here", the user submits the form
*   The user is taken to the requested page

[](#pre-rendering)Pre-Rendering
===============================

Pre-Rendering allows you to speed up page loads for static content by rendering pages at build time instead of at runtime. Pre-rendering is enabled via the `prerender` config in `react-router.config.ts` and can be used in two ways based on the `ssr` config value:

*   Alongside a runtime SSR server with `ssr:true` (the default value)
*   Deployed to a static file server with `ssr:false`

[](#pre-rendering-with-ssrtrue)Pre-rendering with `ssr:true`
------------------------------------------------------------

### [](#configuration)Configuration

Add the `prerender` option to your config, there are three signatures:

    import type { Config } from "@react-router/dev/config";
    
    export default {
      // Can be omitted - defaults to true
      ssr: true,
    
      // all static paths (no dynamic segments like "/post/:slug")
      prerender: true,
    
      // specific paths
      prerender: ["/", "/blog", "/blog/popular-post"],
    
      // async function for dependencies like a CMS
      async prerender({ getStaticPaths }) {
        let posts = await fakeGetPostsFromCMS();
        return [
          "/",
          "/blog",
          ...posts.map((post) => post.href),
        ];
      },
    } satisfies Config;
    

### [](#data-loading-and-pre-rendering)Data Loading and Pre-rendering

There is no extra application API for pre-rendering. Routes being pre-rendered use the same route `loader` functions as server rendering:

    export async function loader({ request, params }) {
      let post = await getPost(params.slug);
      return post;
    }
    
    export function Post({ loaderData }) {
      return <div>{loaderData.title}</div>;
    }
    

Instead of a request coming to your route on a deployed server, the build creates a `new Request()` and runs it through your app just like a server would.

When server rendering, requests to paths that have not been pre-rendered will be server rendered as usual.

### [](#static-file-output)Static File Output

The rendered result will be written out to your `build/client` directory. You'll notice two files for each path:

*   `[url].html` HTML file for initial document requests
*   `[url].data` file for client side navigation browser requests

The output of your build will indicate what files were pre-rendered:

    > react-router build
    vite v5.2.11 building for production...
    ...
    vite v5.2.11 building SSR bundle for production...
    ...
    Prerender: Generated build/client/index.html
    Prerender: Generated build/client/blog.data
    Prerender: Generated build/client/blog/index.html
    Prerender: Generated build/client/blog/my-first-post.data
    Prerender: Generated build/client/blog/my-first-post/index.html
    ...
    

During development, pre-rendering doesn't save the rendered results to the public directory, this only happens for `react-router build`.

[](#pre-rendering-with-ssrfalse)Pre-rendering with `ssr:false`
--------------------------------------------------------------

The above examples assume you are deploying a runtime server but are pre-rendering some static pages to avoid hitting the server, resulting in faster loads.

To disable runtime SSR and configure pre-rendering to be served from a static file server, you can set the `ssr:false` config flag:

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: false, // disable runtime server rendering
      prerender: true, // pre-render all static routes
    } satisfies Config;
    

If you specify `ssr:false` without a `prerender` config, React Router refers to that as [SPA Mode](./spa). In SPA Mode, we render a single HTML file that is capable of hydrating for _any_ of your application paths. It can do this because it only renders the `root` route into the HTML file and then determines which child routes to load based on the browser URL during hydration. This means you can use a `loader` on the root route, but not on any other routes because we don't know which routes to load until hydration in the browser.

If you want to pre-render paths with `ssr:false`, those matched routes _can_ have loaders because we'll pre-render all of the matched routes for those paths, not just the root. You cannot include `actions` or `headers` functions in any routes when `ssr:false` is set because there will be no runtime server to run them on.

### [](#pre-rendering-with-a-spa-fallback)Pre-rendering with a SPA Fallback

If you want `ssr:false` but don't want to pre-render _all_ of your routes - that's fine too! You may have some paths where you need the performance/SEO benefits of pre-rendering, but other pages where a SPA would be fine.

You can do this using the combination of config options as well - just limit your `prerender` config to the paths that you want to pre-render and React Router will also output a "SPA Fallback" HTML file that can be served to hydrate any other paths (using the same approach as [SPA Mode](./spa)).

This will be written to one of the following paths:

*   `build/client/index.html` - If the `/` path is not pre-rendered
*   `build/client/__spa-fallback.html` - If the `/` path is pre-rendered

    import type { Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
    
      // SPA fallback will be written to build/client/index.html
      prerender: ["/about-us"],
    
      // SPA fallback will be written to build/client/__spa-fallback.html
      prerender: ["/", "/about-us"],
    } satisfies Config;
    

You can configure your deployment server to serve this file for any path that otherwise would 404. Some hosts do this by default, but others don't. As an example, a host may support a `_redirects` file to do this:

    # If you did not pre-render the `/` route
    /*    /index.html   200
    
    # If you pre-rendered the `/` route
    /*    /__spa-fallback.html   200
    

If you're getting 404s at valid routes for your app, it's likely you need to configure your host.

Here's another example of how you can do this with the [`sirv-cli`](https://www.npmjs.com/package/sirv-cli#user-content-single-page-applications) tool:

    # If you did not pre-render the `/` route
    sirv-cli build/client --single index.html
    
    # If you pre-rendered the `/` route
    sirv-cli build/client --single __spa-fallback.html
    

### [](#invalid-exports)Invalid Exports

When pre-rendering with `ssr:false`, React Router will error at build time if you have invalid exports to help prevent some mistakes that can be easily overlooked.

*   `headers`/`action` functions are prohibited in all routes because there will be no runtime server on which to run them
*   When using `ssr:false` without a `prerender` config (SPA Mode), a `loader` is permitted on the root route only
*   When using `ssr:false` with a `prerender` config, a `loader` is permitted on any route matched by a `prerender` path
    *   If you are using a `loader` on a pre-rendered route that has child routes, you will need to make sure the parent `loaderData` can be determined at run-time properly by either:
        *   Pre-rendering all child routes so that the parent `loader` can be called at build-time for each child route path and rendered into a `.data` file, or
        *   Use a `clientLoader` on the parent that can be called at run-time for non-pre-rendered child paths

[](#resource-routes)Resource Routes
===================================

When server rendering, routes can serve "resources" instead of rendering components, like images, PDFs, JSON payloads, webhooks, etc.

[](#defining-a-resource-route)Defining a Resource Route
-------------------------------------------------------

A route becomes a resource route by convention when its module exports a loader or action but does not export a default component.

Consider a route that serves a PDF instead of UI:

    route("/reports/pdf/:id", "pdf-report.ts");
    

    import type { Route } from "./+types/pdf-report";
    
    export async function loader({ params }: Route.LoaderArgs) {
      const report = await getReport(params.id);
      const pdf = await generateReportPDF(report);
      return new Response(pdf, {
        status: 200,
        headers: {
          "Content-Type": "application/pdf",
        },
      });
    }
    

Note there is no default export. That makes this route a resource route.

[](#linking-to-resource-routes)Linking to Resource Routes
---------------------------------------------------------

When linking to resource routes, use `<a>` or `<Link reloadDocument>`, otherwise React Router will attempt to use client side routing and fetching the payload (you'll get a helpful error message if you make this mistake).

    <Link reloadDocument to="/reports/pdf/123">
      View as PDF
    </Link>
    

[](#handling-different-request-methods)Handling different request methods
-------------------------------------------------------------------------

GET requests are handled by the `loader`, while POST, PUT, PATCH, and DELETE are handled by the `action`:

    import type { Route } from "./+types/resource";
    
    export function loader(_: Route.LoaderArgs) {
      return Response.json({ message: "I handle GET" });
    }
    
    export function action(_: Route.ActionArgs) {
      return Response.json({
        message: "I handle everything else",
      });
    }
    

[](#route-module-type-safety)Route Module Type Safety
=====================================================

React Router generates route-specific types to power type inference for URL params, loader data, and more. This guide will help you set it up if you didn't start with a template.

To learn more about how type safety works in React Router, check out [Type Safety Explanation](../explanation/type-safety).

[](#1-add-react-router-to-gitignore)1\. Add `.react-router/` to `.gitignore`
----------------------------------------------------------------------------

React Router generates types into a `.react-router/` directory at the root of your app. This directory is fully managed by React Router and should be gitignore'd.

    .react-router/
    

[](#2-include-the-generated-types-in-tsconfig)2\. Include the generated types in tsconfig
-----------------------------------------------------------------------------------------

Edit your tsconfig to get TypeScript to use the generated types. Additionally, `rootDirs` needs to be configured so the types can be imported as relative siblings to route modules.

    {
      "include": [".react-router/types/**/*"],
      "compilerOptions": {
        "rootDirs": [".", "./.react-router/types"]
      }
    }
    

If you are using multiple `tsconfig` files for your app, you'll need to make these changes in whichever one `include`s your app directory. For example, the [`node-custom-server` template](https://github.com/remix-run/react-router-templates/tree/390fcec476dd336c810280479688fe893da38713/node-custom-server) contains `tsconfig.json`, `tsconfig.node.json`, and `tsconfig.vite.json`. Since `tsconfig.vite.json` is the one that [includes the app directory](https://github.com/remix-run/react-router-templates/blob/390fcec476dd336c810280479688fe893da38713/node-custom-server/tsconfig.vite.json#L4-L6), that's the one that sets up `.react-router/types` for route module type safety.

[](#3-generate-types-before-type-checking)3\. Generate types before type checking
---------------------------------------------------------------------------------

If you want to run type checking as its own command — for example, as part of your Continuous Integration pipeline — you'll need to make sure to generate types _before_ running typechecking:

    {
      "scripts": {
        "typecheck": "react-router typegen && tsc"
      }
    }
    

[](#4-typing-apploadcontext)4\. Typing `AppLoadContext`
-------------------------------------------------------

[](#extending-app-context-types)Extending app `Context` types
-------------------------------------------------------------

To define your app's `context` type, add the following in a `.ts` or `.d.ts` file within your project:

    import "react-router";
    declare module "react-router" {
      interface AppLoadContext {
        // add context properties here
      }
    }
    

[](#5-type-only-auto-imports-optional)5\. Type-only auto-imports (optional)
---------------------------------------------------------------------------

When auto-importing the `Route` type helper, TypeScript will generate:

    import { Route } from "./+types/my-route";
    

But if you enable [verbatimModuleSyntax](https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax):

    {
      "compilerOptions": {
        "verbatimModuleSyntax": true
      }
    }
    

Then, you will get the `type` modifier for the import automatically as well:

    import type { Route } from "./+types/my-route";
    //     ^^^^
    

This helps tools like bundlers to detect type-only module that can be safely excluded from the bundle.

[](#conclusion)Conclusion
-------------------------

React Router's Vite plugin should be automatically generating types into `.react-router/types/` anytime you edit your route config (`routes.ts`). That means all you need to do is run `react-router dev` (or your custom dev server) to get to up-to-date types in your routes.

Check out our [Type Safety Explanation](../explanation/type-safety) for an example of how to pull in those types into your routes.

[](#security)Security
=====================

This is by no means a comprehensive guide, but React Router provides features to help address a few aspects under the _very large_ umbrella that is _Security_.

[](#content-security-policy)`Content-Security-Policy`
-----------------------------------------------------

If you are implementing a [Content-Security-Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP) in your application, specifically one using the `unsafe-inline` directive, you will need to specify a [`nonce`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) attribute on the inline `<script>` elements rendered in your HTML. This must be specified on any API that generates inline scripts, including:

*   [`<Scripts nonce>`](../api/components/Scripts) (`root.tsx`)
*   [`<ScrollRestoration nonce>`](../api/components/ScrollRestoration) (`root.tsx`)
*   [`<ServerRouter nonce>`](../api/components/ServerRouter) (`entry.server.tsx`)
*   [`renderToPipeableStream(..., { nonce })`](https://react.dev/reference/react-dom/server/renderToPipeableStream) (`entry.server.tsx`)
*   [`renderToReadableStream(..., { nonce })`](https://react.dev/reference/react-dom/server/renderToReadableStream) (`entry.server.tsx`)

[](#single-page-app-spa)Single Page App (SPA)
=============================================

There are two ways to ship a single page app with React Router

*   **as a library** - Instead of using React Router's framework features, you can use it as a library in your own SPA architecture. Refer to [React Router as a Library](../start/library/installation) guides.
*   **as a framework** - This guide will focus here

[](#overview)Overview
---------------------

When using React Router as a framework, you can enable "SPA Mode" by setting `ssr:false` in your `react-router.config.ts` file. This will disable runtime server rendering and generate an `index.html` at build time that you can serve and hydrate as a SPA.

Typical Single Page apps send a mostly blank `index.html` template with little more than an empty `<div id="root"></div>`. In contrast, `react-router build` (in SPA Mode) pre-renders your root route at build time into an `index.html` file. This means you can:

*   Send more than an empty `<div>`
*   Use a root `loader` to load data for your application shell
*   Use React components to generate the initial page users see (root `HydrateFallback`)
*   Re-enable server rendering later without changing anything about your UI

It's important to note that setting `ssr:false` only disables _runtime server rendering_. React Router will still server render your root route at _build time_ to generate the `index.html` file. This is why your project still needs a dependency on `@react-router/node` and your routes need to be SSR-safe. That means you can't call `window` or other browser-only APIs during the initial render, even when server rendering is disabled.

SPA Mode is a special form of "Pre-Rendering" that allows you to serve all paths in your application from the same HTML file. Please refer to the [Pre-Rendering](./pre-rendering) guide if you want to do more extensive pre-rendering.

[](#1-disable-runtime-server-rendering)1\. Disable Runtime Server Rendering
---------------------------------------------------------------------------

Server rendering is enabled by default. Set the `ssr` flag to `false` in `react-router.config.ts` to disable it.

    import { type Config } from "@react-router/dev/config";
    
    export default {
      ssr: false,
    } satisfies Config;
    

With this set to false, the server build will no longer be generated.

It's important to note that setting `ssr:false` only disables _runtime server rendering_. React Router will still server render your root route at _build time_ to generate the `index.html` file. This is why your project still needs a dependency on `@react-router/node` and your routes need to be SSR-safe. That means you can't call `window` or other browser-only APIs during the initial render, even when server rendering is disabled.

[](#2-add-a-hydratefallback-and-optional-loader-to-your-root-route)2\. Add a `HydrateFallback` and optional `loader` to your root route
---------------------------------------------------------------------------------------------------------------------------------------

SPA Mode will generate an `index.html` file at build-time that you can serve as the entry point for your SPA. This will only render the root route so that it is capable of hydrating at runtime for any path in your application.

To provide a better loading UI than an empty `<div>`, you can add a `HydrateFallback` component to your root route to render your loading UI into the `index.html` at build time. This way, it will be shown to users immediately while the SPA is loading/hydrating.

    import LoadingScreen from "./components/loading-screen";
    
    export function Layout() {
      return <html>{/*...*/}</html>;
    }
    
    export function HydrateFallback() {
      return <LoadingScreen />;
    }
    
    export default function App() {
      return <Outlet />;
    }
    

Because the root route is server-rendered at build time, you can also use a `loader` in your root route if you choose. This `loader` will be called at build time and the data will be available via the optional `HydrateFallback` `loaderData` prop.

    import { Route } from "./+types/root";
    
    export async function loader() {
      return {
        version: await getVersion(),
      };
    }
    
    export function HydrateFallback({
      loaderData,
    }: Route.ComponentProps) {
      return (
        <div>
          <h1>Loading version {loaderData.version}...</h1>
          <AwesomeSpinner />
        </div>
      );
    }
    

You cannot include a `loader` in any other routes in your app when using SPA Mode unless you are [pre-rendering those pages](./pre-rendering).

[](#3-use-client-loaders-and-client-actions)3\. Use client loaders and client actions
-------------------------------------------------------------------------------------

With server rendering disabled, you can still use `clientLoader` and `clientAction` to manage route data and mutations.

    import { Route } from "./+types/some-route";
    
    export async function clientLoader({
      params,
    }: Route.ClientLoaderArgs) {
      let data = await fetch(`/some/api/stuff/${params.id}`);
      return data;
    }
    
    export async function clientAction({
      request,
    }: Route.ClientActionArgs) {
      let formData = await request.formData();
      return await processPayment(formData);
    }
    

[](#4-direct-all-urls-to-indexhtml)4\. Direct all URLs to index.html
--------------------------------------------------------------------

After running `react-router build`, deploy the `build/client` directory to whatever static host you prefer.

Common to deploying any SPA, you'll need to configure your host to direct all URLs to the `index.html` of the client build. Some hosts do this by default, but others don't. As an example, a host may support a `_redirects` file to do this:

    /*    /index.html   200
    

If you're getting 404s at valid routes for your app, it's likely you need to configure your host.

[](#status-codes)Status Codes
=============================

Set status codes from loaders and actions with `data`.

    // route('/projects/:projectId', './project.tsx')
    import type { Route } from "./+types/project";
    import { data } from "react-router";
    import { fakeDb } from "../db";
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      let formData = await request.formData();
      let title = formData.get("title");
      if (!title) {
        return data(
          { message: "Invalid title" },
          { status: 400 }
        );
      }
    
      if (!projectExists(title)) {
        let project = await fakeDb.createProject({ title });
        return data(project, { status: 201 });
      } else {
        let project = await fakeDb.updateProject({ title });
        // the default status code is 200, no need for `data`
        return project;
      }
    }
    

See [Form Validation](./form-validation) for more information on rendering form errors like this.

Another common status code is 404:

    // route('/projects/:projectId', './project.tsx')
    import type { Route } from "./+types/project";
    import { data } from "react-router";
    import { fakeDb } from "../db";
    
    export async function loader({ params }: Route.ActionArgs) {
      let project = await fakeDb.getProject(params.id);
      if (!project) {
        // throw to ErrorBoundary
        throw data(null, { status: 404 });
      }
      return project;
    }
    

See the [Error Boundaries](./error-boundary) for more information on thrown `data`.

[](#streaming-with-suspense)Streaming with Suspense
===================================================

Streaming with React Suspense allows apps to speed up initial renders by deferring non-critical data and unblocking UI rendering.

React Router supports React Suspense by returning promises from loaders and actions.

[](#1-return-a-promise-from-loader)1\. Return a promise from loader
-------------------------------------------------------------------

React Router awaits route loaders before rendering route components. To unblock the loader for non-critical data, return the promise instead of awaiting it in the loader.

    import type { Route } from "./+types/my-route";
    
    export async function loader({}: Route.LoaderArgs) {
      // note this is NOT awaited
      let nonCriticalData = new Promise((res) =>
        setTimeout(() => res("non-critical"), 5000)
      );
    
      let criticalData = await new Promise((res) =>
        setTimeout(() => res("critical"), 300)
      );
    
      return { nonCriticalData, criticalData };
    }
    

Note you can't return a single promise, it must be an object with keys.

[](#2-render-the-fallback-and-resolved-ui)2\. Render the fallback and resolved UI
---------------------------------------------------------------------------------

The promise will be available on `loaderData`, `<Await>` will await the promise and trigger `<Suspense>` to render the fallback UI.

    import * as React from "react";
    import { Await } from "react-router";
    
    // [previous code]
    
    export default function MyComponent({
      loaderData,
    }: Route.ComponentProps) {
      let { criticalData, nonCriticalData } = loaderData;
    
      return (
        <div>
          <h1>Streaming example</h1>
          <h2>Critical data value: {criticalData}</h2>
    
          <React.Suspense fallback={<div>Loading...</div>}>
            <Await resolve={nonCriticalData}>
              {(value) => <h3>Non critical value: {value}</h3>}
            </Await>
          </React.Suspense>
        </div>
      );
    }
    

[](#with-react-19)With React 19
-------------------------------

If you're experimenting with React 19, you can use `React.use` instead of `Await`, but you'll need to create a new component and pass the promise down to trigger the suspense fallback.

    <React.Suspense fallback={<div>Loading...</div>}>
      <NonCriticalUI p={nonCriticalData} />
    </React.Suspense>
    

    function NonCriticalUI({ p }: { p: Promise<string> }) {
      let value = React.use(p);
      return <h3>Non critical value {value}</h3>;
    }
    

[](#timeouts)Timeouts
---------------------

By default, loaders and actions reject any outstanding promises after 4950ms. You can control this by exporting a `streamTimeout` numerical value from your `entry.server.tsx`.

    // Reject all pending promises from handler functions after 10 seconds
    export const streamTimeout = 10_000;
    

[](#view-transitions)View Transitions
=====================================

Enable smooth animations between page transitions in your React Router applications using the [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition). This feature allows you to create seamless visual transitions during client-side navigation.

[](#basic-view-transition)Basic View Transition
-----------------------------------------------

### [](#1-enable-view-transitions-on-navigation)1\. Enable view transitions on navigation

The simplest way to enable view transitions is by adding the `viewTransition` prop to your `Link`, `NavLink`, or `Form` components. This automatically wraps the navigation update in `document.startViewTransition()`.

    <Link to="/about" viewTransition>
      About
    </Link>
    

Without any additional CSS, this provides a basic cross-fade animation between pages.

### [](#2-enable-view-transitions-with-programmatic-navigation)2\. Enable view transitions with programmatic navigation

When using programmatic navigation with the `useNavigate` hook, you can enable view transitions by passing the `viewTransition: true` option:

    import { useNavigate } from "react-router";
    
    function NavigationButton() {
      const navigate = useNavigate();
    
      return (
        <button
          onClick={() =>
            navigate("/about", { viewTransition: true })
          }
        >
          About
        </button>
      );
    }
    

This provides the same cross-fade animation as using the `viewTransition` prop on Link components.

For more information on using the View Transitions API, please refer to the ["Smooth transitions with the View Transition API" guide](https://developer.chrome.com/docs/web-platform/view-transitions) from the Google Chrome team.

[](#image-gallery-example)Image Gallery Example
-----------------------------------------------

Let's build an image gallery that demonstrates how to trigger and use view transitions. We'll create a list of images that expand into a detail view with smooth animations.

### [](#1-create-the-image-gallery-route)1\. Create the image gallery route

    import { NavLink } from "react-router";
    
    export const images = [
      "https://remix.run/blog-images/headers/the-future-is-now.jpg",
      "https://remix.run/blog-images/headers/waterfall.jpg",
      "https://remix.run/blog-images/headers/webpack.png",
      // ... more images ...
    ];
    
    export default function ImageGalleryRoute() {
      return (
        <div className="image-list">
          <h1>Image List</h1>
          <div>
            {images.map((src, idx) => (
              <NavLink
                key={src}
                to={`/image/${idx}`}
                viewTransition // Enable view transitions for this link
              >
                <p>Image Number {idx}</p>
                <img
                  className="max-w-full contain-layout"
                  src={src}
                />
              </NavLink>
            ))}
          </div>
        </div>
      );
    }
    

### [](#2-add-transition-styles)2\. Add transition styles

Define view transition names and animations for elements that should transition smoothly between routes.

    /* Layout styles for the image grid */
    .image-list > div {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      column-gap: 10px;
    }
    
    .image-list h1 {
      font-size: 2rem;
      font-weight: 600;
    }
    
    .image-list img {
      max-width: 100%;
      contain: layout;
    }
    
    .image-list p {
      width: fit-content;
    }
    
    /* Assign transition names to elements during navigation */
    .image-list a.transitioning img {
      view-transition-name: image-expand;
    }
    
    .image-list a.transitioning p {
      view-transition-name: image-title;
    }
    

### [](#3-create-the-image-detail-route)3\. Create the image detail route

The detail view needs to use the same view transition names to create a seamless animation.

    import { Link } from "react-router";
    import { images } from "./home";
    import type { Route } from "./+types/image-details";
    
    export default function ImageDetailsRoute({
      params,
    }: Route.ComponentProps) {
      return (
        <div className="image-detail">
          <Link to="/" viewTransition>
            Back
          </Link>
          <h1>Image Number {params.id}</h1>
          <img src={images[Number(params.id)]} />
        </div>
      );
    }
    

### [](#4-add-matching-transition-styles-for-the-detail-view)4\. Add matching transition styles for the detail view

    /* Match transition names from the list view */
    .image-detail h1 {
      font-size: 2rem;
      font-weight: 600;
      width: fit-content;
      view-transition-name: image-title;
    }
    
    .image-detail img {
      max-width: 100%;
      contain: layout;
      view-transition-name: image-expand;
    }
    

[](#advanced-usage)Advanced Usage
---------------------------------

You can control view transitions more precisely using either render props or the `useViewTransitionState` hook.

### [](#1-using-render-props)1\. Using render props

    <NavLink to={`/image/${idx}`} viewTransition>
      {({ isTransitioning }) => (
        <>
          <p
            style={{
              viewTransitionName: isTransitioning
                ? "image-title"
                : "none",
            }}
          >
            Image Number {idx}
          </p>
          <img
            src={src}
            style={{
              viewTransitionName: isTransitioning
                ? "image-expand"
                : "none",
            }}
          />
        </>
      )}
    </NavLink>
    

### [](#2-using-the-useviewtransitionstate-hook)2\. Using the `useViewTransitionState` hook

    function NavImage(props: { src: string; idx: number }) {
      const href = `/image/${props.idx}`;
      // Hook provides transition state for specific route
      const isTransitioning = useViewTransitionState(href);
    
      return (
        <Link to={href} viewTransition>
          <p
            style={{
              viewTransitionName: isTransitioning
                ? "image-title"
                : "none",
            }}
          >
            Image Number {props.idx}
          </p>
          <img
            src={props.src}
            style={{
              viewTransitionName: isTransitioning
                ? "image-expand"
                : "none",
            }}
          />
        </Link>
      );
    }
    

[](#automatic-code-splitting)Automatic Code Splitting
=====================================================

When using React Router's framework features, your application is automatically code split to improve the performance of initial load times when users visit your application.

[](#code-splitting-by-route)Code Splitting by Route
---------------------------------------------------

Consider this simple route config:

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("/contact", "./contact.tsx"),
      route("/about", "./about.tsx"),
    ] satisfies RouteConfig;
    

Instead of bundling all routes into a single giant build, the modules referenced (`contact.tsx` and `about.tsx`) become entry points to the bundler.

Because these entry points are coupled to URL segments, React Router knows just from a URL which bundles are needed in the browser, and more importantly, which are not.

If the user visits `"/about"` then the bundles for `about.tsx` will be loaded but not `contact.tsx`. This ensures drastically reduces the JavaScript footprint for initial page loads and speeds up your application.

[](#removal-of-server-code)Removal of Server Code
-------------------------------------------------

Any server-only [Route Module APIs](../../start/framework/route-module) will be removed from the bundles. Consider this route module:

    export async function loader() {
      return { message: "hello" };
    }
    
    export async function action() {
      console.log(Date.now());
      return { ok: true };
    }
    
    export async function headers() {
      return { "Cache-Control": "max-age=300" };
    }
    
    export default function Component({ loaderData }) {
      return <div>{loaderData.message}</div>;
    }
    

After building for the browser, only the `Component` will still be in the bundle, so you can use server-only code in the other module exports.

[](#hot-module-replacement)Hot Module Replacement
=================================================

Hot Module Replacement is a technique for updating modules in your app without needing to reload the page. It's a great developer experience, and React Router supports it when using Vite.

HMR does its best to preserve browser state across updates. For example, let's say you have form within a modal and you fill out all the fields. As soon as you save any changes to the code, traditional live reload would hard refresh the page causing all of those fields to be reset. Every time you make a change, you'd have to open up the modal _again_ and fill out the form _again_.

But with HMR, all of that state is preserved _across updates_.

[](#react-fast-refresh)React Fast Refresh
-----------------------------------------

React already has mechanisms for updating the DOM via its [virtual DOM](https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom) in response to user interactions like clicking a button. Wouldn't it be great if React could handle updating the DOM in response to code changes too?

That's exactly what [React Fast Refresh](https://github.com/facebook/react/tree/main/packages/react-refresh) is all about! Of course, React is all about components, not general JavaScript code, so React Fast Refresh only handles hot updates for exported React components.

But React Fast Refresh does have some limitations that you should be aware of.

### [](#class-component-state)Class Component State

React Fast Refresh does not preserve state for class components. This includes higher-order components that internally return classes:

    export class ComponentA extends Component {} // ❌
    
    export const ComponentB = HOC(ComponentC); // ❌ Won't work if HOC returns a class component
    
    export function ComponentD() {} // ✅
    export const ComponentE = () => {}; // ✅
    export default function ComponentF() {} // ✅
    

### [](#named-function-components)Named Function Components

Function components must be named, not anonymous, for React Fast Refresh to track changes:

    export default () => {}; // ❌
    export default function () {} // ❌
    
    const ComponentA = () => {};
    export default ComponentA; // ✅
    
    export default function ComponentB() {} // ✅
    

### [](#supported-exports)Supported Exports

React Fast Refresh can only handle component exports. While React Router manages [route exports like `action`, `headers`, `links`, `loader`, and `meta`](../start/framework/route-module) for you, any user-defined exports will cause full reloads:

    // These exports are handled by the React Router Vite plugin
    // to be HMR-compatible
    export const meta = { title: "Home" }; // ✅
    export const links = [
      { rel: "stylesheet", href: "style.css" },
    ]; // ✅
    
    // These exports are removed by the React Router Vite plugin
    // so they never affect HMR
    export const headers = { "Cache-Control": "max-age=3600" }; // ✅
    export const loader = async () => {}; // ✅
    export const action = async () => {}; // ✅
    
    // This is not a route module export, nor a component export,
    // so it will cause a full reload for this route
    export const myValue = "some value"; // ❌
    
    export default function Route() {} // ✅
    

👆 Routes probably shouldn't be exporting random values like that anyway. If you want to reuse values across routes, stick them in their own non-route module:

    export const myValue = "some value";
    

### [](#changing-hooks)Changing Hooks

React Fast Refresh cannot track changes for a component when hooks are being added or removed from it, causing full reloads just for the next render. After the hooks have been updated, changes should result in hot updates again. For example, if you add a `useState` to your component, you may lose that component's local state for the next render.

Additionally, if you are destructuring a hook's return value, React Fast Refresh will not be able to preserve state for the component if the destructured key is removed or renamed. For example:

    export default function Component({ loaderData }) {
      const { pet } = useMyCustomHook();
      return (
        <div>
          <input />
          <p>My dog's name is {pet.name}!</p>
        </div>
      );
    }
    

If you change the key `pet` to `dog`:

     export default function Component() {
    -  const { pet } = useMyCustomHook();
    +  const { dog } = useMyCustomHook();
       return (
         <div>
           <input />
    -      <p>My dog's name is {pet.name}!</p>
    +      <p>My dog's name is {dog.name}!</p>
         </div>
       );
     }
    

then React Fast Refresh will not be able to preserve state `<input />` ❌.

### [](#component-keys)Component Keys

In some cases, React cannot distinguish between existing components being changed and new components being added. [React needs `key`s](https://react.dev/learn/rendering-lists#why-does-react-need-keys) to disambiguate these cases and track changes when sibling elements are modified.

[](#progressive-enhancement)Progressive Enhancement
===================================================

> Progressive enhancement is a strategy in web design that puts emphasis on web content first, allowing everyone to access the basic content and functionality of a web page, whilst users with additional browser features or faster Internet access receive the enhanced version instead.

\- [Wikipedia](https://en.wikipedia.org/wiki/Progressive_enhancement)

When using React Router with Server-Side Rendering (the default in framework mode), you can automatically leverage the benefits of progressive enhancement.

[](#why-progressive-enhancement-matters)Why Progressive Enhancement Matters
---------------------------------------------------------------------------

Coined in 2003 by Steven Champeon & Nick Finck, the phrase emerged during a time of varied CSS and JavaScript support across different browsers, with many users actually browsing the web with JavaScript disabled.

Today, we are fortunate to develop for a much more consistent web and where the majority of users have JavaScript enabled.

However, we still believe in the core principles of progressive enhancement in React Router. It leads to fast and resilient apps with simple development workflows.

**Performance**: While it's easy to think that only 5% of your users have slow connections, the reality is that 100% of your users have slow connections 5% of the time.

**Resilience**: Everybody has JavaScript disabled until it's loaded.

**Simplicity**: Building your apps in a progressively enhanced way with React Router is actually simpler than building a traditional SPA.

[](#performance)Performance
---------------------------

Server rendering allows your app to do more things in parallel than a typical [Single Page App (SPA)](../how-to/spa), making the initial loading experience and subsequent navigations faster.

Typical SPAs send a blank document and only start doing work when JavaScript has loaded:

    HTML        |---|
    JavaScript      |---------|
    Data                      |---------------|
                                page rendered 👆
    

A React Router app can start doing work the moment the request hits the server and stream the response so that the browser can start downloading JavaScript, other assets, and data in parallel:

                   👇 first byte
    HTML        |---|-----------|
    JavaScript      |---------|
    Data        |---------------|
                  page rendered 👆
    

[](#resilience-and-accessibility)Resilience and Accessibility
-------------------------------------------------------------

While your users probably don't browse the web with JavaScript disabled, everybody uses the websites without JavaScript before it finishes loading. React Router embraces progressive enhancement by building on top of HTML, allowing you to build your app in a way that works without JavaScript, and then layer on JavaScript to enhance the experience.

The simplest case is a `<Link to="/account">`. These render an `<a href="/account">` tag that works without JavaScript. When JavaScript loads, React Router will intercept clicks and handle the navigation with client side routing. This gives you more control over the UX instead of just spinning favicons in the browser tab--but it works either way.

Now consider a simple add to cart button:

    export function AddToCart({ id }) {
      return (
        <Form method="post" action="/add-to-cart">
          <input type="hidden" name="id" value={id} />
          <button type="submit">Add To Cart</button>
        </Form>
      );
    }
    

Whether JavaScript has loaded or not doesn't matter, this button will add the product to the cart.

When JavaScript loads, React Router will intercept the form submission and handle it client side. This allows you to add your own pending UI, or other client side behavior.

[](#simplicity)Simplicity
-------------------------

When you start to rely on basic features of the web like HTML and URLs, you will find that you reach for client side state and state management much less.

Consider the button from before, with no fundamental change to the code, we can pepper in some client side behavior:

    import { useFetcher } from "react-router";
    
    export function AddToCart({ id }) {
      const fetcher = useFetcher();
    
      return (
        <fetcher.Form method="post" action="/add-to-cart">
          <input name="id" value={id} />
          <button type="submit">
            {fetcher.state === "submitting"
              ? "Adding..."
              : "Add To Cart"}
          </button>
        </fetcher.Form>
      );
    }
    

This feature continues to work the very same as it did before when JavaScript is loading, but once JavaScript loads:

*   `useFetcher` no longer causes a navigation like `<Form>` does, so the user can stay on the same page and keep shopping
*   The app code determines the pending UI instead of spinning favicons in the browser

It's not about building it two different ways–once for JavaScript and once without–it's about building it in iterations. Start with the simplest version of the feature and ship it; then iterate to an enhanced user experience.

Not only will the user get a progressively enhanced experience, but the app developer gets to "progressively enhance" the UI without changing the fundamental design of the feature.

Another example where progressive enhancement leads to simplicity is with the URL. When you start with a URL, you don't need to worry about client side state management. You can just use the URL as the source of truth for the UI.

    export function SearchBox() {
      return (
        <Form method="get" action="/search">
          <input type="search" name="query" />
          <SearchIcon />
        </Form>
      );
    }
    

This component doesn't need any state management. It just renders a form that submits to `/search`. When JavaScript loads, React Router will intercept the form submission and handle it client side. Here's the next iteration:

    import { useNavigation } from "react-router";
    
    export function SearchBox() {
      const navigation = useNavigation();
      const isSearching =
        navigation.location.pathname === "/search";
    
      return (
        <Form method="get" action="/search">
          <input type="search" name="query" />
          {isSearching ? <Spinner /> : <SearchIcon />}
        </Form>
      );
    }
    

No fundamental change in architecture, simply a progressive enhancement for both the user and the code.

See also: [State Management](./state-management)

[](#race-conditions)Race Conditions
===================================

While impossible to eliminate every possible race condition in your application, React Router automatically handles the most common race conditions found in web user interfaces.

[](#browser-behavior)Browser Behavior
-------------------------------------

React Router's handling of network concurrency is heavily inspired by the behavior of web browsers when processing documents.

Consider clicking a link to a new document, and then clicking a different link before the new page has finished loading. The browser will:

1.  cancel the first request
2.  immediately process the new navigation

The same behavior applies to form submissions. When a pending form submission is interrupted by a new one, the first is canceled and the new submission is immediately processed.

[](#react-router-behavior)React Router Behavior
-----------------------------------------------

Like the browser, interrupted navigations with links and form submissions will cancel in flight data requests and immediately process the new event.

Fetchers are a bit more nuanced since they are not singleton events like navigation. Fetchers can't interrupt other fetcher instances, but they can interrupt themselves and the behavior is the same as everything else: cancel the interrupted request and immediately process the new one.

Fetchers do, however, interact with each other when it comes to revalidation. After a fetcher's action request returns to the browser, a revalidation for all page data is sent. This means multiple revalidation requests can be in-flight at the same time. React Router will commit all "fresh" revalidation responses and cancel any stale requests. A stale request is any request that started _earlier_ than one that has returned.

This management of the network prevents the most common UI bugs caused by network race conditions.

Since networks are unpredictable, and your server still processes these cancelled requests, your backend may still experience race conditions and have potential data integrity issues. These risks are the same risks as using default browser behavior with plain HTML `<forms>`, which we consider to be low, and outside the scope of React Router.

[](#practical-benefits)Practical Benefits
-----------------------------------------

Consider building a type-ahead combobox. As the user types, you send a request to the server. As they type each new character you send a new request. It's important to not show the user results for a value that's not in the text field anymore.

When using a fetcher, this is automatically managed for you. Consider this pseudo-code:

    // route("/city-search", "./search-cities.ts")
    export async function loader({ request }) {
      const { searchParams } = new URL(request.url);
      return searchCities(searchParams.get("q"));
    }
    

    export function CitySearchCombobox() {
      const fetcher = useFetcher();
    
      return (
        <fetcher.Form action="/city-search">
          <Combobox aria-label="Cities">
            <ComboboxInput
              name="q"
              onChange={(event) =>
                // submit the form onChange to get the list of cities
                fetcher.submit(event.target.form)
              }
            />
    
            {fetcher.data ? (
              <ComboboxPopover className="shadow-popup">
                {fetcher.data.length > 0 ? (
                  <ComboboxList>
                    {fetcher.data.map((city) => (
                      <ComboboxOption
                        key={city.id}
                        value={city.name}
                      />
                    ))}
                  </ComboboxList>
                ) : (
                  <span>No results found</span>
                )}
              </ComboboxPopover>
            ) : null}
          </Combobox>
        </fetcher.Form>
      );
    }
    

Calls to `fetcher.submit` will cancel pending requests on that fetcher automatically. This ensures you never show the user results for a request for a different input value.

[](#sessions-and-cookies)Sessions and Cookies
=============================================

[](#sessions)Sessions
---------------------

Sessions are an important part of websites that allow the server to identify requests coming from the same person, especially when it comes to server-side form validation or when JavaScript is not on the page. Sessions are a fundamental building block of many sites that let users "log in", including social, e-commerce, business, and educational websites.

When using React Router as your framework, sessions are managed on a per-route basis (rather than something like express middleware) in your `loader` and `action` methods using a "session storage" object (that implements the [`SessionStorage`](https://api.reactrouter.com/v7/interfaces/react_router.SessionStorage) interface). Session storage understands how to parse and generate cookies, and how to store session data in a database or filesystem.

### [](#using-sessions)Using Sessions

This is an example of a cookie session storage:

    import { createCookieSessionStorage } from "react-router";
    
    type SessionData = {
      userId: string;
    };
    
    type SessionFlashData = {
      error: string;
    };
    
    const { getSession, commitSession, destroySession } =
      createCookieSessionStorage<SessionData, SessionFlashData>(
        {
          // a Cookie from `createCookie` or the CookieOptions to create one
          cookie: {
            name: "__session",
    
            // all of these are optional
            domain: "reactrouter.com",
            // Expires can also be set (although maxAge overrides it when used in combination).
            // Note that this method is NOT recommended as `new Date` creates only one date on each server deployment, not a dynamic date in the future!
            //
            // expires: new Date(Date.now() + 60_000),
            httpOnly: true,
            maxAge: 60,
            path: "/",
            sameSite: "lax",
            secrets: ["s3cret1"],
            secure: true,
          },
        }
      );
    
    export { getSession, commitSession, destroySession };
    

We recommend setting up your session storage object in `app/sessions.server.ts` so all routes that need to access session data can import from the same spot.

The input/output to a session storage object are HTTP cookies. `getSession()` retrieves the current session from the incoming request's `Cookie` header, and `commitSession()`/`destroySession()` provide the `Set-Cookie` header for the outgoing response.

You'll use methods to get access to sessions in your `loader` and `action` functions.

After retrieving a session with `getSession`, the returned session object has a handful of methods and properties:

    export async function action({
      request,
    }: ActionFunctionArgs) {
      const session = await getSession(
        request.headers.get("Cookie")
      );
      session.get("foo");
      session.has("bar");
      // etc.
    }
    

See the [Session API](https://api.reactrouter.com/v7/interfaces/react_router.Session) for all methods available on the session object.

### [](#login-form-example)Login form example

A login form might look something like this:

    import { data, redirect } from "react-router";
    import type { Route } from "./+types/login";
    
    import {
      getSession,
      commitSession,
    } from "../sessions.server";
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const session = await getSession(
        request.headers.get("Cookie")
      );
    
      if (session.has("userId")) {
        // Redirect to the home page if they are already signed in.
        return redirect("/");
      }
    
      return data(
        { error: session.get("error") },
        {
          headers: {
            "Set-Cookie": await commitSession(session),
          },
        }
      );
    }
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      const session = await getSession(
        request.headers.get("Cookie")
      );
      const form = await request.formData();
      const username = form.get("username");
      const password = form.get("password");
    
      const userId = await validateCredentials(
        username,
        password
      );
    
      if (userId == null) {
        session.flash("error", "Invalid username/password");
    
        // Redirect back to the login page with errors.
        return redirect("/login", {
          headers: {
            "Set-Cookie": await commitSession(session),
          },
        });
      }
    
      session.set("userId", userId);
    
      // Login succeeded, send them to the home page.
      return redirect("/", {
        headers: {
          "Set-Cookie": await commitSession(session),
        },
      });
    }
    
    export default function Login({
      loaderData,
    }: Route.ComponentProps) {
      const { error } = loaderData;
    
      return (
        <div>
          {error ? <div className="error">{error}</div> : null}
          <form method="POST">
            <div>
              <p>Please sign in</p>
            </div>
            <label>
              Username: <input type="text" name="username" />
            </label>
            <label>
              Password:{" "}
              <input type="password" name="password" />
            </label>
          </form>
        </div>
      );
    }
    

And then a logout form might look something like this:

    import {
      getSession,
      destroySession,
    } from "../sessions.server";
    import type { Route } from "./+types/logout";
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      const session = await getSession(
        request.headers.get("Cookie")
      );
      return redirect("/login", {
        headers: {
          "Set-Cookie": await destroySession(session),
        },
      });
    }
    
    export default function LogoutRoute() {
      return (
        <>
          <p>Are you sure you want to log out?</p>
          <Form method="post">
            <button>Logout</button>
          </Form>
          <Link to="/">Never mind</Link>
        </>
      );
    }
    

It's important that you logout (or perform any mutation for that matter) in an `action` and not a `loader`. Otherwise you open your users to [Cross-Site Request Forgery](https://developer.mozilla.org/en-US/docs/Glossary/CSRF) attacks.

### [](#session-gotchas)Session Gotchas

Because of nested routes, multiple loaders can be called to construct a single page. When using `session.flash()` or `session.unset()`, you need to be sure no other loaders in the request are going to want to read that, otherwise you'll get race conditions. Typically if you're using flash, you'll want to have a single loader read it, if another loader wants a flash message, use a different key for that loader.

### [](#creating-custom-session-storage)Creating custom session storage

React Router makes it easy to store sessions in your own database if needed. The [`createSessionStorage()`](https://api.reactrouter.com/v7/functions/react_router.createSessionStorage) API requires a `cookie` (for options for creating a cookie, see [cookies](#cookies)) and a set of create, read, update, and delete (CRUD) methods for managing the session data. The cookie is used to persist the session ID.

*   `createData` will be called from `commitSession` on the initial session creation when no session ID exists in the cookie
*   `readData` will be called from `getSession` when a session ID exists in the cookie
*   `updateData` will be called from `commitSession` when a session ID already exists in the cookie
*   `deleteData` is called from `destroySession`

The following example shows how you could do this using a generic database client:

    import { createSessionStorage } from "react-router";
    
    function createDatabaseSessionStorage({
      cookie,
      host,
      port,
    }) {
      // Configure your database client...
      const db = createDatabaseClient(host, port);
    
      return createSessionStorage({
        cookie,
        async createData(data, expires) {
          // `expires` is a Date after which the data should be considered
          // invalid. You could use it to invalidate the data somehow or
          // automatically purge this record from your database.
          const id = await db.insert(data);
          return id;
        },
        async readData(id) {
          return (await db.select(id)) || null;
        },
        async updateData(id, data, expires) {
          await db.update(id, data);
        },
        async deleteData(id) {
          await db.delete(id);
        },
      });
    }
    

And then you can use it like this:

    const { getSession, commitSession, destroySession } =
      createDatabaseSessionStorage({
        host: "localhost",
        port: 1234,
        cookie: {
          name: "__session",
          sameSite: "lax",
        },
      });
    

The `expires` argument to `createData` and `updateData` is the same `Date` at which the cookie itself expires and is no longer valid. You can use this information to automatically purge the session record from your database to save on space, or to ensure that you do not otherwise return any data for old, expired cookies.

### [](#additional-session-utils)Additional session utils

There are also several other session utilities available if you need them:

*   [`isSession`](https://api.reactrouter.com/v7/functions/react_router.isSession)
*   [`createMemorySessionStorage`](https://api.reactrouter.com/v7/functions/react_router.createMemorySessionStorage)
*   [`createSession`](https://api.reactrouter.com/v7/functions/react_router.createSession) (custom storage)
*   [`createFileSessionStorage`](https://api.reactrouter.com/v7/functions/_react_router_node.createFileSessionStorage) (node)
*   [`createWorkersKVSessionStorage`](https://api.reactrouter.com/v7/functions/_react_router_cloudflare.createWorkersKVSessionStorage) (Cloudflare Workers)
*   [`createArcTableSessionStorage`](https://api.reactrouter.com/v7/functions/_react_router_architect.createArcTableSessionStorage) (architect, Amazon DynamoDB)

[](#cookies)Cookies
-------------------

A [cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) is a small piece of information that your server sends someone in a HTTP response that their browser will send back on subsequent requests. This technique is a fundamental building block of many interactive websites that adds state so you can build authentication (see [sessions](#sessions)), shopping carts, user preferences, and many other features that require remembering who is "logged in".

React Router's [`Cookie` interface](https://api.reactrouter.com/v7/interfaces/react_router.Cookie) provides a logical, reusable container for cookie metadata.

### [](#using-cookies)Using cookies

While you may create these cookies manually, it is more common to use a [session storage](#sessions).

In React Router, you will typically work with cookies in your `loader` and/or `action` functions, since those are the places where you need to read and write data.

Let's say you have a banner on your e-commerce site that prompts users to check out the items you currently have on sale. The banner spans the top of your homepage, and includes a button on the side that allows the user to dismiss the banner so they don't see it for at least another week.

First, create a cookie:

    import { createCookie } from "react-router";
    
    export const userPrefs = createCookie("user-prefs", {
      maxAge: 604_800, // one week
    });
    

Then, you can `import` the cookie and use it in your `loader` and/or `action`. The `loader` in this case just checks the value of the user preference so you can use it in your component for deciding whether to render the banner. When the button is clicked, the `<form>` calls the `action` on the server and reloads the page without the banner.

### [](#user-preferences-example)User preferences example

    import { Link, Form, redirect } from "react-router";
    import type { Route } from "./+types/home";
    
    import { userPrefs } from "../cookies.server";
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const cookieHeader = request.headers.get("Cookie");
      const cookie =
        (await userPrefs.parse(cookieHeader)) || {};
      return { showBanner: cookie.showBanner };
    }
    
    export async function action({
      request,
    }: Route.ActionArgs) {
      const cookieHeader = request.headers.get("Cookie");
      const cookie =
        (await userPrefs.parse(cookieHeader)) || {};
      const bodyParams = await request.formData();
    
      if (bodyParams.get("bannerVisibility") === "hidden") {
        cookie.showBanner = false;
      }
    
      return redirect("/", {
        headers: {
          "Set-Cookie": await userPrefs.serialize(cookie),
        },
      });
    }
    
    export default function Home({
      loaderData,
    }: Route.ComponentProps) {
      return (
        <div>
          {loaderData.showBanner ? (
            <div>
              <Link to="/sale">Don't miss our sale!</Link>
              <Form method="post">
                <input
                  type="hidden"
                  name="bannerVisibility"
                  value="hidden"
                />
                <button type="submit">Hide</button>
              </Form>
            </div>
          ) : null}
          <h1>Welcome!</h1>
        </div>
      );
    }
    

### [](#cookie-attributes)Cookie attributes

Cookies have [several attributes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes) that control when they expire, how they are accessed, and where they are sent. Any of these attributes may be specified either in `createCookie(name, options)`, or during `serialize()` when the `Set-Cookie` header is generated.

    const cookie = createCookie("user-prefs", {
      // These are defaults for this cookie.
      path: "/",
      sameSite: "lax",
      httpOnly: true,
      secure: true,
      expires: new Date(Date.now() + 60_000),
      maxAge: 60,
    });
    
    // You can either use the defaults:
    cookie.serialize(userPrefs);
    
    // Or override individual ones as needed:
    cookie.serialize(userPrefs, { sameSite: "strict" });
    

Please read [more info about these attributes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes) to get a better understanding of what they do.

### [](#signing-cookies)Signing cookies

It is possible to sign a cookie to automatically verify its contents when it is received. Since it's relatively easy to spoof HTTP headers, this is a good idea for any information that you do not want someone to be able to fake, like authentication information (see [sessions](#sessions)).

To sign a cookie, provide one or more `secrets` when you first create the cookie:

    const cookie = createCookie("user-prefs", {
      secrets: ["s3cret1"],
    });
    

Cookies that have one or more `secrets` will be stored and verified in a way that ensures the cookie's integrity.

Secrets may be rotated by adding new secrets to the front of the `secrets` array. Cookies that have been signed with old secrets will still be decoded successfully in `cookie.parse()`, and the newest secret (the first one in the array) will always be used to sign outgoing cookies created in `cookie.serialize()`.

    export const cookie = createCookie("user-prefs", {
      secrets: ["n3wsecr3t", "olds3cret"],
    });
    

    import { data } from "react-router";
    import { cookie } from "../cookies.server";
    import type { Route } from "./+types/my-route";
    
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const oldCookie = request.headers.get("Cookie");
      // oldCookie may have been signed with "olds3cret", but still parses ok
      const value = await cookie.parse(oldCookie);
    
      return data("...", {
        headers: {
          // Set-Cookie is signed with "n3wsecr3t"
          "Set-Cookie": await cookie.serialize(value),
        },
      });
    }
    

### [](#additional-cookie-utils)Additional cookie utils

There are also several other cookie utilities available if you need them:

*   [`isCookie`](https://api.reactrouter.com/v7/functions/react_router.isCookie)
*   [`createCookie`](https://api.reactrouter.com/v7/functions/react_router.createCookie)

To learn more about each attribute, please see the [MDN Set-Cookie docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#attributes).

[](#special-files)Special Files
===============================

There are a few special files that React Router looks for in your project. Not all of these files are required

[](#react-routerconfigts)react-router.config.ts
-----------------------------------------------

**This file is optional**

The config file is used to configure certain aspects of your app, such as whether you are using server-side rendering, where certain directories are located, and more.

    import type { Config } from "@react-router/dev/config";
    
    export default {
      // Config options...
    } satisfies Config;
    

See the details on [react-router config API](https://api.reactrouter.com/v7/types/_react_router_dev.config.Config.html) for more information.

[](#roottsx)root.tsx
--------------------

**This file is required**

The "root" route (`app/root.tsx`) is the only _required_ route in your React Router application because it is the parent to all routes in your `routes/` directory and is in charge of rendering the root `<html>` document.

Because the root route manages your document, it is the proper place to render a handful of "document-level" components React Router provides. These components are to be used once inside your root route and they include everything React Router figured out or built in order for your page to render properly.

    import type { LinksFunction } from "react-router";
    import {
      Links,
      Meta,
      Outlet,
      Scripts,
      ScrollRestoration,
    } from "react-router";
    
    import "./global-styles.css";
    
    export default function App() {
      return (
        <html lang="en">
          <head>
            <meta charSet="utf-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1"
            />
    
            {/* All `meta` exports on all routes will render here */}
            <Meta />
    
            {/* All `link` exports on all routes will render here */}
            <Links />
          </head>
          <body>
            {/* Child routes render here */}
            <Outlet />
    
            {/* Manages scroll position for client-side transitions */}
            {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
            <ScrollRestoration />
    
            {/* Script tags go here */}
            {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
            <Scripts />
          </body>
        </html>
      );
    }
    

### [](#layout-export)Layout export

The root route supports all [route module exports](../start/framework/route-module).

The root route also supports an additional optional `Layout` export. The `Layout` component serves 2 purposes:

1.  Avoid duplicating your document's "app shell" across your root component, `HydrateFallback`, and `ErrorBoundary`
2.  Prevent React from re-mounting your app shell elements when switching between the root component/`HydrateFallback`/`ErrorBoundary` which can cause a FOUC if React removes and re-adds `<link rel="stylesheet">` tags from your `<Links>` component.

    export function Layout({ children }) {
      return (
        <html lang="en">
          <head>
            <meta charSet="utf-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1"
            />
            <Meta />
            <Links />
          </head>
          <body>
            {/* children will be the root Component, ErrorBoundary, or HydrateFallback */}
            {children}
            <Scripts />
            <ScrollRestoration />
          </body>
        </html>
      );
    }
    
    export default function App() {
      return <Outlet />;
    }
    
    export function ErrorBoundary() {}
    

**A note on `useLoaderData`in the `Layout` Component**

`useLoaderData` is not permitted to be used in `ErrorBoundary` components because it is intended for the happy-path route rendering, and its typings have a built-in assumption that the `loader` ran successfully and returned something. That assumption doesn't hold in an `ErrorBoundary` because it could have been the `loader` that threw and triggered the boundary! In order to access loader data in `ErrorBoundary`'s, you can use `useRouteLoaderData` which accounts for the loader data potentially being `undefined`.

Because your `Layout` component is used in both success and error flows, this same restriction holds. If you need to fork logic in your `Layout` depending on if it was a successful request or not, you can use `useRouteLoaderData("root")` and `useRouteError()`.

Because your `<Layout>` component is used for rendering the `ErrorBoundary`, you should be _very defensive_ to ensure that you can render your `ErrorBoundary` without encountering any render errors. If your `Layout` throws another error trying to render the boundary, then it can't be used and your UI will fall back to the very minimal built-in default `ErrorBoundary`.

    export function Layout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      const data = useRouteLoaderData("root");
      const error = useRouteError();
    
      return (
        <html lang="en">
          <head>
            <meta charSet="utf-8" />
            <meta
              name="viewport"
              content="width=device-width, initial-scale=1"
            />
            <Meta />
            <Links />
            <style
              dangerouslySetInnerHTML={{
                __html: `
                  :root {
                    --themeVar: ${
                      data?.themeVar || defaultThemeVar
                    }
                  }
                `,
              }}
            />
          </head>
          <body>
            {data ? (
              <Analytics token={data.analyticsToken} />
            ) : null}
            {children}
            <ScrollRestoration />
            <Scripts />
          </body>
        </html>
      );
    }
    

[](#routests)routes.ts
----------------------

**This file is required**

The `routes.ts` file is used to configure which url patterns are matched to which route modules.

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("some/path", "./some/file.tsx"),
      // pattern ^           ^ module file
    ] satisfies RouteConfig;
    

See the [routing guide](../start/framework/routing) for more information.

[](#entryclienttsx)entry.client.tsx
-----------------------------------

**This file is optional**

By default, React Router will handle hydrating your app on the client for you. You can reveal the default entry client file with the following:

    react-router reveal
    

This file is the entry point for the browser and is responsible for hydrating the markup generated by the server in your [server entry module](#entryservertsx), however you can also initialize any other client-side code here.

    import { startTransition, StrictMode } from "react";
    import { hydrateRoot } from "react-dom/client";
    import { HydratedRouter } from "react-router/dom";
    
    startTransition(() => {
      hydrateRoot(
        document,
        <StrictMode>
          <HydratedRouter />
        </StrictMode>
      );
    });
    

This is the first piece of code that runs in the browser. You can initialize client side libraries, add client only providers, etc.

[](#entryservertsx)entry.server.tsx
-----------------------------------

**This file is optional**

By default, React Router will handle generating the HTTP Response for you. You can reveal the default entry server file with the following:

    react-router reveal
    

The `default` export of this module is a function that lets you create the response, including HTTP status, headers, and HTML, giving you full control over the way the markup is generated and sent to the client.

This module should render the markup for the current page using a `<ServerRouter>` element with the `context` and `url` for the current request. This markup will (optionally) be re-hydrated once JavaScript loads in the browser using the [client entry module](#entryclienttsx).

### [](#streamtimeout)`streamTimeout`

If you are [streaming](../how-to/suspense) responses, you can export an optional `streamTimeout` value (in milliseconds) that will control the amount of time the server will wait for streamed promises to settle before rejecting outstanding promises them and closing the stream.

It's recommended to decouple this value from the timeout in which you abort the React renderer. You should always set the React rendering timeout to a higher value so it has time to stream down the underlying rejections from your `streamTimeout`.

    // Reject all pending promises from handler functions after 10 seconds
    export const streamTimeout = 10000;
    
    export default function handleRequest(...) {
      return new Promise((resolve, reject) => {
        // ...
    
        const { pipe, abort } = renderToPipeableStream(
          <ServerRouter context={routerContext} url={request.url} />,
          { /* ... */ }
        );
    
        // Abort the streaming render pass after 11 seconds to allow the rejected
        // boundaries to be flushed
        setTimeout(abort, streamTimeout + 1000);
      });
    }
    

### [](#handledatarequest)`handleDataRequest`

You can export an optional `handleDataRequest` function that will allow you to modify the response of a data request. These are the requests that do not render HTML, but rather return the loader and action data to the browser once client-side hydration has occurred.

    export function handleDataRequest(
      response: Response,
      {
        request,
        params,
        context,
      }: LoaderFunctionArgs | ActionFunctionArgs
    ) {
      response.headers.set("X-Custom-Header", "value");
      return response;
    }
    

### [](#handleerror)`handleError`

By default, React Router will log encountered server-side errors to the console. If you'd like more control over the logging, or would like to also report these errors to an external service, then you can export an optional `handleError` function which will give you control (and will disable the built-in error logging).

    export function handleError(
      error: unknown,
      {
        request,
        params,
        context,
      }: LoaderFunctionArgs | ActionFunctionArgs
    ) {
      if (!request.signal.aborted) {
        sendErrorToErrorReportingService(error);
        console.error(formatErrorForJsonLogging(error));
      }
    }
    

_Note that you generally want to avoid logging when the request was aborted, since React Router's cancellation and race-condition handling can cause a lot of requests to be aborted._

### [](#streaming-rendering-errors)Streaming Rendering Errors

When you are streaming your HTML responses via [`renderToPipeableStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream) or [`renderToReadableStream`](https://react.dev/reference/react-dom/server/renderToReadableStream), your own `handleError` implementation will only handle errors encountered during the initial shell render. If you encounter a rendering error during subsequent streamed rendering you will need to handle these errors manually since the React Router server has already sent the Response by that point.

For `renderToPipeableStream`, you can handle these errors in the `onError` callback function. You will need to toggle a boolean in `onShellReady` so you know if the error was a shell rendering error (and can be ignored) or an async

For an example, please refer to the default [`entry.server.tsx`](https://github.com/remix-run/react-router/blob/dev/packages/react-router-dev/config/defaults/entry.server.node.tsx) for Node.

**Thrown Responses**

Note that this does not handle thrown `Response` instances from your `loader`/`action` functions. The intention of this handler is to find bugs in your code which result in unexpected thrown errors. If you are detecting a scenario and throwing a 401/404/etc. `Response` in your `loader`/`action` then it's an expected flow that is handled by your code. If you also wish to log, or send those to an external service, that should be done at the time you throw the response.

[](#server-modules)`.server` modules
------------------------------------

While not strictly necessary, `.server` modules are a good way to explicitly mark entire modules as server-only. The build will fail if any code in a `.server` file or `.server` directory accidentally ends up in the client module graph.

    app
    ├── .server 👈 marks all files in this directory as server-only
    │   ├── auth.ts
    │   └── db.ts
    ├── cms.server.ts 👈 marks this file as server-only
    ├── root.tsx
    └── routes.ts
    

`.server` modules must be within your app directory.

Refer to the Route Module section in the sidebar for more information.

[](#client-modules)`.client` modules
------------------------------------

While uncommon, you may have a file or dependency that uses module side effects in the browser. You can use `*.client.ts` on file names or nest files within `.client` directories to force them out of server bundles.

    // this would break the server
    export const supportsVibrationAPI =
      "vibrate" in window.navigator;
    

Note that values exported from this module will all be `undefined` on the server, so the only places to use them are in [`useEffect`](https://react.dev/reference/react/useEffect) and user events like click handlers.

    import { supportsVibrationAPI } from "./feature-check.client.ts";
    
    console.log(supportsVibrationAPI);
    // server: undefined
    // client: true | false
    

[](#state-management)State Management
=====================================

State management in React typically involves maintaining a synchronized cache of server data on the client side. However, when using React Router as your framework, most of the traditional caching solutions become redundant because of how it inherently handles data synchronization.

[](#understanding-state-management-in-react)Understanding State Management in React
-----------------------------------------------------------------------------------

In a typical React context, when we refer to "state management", we're primarily discussing how we synchronize server state with the client. A more apt term could be "cache management" because the server is the source of truth and the client state is mostly functioning as a cache.

Popular caching solutions in React include:

*   **Redux:** A predictable state container for JavaScript apps.
*   **React Query:** Hooks for fetching, caching, and updating asynchronous data in React.
*   **Apollo:** A comprehensive state management library for JavaScript that integrates with GraphQL.

In certain scenarios, using these libraries may be warranted. However, with React Router's unique server-focused approach, their utility becomes less prevalent. In fact, most React Router applications forgo them entirely.

[](#how-react-router-simplifies-state)How React Router Simplifies State
-----------------------------------------------------------------------

React Router seamlessly bridges the gap between the backend and frontend via mechanisms like loaders, actions, and forms with automatic synchronization through revalidation. This offers developers the ability to directly use server state within components without managing a cache, the network communication, or data revalidation, making most client-side caching redundant.

Here's why using typical React state patterns might be an anti-pattern in React Router:

1.  **Network-related State:** If your React state is managing anything related to the network—such as data from loaders, pending form submissions, or navigational states—it's likely that you're managing state that React Router already manages:
    
    *   **[`useNavigation`](https://api.reactrouter.com/v7/functions/react_router.useNavigation)**: This hook gives you access to `navigation.state`, `navigation.formData`, `navigation.location`, etc.
    *   **[`useFetcher`](https://api.reactrouter.com/v7/functions/react_router.useFetcher)**: This facilitates interaction with `fetcher.state`, `fetcher.formData`, `fetcher.data` etc.
    *   **[`loaderData`](../start/framework/data-loading)**: Access the data for a route.
    *   **[`actionData`](../start/framework/actions)**: Access the data from the latest action.
2.  **Storing Data in React Router:** A lot of data that developers might be tempted to store in React state has a more natural home in React Router, such as:
    
    *   **URL Search Params:** Parameters within the URL that hold state.
    *   **[Cookies](./sessions-and-cookies#cookies):** Small pieces of data stored on the user's device.
    *   **[Server Sessions](./sessions-and-cookies#sessions):** Server-managed user sessions.
    *   **Server Caches:** Cached data on the server side for quicker retrieval.
3.  **Performance Considerations:** At times, client state is leveraged to avoid redundant data fetching. With React Router, you can use the [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) headers within `loader`s, allowing you to tap into the browser's native cache. However, this approach has its limitations and should be used judiciously. It's usually more beneficial to optimize backend queries or implement a server cache. This is because such changes benefit all users and do away with the need for individual browser caches.
    

As a developer transitioning to React Router, it's essential to recognize and embrace its inherent efficiencies rather than applying traditional React patterns. React Router offers a streamlined solution to state management leading to less code, fresh data, and no state synchronization bugs.

[](#examples)Examples
---------------------

### [](#network-related-state)Network Related State

For examples on using React Router's internal state to manage network related state, refer to [Pending UI](../start/framework/pending-ui).

### [](#url-search-params)URL Search Params

Consider a UI that lets the user customize between list view or detail view. Your instinct might be to reach for React state:

    export function List() {
      const [view, setView] = useState("list");
      return (
        <div>
          <div>
            <button onClick={() => setView("list")}>
              View as List
            </button>
            <button onClick={() => setView("details")}>
              View with Details
            </button>
          </div>
          {view === "list" ? <ListView /> : <DetailView />}
        </div>
      );
    }
    

Now consider you want the URL to update when the user changes the view. Note the state synchronization:

    import { useNavigate, useSearchParams } from "react-router";
    
    export function List() {
      const navigate = useNavigate();
      const [searchParams] = useSearchParams();
      const [view, setView] = useState(
        searchParams.get("view") || "list"
      );
    
      return (
        <div>
          <div>
            <button
              onClick={() => {
                setView("list");
                navigate(`?view=list`);
              }}
            >
              View as List
            </button>
            <button
              onClick={() => {
                setView("details");
                navigate(`?view=details`);
              }}
            >
              View with Details
            </button>
          </div>
          {view === "list" ? <ListView /> : <DetailView />}
        </div>
      );
    }
    

Instead of synchronizing state, you can simply read and set the state in the URL directly with boring old HTML forms:

    import { Form, useSearchParams } from "react-router";
    
    export function List() {
      const [searchParams] = useSearchParams();
      const view = searchParams.get("view") || "list";
    
      return (
        <div>
          <Form>
            <button name="view" value="list">
              View as List
            </button>
            <button name="view" value="details">
              View with Details
            </button>
          </Form>
          {view === "list" ? <ListView /> : <DetailView />}
        </div>
      );
    }
    

### [](#persistent-ui-state)Persistent UI State

Consider a UI that toggles a sidebar's visibility. We have three ways to handle the state:

1.  React state
2.  Browser local storage
3.  Cookies

In this discussion, we'll break down the trade-offs associated with each method.

#### [](#react-state)React State

React state provides a simple solution for temporary state storage.

**Pros**:

*   **Simple**: Easy to implement and understand.
*   **Encapsulated**: State is scoped to the component.

**Cons**:

*   **Transient**: Doesn't survive page refreshes, returning to the page later, or unmounting and remounting the component.

**Implementation**:

    function Sidebar() {
      const [isOpen, setIsOpen] = useState(false);
      return (
        <div>
          <button onClick={() => setIsOpen((open) => !open)}>
            {isOpen ? "Close" : "Open"}
          </button>
          <aside hidden={!isOpen}>
            <Outlet />
          </aside>
        </div>
      );
    }
    

#### [](#local-storage)Local Storage

To persist state beyond the component lifecycle, browser local storage is a step-up. See our doc on [Client Data](../how-to/client-data) for more advanced examples.

**Pros**:

*   **Persistent**: Maintains state across page refreshes and component mounts/unmounts.
*   **Encapsulated**: State is scoped to the component.

**Cons**:

*   **Requires Synchronization**: React components must sync up with local storage to initialize and save the current state.
*   **Server Rendering Limitation**: The [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) and [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) objects are not accessible during server-side rendering, so state must be initialized in the browser with an effect.
*   **UI Flickering**: On initial page loads, the state in local storage may not match what was rendered by the server and the UI will flicker when JavaScript loads.

**Implementation**:

    function Sidebar() {
      const [isOpen, setIsOpen] = useState(false);
    
      // synchronize initially
      useLayoutEffect(() => {
        const isOpen = window.localStorage.getItem("sidebar");
        setIsOpen(isOpen);
      }, []);
    
      // synchronize on change
      useEffect(() => {
        window.localStorage.setItem("sidebar", isOpen);
      }, [isOpen]);
    
      return (
        <div>
          <button onClick={() => setIsOpen((open) => !open)}>
            {isOpen ? "Close" : "Open"}
          </button>
          <aside hidden={!isOpen}>
            <Outlet />
          </aside>
        </div>
      );
    }
    

In this approach, state must be initialized within an effect. This is crucial to avoid complications during server-side rendering. Directly initializing the React state from `localStorage` will cause errors since `window.localStorage` is unavailable during server rendering.

    function Sidebar() {
      const [isOpen, setIsOpen] = useState(
        // error: window is not defined
        window.localStorage.getItem("sidebar")
      );
    
      // ...
    }
    

By initializing the state within an effect, there's potential for a mismatch between the server-rendered state and the state stored in local storage. This discrepancy will lead to brief UI flickering shortly after the page renders and should be avoided.

#### [](#cookies)Cookies

Cookies offer a comprehensive solution for this use case. However, this method introduces added preliminary setup before making the state accessible within the component.

**Pros**:

*   **Server Rendering**: State is available on the server for rendering and even for server actions.
*   **Single Source of Truth**: Eliminates state synchronization hassles.
*   **Persistence**: Maintains state across page loads and component mounts/unmounts. State can even persist across devices if you switch to a database-backed session.
*   **Progressive Enhancement**: Functions even before JavaScript loads.

**Cons**:

*   **Boilerplate**: Requires more code because of the network.
*   **Exposed**: The state is not encapsulated to a single component, other parts of the app must be aware of the cookie.

**Implementation**:

First we'll need to create a cookie object:

    import { createCookie } from "react-router";
    export const prefs = createCookie("prefs");
    

Next we set up the server action and loader to read and write the cookie:

    import { data, Outlet } from "react-router";
    import type { Route } from "./+types/sidebar";
    
    import { prefs } from "./prefs-cookie";
    
    // read the state from the cookie
    export async function loader({
      request,
    }: Route.LoaderArgs) {
      const cookieHeader = request.headers.get("Cookie");
      const cookie = (await prefs.parse(cookieHeader)) || {};
      return data({ sidebarIsOpen: cookie.sidebarIsOpen });
    }
    
    // write the state to the cookie
    export async function action({
      request,
    }: Route.ActionArgs) {
      const cookieHeader = request.headers.get("Cookie");
      const cookie = (await prefs.parse(cookieHeader)) || {};
      const formData = await request.formData();
    
      const isOpen = formData.get("sidebar") === "open";
      cookie.sidebarIsOpen = isOpen;
    
      return data(isOpen, {
        headers: {
          "Set-Cookie": await prefs.serialize(cookie),
        },
      });
    }
    

After the server code is set up, we can use the cookie state in our UI:

    function Sidebar({ loaderData }: Route.ComponentProps) {
      const fetcher = useFetcher();
      let { sidebarIsOpen } = loaderData;
    
      // use optimistic UI to immediately change the UI state
      if (fetcher.formData?.has("sidebar")) {
        sidebarIsOpen =
          fetcher.formData.get("sidebar") === "open";
      }
    
      return (
        <div>
          <fetcher.Form method="post">
            <button
              name="sidebar"
              value={sidebarIsOpen ? "closed" : "open"}
            >
              {sidebarIsOpen ? "Close" : "Open"}
            </button>
          </fetcher.Form>
          <aside hidden={!sidebarIsOpen}>
            <Outlet />
          </aside>
        </div>
      );
    }
    

While this is certainly more code that touches more of the application to account for the network requests and responses, the UX is greatly improved. Additionally, state comes from a single source of truth without any state synchronization required.

In summary, each of the discussed methods offers a unique set of benefits and challenges:

*   **React state**: Offers simple but transient state management.
*   **Local Storage**: Provides persistence but with synchronization requirements and UI flickering.
*   **Cookies**: Delivers robust, persistent state management at the cost of added boilerplate.

None of these are wrong, but if you want to persist the state across visits, cookies offer the best user experience.

### [](#form-validation-and-action-data)Form Validation and Action Data

Client-side validation can augment the user experience, but similar enhancements can be achieved by leaning more towards server-side processing and letting it handle the complexities.

The following example illustrates the inherent complexities of managing network state, coordinating state from the server, and implementing validation redundantly on both the client and server sides. It's just for illustration, so forgive any obvious bugs or problems you find.

    export function Signup() {
      // A multitude of React State declarations
      const [isSubmitting, setIsSubmitting] = useState(false);
    
      const [userName, setUserName] = useState("");
      const [userNameError, setUserNameError] = useState(null);
    
      const [password, setPassword] = useState(null);
      const [passwordError, setPasswordError] = useState("");
    
      // Replicating server-side logic in the client
      function validateForm() {
        setUserNameError(null);
        setPasswordError(null);
        const errors = validateSignupForm(userName, password);
        if (errors) {
          if (errors.userName) {
            setUserNameError(errors.userName);
          }
          if (errors.password) {
            setPasswordError(errors.password);
          }
        }
        return Boolean(errors);
      }
    
      // Manual network interaction handling
      async function handleSubmit() {
        if (validateForm()) {
          setSubmitting(true);
          const res = await postJSON("/api/signup", {
            userName,
            password,
          });
          const json = await res.json();
          setIsSubmitting(false);
    
          // Server state synchronization to the client
          if (json.errors) {
            if (json.errors.userName) {
              setUserNameError(json.errors.userName);
            }
            if (json.errors.password) {
              setPasswordError(json.errors.password);
            }
          }
        }
      }
    
      return (
        <form
          onSubmit={(event) => {
            event.preventDefault();
            handleSubmit();
          }}
        >
          <p>
            <input
              type="text"
              name="username"
              value={userName}
              onChange={() => {
                // Synchronizing form state for the fetch
                setUserName(event.target.value);
              }}
            />
            {userNameError ? <i>{userNameError}</i> : null}
          </p>
    
          <p>
            <input
              type="password"
              name="password"
              onChange={(event) => {
                // Synchronizing form state for the fetch
                setPassword(event.target.value);
              }}
            />
            {passwordError ? <i>{passwordError}</i> : null}
          </p>
    
          <button disabled={isSubmitting} type="submit">
            Sign Up
          </button>
    
          {isSubmitting ? <BusyIndicator /> : null}
        </form>
      );
    }
    

The backend endpoint, `/api/signup`, also performs validation and sends error feedback. Note that some essential validation, like detecting duplicate usernames, can only be done server-side using information the client doesn't have access to.

    export async function signupHandler(request: Request) {
      const errors = await validateSignupRequest(request);
      if (errors) {
        return { ok: false, errors: errors };
      }
      await signupUser(request);
      return { ok: true, errors: null };
    }
    

Now, let's contrast this with a React Router-based implementation. The action remains consistent, but the component is vastly simplified due to the direct utilization of server state via `actionData`, and leveraging the network state that React Router inherently manages.

    import { useNavigation } from "react-router";
    import type { Route } from "./+types/signup";
    
    export async function action({
      request,
    }: ActionFunctionArgs) {
      const errors = await validateSignupRequest(request);
      if (errors) {
        return { ok: false, errors: errors };
      }
      await signupUser(request);
      return { ok: true, errors: null };
    }
    
    export function Signup({
      actionData,
    }: Route.ComponentProps) {
      const navigation = useNavigation();
    
      const userNameError = actionData?.errors?.userName;
      const passwordError = actionData?.errors?.password;
      const isSubmitting = navigation.formAction === "/signup";
    
      return (
        <Form method="post">
          <p>
            <input type="text" name="username" />
            {userNameError ? <i>{userNameError}</i> : null}
          </p>
    
          <p>
            <input type="password" name="password" />
            {passwordError ? <i>{passwordError}</i> : null}
          </p>
    
          <button disabled={isSubmitting} type="submit">
            Sign Up
          </button>
    
          {isSubmitting ? <BusyIndicator /> : null}
        </Form>
      );
    }
    

The extensive state management from our previous example is distilled into just three code lines. We eliminate the necessity for React state, change event listeners, submit handlers, and state management libraries for such network interactions.

Direct access to the server state is made possible through `actionData`, and network state through `useNavigation` (or `useFetcher`).

As bonus party trick, the form is functional even before JavaScript loads (see [Progressive Enhancement](./progressive-enhancement)). Instead of React Router managing the network operations, the default browser behaviors step in.

If you ever find yourself entangled in managing and synchronizing state for network operations, React Router likely offers a more elegant solution.

[](#type-safety)Type Safety
===========================

If you haven't done so already, check out our guide for [setting up type safety](../how-to/route-module-type-safety) in a new project.

React Router generates types for each route in your app to provide type safety for the route module exports.

For example, let's say you have a `products/:id` route configured:

    import {
      type RouteConfig,
      route,
    } from "@react-router/dev/routes";
    
    export default [
      route("products/:id", "./routes/product.tsx"),
    ] satisfies RouteConfig;
    

You can import route-specific types like so:

    import type { Route } from "./+types/product";
    // types generated for this route 👆
    
    export function loader({ params }: Route.LoaderArgs) {
      //                      👆 { id: string }
      return { planet: `world #${params.id}` };
    }
    
    export default function Component({
      loaderData, // 👈 { planet: string }
    }: Route.ComponentProps) {
      return <h1>Hello, {loaderData.planet}!</h1>;
    }
    

[](#how-it-works)How it works
-----------------------------

React Router's type generation executes your route config (`app/routes.ts` by default) to determine the routes for your app. It then generates a `+types/<route file>.d.ts` for each route within a special `.react-router/types/` directory. With [`rootDirs` configured](../how-to/route-module-type-safety), TypeScript can import these generated files as if they were right next to their corresponding route modules.

For a deeper dive into some of the design decisions, check out our [type inference decision doc](https://github.com/remix-run/react-router/blob/dev/decisions/0012-type-inference.md).

[](#typegen-command)`typegen` command
-------------------------------------

You can manually generate types with the `typegen` command:

    react-router typegen
    

The following types are generated for each route:

*   `LoaderArgs`
*   `ClientLoaderArgs`
*   `ActionArgs`
*   `ClientActionArgs`
*   `HydrateFallbackProps`
*   `ComponentProps` (for the `default` export)
*   `ErrorBoundaryProps`

### [](#--watch)\--watch

If you run `react-router dev` — or if your custom server calls `vite.createServer` — then React Router's Vite plugin is already generating up-to-date types for you. But if you really need to run type generation on its own, you can also use `--watch` to automatically regenerate types as files change:

    react-router typegen --watch
    

[](#api-development-strategy)API Development Strategy
=====================================================

React Router is foundational to your application. We want to make sure that upgrading to new major versions is as smooth as possible while still allowing us to adjust and enhance the behavior and API as the React ecosystem advances.

Our strategy and motivations are discussed in more detail in our [Future Flags](https://remix.run/blog/future-flags) blog post.

[](#future-flags)Future Flags
-----------------------------

When an API changes in a breaking way, it is introduced in a future flag. This allows you to opt-in to one change a time before it becomes the default in the next major version.

*   Without enabling the future flag, nothing changes about your app
*   Enabling the flag changes the behavior for that feature

All current future flags are documented in the [Future Flags Guide](../upgrading/future) to help you stay up-to-date.

[](#unstable-flags)Unstable Flags
---------------------------------

Unstable flags are for features still being designed and developed and made available to our users to help us get it right.

Unstable flags are not recommended for production:

*   they will change without warning and without upgrade paths
*   they will have bugs
*   they aren't documented
*   they may be scrapped completely

When you opt-in to an unstable flag you are becoming a contributor to the project, rather than a user. We appreciate your help, but please be aware of the new role!

Because unstable flags are experimental and not guaranteed to stick around, we ship them in SemVer patch releases because they're not new _stable_/_documented_ APIs. When an unstable flag stabilizes into a Future Flag, that will be released in a SemVer minor release and will be properly documented and added to the [Future Flags Guide](../upgrading/future).

To learn about current unstable flags, keep an eye on the [CHANGELOG](../start/changelog).

### [](#example-new-feature-flow)Example New Feature Flow

The decision flow for a new feature looks something like this (note this diagram is in relation to Remix v1/v2 but applies to React Router v6/v7 as well):

[](#contributing-to-react-router)Contributing to React Router
=============================================================

Thanks for contributing, you rock!

When it comes to open source, there are many different kinds of contributions that can be made, all of which are valuable. Here are a few guidelines that should help you as you prepare your contribution.

[](#setup)Setup
---------------

Before you can contribute to the codebase, you will need to fork the repo. This will look a bit different depending on what type of contribution you are making:

*   All new features, bug-fixes, or **anything that touches `react-router` code** should be branched off of and merged into the `dev` branch
*   Changes that only touch documentation can be branched off of and merged into the `main` branch

The following steps will get you set up to contribute changes to this repo:

1.  Fork the repo (click the Fork button at the top right of [this page](https://github.com/remix-run/react-router))
    
2.  Clone your fork locally
    
        # in a terminal, cd to parent directory where you want your clone to be, then
        git clone https://github.com/<your_github_username>/react-router.git
        cd react-router
        
        # if you are making *any* code changes, make sure to checkout the dev branch
        git checkout dev
        
    
3.  Install dependencies and build. React Router uses [pnpm](https://pnpm.io), so you should too. If you install using `npm`, unnecessary `package-lock.json` files will be generated.
    

[](#think-you-found-a-bug)Think You Found a Bug?
------------------------------------------------

Please conform to the issue template and provide a clear path to reproduction with a code example. Best is a pull request with a [failing test](https://github.com/remix-run/react-router/blob/dev/integration/bug-report-test.ts). Next best is a link to [StackBlitz](https://reactrouter.com/new) or repository that illustrates the bug.

[](#adding-an-example)Adding an Example?
----------------------------------------

Examples can be added directly to the main branch. Create a branch off of your local clone of main. Once you've finished, create a pull request and outline your example.

[](#proposing-new-or-changed-api)Proposing New or Changed API?
--------------------------------------------------------------

Please provide thoughtful comments and some sample code that show what you'd like to do with React Router in your app. It helps the conversation if you can show us how you're limited by the current API first before jumping to a conclusion about what needs to be changed and/or added.

We have learned by experience that small APIs are usually better, so we may be a little reluctant to add something new unless there's an obvious limitation with the current API. That being said, we are always anxious to hear about cases that we just haven't considered before, so please don't be shy! :)

[](#issue-not-getting-attention)Issue Not Getting Attention?
------------------------------------------------------------

If you need a bug fixed and nobody is fixing it, your best bet is to provide a fix for it and make a [pull request](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request). Open source code belongs to all of us, and it's all of our responsibility to push it forward.

[](#making-a-pull-request)Making a Pull Request?
------------------------------------------------

Pull requests need only the approval of two or more collaborators to be merged; when the PR author is a collaborator, that counts as one.

When creating the PR in GitHub, make sure that you set the base to the correct branch. If you are submitting a PR that touches any code, this should be the `dev` branch. You set the base in GitHub when authoring the PR with the dropdown below the "Compare changes" heading:

### [](#tests)Tests

All commits that fix bugs or add features need a test.

Do not merge code without tests!

### [](#docs--examples)Docs + Examples

All commits that change or add to the API must be done in a pull request that also updates all relevant examples and docs.

Documentation is located in the `docs` directory. Once changes make their way into the `main` branch, they will automatically be published to the docs site.

If you want to preview how the changes will look on the docs site, clone the [`react-router-website` repository](https://github.com/remix-run/react-router-website) and follow the instructions in `README.md` to view your changes locally.

[](#development)Development
---------------------------

### [](#packages)Packages

React Router uses a monorepo to host code for multiple packages. These packages live in the `packages` directory.

We use [pnpm workspaces](https://pnpm.io/workspaces/) to manage installation of dependencies and running various scripts. To get everything installed, make sure you have [pnpm installed](https://pnpm.io/installation), and then run `pnpm install` from the repo root.

### [](#building)Building

Calling `pnpm build` from the root directory will run the build, which should take only a few seconds. It's important to build all the packages together because the individual packages have dependencies on one another.

### [](#testing)Testing

Before running the tests, you need to run a build. After you build, running `pnpm test` from the root directory will run **every** package's tests. If you want to run tests for a specific package, use `pnpm test --projects packages/<package-name>`:

    # Test all packages
    pnpm test
    
    # Test only react-router-dom
    pnpm test --projects packages/react-router-dom
    

[](#repository-branching)Repository Branching
---------------------------------------------

This repo maintains separate branches for different purposes. They will look something like this:

    - main   > the most recent release and current docs
    - dev    > code under active development between stable releases
    - v5     > the most recent code for a specific major release
    

There may be other branches for various features and experimentation, but all of the magic happens from these branches.

[](#new-releases)New Releases
-----------------------------

When it's time to cut a new release, we follow a process based on our branching strategy depending on the type of release.

### [](#react-routernext-releases)`react-router@next` Releases

We create experimental releases from the current state of the `dev` branch. They can be installed by using the `@next` tag:

    pnpm add react-router-dom@next
    # or
    npm install react-router-dom@next
    

These releases will be automated as PRs are merged into the `dev` branch.

### [](#latest-major-releases)Latest Major Releases

    # Start from the dev branch.
    git checkout dev
    
    # Merge the main branch into dev to ensure that any hotfixes and
    # docs updates are available in the release.
    git merge main
    
    # Create a new release branch from dev.
    git checkout -b release/v6.1.0
    
    # Create a new tag and update version references throughout the
    # codebase.
    pnpm run version [nextVersion]
    
    # Push the release branch along with the new release tag.
    git push origin release/v6.1.0 --follow-tags
    
    # Wait for GitHub actions to run all tests. If the tests pass, the
    # release is ready to go! Merge the release branch into main and dev.
    git checkout main
    git merge release/v6.1.0
    git checkout dev
    git merge release/v6.1.0
    
    # The release branch can now be deleted.
    git branch -D release/v6.1.0
    git push origin --delete release/v6.1.0
    
    # Now go to GitHub and create the release from the new tag. Let
    # GitHub Actions take care of the rest!
    

### [](#hot-fix-releases)Hot-fix Releases

Sometimes we have a crucial bug that needs to be patched right away. If the bug affects the latest release, we can create a new version directly from `main` (or the relevant major release branch where the bug exists):

    # From the main branch, make sure to run the build and all tests
    # before creating a new release.
    pnpm install && pnpm build && pnpm test
    
    # Assuming the tests pass, create the release tag and update
    # version references throughout the codebase.
    pnpm run version [nextVersion]
    
    # Push changes along with the new release tag.
    git push origin main --follow-tags
    
    # In GitHub, create the release from the new tag and it will be
    # published via GitHub actions
    
    # When the hot-fix is done, merge the changes into dev and clean
    # up conflicts as needed.
    git checkout dev
    git merge main
    git push origin dev
    

[](#installation)Installation
=============================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

[](#introduction)Introduction
-----------------------------

You can start with a React template from Vite and choose "React", otherwise bootstrap your application however you prefer.

    npx create-vite@latest
    

Next install React Router from npm:

    npm i react-router
    

Finally, render a `<BrowserRouter>` around your application:

    import React from "react";
    import ReactDOM from "react-dom/client";
    import { BrowserRouter } from "react-router";
    import App from "./app";
    
    const root = document.getElementById("root");
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    

* * *

Next: [Routing](./routing)

[](#custom-framework)Custom Framework
=====================================

*   [Framework](../../start/modes "Not available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Instead of using `@react-router/dev`, you can integrate React Router's framework features (like loaders, actions, fetchers, etc.) into your own bundler and server abstractions with Data Mode.

[](#client-rendering)Client Rendering
-------------------------------------

### [](#1-create-a-router)1\. Create a Router

The browser runtime API that enables route module APIs (loaders, actions, etc.) is `createBrowserRouter`.

It takes an array of route objects that support loaders, actions, error boundaries and more. The React Router Vite plugin creates one of these from `routes.ts`, but you can create one manually (or with an abstraction) and use your own bundler.

    import { createBrowserRouter } from "react-router";
    
    let router = createBrowserRouter([
      {
        path: "/",
        Component: Root,
        children: [
          {
            path: "shows/:showId",
            Component: Show,
            loader: ({ request, params }) =>
              fetch(`/api/show/${params.id}.json`, {
                signal: request.signal,
              }),
          },
        ],
      },
    ]);
    

### [](#2-render-the-router)2\. Render the Router

To render the router in the browser, use `<RouterProvider>`.

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    import { createRoot } from "react-dom/client";
    
    createRoot(document.getElementById("root")).render(
      <RouterProvider router={router} />
    );
    

### [](#3-lazy-loading)3\. Lazy Loading

Routes can take most of their definition lazily with the `lazy` property.

    createBrowserRouter([
      {
        path: "/show/:showId",
        lazy: {
          loader: async () =>
            (await import("./show.loader.js")).loader,
          action: async () =>
            (await import("./show.action.js")).action,
          Component: async () =>
            (await import("./show.component.js")).Component,
        },
      },
    ]);
    

[](#server-rendering)Server Rendering
-------------------------------------

To server render a custom setup, there are a few server APIs available for rendering and data loading.

This guide simply gives you some ideas about how it works. For deeper understanding, please see the [Custom Framework Example Repo](https://github.com/remix-run/custom-react-router-framework-example)

### [](#1-define-your-routes)1\. Define Your Routes

Routes are the same kinds of objects on the server as the client.

    export default [
      {
        path: "/",
        Component: Root,
        children: [
          {
            path: "shows/:showId",
            Component: Show,
            loader: ({ params }) => {
              return db.loadShow(params.id);
            },
          },
        ],
      },
    ];
    

### [](#2-create-a-static-handler)2\. Create a static handler

Turn your routes into a request handler with `createStaticHandler`:

    import { createStaticHandler } from "react-router";
    import routes from "./some-routes";
    
    let { query, dataRoutes } = createStaticHandler(routes);
    

### [](#3-get-routing-context-and-render)3\. Get Routing Context and Render

React Router works with web fetch [Requests](https://developer.mozilla.org/en-US/docs/Web/API/Request), so if your server doesn't, you'll need to adapt whatever objects it uses to a web fetch `Request` object.

This step assumes your server receives `Request` objects.

    import { renderToString } from "react-dom/server";
    import {
      createStaticHandler,
      createStaticRouter,
      StaticRouterProvider,
    } from "react-router";
    
    import routes from "./some-routes.js";
    
    let { query, dataRoutes } = createStaticHandler(routes);
    
    export async function handler(request: Request) {
      // 1. run actions/loaders to get the routing context with `query`
      let context = await query(request);
    
      // If `query` returns a Response, send it raw (a route probably a redirected)
      if (context instanceof Response) {
        return context;
      }
    
      // 2. Create a static router for SSR
      let router = createStaticRouter(dataRoutes, context);
    
      // 3. Render everything with StaticRouterProvider
      let html = renderToString(
        <StaticRouterProvider
          router={router}
          context={context}
        />
      );
    
      // Setup headers from action and loaders from deepest match
      let leaf = context.matches[context.matches.length - 1];
      let actionHeaders = context.actionHeaders[leaf.route.id];
      let loaderHeaders = context.loaderHeaders[leaf.route.id];
      let headers = new Headers(actionHeaders);
      if (loaderHeaders) {
        for (let [key, value] of loaderHeaders.entries()) {
          headers.append(key, value);
        }
      }
    
      headers.set("Content-Type", "text/html; charset=utf-8");
    
      // 4. send a response
      return new Response(`<!DOCTYPE html>${html}`, {
        status: context.statusCode,
        headers,
      });
    }
    

### [](#4-hydrate-in-the-browser)4\. Hydrate in the browser

Hydration data is embedded onto `window.__staticRouterHydrationData`, use that to initialize your client side router and render a `<RouterProvider>`.

    import { StrictMode } from "react";
    import { hydrateRoot } from "react-dom/client";
    import { RouterProvider } from "react-router/dom";
    import routes from "./app/routes.js";
    import { createBrowserRouter } from "react-router";
    
    let router = createBrowserRouter(routes, {
      hydrationData: window.__staticRouterHydrationData,
    });
    
    hydrateRoot(
      document,
      <StrictMode>
        <RouterProvider router={router} />
      </StrictMode>
    );
    

[](#installation)Installation
=============================

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Not available with Data")
*   [Declarative](../../start/modes "Not available with Declarative")

[](#introduction)Introduction
-----------------------------

Most projects start with a template. Let's use a basic template maintained by React Router:

    npx create-react-router@latest my-react-router-app
    

Now change into the new directory and start the app

    cd my-react-router-app
    npm i
    npm run dev
    

You can now open your browser to `http://localhost:5173`

You can [view the template on GitHub](https://github.com/remix-run/react-router-templates/tree/main/default) to see how to manually set up your project.

We also have a number of [ready to deploy templates](https://github.com/remix-run/react-router-templates) available for you to get started with:

    npx create-react-router@latest --template remix-run/react-router-templates/<template-name>
    

* * *

Next: [Routing](./routing)

[](#picking-a-mode)Picking a Mode
=================================

React Router is a multi-strategy router for React. There are three primary ways, or "modes", to use it in your app. Across the docs you'll see these icons indicating which mode the content is relevant to:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

The features available in each mode are additive, so moving from Declarative to Data to Framework simply adds more features at the cost of architectural control. So pick your mode based on how much control or how much help you want from React Router.

The mode depends on which "top level" router API you're using:

**Declarative**

Declarative mode enables basic routing features like matching URLs to components, navigating around the app, and providing active states with APIs like `<Link>`, `useNavigate`, and `useLocation`.

    import { BrowserRouter } from "react-router";
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    

**Data**

By moving route configuration outside of React rendering, Data Mode adds data loading, actions, pending states and more with APIs like `loader`, `action`, and `useFetcher`.

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    
    let router = createBrowserRouter([
      {
        path: "/",
        Component: Root,
        loader: loadRootData,
      },
    ]);
    
    ReactDOM.createRoot(root).render(
      <RouterProvider router={router} />
    );
    

**Framework**

Framework Mode wraps Data Mode with a Vite plugin to add the full React Router experience with:

*   typesafe `href`
*   typesafe Route Module API
*   intelligent code splitting
*   SPA, SSR, and static rendering strategies
*   and more

    import { index, route } from "@react-router/dev/routes";
    
    export default [
      index("./home.tsx"),
      route("products/:pid", "./product.tsx"),
    ];
    

You'll then have access to the Route Module API with typesafe params, loaderData, code splitting, SPA/SSR/SSG strategies, and more.

    import { Route } from "+./types/product.tsx";
    
    export async function loader({ params }: Route.LoaderArgs) {
      let product = await getProduct(params.pid);
      return { product };
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      return <div>{loaderData.product.name}</div>;
    }
    

[](#decision-advice)Decision Advice
-----------------------------------

Every mode supports any architecture and deployment target, so the question isn't really about if you want SSR, SPA, etc. It's about how much you want to do yourself.

**Use Framework Mode if you:**

*   are too new to have an opinion
*   are considering Next.js, Solid Start, SvelteKit, Astro, TanStack Start, etc. and want to compare
*   just want to build something with React
*   might want to server render, might not
*   are coming from Remix (React Router v7 is the "next version" after Remix v2)
*   are migrating from Next.js

[→ Get Started with Framework Mode](./framework/installation).

**Use Data Mode if you:**

*   want data features but also want to have control over bundling, data, and server abstractions
*   started a data router in v6.4 and are happy with it

[→ Get Started with Data Mode](./data/custom).

**Use Declarative Mode if you:**

*   want to use React Router as simply as possible
*   are coming from v6 and are happy with the `<BrowserRouter>`
*   have a data layer that either skips pending states (like local first, background data replication/sync) or has its own abstractions for them
*   are coming from Create React App (you may want to consider framework mode though)

[→ Get Started with Declarative Mode](./declarative/installation).

[](#api--mode-availability-table)API + Mode Availability Table
--------------------------------------------------------------

This is mostly for the LLMs, but knock yourself out:

API

Framework

Data

Declarative

Await

✅

✅

Form

✅

✅

Link

✅

✅

✅

`<Link discover>`

✅

`<Link prefetch>`

✅

`<Link preventScrollReset>`

✅

✅

Links

✅

Meta

✅

NavLink

✅

✅

✅

`<NavLink discover>`

✅

`<NavLink prefetch>`

✅

`<NavLink preventScrollReset>`

✅

✅

NavLink `isPending`

✅

✅

Navigate

✅

✅

✅

Outlet

✅

✅

✅

PrefetchPageLinks

✅

Route

✅

✅

✅

Routes

✅

✅

✅

Scripts

✅

ScrollRestoration

✅

✅

ServerRouter

✅

usePrompt

✅

✅

✅

useActionData

✅

✅

useAsyncError

✅

✅

useAsyncValue

✅

✅

useBeforeUnload

✅

✅

✅

useBlocker

✅

✅

useFetcher

✅

✅

useFetchers

✅

✅

useFormAction

✅

✅

useHref

✅

✅

✅

useInRouterContext

✅

✅

✅

useLinkClickHandler

✅

✅

✅

useLoaderData

✅

✅

useLocation

✅

✅

✅

useMatch

✅

✅

✅

useMatches

✅

✅

useNavigate

✅

✅

✅

useNavigation

✅

✅

useNavigationType

✅

✅

✅

useOutlet

✅

✅

✅

useOutletContext

✅

✅

✅

useParams

✅

✅

✅

useResolvedPath

✅

✅

✅

useRevalidator

✅

✅

useRouteError

✅

✅

useRouteLoaderData

✅

✅

useRoutes

✅

✅

✅

useSearchParams

✅

✅

✅

useSubmit

✅

✅

useViewTransitionState

✅

✅

isCookieFunction

✅

✅

isSessionFunction

✅

✅

createCookie

✅

✅

createCookieSessionStorage

✅

✅

createMemorySessionStorage

✅

✅

createPath

✅

✅

✅

createRoutesStub

✅

✅

createSearchParams

✅

✅

✅

data

✅

✅

generatePath

✅

✅

✅

href

✅

isCookie

✅

✅

isRouteErrorResponse

✅

✅

isSession

✅

✅

matchPath

✅

✅

✅

matchRoutes

✅

✅

✅

parsePath

✅

✅

✅

redirect

✅

✅

redirectDocument

✅

✅

renderMatches

✅

✅

✅

replace

✅

✅

resolvePath

✅

✅

✅

[](#picking-a-mode)Picking a Mode
=================================

React Router is a multi-strategy router for React. There are three primary ways, or "modes", to use it in your app. Across the docs you'll see these icons indicating which mode the content is relevant to:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

The features available in each mode are additive, so moving from Declarative to Data to Framework simply adds more features at the cost of architectural control. So pick your mode based on how much control or how much help you want from React Router.

The mode depends on which "top level" router API you're using:

**Declarative**

Declarative mode enables basic routing features like matching URLs to components, navigating around the app, and providing active states with APIs like `<Link>`, `useNavigate`, and `useLocation`.

    import { BrowserRouter } from "react-router";
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    

**Data**

By moving route configuration outside of React rendering, Data Mode adds data loading, actions, pending states and more with APIs like `loader`, `action`, and `useFetcher`.

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    
    let router = createBrowserRouter([
      {
        path: "/",
        Component: Root,
        loader: loadRootData,
      },
    ]);
    
    ReactDOM.createRoot(root).render(
      <RouterProvider router={router} />
    );
    

**Framework**

Framework Mode wraps Data Mode with a Vite plugin to add the full React Router experience with:

*   typesafe `href`
*   typesafe Route Module API
*   intelligent code splitting
*   SPA, SSR, and static rendering strategies
*   and more

    import { index, route } from "@react-router/dev/routes";
    
    export default [
      index("./home.tsx"),
      route("products/:pid", "./product.tsx"),
    ];
    

You'll then have access to the Route Module API with typesafe params, loaderData, code splitting, SPA/SSR/SSG strategies, and more.

    import { Route } from "+./types/product.tsx";
    
    export async function loader({ params }: Route.LoaderArgs) {
      let product = await getProduct(params.pid);
      return { product };
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      return <div>{loaderData.product.name}</div>;
    }
    

[](#decision-advice)Decision Advice
-----------------------------------

Every mode supports any architecture and deployment target, so the question isn't really about if you want SSR, SPA, etc. It's about how much you want to do yourself.

**Use Framework Mode if you:**

*   are too new to have an opinion
*   are considering Next.js, Solid Start, SvelteKit, Astro, TanStack Start, etc. and want to compare
*   just want to build something with React
*   might want to server render, might not
*   are coming from Remix (React Router v7 is the "next version" after Remix v2)
*   are migrating from Next.js

[→ Get Started with Framework Mode](./framework/installation).

**Use Data Mode if you:**

*   want data features but also want to have control over bundling, data, and server abstractions
*   started a data router in v6.4 and are happy with it

[→ Get Started with Data Mode](./data/custom).

**Use Declarative Mode if you:**

*   want to use React Router as simply as possible
*   are coming from v6 and are happy with the `<BrowserRouter>`
*   have a data layer that either skips pending states (like local first, background data replication/sync) or has its own abstractions for them
*   are coming from Create React App (you may want to consider framework mode though)

[→ Get Started with Declarative Mode](./declarative/installation).

[](#api--mode-availability-table)API + Mode Availability Table
--------------------------------------------------------------

This is mostly for the LLMs, but knock yourself out:

API

Framework

Data

Declarative

Await

✅

✅

Form

✅

✅

Link

✅

✅

✅

`<Link discover>`

✅

`<Link prefetch>`

✅

`<Link preventScrollReset>`

✅

✅

Links

✅

Meta

✅

NavLink

✅

✅

✅

`<NavLink discover>`

✅

`<NavLink prefetch>`

✅

`<NavLink preventScrollReset>`

✅

✅

NavLink `isPending`

✅

✅

Navigate

✅

✅

✅

Outlet

✅

✅

✅

PrefetchPageLinks

✅

Route

✅

✅

✅

Routes

✅

✅

✅

Scripts

✅

ScrollRestoration

✅

✅

ServerRouter

✅

usePrompt

✅

✅

✅

useActionData

✅

✅

useAsyncError

✅

✅

useAsyncValue

✅

✅

useBeforeUnload

✅

✅

✅

useBlocker

✅

✅

useFetcher

✅

✅

useFetchers

✅

✅

useFormAction

✅

✅

useHref

✅

✅

✅

useInRouterContext

✅

✅

✅

useLinkClickHandler

✅

✅

✅

useLoaderData

✅

✅

useLocation

✅

✅

✅

useMatch

✅

✅

✅

useMatches

✅

✅

useNavigate

✅

✅

✅

useNavigation

✅

✅

useNavigationType

✅

✅

✅

useOutlet

✅

✅

✅

useOutletContext

✅

✅

✅

useParams

✅

✅

✅

useResolvedPath

✅

✅

✅

useRevalidator

✅

✅

useRouteError

✅

✅

useRouteLoaderData

✅

✅

useRoutes

✅

✅

✅

useSearchParams

✅

✅

✅

useSubmit

✅

✅

useViewTransitionState

✅

✅

isCookieFunction

✅

✅

isSessionFunction

✅

✅

createCookie

✅

✅

createCookieSessionStorage

✅

✅

createMemorySessionStorage

✅

✅

createPath

✅

✅

✅

createRoutesStub

✅

✅

createSearchParams

✅

✅

✅

data

✅

✅

generatePath

✅

✅

✅

href

✅

isCookie

✅

✅

isRouteErrorResponse

✅

✅

isSession

✅

✅

matchPath

✅

✅

✅

matchRoutes

✅

✅

✅

parsePath

✅

✅

✅

redirect

✅

✅

redirectDocument

✅

✅

renderMatches

✅

✅

✅

replace

✅

✅

resolvePath

✅

✅

✅

[](#picking-a-mode)Picking a Mode
=================================

React Router is a multi-strategy router for React. There are three primary ways, or "modes", to use it in your app. Across the docs you'll see these icons indicating which mode the content is relevant to:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

The features available in each mode are additive, so moving from Declarative to Data to Framework simply adds more features at the cost of architectural control. So pick your mode based on how much control or how much help you want from React Router.

The mode depends on which "top level" router API you're using:

**Declarative**

Declarative mode enables basic routing features like matching URLs to components, navigating around the app, and providing active states with APIs like `<Link>`, `useNavigate`, and `useLocation`.

    import { BrowserRouter } from "react-router";
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    

**Data**

By moving route configuration outside of React rendering, Data Mode adds data loading, actions, pending states and more with APIs like `loader`, `action`, and `useFetcher`.

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    
    let router = createBrowserRouter([
      {
        path: "/",
        Component: Root,
        loader: loadRootData,
      },
    ]);
    
    ReactDOM.createRoot(root).render(
      <RouterProvider router={router} />
    );
    

**Framework**

Framework Mode wraps Data Mode with a Vite plugin to add the full React Router experience with:

*   typesafe `href`
*   typesafe Route Module API
*   intelligent code splitting
*   SPA, SSR, and static rendering strategies
*   and more

    import { index, route } from "@react-router/dev/routes";
    
    export default [
      index("./home.tsx"),
      route("products/:pid", "./product.tsx"),
    ];
    

You'll then have access to the Route Module API with typesafe params, loaderData, code splitting, SPA/SSR/SSG strategies, and more.

    import { Route } from "+./types/product.tsx";
    
    export async function loader({ params }: Route.LoaderArgs) {
      let product = await getProduct(params.pid);
      return { product };
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      return <div>{loaderData.product.name}</div>;
    }
    

[](#decision-advice)Decision Advice
-----------------------------------

Every mode supports any architecture and deployment target, so the question isn't really about if you want SSR, SPA, etc. It's about how much you want to do yourself.

**Use Framework Mode if you:**

*   are too new to have an opinion
*   are considering Next.js, Solid Start, SvelteKit, Astro, TanStack Start, etc. and want to compare
*   just want to build something with React
*   might want to server render, might not
*   are coming from Remix (React Router v7 is the "next version" after Remix v2)
*   are migrating from Next.js

[→ Get Started with Framework Mode](./framework/installation).

**Use Data Mode if you:**

*   want data features but also want to have control over bundling, data, and server abstractions
*   started a data router in v6.4 and are happy with it

[→ Get Started with Data Mode](./data/custom).

**Use Declarative Mode if you:**

*   want to use React Router as simply as possible
*   are coming from v6 and are happy with the `<BrowserRouter>`
*   have a data layer that either skips pending states (like local first, background data replication/sync) or has its own abstractions for them
*   are coming from Create React App (you may want to consider framework mode though)

[→ Get Started with Declarative Mode](./declarative/installation).

[](#api--mode-availability-table)API + Mode Availability Table
--------------------------------------------------------------

This is mostly for the LLMs, but knock yourself out:

API

Framework

Data

Declarative

Await

✅

✅

Form

✅

✅

Link

✅

✅

✅

`<Link discover>`

✅

`<Link prefetch>`

✅

`<Link preventScrollReset>`

✅

✅

Links

✅

Meta

✅

NavLink

✅

✅

✅

`<NavLink discover>`

✅

`<NavLink prefetch>`

✅

`<NavLink preventScrollReset>`

✅

✅

NavLink `isPending`

✅

✅

Navigate

✅

✅

✅

Outlet

✅

✅

✅

PrefetchPageLinks

✅

Route

✅

✅

✅

Routes

✅

✅

✅

Scripts

✅

ScrollRestoration

✅

✅

ServerRouter

✅

usePrompt

✅

✅

✅

useActionData

✅

✅

useAsyncError

✅

✅

useAsyncValue

✅

✅

useBeforeUnload

✅

✅

✅

useBlocker

✅

✅

useFetcher

✅

✅

useFetchers

✅

✅

useFormAction

✅

✅

useHref

✅

✅

✅

useInRouterContext

✅

✅

✅

useLinkClickHandler

✅

✅

✅

useLoaderData

✅

✅

useLocation

✅

✅

✅

useMatch

✅

✅

✅

useMatches

✅

✅

useNavigate

✅

✅

✅

useNavigation

✅

✅

useNavigationType

✅

✅

✅

useOutlet

✅

✅

✅

useOutletContext

✅

✅

✅

useParams

✅

✅

✅

useResolvedPath

✅

✅

✅

useRevalidator

✅

✅

useRouteError

✅

✅

useRouteLoaderData

✅

✅

useRoutes

✅

✅

✅

useSearchParams

✅

✅

✅

useSubmit

✅

✅

useViewTransitionState

✅

✅

isCookieFunction

✅

✅

isSessionFunction

✅

✅

createCookie

✅

✅

createCookieSessionStorage

✅

✅

createMemorySessionStorage

✅

✅

createPath

✅

✅

✅

createRoutesStub

✅

✅

createSearchParams

✅

✅

✅

data

✅

✅

generatePath

✅

✅

✅

href

✅

isCookie

✅

✅

isRouteErrorResponse

✅

✅

isSession

✅

✅

matchPath

✅

✅

✅

matchRoutes

✅

✅

✅

parsePath

✅

✅

✅

redirect

✅

✅

redirectDocument

✅

✅

renderMatches

✅

✅

✅

replace

✅

✅

resolvePath

✅

✅

✅

[](#picking-a-mode)Picking a Mode
=================================

React Router is a multi-strategy router for React. There are three primary ways, or "modes", to use it in your app. Across the docs you'll see these icons indicating which mode the content is relevant to:

*   [Framework](../../start/modes "Available with Framework")
*   [Data](../../start/modes "Available with Data")
*   [Declarative](../../start/modes "Available with Declarative")

The features available in each mode are additive, so moving from Declarative to Data to Framework simply adds more features at the cost of architectural control. So pick your mode based on how much control or how much help you want from React Router.

The mode depends on which "top level" router API you're using:

**Declarative**

Declarative mode enables basic routing features like matching URLs to components, navigating around the app, and providing active states with APIs like `<Link>`, `useNavigate`, and `useLocation`.

    import { BrowserRouter } from "react-router";
    
    ReactDOM.createRoot(root).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    

**Data**

By moving route configuration outside of React rendering, Data Mode adds data loading, actions, pending states and more with APIs like `loader`, `action`, and `useFetcher`.

    import {
      createBrowserRouter,
      RouterProvider,
    } from "react-router";
    
    let router = createBrowserRouter([
      {
        path: "/",
        Component: Root,
        loader: loadRootData,
      },
    ]);
    
    ReactDOM.createRoot(root).render(
      <RouterProvider router={router} />
    );
    

**Framework**

Framework Mode wraps Data Mode with a Vite plugin to add the full React Router experience with:

*   typesafe `href`
*   typesafe Route Module API
*   intelligent code splitting
*   SPA, SSR, and static rendering strategies
*   and more

    import { index, route } from "@react-router/dev/routes";
    
    export default [
      index("./home.tsx"),
      route("products/:pid", "./product.tsx"),
    ];
    

You'll then have access to the Route Module API with typesafe params, loaderData, code splitting, SPA/SSR/SSG strategies, and more.

    import { Route } from "+./types/product.tsx";
    
    export async function loader({ params }: Route.LoaderArgs) {
      let product = await getProduct(params.pid);
      return { product };
    }
    
    export default function Product({
      loaderData,
    }: Route.ComponentProps) {
      return <div>{loaderData.product.name}</div>;
    }
    

[](#decision-advice)Decision Advice
-----------------------------------

Every mode supports any architecture and deployment target, so the question isn't really about if you want SSR, SPA, etc. It's about how much you want to do yourself.

**Use Framework Mode if you:**

*   are too new to have an opinion
*   are considering Next.js, Solid Start, SvelteKit, Astro, TanStack Start, etc. and want to compare
*   just want to build something with React
*   might want to server render, might not
*   are coming from Remix (React Router v7 is the "next version" after Remix v2)
*   are migrating from Next.js

[→ Get Started with Framework Mode](./framework/installation).

**Use Data Mode if you:**

*   want data features but also want to have control over bundling, data, and server abstractions
*   started a data router in v6.4 and are happy with it

[→ Get Started with Data Mode](./data/custom).

**Use Declarative Mode if you:**

*   want to use React Router as simply as possible
*   are coming from v6 and are happy with the `<BrowserRouter>`
*   have a data layer that either skips pending states (like local first, background data replication/sync) or has its own abstractions for them
*   are coming from Create React App (you may want to consider framework mode though)

[→ Get Started with Declarative Mode](./declarative/installation).

[](#api--mode-availability-table)API + Mode Availability Table
--------------------------------------------------------------

This is mostly for the LLMs, but knock yourself out:

API

Framework

Data

Declarative

Await

✅

✅

Form

✅

✅

Link

✅

✅

✅

`<Link discover>`

✅

`<Link prefetch>`

✅

`<Link preventScrollReset>`

✅

✅

Links

✅

Meta

✅

NavLink

✅

✅

✅

`<NavLink discover>`

✅

`<NavLink prefetch>`

✅

`<NavLink preventScrollReset>`

✅

✅

NavLink `isPending`

✅

✅

Navigate

✅

✅

✅

Outlet

✅

✅

✅

PrefetchPageLinks

✅

Route

✅

✅

✅

Routes

✅

✅

✅

Scripts

✅

ScrollRestoration

✅

✅

ServerRouter

✅

usePrompt

✅

✅

✅

useActionData

✅

✅

useAsyncError

✅

✅

useAsyncValue

✅

✅

useBeforeUnload

✅

✅

✅

useBlocker

✅

✅

useFetcher

✅

✅

useFetchers

✅

✅

useFormAction

✅

✅

useHref

✅

✅

✅

useInRouterContext

✅

✅

✅

useLinkClickHandler

✅

✅

✅

useLoaderData

✅

✅

useLocation

✅

✅

✅

useMatch

✅

✅

✅

useMatches

✅

✅

useNavigate

✅

✅

✅

useNavigation

✅

✅

useNavigationType

✅

✅

✅

useOutlet

✅

✅

✅

useOutletContext

✅

✅

✅

useParams

✅

✅

✅

useResolvedPath

✅

✅

✅

useRevalidator

✅

✅

useRouteError

✅

✅

useRouteLoaderData

✅

✅

useRoutes

✅

✅

✅

useSearchParams

✅

✅

✅

useSubmit

✅

✅

useViewTransitionState

✅

✅

isCookieFunction

✅

✅

isSessionFunction

✅

✅

createCookie

✅

✅

createCookieSessionStorage

✅

✅

createMemorySessionStorage

✅

✅

createPath

✅

✅

✅

createRoutesStub

✅

✅

createSearchParams

✅

✅

✅

data

✅

✅

generatePath

✅

✅

✅

href

✅

isCookie

✅

✅

isRouteErrorResponse

✅

✅

isSession

✅

✅

matchPath

✅

✅

✅

matchRoutes

✅

✅

✅

parsePath

✅

✅

✅

redirect

✅

✅

redirectDocument

✅

✅

renderMatches

✅

✅

✅

replace

✅

✅

resolvePath

✅

✅

✅

react\_router.html is not found or the page is under construction.

[](#upgrading-from-v6)Upgrading from v6
=======================================

React Router v7 requires the following minimum versions:

*   `node@20`
*   `react@18`
*   `react-dom@18`

The v7 upgrade has no breaking changes if you have enabled all future flags. These flags allow you to update your app one change at a time. We highly recommend you make a commit after each step and ship it instead of doing everything all at once.

[](#update-to-latest-v6x)Update to latest v6.x
----------------------------------------------

First update to the latest minor version of v6.x to have the latest future flags and console warnings.

👉 **Update to latest v6**

    npm install react-router-dom@6
    

### [](#v7_relativesplatpath)v7\_relativeSplatPath

**Background**

Changes the relative path matching and linking for multi-segment splats paths like `dashboard/*` (vs. just `*`). [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#futurev7_relativesplatpath) for more information.

👉 **Enable the flag**

Enabling the flag depends on the type of router:

    <BrowserRouter
      future={{
        v7_relativeSplatPath: true,
      }}
    />
    

    createBrowserRouter(routes, {
      future: {
        v7_relativeSplatPath: true,
      },
    });
    

**Update your Code**

If you have any routes with a path + a splat like `<Route path="dashboard/*">` that have relative links like `<Link to="relative">` or `<Link to="../relative">` beneath them, you will need to update your code.

👉 **Split the `<Route>` into two**

Split any multi-segment splat `<Route>` into a parent route with the path and a child route with the splat:

    <Routes>
      <Route path="/" element={<Home />} />
    -  <Route path="dashboard/*" element={<Dashboard />} />
    +  <Route path="dashboard">
    +    <Route path="*" element={<Dashboard />} />
    +  </Route>
    </Routes>
    
    // or
    createBrowserRouter([
      { path: "/", element: <Home /> },
      {
    -    path: "dashboard/*",
    -    element: <Dashboard />,
    +    path: "dashboard",
    +    children: [{ path: "*", element: <Dashboard /> }],
      },
    ]);
    

👉 **Update relative links**

Update any `<Link>` elements within that route tree to include the extra `..` relative segment to continue linking to the same place:

    function Dashboard() {
      return (
        <div>
          <h2>Dashboard</h2>
          <nav>
    -        <Link to="/">Dashboard Home</Link>
    -        <Link to="team">Team</Link>
    -        <Link to="projects">Projects</Link>
    +        <Link to="../">Dashboard Home</Link>
    +        <Link to="../team">Team</Link>
    +        <Link to="../projects">Projects</Link>
          </nav>
    
          <Routes>
            <Route path="/" element={<DashboardHome />} />
            <Route path="team" element={<DashboardTeam />} />
            <Route
              path="projects"
              element={<DashboardProjects />}
            />
          </Routes>
        </div>
      );
    }
    

### [](#v7_starttransition)v7\_startTransition

**Background**

This uses `React.useTransition` instead of `React.useState` for Router state updates. View the [CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#futurev7_starttransition) for more information.

👉 **Enable the flag**

    <BrowserRouter
      future={{
        v7_startTransition: true,
      }}
    />
    
    // or
    <RouterProvider
      future={{
        v7_startTransition: true,
      }}
    />
    

👉 **Update your Code**

You don't need to update anything unless you are using `React.lazy` _inside_ of a component.

Using `React.lazy` inside of a component is incompatible with `React.useTransition` (or other code that makes promises inside of components). Move `React.lazy` to the module scope and stop making promises inside of components. This is not a limitation of React Router but rather incorrect usage of React.

### [](#v7_fetcherpersist)v7\_fetcherPersist

If you are not using a `<RouterProvider>` you can skip this

**Background**

The fetcher lifecycle is now based on when it returns to an idle state rather than when its owner component unmounts: [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#persistence-future-flag-futurev7_fetcherpersist) for more information.

**Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_fetcherPersist: true,
      },
    });
    

**Update your Code**

It's unlikely to affect your app. You may want to check any usage of `useFetchers` as they may persist longer than they did before. Depending on what you're doing, you may render something longer than before.

### [](#v7_normalizeformmethod)v7\_normalizeFormMethod

If you are not using a `<RouterProvider>` you can skip this

This normalizes `formMethod` fields as uppercase HTTP methods to align with the `fetch()` behavior. [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#futurev7_normalizeformmethod) for more information.

👉 **Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_normalizeFormMethod: true,
      },
    });
    

**Update your Code**

If any of your code is checking for lowercase HTTP methods, you will need to update it to check for uppercase HTTP methods (or call `toLowerCase()` on it).

👉 **Compare `formMethod` to UPPERCASE**

    -useNavigation().formMethod === "post"
    -useFetcher().formMethod === "get";
    +useNavigation().formMethod === "POST"
    +useFetcher().formMethod === "GET";
    

### [](#v7_partialhydration)v7\_partialHydration

If you are not using a `<RouterProvider>` you can skip this

This enables partial hydration of a data router which is primarily used for SSR frameworks, but it is also useful if you are using `lazy` to load your route modules. It's unlikely you need to worry about this, just turn the flag on. [View the CHANGELOG](https://github.com/remix-run/react-router/blob/main/CHANGELOG.md#partial-hydration) for more information.

👉 **Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_partialHydration: true,
      },
    });
    

**Update your Code**

With partial hydration, you need to provide a `HydrateFallback` component to render during initial hydration. Additionally, if you were using `fallbackElement` before, you need to remove it as it is now deprecated. In most cases, you will want to reuse the `fallbackElement` as the `HydrateFallback`.

👉 **Replace `fallbackElement` with `HydrateFallback`**

    const router = createBrowserRouter(
      [
        {
          path: "/",
          Component: Layout,
    +      HydrateFallback: Fallback,
          // or
    +      hydrateFallbackElement: <Fallback />,
          children: [],
        },
      ],
    );
    
    
    <RouterProvider
      router={router}
    -  fallbackElement={<Fallback />}
    />
    

### [](#v7_skipactionerrorrevalidation)v7\_skipActionErrorRevalidation

If you are not using a `createBrowserRouter` you can skip this

When this flag is enabled, loaders will no longer revalidate by default after an action throws/returns a `Response` with a `4xx`/`5xx` status code. You may opt-into revalidation in these scenarios via `shouldRevalidate` and the `actionStatus` parameter.

👉 **Enable the Flag**

    createBrowserRouter(routes, {
      future: {
        v7_skipActionErrorRevalidation: true,
      },
    });
    

**Update your Code**

In most cases, you probably won't have to make changes to your app code. Usually, if an action errors, it's unlikely data was mutated and needs revalidation. If any of your code _does_ mutate data in action error scenarios you have 2 options:

👉 **Option 1: Change the `action` to avoid mutations in error scenarios**

    // Before
    async function action() {
      await mutateSomeData();
      if (detectError()) {
        throw new Response(error, { status: 400 });
      }
      await mutateOtherData();
      // ...
    }
    
    // After
    async function action() {
      if (detectError()) {
        throw new Response(error, { status: 400 });
      }
      // All data is now mutated after validations
      await mutateSomeData();
      await mutateOtherData();
      // ...
    }
    

👉 **Option 2: Opt-into revalidation via `shouldRevalidate` and `actionStatus`**

    async function action() {
      await mutateSomeData();
      if (detectError()) {
        throw new Response(error, { status: 400 });
      }
      await mutateOtherData();
    }
    
    async function loader() { ... }
    
    function shouldRevalidate({ actionStatus, defaultShouldRevalidate }) {
      if (actionStatus != null && actionStatus >= 400) {
        // Revalidate this loader when actions return a 4xx/5xx status
        return true;
      }
      return defaultShouldRevalidate;
    }
    

[](#deprecations)Deprecations
-----------------------------

The `json` and `defer` methods are deprecated in favor of returning raw objects.

    async function loader() {
    - return json({ data });
    + return { data };
    

If you were using `json` to serialize your data to JSON, you can use the native [Response.json()](https://developer.mozilla.org/en-US/docs/Web/API/Response/json) method instead.

[](#upgrade-to-v7)Upgrade to v7
-------------------------------

Now that your app is caught up, you can simply update to v7 (theoretically!) without issue.

👉 **Install v7**

    npm install react-router-dom@latest
    

👉 **Replace react-router-dom with react-router**

In v7 we no longer need `"react-router-dom"` as the packages have been simplified. You can import everything from `"react-router"`:

    npm uninstall react-router-dom
    npm install react-router@latest
    

Note you only need `"react-router"` in your package.json.

👉 **Update imports**

Now you should update your imports to use `react-router`:

    -import { useLocation } from "react-router-dom";
    +import { useLocation } from "react-router";
    

Instead of manually updating imports, you can use this command. Make sure your git working tree is clean though so you can revert if it doesn't work as expected.

    find ./path/to/src \( -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.jsx" \) -type f -exec sed -i '' 's|from "react-router-dom"|from "react-router"|g' {} +
    

If you have GNU `sed` installed (most Linux distributions), use this command instead:

    find ./path/to/src \( -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.jsx" \) -type f -exec sed -i 's|from "react-router-dom"|from "react-router"|g' {} +
    

👉 **Update DOM-specific imports**

`RouterProvider` and `HydratedRouter` come from a deep import because they depend on `"react-dom"`:

    -import { RouterProvider } from "react-router-dom";
    +import { RouterProvider } from "react-router/dom";
    

Note you should use a top-level import for non-DOM contexts, such as Jest tests:

    -import { RouterProvider } from "react-router-dom";
    +import { RouterProvider } from "react-router";
    

Congratulations, you're now on v7!

[](#upgrading-from-remix)Upgrading from Remix
=============================================

React Router v7 requires the following minimum versions:

*   `node@20`
*   `react@18`
*   `react-dom@18`

React Router v7 is the next major version of Remix after v2 (see our ["Incremental Path to React 19" blog post](https://remix.run/blog/incremental-path-to-react-19) for more information).

If you have enabled all [Remix v2 future flags](https://remix.run/docs/start/future-flags), upgrading from Remix v2 to React Router v7 mainly involves updating dependencies.

The majority of steps 2-8 can be automatically updated using a [codemod](https://codemod.com/registry/remix-2-react-router-upgrade) created by community member [James Restall](https://github.com/jrestall).

[](#1-adopt-future-flags)1\. Adopt future flags
-----------------------------------------------

**👉 Adopt future flags**

Adopt all existing [future flags](https://remix.run/docs/start/future-flags) in your Remix v2 application.

[](#2-update-dependencies)2\. Update dependencies
-------------------------------------------------

Most of the "shared" APIs that used to be re-exported through the runtime-specific packages (`@remix-run/node`, `@remix-run/cloudflare`, etc.) have all been collapsed into `react-router` in v7. So instead of importing from `@react-router/node` or `@react-router/cloudflare`, you'll import those directly from `react-router`.

    -import { redirect } from "@remix-run/node";
    +import { redirect } from "react-router";
    

The only APIs you should be importing from the runtime-specific packages in v7 are APIs that are specific to that runtime, such as `createFileSessionStorage` for Node and `createWorkersKVSessionStorage` for Cloudflare.

**👉 Run the codemod (automated)**

You can automatically update your packages and imports with the following [codemod](https://codemod.com/registry/remix-2-react-router-upgrade). This codemod updates all of your packages and imports. Be sure to commit any pending changes before running the codemod, in case you need to revert.

    npx codemod remix/2/react-router/upgrade
    

**👉 Install the new dependencies**

After the codemod updates your dependencies, you need to install the dependencies to remove Remix packages and add the new React Router packages.

    npm install
    

**👉 Update your dependencies (manual)**

If you prefer not to use the codemod, you can manually update your dependencies.

Expand to see a table of package name changes in alphabetical order

Remix v2 Package

React Router v7 Package

`@remix-run/architect`

➡️

`@react-router/architect`

`@remix-run/cloudflare`

➡️

`@react-router/cloudflare`

`@remix-run/dev`

➡️

`@react-router/dev`

`@remix-run/express`

➡️

`@react-router/express`

`@remix-run/fs-routes`

➡️

`@react-router/fs-routes`

`@remix-run/node`

➡️

`@react-router/node`

`@remix-run/react`

➡️

`react-router`

`@remix-run/route-config`

➡️

`@react-router/dev`

`@remix-run/routes-option-adapter`

➡️

`@react-router/remix-routes-option-adapter`

`@remix-run/serve`

➡️

`@react-router/serve`

`@remix-run/server-runtime`

➡️

`react-router`

`@remix-run/testing`

➡️

`react-router`

[](#3-change-scripts-in-packagejson)3\. Change `scripts` in `package.json`
--------------------------------------------------------------------------

If you used the codemod you can skip this step as it was automatically completed.

**👉 Update the scripts in your `package.json`**

Script

Remix v2

React Router v7

`dev`

`remix vite:dev`

➡️

`react-router dev`

`build`

`remix vite:build`

➡️

`react-router build`

`start`

`remix-serve build/server/index.js`

➡️

`react-router-serve build/server/index.js`

`typecheck`

`tsc`

➡️

`react-router typegen && tsc`

[](#4-add-a-routests-file)4\. Add a `routes.ts` file
----------------------------------------------------

If you used the codemod _and_ Remix v2 `v3_routeConfig` flag, you can skip this step as it was automatically completed.

In React Router v7 you define your routes using the `app/routes.ts` file. View the [routing documentation](../start/framework/routing) for more information.

**👉 Update dependencies (if using Remix v2 `v3_routeConfig` flag)**

    // app/routes.ts
    -import { type RouteConfig } from "@remix-run/route-config";
    -import { flatRoutes } from "@remix-run/fs-routes";
    -import { remixRoutesOptionAdapter } from "@remix-run/routes-option-adapter";
    +import { type RouteConfig } from "@react-router/dev/routes";
    +import { flatRoutes } from "@react-router/fs-routes";
    +import { remixRoutesOptionAdapter } from "@react-router/remix-routes-option-adapter";
    
    export default [
      // however your routes are defined
    ] satisfies RouteConfig;
    
    

**👉 Add a `routes.ts` file (if _not_ using Remix v2 `v3_routeConfig` flag)**

    touch app/routes.ts
    

For backwards-compatibility and for folks who prefer [file-based conventions](../how-to/file-route-conventions), you can opt-into the same "flat routes" convention you are using in Remix v2 via the new `@react-router/fs-routes` package:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { flatRoutes } from "@react-router/fs-routes";
    
    export default flatRoutes() satisfies RouteConfig;
    

Or, if you were using the `routes` option to define config-based routes:

    import { type RouteConfig } from "@react-router/dev/routes";
    import { remixRoutesOptionAdapter } from "@react-router/remix-routes-option-adapter";
    
    export default remixRoutesOptionAdapter((defineRoutes) => {
      return defineRoutes((route) => {
        route("/", "home/route.tsx", { index: true });
        route("about", "about/route.tsx");
        route("", "concerts/layout.tsx", () => {
          route("trending", "concerts/trending.tsx");
          route(":city", "concerts/city.tsx");
        });
      });
    }) satisfies RouteConfig;
    

If you were using the `routes` option in your `vite.config.ts`, be sure to remove it.

    export default defineConfig({
      plugins: [
        remix({
          ssr: true,
    -     ignoredRouteFiles: ['**/*'],
    -     routes(defineRoutes) {
    -       return defineRoutes((route) => {
    -         route("/somewhere/cool/*", "catchall.tsx");
    -       });
    -     },
        })
        tsconfigPaths(),
      ],
    });
    

[](#5-add-a-react-router-config)5\. Add a React Router config
-------------------------------------------------------------

**👉 Add `react-router.config.ts` your project**

The config that was previously passed to the `remix` plugin in `vite.config.ts` is now exported from `react-router.config.ts`.

Note: At this point you should remove the v3 future flags you added in step 1.

    touch react-router.config.ts
    

    // vite.config.ts
    export default defineConfig({
      plugins: [
    -   remix({
    -     ssr: true,
    -     future: {/* all the v3 flags */}
    -   }),
    +   reactRouter(),
        tsconfigPaths(),
      ],
    });
    
    // react-router.config.ts
    +import type { Config } from "@react-router/dev/config";
    +export default {
    +  ssr: true,
    +} satisfies Config;
    

[](#6-add-react-router-plugin-to-viteconfig)6\. Add React Router plugin to `vite.config`
----------------------------------------------------------------------------------------

If you used the codemod you can skip this step as it was automatically completed.

**👉 Add `reactRouter` plugin to `vite.config`**

Change `vite.config.ts` to import and use the new `reactRouter` plugin from `@react-router/dev/vite`:

    -import { vitePlugin as remix } from "@remix-run/dev";
    +import { reactRouter } from "@react-router/dev/vite";
    import { defineConfig } from "vite";
    import tsconfigPaths from "vite-tsconfig-paths";
    
    export default defineConfig({
      plugins: [
    -   remix(),
    +   reactRouter(),
        tsconfigPaths(),
      ],
    });
    

[](#7-enable-type-safety)7\. Enable type safety
-----------------------------------------------

If you are not using TypeScript, you can skip this step.

React Router automatically generates types for your route modules into a `.react-router/` directory at the root of your app. This directory is fully managed by React Router and should be gitignore'd. Learn more about the [new type safety features](../explanation/type-safety).

**👉 Add `.react-router/` to `.gitignore`**

    .react-router/
    

**👉 Update `tsconfig.json`**

Update the `types` field in your `tsconfig.json` to include:

*   `.react-router/types/**/*` path in the `include` field
*   The appropriate `@react-router/*` package in the `types` field
*   `rootDirs` for simplified relative imports

    {
      "include": [
        /* ... */
    +   ".react-router/types/**/*"
      ],
      "compilerOptions": {
    -   "types": ["@remix-run/node", "vite/client"],
    +   "types": ["@react-router/node", "vite/client"],
        /* ... */
    +   "rootDirs": [".", "./.react-router/types"]
      }
    }
    

[](#8-rename-components-in-entry-files)8\. Rename components in entry files
---------------------------------------------------------------------------

If you used the codemod you can skip this step as it was automatically completed.

If you have an `entry.server.tsx` and/or an `entry.client.tsx` file in your application, you will need to update the main components in these files:

    -import { RemixServer } from "@remix-run/react";
    +import { ServerRouter } from "react-router";
    
    -<RemixServer context={remixContext} url={request.url} />,
    +<ServerRouter context={remixContext} url={request.url} />,
    

    -import { RemixBrowser } from "@remix-run/react";
    +import { HydratedRouter } from "react-router/dom";
    
    hydrateRoot(
      document,
      <StrictMode>
    -   <RemixBrowser />
    +   <HydratedRouter />
      </StrictMode>,
    );
    

[](#9-update-types-for-apploadcontext)9\. Update types for `AppLoadContext`
---------------------------------------------------------------------------

If you were using `remix-serve` you can skip this step. This is only applicable if you were using a custom server in Remix v2.

Since React Router can be used as both a React framework _and_ a stand-alone routing library, the `context` argument for `LoaderFunctionArgs` and `ActionFunctionArgs` is now optional and typed as `any` by default. You can register types for your load context to get type safety for your loaders and actions.

👉 **Register types for your load context**

Before you migrate to the new `Route.LoaderArgs` and `Route.ActionArgs` types, you can temporarily augment `LoaderFunctionArgs` and `ActionFunctionArgs` with your load context type to ease migration.

    declare module "react-router" {
      // Your AppLoadContext used in v2
      interface AppLoadContext {
        whatever: string;
      }
    
      // TODO: remove this once we've migrated to `Route.LoaderArgs` instead for our loaders
      interface LoaderFunctionArgs {
        context: AppLoadContext;
      }
    
      // TODO: remove this once we've migrated to `Route.ActionArgs` instead for our actions
      interface ActionFunctionArgs {
        context: AppLoadContext;
      }
    }
    
    export {}; // necessary for TS to treat this as a module
    

Using `declare module` to register types is a standard TypeScript technique called [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation). You can do this in any TypeScript file covered by your `tsconfig.json`'s `include` field, but we recommend a dedicated `env.ts` within your app directory.

👉 **Use the new types**

Once you adopt the [new type generation](../explanation/type-safety), you can remove the `LoaderFunctionArgs`/`ActionFunctionArgs` augmentations and use the `context` argument from [`Route.LoaderArgs`](../start/framework/data-loading#server-data-loading) and [`Route.ActionArgs`](../start/framework/actions#server-actions) instead.

    declare module "react-router" {
      // Your AppLoadContext used in v2
      interface AppLoadContext {
        whatever: string;
      }
    }
    
    export {}; // necessary for TS to treat this as a module
    

    import type { Route } from "./+types/my-route";
    
    export function loader({ context }: Route.LoaderArgs) {}
    // { whatever: string }  ^^^^^^^
    
    export function action({ context }: Route.ActionArgs) {}
    // { whatever: string }  ^^^^^^^
    

Congratulations! You are now on React Router v7. Go ahead and run your application to make sure everything is working as expected.

brand is not found or the page is under construction.