valibot version: 1.1.0, last updated: 2025-05-25T14:47:54.734Z

[](#any)any
===========

Creates an any schema.

> This schema function exists only for completeness and is not recommended in practice. Instead, [`unknown`](/api/unknown/) should be used to accept unknown data.

`const Schema = v.any();`

[](#returns)Returns
-------------------

*   `Schema` `[AnySchema](/api/AnySchema/)`

[](#related)Related
-------------------

The following APIs can be combined with `any`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#array)array
===============

Creates an array schema.

`const Schema = v.array<TItem, TMessage>(item, message);`

[](#generics)Generics
---------------------

*   `TItem` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ArrayIssue](/api/ArrayIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `item` `TItem`
*   `message` `TMessage`

### [](#explanation)Explanation

With `array` you can validate the data type of the input. If the input is not an array, you can use `message` to customize the error message.

> If your array has a fixed length, consider using [`tuple`](/api/tuple/) for a more precise typing.

[](#returns)Returns
-------------------

*   `Schema` `[ArraySchema](/api/ArraySchema/)<TItem, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `array` can be used.

### [](#string-array-schema)String array schema

Schema to validate an array of strings.

`const StringArraySchema = v.array(v.string(), 'An array is required.');`

### [](#object-array-schema)Object array schema

Schema to validate an array of objects.

`const ObjectArraySchema = v.array(v.object({ key: v.string() }));`

### [](#validate-length)Validate length

Schema that validates the length of an array.

`const ArrayLengthSchema = v.pipe(   v.array(v.number()),   v.minLength(1),   v.maxLength(3) );`

### [](#validate-content)Validate content

Schema that validates the content of an array.

`const ArrayContentSchema = v.pipe(   v.array(v.string()),   v.includes('foo'),   v.excludes('bar') );`

[](#related)Related
-------------------

The following APIs can be combined with `array`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#bigint)bigint
=================

Creates a bigint schema.

`const Schema = v.bigint<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[BigintIssue](/api/BigintIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `bigint` you can validate the data type of the input. If the input is not a bigint, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[BigintSchema](/api/BigintSchema/)<TMessage>`

[](#examples)Examples
---------------------

The following examples show how `bigint` can be used.

### [](#force-minimum)Force minimum

Schema that forces a minimum bigint value.

`const MinBigintSchema = v.pipe(v.bigint(), v.toMinValue(10n));`

### [](#validate-maximum)Validate maximum

Schema that validates a maximum bigint value.

`const MaxBigintSchema = v.pipe(v.bigint(), v.maxValue(999n));`

[](#related)Related
-------------------

The following APIs can be combined with `bigint`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`gtValue`](/api/gtValue/),
*   [`ltValue`](/api/ltValue/),
*   [`maxValue`](/api/maxValue/),
*   [`metadata`](/api/metadata/),
*   [`minValue`](/api/minValue/),
*   [`multipleOf`](/api/multipleOf/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`transform`](/api/transform/),
*   [`value`](/api/value/),
*   [`values`](/api/values/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#blob)blob
=============

Creates a blob schema.

> The `Blob` class is not available by default in Node.js v16 and below.

`const Schema = v.blob<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[BlobIssue](/api/BlobIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `blob` you can validate the data type of the input. If the input is not a blob, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[BlobSchema](/api/BlobSchema/)<TMessage>`

[](#examples)Examples
---------------------

The following examples show how `blob` can be used.

### [](#image-schema)Image schema

Schema to validate an image.

`const ImageSchema = v.pipe(   v.blob('Please select an image file.'),   v.mimeType(['image/jpeg', 'image/png'], 'Please select a JPEG or PNG file.'),   v.maxSize(1024 * 1024 * 10, 'Please select a file smaller than 10 MB.') );`

[](#related)Related
-------------------

The following APIs can be combined with `blob`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`maxSize`](/api/maxSize/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minSize`](/api/minSize/),
*   [`notSize`](/api/notSize/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`size`](/api/size/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#boolean)boolean
===================

Creates a boolean schema.

`const Schema = v.boolean<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[BooleanIssue](/api/BooleanIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `boolean` you can validate the data type of the input. If the input is not a boolean, you can use `message` to customize the error message.

> Instead of using a [`pipe`](/api/pipe/) to force `true` or `false` as a value, in most cases it makes more sense to use [`literal`](/api/literal/) for better typing.

[](#returns)Returns
-------------------

*   `Schema` `[BooleanSchema](/api/BooleanSchema/)<TMessage>`

[](#examples)Examples
---------------------

The following examples show how `boolean` can be used.

### [](#custom-message)Custom message

Boolean schema with a custom error message.

`const BooleanSchema = v.boolean('A boolean is required');`

[](#related)Related
-------------------

The following APIs can be combined with `boolean`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`gtValue`](/api/gtValue/),
*   [`ltValue`](/api/ltValue/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`minValue`](/api/minValue/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`transform`](/api/transform/),
*   [`value`](/api/value/),
*   [`values`](/api/values/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#custom)custom
=================

Creates a custom schema.

> This schema function allows you to define a schema that matches a value based on a custom function. Use it whenever you need to define a schema that cannot be expressed using any of the other schema functions.

`const Schema = v.custom<TInput, TMessage>(check, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CustomIssue](/api/CustomIssue/)> | undefined = [ErrorMessage](/api/ErrorMessage/)<[CustomIssue](/api/CustomIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `check` `(input: unknown) => boolean`
*   `message` `TMessage`

### [](#explanation)Explanation

With `custom` you can validate the data type of the input. If the input does not match the validation of `check`, you can use `message` to customize the error message.

> Make sure that the validation in `check` matches the data type of `TInput`.

[](#returns)Returns
-------------------

*   `Schema` `[CustomSchema](/api/CustomSchema/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `custom` can be used.

### [](#pixel-string-schema)Pixel string schema

Schema to validate a pixel string.

``const PixelStringSchema = v.custom<`${number}px`>((input) =>   typeof input === 'string' ? /^\d+px$/.test(input) : false );``

[](#related)Related
-------------------

The following APIs can be combined with `custom`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#date)date
=============

Creates a date schema.

`const Schema = v.date<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[DateIssue](/api/DateIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `date` you can validate the data type of the input. If the input is not a date, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[DateSchema](/api/DateSchema/)<TMessage>`

[](#examples)Examples
---------------------

The following examples show how `date` can be used.

### [](#force-minimum)Force minimum

Schema that forces a minimum date of today.

`const MinDateSchema = v.pipe(v.date(), v.toMinValue(new Date()));`

### [](#validate-range)Validate range

Schema that validates a date in a range.

`const DateRangeSchema = v.pipe(   v.date(),   v.minValue(new Date(2019, 0, 1)),   v.maxValue(new Date(2020, 0, 1)) );`

[](#related)Related
-------------------

The following APIs can be combined with `date`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`gtValue`](/api/gtValue/),
*   [`ltValue`](/api/ltValue/),
*   [`maxValue`](/api/maxValue/),
*   [`metadata`](/api/metadata/),
*   [`minValue`](/api/minValue/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`transform`](/api/transform/),
*   [`value`](/api/value/),
*   [`values`](/api/values/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#enum)enum
=============

Creates an enum schema.

`const Schema = v.enum<TEnum, TMessage>(enum, message);`

[](#generics)Generics
---------------------

*   `TEnum` `extends [Enum](/api/Enum/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EnumIssue](/api/EnumIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `enum` `TEnum`
*   `message` `TMessage`

### [](#explanation)Explanation

With `enum` you can validate that the input corresponds to an enum option. If the input is invalid, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[EnumSchema](/api/EnumSchema/)<TEnum, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `enum` can be used.

### [](#direction-enum)Direction enum

Schema to validate a direction enum option.

`enum Direction {   Left,   Right, }  const DirectionSchema = v.enum(Direction, 'Invalid direction');`

[](#related)Related
-------------------

The following APIs can be combined with `enum`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#exactoptional)exactOptional
===============================

Creates an exact optional schema.

`const Schema = v.exactOptional<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, never>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `exactOptional` the validation of your schema will pass missing object entries, and if you specify a `default_` input value, the schema will use it if the object entry is missing. For this reason, the output type may differ from the input type of the schema.

> The difference to [`optional`](/api/optional/) is that this schema function follows the implementation of TypeScript's [`exactOptionalPropertyTypes` configuration](https://www.typescriptlang.org/tsconfig/#exactOptionalPropertyTypes) and only allows missing but not undefined object entries.

[](#returns)Returns
-------------------

*   `Schema` `[ExactOptionalSchema](/api/ExactOptionalSchema/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `exactOptional` can be used.

### [](#exact-optional-object-entries)Exact optional object entries

Object schema with exact optional entries.

> By using a function as the `default_` parameter, the schema will return a new [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) instance each time the input is `undefined`.

`const OptionalEntrySchema = v.object({   key1: v.exactOptional(v.string()),   key2: v.exactOptional(v.string(), "I'm the default!"),   key3: v.exactOptional(v.date(), () => new Date()), });`

### [](#unwrap-exact-optional-schema)Unwrap exact optional schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `exactOptional`.

`const OptionalNumberSchema = v.exactOptional(v.number()); const NumberSchema = v.unwrap(OptionalNumberSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `exactOptional`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#file)file
=============

Creates a file schema.

> The `File` class is not available by default in Node.js v18 and below.

`const Schema = v.file<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[FileIssue](/api/FileIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `file` you can validate the data type of the input. If the input is not a file, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[FileSchema](/api/FileSchema/)<TMessage>`

[](#examples)Examples
---------------------

The following examples show how `file` can be used.

### [](#image-schema)Image schema

Schema to validate an image.

`const ImageSchema = v.pipe(   v.file('Please select an image file.'),   v.mimeType(['image/jpeg', 'image/png'], 'Please select a JPEG or PNG file.'),   v.maxSize(1024 * 1024 * 10, 'Please select a file smaller than 10 MB.') );`

[](#related)Related
-------------------

The following APIs can be combined with `file`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`maxSize`](/api/maxSize/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minSize`](/api/minSize/),
*   [`notSize`](/api/notSize/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`size`](/api/size/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#function)function
=====================

Creates a function schema.

`const Schema = v.function<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[FunctionIssue](/api/FunctionIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `function` you can validate the data type of the input. If the input is not a function, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[FunctionSchema](/api/FunctionSchema/)<TMessage>`

[](#related)Related
-------------------

The following APIs can be combined with `function`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#instance)instance
=====================

Creates an instance schema.

`const Schema = v.instance<TClass, TMessage>(class_, message);`

[](#generics)Generics
---------------------

*   `TClass` `extends [Class](/api/Class/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[InstanceIssue](/api/InstanceIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `class_` `TClass`
*   `message` `TMessage`

### [](#explanation)Explanation

With `instance` you can validate the data type of the input. If the input is not an instance of the specified `class_`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[InstanceSchema](/api/InstanceSchema/)<TClass, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `instance` can be used.

### [](#error-schema)Error schema

Schema to validate an `Error` instance.

`const ErrorSchema = v.instance(Error, 'Error instance required.');`

### [](#file-schema)File schema

Schema to validate an `File` instance.

`const FileSchema = v.pipe(   v.instance(File),   v.mimeType(['image/jpeg', 'image/png']),   v.maxSize(1024 * 1024 * 10) );`

[](#related)Related
-------------------

The following APIs can be combined with `instance`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`gtValue`](/api/gtValue/),
*   [`ltValue`](/api/ltValue/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`size`](/api/size/),
*   [`title`](/api/title/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`transform`](/api/transform/),
*   [`value`](/api/value/),
*   [`values`](/api/values/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#intersect)intersect
=======================

Creates an intersect schema.

> I recommend to read the [intersections guide](/guides/intersections/) before using this schema function.

`const Schema = v.intersect<TOptions, TMessage>(options, message);`

[](#generics)Generics
---------------------

*   `TOptions` `extends [IntersectOptions](/api/IntersectOptions/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IntersectIssue](/api/IntersectIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `options` `TOptions`
*   `message` `TMessage`

### [](#explanation)Explanation

With `intersect` you can validate if the input matches each of the given `options`. If the output of the intersection cannot be successfully merged, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[IntersectSchema](/api/IntersectSchema/)<TOptions, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `intersect` can be used.

### [](#object-intersection)Object intersection

Schema that combines two object schemas.

`const ObjectSchema = v.intersect([   v.object({ foo: v.string() }),   v.object({ bar: v.number() }), ]);`

[](#related)Related
-------------------

The following APIs can be combined with `intersect`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#lazy)lazy
=============

Creates a lazy schema.

`const Schema = v.lazy<TWrapped>(getter);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `getter` `(input: unknown) => TWrapped`

### [](#explanation)Explanation

The `getter` function is called lazily to retrieve the schema. This is necessary to be able to access the input through the first argument of the `getter` function and to avoid a circular dependency for recursive schemas.

> Due to a TypeScript limitation, the input and output types of recursive schemas cannot be inferred automatically. Therefore, you must explicitly specify these types using [`GenericSchema`](/api/GenericSchema/). Please see the examples below.

[](#returns)Returns
-------------------

*   `Schema` `[LazySchema](/api/LazySchema/)<TWrapped>`

[](#examples)Examples
---------------------

The following examples show how `lazy` can be used.

### [](#binary-tree-schema)Binary tree schema

Recursive schema to validate a binary tree.

`type BinaryTree = {   element: string;   left: BinaryTree | null;   right: BinaryTree | null; };  const BinaryTreeSchema: v.GenericSchema<BinaryTree> = v.object({   element: v.string(),   left: v.nullable(v.lazy(() => BinaryTreeSchema)),   right: v.nullable(v.lazy(() => BinaryTreeSchema)), });`

### [](#json-data-schema)JSON data schema

Schema to validate all possible `JSON` values.

`import * as v from 'valibot';  type JsonData =   | string   | number   | boolean   | null   | { [key: string]: JsonData }   | JsonData[];  const JsonSchema: v.GenericSchema<JsonData> = v.lazy(() =>   v.union([     v.string(),     v.number(),     v.boolean(),     v.null(),     v.record(v.string(), JsonSchema),     v.array(JsonSchema),   ]) );`

### [](#lazy-union-schema)Lazy union schema

Schema to validate a discriminated union of objects.

> In most cases, [`union`](/api/union/) and [`variant`](/api/variant/) are the better choices for creating such a schema. I recommend using `lazy` only in special cases.

`const LazyUnionSchema = v.lazy((input) => {   if (input && typeof input === 'object' && 'type' in input) {     switch (input.type) {       case 'email':         return v.object({           type: v.literal('email'),           email: v.pipe(v.string(), v.email()),         });       case 'url':         return v.object({           type: v.literal('url'),           url: v.pipe(v.string(), v.url()),         });       case 'date':         return v.object({           type: v.literal('date'),           date: v.pipe(v.string(), v.isoDate()),         });     }   }   return v.never(); });`

[](#related)Related
-------------------

The following APIs can be combined with `lazy`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`undefined`](/api/undefined/),
*   [`union`](/api/union/),
*   [`unionWithRest`](/api/unionWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#literal)literal
===================

Creates a literal schema.

`const Schema = v.literal<TLiteral, TMessage>(literal, message);`

[](#generics)Generics
---------------------

*   `TLiteral` `extends [Literal](/api/Literal/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LiteralIssue](/api/LiteralIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `literal` `TLiteral`
*   `message` `TMessage`

### [](#explanation)Explanation

With `literal` you can validate that the input matches a specified value. If the input is invalid, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[LiteralSchema](/api/LiteralSchema/)<TLiteral, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `literal` can be used.

### [](#string-literal)String literal

Schema to validate a string literal.

`const StringLiteralSchema = v.literal('foo');`

### [](#number-literal)Number literal

Schema to validate a number literal.

`const NumberLiteralSchema = v.literal(26);`

### [](#boolean-literal)Boolean literal

Schema to validate a boolean literal.

`const BooleanLiteralSchema = v.literal(true);`

[](#related)Related
-------------------

The following APIs can be combined with `literal`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#looseobject)looseObject
===========================

Creates a loose object schema.

`const Schema = v.looseObject<TEntries, TMessage>(entries, message);`

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntries](/api/ObjectEntries/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LooseObjectIssue](/api/LooseObjectIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `entries` `TEntries`
*   `message` `TMessage`

### [](#explanation)Explanation

With `looseObject` you can validate the data type of the input and whether the content matches `entries`. If the input is not an object, you can use `message` to customize the error message.

> The difference to [`object`](/api/object/) is that this schema includes any unknown entries in the output. In addition, this schema filters certain entries from the unknown entries for security reasons.

[](#returns)Returns
-------------------

*   `Schema` `[LooseObjectSchema](/api/LooseObjectSchema/)<TEntries, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `looseObject` can be used. Please see the [object guide](/guides/objects/) for more examples and explanations.

### [](#simple-object-schema)Simple object schema

Schema to validate a loose object with two specific keys.

`const SimpleObjectSchema = v.looseObject({   key1: v.string(),   key2: v.number(), });`

### [](#merge-several-objects)Merge several objects

Schema that merges the entries of two object schemas.

`const MergedObjectSchema = v.looseObject({   ...ObjectSchema1.entries,   ...ObjectSchema2.entries, });`

### [](#mark-keys-as-optional)Mark keys as optional

Schema to validate an object with partial entries.

`const PartialObjectSchema = v.partial(   v.looseObject({     key1: v.string(),     key2: v.number(),   }) );`

### [](#object-with-selected-entries)Object with selected entries

Schema to validate only selected entries of a loose object.

`const PickObjectSchema = v.pick(   v.looseObject({     key1: v.string(),     key2: v.number(),     key3: v.boolean(),   }),   ['key1', 'key3'] );`

[](#related)Related
-------------------

The following APIs can be combined with `looseObject`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#loosetuple)looseTuple
=========================

Creates a loose tuple schema.

`const Schema = v.looseTuple<TItems, TMessage>(items, message);`

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItems](/api/TupleItems/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `items` `TItems`
*   `message` `TMessage`

### [](#explanation)Explanation

With `looseTuple` you can validate the data type of the input and whether the content matches `items`. If the input is not an array, you can use `message` to customize the error message.

> The difference to [`tuple`](/api/tuple/) is that this schema does include unknown items into the output.

[](#returns)Returns
-------------------

*   `Schema` `[LooseTupleSchema](/api/LooseTupleSchema/)<TItems, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `looseTuple` can be used. Please see the [arrays guide](/guides/arrays/) for more examples and explanations.

### [](#simple-tuple-schema)Simple tuple schema

Schema to validate a loose tuple with two specific items.

`const SimpleTupleSchema = v.looseTuple([v.string(), v.number()]);`

[](#related)Related
-------------------

The following APIs can be combined with `looseTuple`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#map)map
===========

Creates a map schema.

`const Schema = v.map<TKey, TValue, TMessage>(key, value, message);`

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MapIssue](/api/MapIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `key` `TKey`
*   `value` `TValue`
*   `message` `TMessage`

### [](#explanation)Explanation

With `map` you can validate the data type of the input and whether the entries matches `key` and `value`. If the input is not a map, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[MapSchema](/api/MapSchema/)<TKey, TValue, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `map` can be used.

### [](#string-map-schema)String map schema

Schema to validate a map with string values.

`const StringMapSchema = v.map(v.string(), v.string());`

### [](#object-map-schema)Object map schema

Schema to validate a map with object values.

`const ObjectMapSchema = v.map(v.string(), v.object({ key: v.string() }));`

[](#related)Related
-------------------

The following APIs can be combined with `map`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`maxSize`](/api/maxSize/),
*   [`metadata`](/api/metadata/),
*   [`minSize`](/api/minSize/),
*   [`notSize`](/api/notSize/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`size`](/api/size/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#nan)nan
===========

Creates a NaN schema.

`const Schema = v.nan<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NanIssue](/api/NanIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `nan` you can validate the data type of the input and if it is not `NaN`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NanSchema](/api/NanSchema/)<TMessage>`

[](#related)Related
-------------------

The following APIs can be combined with `nan`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#never)never
===============

Creates a never schema.

`const Schema = v.never<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NeverIssue](/api/NeverIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

When validated, `never` always returns an issue. You can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NeverSchema](/api/NeverSchema/)<TMessage>`

[](#related)Related
-------------------

The following APIs can be combined with `never`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#nonnullable)nonNullable
===========================

Creates a non nullable schema.

> This schema function can be used to override the behavior of [`nullable`](/api/nullable/).

`const Schema = v.nonNullable<TWrapped, TMessage>(wrapped, message);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonNullableIssue](/api/NonNullableIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `message` `TMessage`

### [](#explanation)Explanation

With `nonNullable` the validation of your schema will not pass `null` inputs. If the input is `null`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NonNullableSchema](/api/NonNullableSchema/)<TWrapped, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `nonNullable` can be used.

### [](#non-nullable-string)Non nullable string

Schema that does not accept `null`.

`const NonNullableStringSchema = v.nonNullable(v.nullable(v.string()));`

### [](#unwrap-non-nullable)Unwrap non nullable

Use [`unwrap`](/api/unwrap/) to undo the effect of `nonNullable`.

`const NonNullableNumberSchema = v.nonNullable(v.nullable(v.number())); const NullableNumberSchema = v.unwrap(NonNullableNumberSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `nonNullable`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#nonnullish)nonNullish
=========================

Creates a non nullish schema.

> This schema function can be used to override the behavior of [`nullish`](/api/nullish/).

`const Schema = v.nonNullish<TWrapped, TMessage>(wrapped, message);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonNullishIssue](/api/NonNullishIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `message` `TMessage`

### [](#explanation)Explanation

With `nonNullish` the validation of your schema will not pass `null` and `undefined` inputs. If the input is `null` or `undefined`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NonNullishSchema](/api/NonNullishSchema/)<TWrapped, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `nonNullish` can be used.

### [](#non-nullish-string)Non nullish string

Schema that does not accept `null` and `undefined`.

`const NonNullishStringSchema = v.nonNullish(v.nullish(v.string()));`

### [](#unwrap-non-nullish)Unwrap non nullish

Use [`unwrap`](/api/unwrap/) to undo the effect of `nonNullish`.

`const NonNullishNumberSchema = v.nonNullish(v.nullish(v.number())); const NullishNumberSchema = v.unwrap(NonNullishNumberSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `nonNullish`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#nonoptional)nonOptional
===========================

Creates a non optional schema.

> This schema function can be used to override the behavior of [`optional`](/api/optional/).

`const Schema = v.nonOptional<TWrapped, TMessage>(wrapped, message);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonOptionalIssue](/api/NonOptionalIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `message` `TMessage`

### [](#explanation)Explanation

With `nonOptional` the validation of your schema will not pass `undefined` inputs. If the input is `undefined`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NonOptionalSchema](/api/NonOptionalSchema/)<TWrapped, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `nonOptional` can be used.

### [](#non-optional-string)Non optional string

Schema that does not accept `undefined`.

`const NonOptionalStringSchema = v.nonOptional(v.optional(v.string()));`

### [](#unwrap-non-optional)Unwrap non optional

Use [`unwrap`](/api/unwrap/) to undo the effect of `nonOptional`.

`const NonOptionalNumberSchema = v.nonOptional(v.optional(v.number())); const OptionalNumberSchema = v.unwrap(NonOptionalNumberSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `nonOptional`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#null)null
=============

Creates a null schema.

`const Schema = v.null<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NullIssue](/api/NullIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `null` you can validate the data type of the input and if it is not `null`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NullSchema](/api/NullSchema/)<TMessage>`

[](#related)Related
-------------------

The following APIs can be combined with `null`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#nullable)nullable
=====================

Creates a nullable schema.

`const Schema = v.nullable<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, null>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `nullable` the validation of your schema will pass `null` inputs, and if you specify a `default_` input value, the schema will use it if the input is `null`. For this reason, the output type may differ from the input type of the schema.

> Note that `nullable` does not accept `undefined` as an input. If you want to accept `undefined` inputs, use [`optional`](/api/optional/), and if you want to accept `null` and `undefined` inputs, use [`nullish`](/api/nullish/) instead. Also, if you want to set a default output value for any invalid input, you should use [`fallback`](/api/fallback/) instead.

[](#returns)Returns
-------------------

*   `Schema` `[NullableSchema](/api/NullableSchema/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `nullable` can be used.

### [](#nullable-string-schema)Nullable string schema

Schema that accepts `string` and `null`.

`const NullableStringSchema = v.nullable(v.string(), "I'm the default!");`

### [](#nullable-date-schema)Nullable date schema

Schema that accepts [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) and `null`.

> By using a function as the `default_` parameter, the schema will return a new [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) instance each time the input is `null`.

`const NullableDateSchema = v.nullable(v.date(), () => new Date());`

### [](#nullable-entry-schema)Nullable entry schema

Object schema with a nullable entry.

`const NullableEntrySchema = v.object({   key: v.nullable(v.string()), });`

### [](#unwrap-nullable-schema)Unwrap nullable schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `nullable`.

`const NullableNumberSchema = v.nullable(v.number()); const NumberSchema = v.unwrap(NullableNumberSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `nullable`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#nullish)nullish
===================

Creates a nullish schema.

`const Schema = v.nullish<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, null | undefined>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `nullish` the validation of your schema will pass `undefined` and `null` inputs, and if you specify a `default_` input value, the schema will use it if the input is `undefined` or `null`. For this reason, the output type may differ from the input type of the schema.

> Note that `nullish` accepts `undefined` and `null` as an input. If you want to accept only `null` inputs, use [`nullable`](/api/nullable/), and if you want to accept only `undefined` inputs, use [`optional`](/api/optional/) instead. Also, if you want to set a default output value for any invalid input, you should use [`fallback`](/api/fallback/) instead.

[](#returns)Returns
-------------------

*   `Schema` `[NullishSchema](/api/NullishSchema/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `nullish` can be used.

### [](#nullish-string-schema)Nullish string schema

Schema that accepts `string`, `undefined` and `null`.

`const NullishStringSchema = v.nullish(v.string(), "I'm the default!");`

### [](#nullish-date-schema)Nullish date schema

Schema that accepts [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date), `undefined` and `null`.

> By using a function as the `default_` parameter, the schema will return a new [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) instance each time the input is `undefined` or `null`.

`const NullishDateSchema = v.nullish(v.date(), () => new Date());`

### [](#nullish-entry-schema)Nullish entry schema

Object schema with a nullish entry.

`const NullishEntrySchema = v.object({   key: v.nullish(v.string()), });`

### [](#unwrap-nullish-schema)Unwrap nullish schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `nullish`.

`const NullishNumberSchema = v.nullish(v.number()); const NumberSchema = v.unwrap(NullishNumberSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `nullish`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#number)number
=================

Creates a number schema.

`const Schema = v.number<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NumberIssue](/api/NumberIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `number` you can validate the data type of the input. If the input is not a number, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NumberSchema](/api/NumberSchema/)<TMessage>`

[](#examples)Examples
---------------------

The following examples show how `number` can be used.

### [](#integer-schema)Integer schema

Schema to validate an integer.

`const IntegerSchema = v.pipe(v.number(), v.integer());`

### [](#force-minimum)Force minimum

Schema that forces a minimum number of 10.

`const MinNumberSchema = v.pipe(v.number(), v.toMinValue(10));`

### [](#validate-range)Validate range

Schema that validates a number in a range.

`const NumberRangeSchema = v.pipe(v.number(), v.minValue(10), v.maxValue(20));`

[](#related)Related
-------------------

The following APIs can be combined with `number`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`gtValue`](/api/gtValue/),
*   [`integer`](/api/integer/),
*   [`ltValue`](/api/ltValue/),
*   [`maxValue`](/api/maxValue/),
*   [`metadata`](/api/metadata/),
*   [`minValue`](/api/minValue/),
*   [`multipleOf`](/api/multipleOf/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`safeInteger`](/api/safeInteger/),
*   [`title`](/api/title/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`transform`](/api/transform/),
*   [`value`](/api/value/),
*   [`values`](/api/values/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#object)object
=================

Creates an object schema.

`const Schema = v.object<TEntries, TMessage>(entries, message);`

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntries](/api/ObjectEntries/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ObjectIssue](/api/ObjectIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `entries` `TEntries`
*   `message` `TMessage`

### [](#explanation)Explanation

With `object` you can validate the data type of the input and whether the content matches `entries`. If the input is not an object, you can use `message` to customize the error message.

> This schema removes unknown entries. The output will only include the entries you specify. To include unknown entries, use [`looseObject`](/api/looseObject/). To return an issue for unknown entries, use [`strictObject`](/api/strictObject/). To include and validate unknown entries, use [`objectWithRest`](/api/objectWithRest/).

[](#returns)Returns
-------------------

*   `Schema` `[ObjectSchema](/api/ObjectSchema/)<TEntries, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `object` can be used. Please see the [object guide](/guides/objects/) for more examples and explanations.

### [](#simple-object-schema)Simple object schema

Schema to validate an object with two keys.

`const SimpleObjectSchema = v.object({   key1: v.string(),   key2: v.number(), });`

### [](#merge-several-objects)Merge several objects

Schema that merges the entries of two object schemas.

`const MergedObjectSchema = v.object({   ...ObjectSchema1.entries,   ...ObjectSchema2.entries, });`

### [](#mark-keys-as-optional)Mark keys as optional

Schema to validate an object with partial entries.

`const PartialObjectSchema = v.partial(   v.object({     key1: v.string(),     key2: v.number(),   }) );`

### [](#object-with-selected-entries)Object with selected entries

Schema to validate only selected entries of an object.

`const PickObjectSchema = v.pick(   v.object({     key1: v.string(),     key2: v.number(),     key3: v.boolean(),   }),   ['key1', 'key3'] );`

[](#related)Related
-------------------

The following APIs can be combined with `object`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#objectwithrest)objectWithRest
=================================

Creates an object with rest schema.

`const Schema = v.objectWithRest<TEntries, TRest, TMessage>(   entries,   rest,   message );`

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntries](/api/ObjectEntries/)`
*   `TRest` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `entries` `TEntries`
*   `rest` `TRest`
*   `message` `TMessage`

### [](#explanation)Explanation

With `objectWithRest` you can validate the data type of the input and whether the content matches `entries` and `rest`. If the input is not an object, you can use `message` to customize the error message.

> The difference to [`object`](/api/object/) is that this schema includes unknown entries in the output. In addition, this schema filters certain entries from the unknown entries for security reasons.

[](#returns)Returns
-------------------

*   `Schema` `[ObjectWithRestSchema](/api/ObjectWithRestSchema/)<TEntries, TRest, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `objectWithRest` can be used. Please see the [object guide](/guides/objects/) for more examples and explanations.

### [](#object-schema-with-rest)Object schema with rest

Schema to validate an object with generic rest entries.

`const ObjectSchemaWithRest = v.objectWithRest(   {     key1: v.string(),     key2: v.number(),   },   v.boolean() );`

### [](#merge-several-objects)Merge several objects

Schema that merges the entries of two object schemas.

`const MergedObjectSchema = v.objectWithRest(   {     ...ObjectSchema1.entries,     ...ObjectSchema2.entries,   },   v.null() );`

### [](#mark-keys-as-optional)Mark keys as optional

Schema to validate an object with partial entries.

`const PartialObjectSchema = partial(   objectWithRest(     {       key1: string(),       key2: number(),     },     v.undefined()   ) );`

### [](#object-with-selected-entries)Object with selected entries

Schema to validate only selected entries of an object.

`const PickObjectSchema = v.pick(   v.objectWithRest(     {       key1: v.string(),       key2: v.number(),       key3: v.boolean(),     },     v.null()   ),   ['key1', 'key3'] );`

[](#related)Related
-------------------

The following APIs can be combined with `objectWithRest`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#optional)optional
=====================

Creates an optional schema.

`const Schema = v.optional<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, undefined>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `optional` the validation of your schema will pass `undefined` inputs, and if you specify a `default_` input value, the schema will use it if the input is `undefined`. For this reason, the output type may differ from the input type of the schema.

> Note that `optional` does not accept `null` as an input. If you want to accept `null` inputs, use [`nullable`](/api/nullable/), and if you want to accept `null` and `undefined` inputs, use [`nullish`](/api/nullish/) instead. Also, if you want to set a default output value for any invalid input, you should use [`fallback`](/api/fallback/) instead.

[](#returns)Returns
-------------------

*   `Schema` `[OptionalSchema](/api/OptionalSchema/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `optional` can be used.

### [](#optional-string-schema)Optional string schema

Schema that accepts `string` and `undefined`.

`const OptionalStringSchema = v.optional(v.string(), "I'm the default!");`

### [](#optional-date-schema)Optional date schema

Schema that accepts [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) and `undefined`.

> By using a function as the `default_` parameter, the schema will return a new [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) instance each time the input is `undefined`.

`const OptionalDateSchema = v.optional(v.date(), () => new Date());`

### [](#optional-entry-schema)Optional entry schema

Object schema with an optional entry.

`const OptionalEntrySchema = v.object({   key: v.optional(v.string()), });`

### [](#unwrap-optional-schema)Unwrap optional schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `optional`.

`const OptionalNumberSchema = v.optional(v.number()); const NumberSchema = v.unwrap(OptionalNumberSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `optional`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#picklist)picklist
=====================

Creates a picklist schema.

`const Schema = v.picklist<TOptions, TMessage>(options, message);`

[](#generics)Generics
---------------------

*   `TOptions` `extends [PicklistOptions](/api/PicklistOptions/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[PicklistIssue](/api/PicklistIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `options` `TOptions`
*   `message` `TMessage`

### [](#explanation)Explanation

With `picklist` you can validate that the input corresponds to a picklist option. If the input is invalid, you can use `message` to customize the error message.

> `picklist` works in a similar way to [`enum`](/api/enum/). However, in many cases it is easier to use because you can pass an array of values instead of an enum.

[](#returns)Returns
-------------------

*   `Schema` `[PicklistSchema](/api/PicklistSchema/)<TOptions, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `picklist` can be used.

### [](#language-schema)Language schema

Schema to validate programming languages.

`const LanguageSchema = v.picklist(['JavaScript', 'TypeScript']);`

### [](#country-schema)Country schema

Schema to validate country codes.

`const countries = [   { name: 'Germany', code: 'DE' },   { name: 'France', code: 'FR' },   { name: 'United States', code: 'US' }, ] as const;  const CountrySchema = v.picklist(   countries.map((country) => country.code),   'Please select your country.' );`

[](#related)Related
-------------------

The following APIs can be combined with `picklist`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#promise)promise
===================

Creates a promise schema.

`const Schema = v.promise<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[PromiseIssue](/api/PromiseIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `promise` you can validate the data type of the input. If the input is not a promise, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[PromiseSchema](/api/PromiseSchema/)<TMessage>`

[](#examples)Examples
---------------------

The following examples show how `promise` can be used.

### [](#number-promise)Number promise

Schema to validate a promise that resolves to a number.

`const NumberPromiseSchema = v.pipeAsync(   v.promise(),   v.awaitAsync(),   v.number() );`

[](#related)Related
-------------------

The following APIs can be combined with `promise`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`awaitAsync`](/api/awaitAsync/),
*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#record)record
=================

Creates a record schema.

`const Schema = v.record<TKey, TValue, TMessage>(key, value, message);`

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<string, string | number | symbol, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[RecordIssue](/api/RecordIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `key` `TKey`
*   `value` `TValue`
*   `message` `TMessage`

### [](#explanation)Explanation

With `record` you can validate the data type of the input and whether the entries matches `key` and `value`. If the input is not an object, you can use `message` to customize the error message.

> This schema filters certain entries from the record for security reasons.

> This schema marks an entry as optional if it detects that its key is a literal type. The reason for this is that it is not technically possible to detect missing literal keys without restricting the `key` schema to [`string`](/api/string/), [`enum`](/api/enum/) and [`picklist`](/api/picklist/). However, if [`enum`](/api/enum/) and [`picklist`](/api/picklist/) are used, it is better to use [`object`](/api/object/) with [`entriesFromList`](/api/entriesFromList/) because it already covers the needed functionality. This decision also reduces the bundle size of `record`, because it only needs to check the entries of the input and not any missing keys.

[](#returns)Returns
-------------------

*   `Schema` `[RecordSchema](/api/RecordSchema/)<TKey, TValue, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `record` can be used.

### [](#string-record-schema)String record schema

Schema to validate a record with strings.

`const StringRecordSchema = v.record(   v.string(),   v.string(),   'An object is required.' );`

### [](#object-record-schema)Object record schema

Schema to validate a record of objects.

`const ObjectRecordSchema = v.record(v.string(), v.object({ key: v.string() }));`

### [](#picklist-as-key)Picklist as key

Schema to validate a record with specific optional keys.

`const ProductRecordSchema = v.record(   v.picklist(['product_a', 'product_b', 'product_c']),   v.optional(v.number()) );`

### [](#enum-as-key)Enum as key

Schema to validate a record with specific optional keys.

`enum Products {   PRODUCT_A = 'product_a',   PRODUCT_B = 'product_b',   PRODUCT_C = 'product_c', }  const ProductRecordSchema = v.record(v.enum(Products), v.optional(v.number()));`

[](#related)Related
-------------------

The following APIs can be combined with `record`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`minEntries`](/api/minEntries/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#set)set
===========

Creates a set schema.

`const Schema = v.set<TValue, TMessage>(value, message);`

[](#generics)Generics
---------------------

*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SetIssue](/api/SetIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `value` `TValue`
*   `message` `TMessage`

### [](#explanation)Explanation

With `set` you can validate the data type of the input and whether the content matches `value`. If the input is not a set, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[SetSchema](/api/SetSchema/)<TValue, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `set` can be used.

### [](#string-set-schema)String set schema

Schema to validate a set with string values.

`const StringSetSchema = v.set(v.string());`

### [](#object-set-schema)Object set schema

Schema to validate a set with object values.

`const ObjectSetSchema = v.set(v.object({ key: v.string() }));`

[](#related)Related
-------------------

The following APIs can be combined with `set`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`maxSize`](/api/maxSize/),
*   [`metadata`](/api/metadata/),
*   [`minSize`](/api/minSize/),
*   [`notSize`](/api/notSize/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`size`](/api/size/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#strictobject)strictObject
=============================

Creates a strict object schema.

`const Schema = v.strictObject<TEntries, TMessage>(entries, message);`

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntries](/api/ObjectEntries/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StrictObjectIssue](/api/StrictObjectIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `entries` `TEntries`
*   `message` `TMessage`

### [](#explanation)Explanation

With `strictObject` you can validate the data type of the input and whether the content matches `entries`. If the input is not an object or does include unknown entries, you can use `message` to customize the error message.

> The difference to [`object`](/api/object/) is that this schema returns an issue for unknown entries. It intentionally returns only one issue. Otherwise, attackers could send large objects to exhaust device resources. If you want an issue for every unknown key, use the [`objectWithRest`](/api/objectWithRest/) schema with [`never`](/api/never/) for the `rest` argument.

[](#returns)Returns
-------------------

*   `Schema` `[StrictObjectSchema](/api/StrictObjectSchema/)<TEntries, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `strictObject` can be used. Please see the [object guide](/guides/objects/) for more examples and explanations.

### [](#simple-object-schema)Simple object schema

Schema to validate a strict object with two keys.

`const SimpleObjectSchema = v.strictObject({   key1: v.string(),   key2: v.number(), });`

### [](#merge-several-objects)Merge several objects

Schema that merges the entries of two object schemas.

`const MergedObjectSchema = v.strictObject({   ...ObjectSchema1.entries,   ...ObjectSchema2.entries, });`

### [](#mark-keys-as-optional)Mark keys as optional

Schema to validate an object with partial entries.

`const PartialObjectSchema = v.partial(   v.strictObject({     key1: v.string(),     key2: v.number(),   }) );`

### [](#object-with-selected-entries)Object with selected entries

Schema to validate only selected entries of a strict object.

`const PickObjectSchema = v.pick(   v.strictObject({     key1: v.string(),     key2: v.number(),     key3: v.boolean(),   }),   ['key1', 'key3'] );`

[](#related)Related
-------------------

The following APIs can be combined with `strictObject`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#stricttuple)strictTuple
===========================

Creates a strict tuple schema.

`const Schema = v.strictTuple<TItems, TMessage>(items, message);`

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItems](/api/TupleItems/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `items` `TItems`
*   `message` `TMessage`

### [](#explanation)Explanation

With `strictTuple` you can validate the data type of the input and whether the content matches `items`. If the input is not an array or does include unknown items, you can use `message` to customize the error message.

> The difference to [`tuple`](/api/tuple/) is that this schema returns an issue for unknown items. It intentionally returns only one issue. Otherwise, attackers could send large arrays to exhaust device resources. If you want an issue for every unknown item, use the [`tupleWithRest`](/api/tupleWithRest/) schema with [`never`](/api/never/) for the `rest` argument.

[](#returns)Returns
-------------------

*   `Schema` `[StrictTupleSchema](/api/StrictTupleSchema/)<TItems, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `strictTuple` can be used. Please see the [arrays guide](/guides/arrays/) for more examples and explanations.

### [](#simple-tuple-schema)Simple tuple schema

Schema to validate a strict tuple with two items.

`const SimpleTupleSchema = v.strictTuple([v.string(), v.number()]);`

[](#related)Related
-------------------

The following APIs can be combined with `strictTuple`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#string)string
=================

Creates a string schema.

`const Schema = v.string<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StringIssue](/api/StringIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `string` you can validate the data type of the input. If the input is not a string, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[StringSchema](/api/StringSchema/)<TMessage>`

[](#examples)Examples
---------------------

The following examples show how `string` can be used.

### [](#email-schema)Email schema

Schema to validate an email.

`const EmailSchema = v.pipe(   v.string(),   v.nonEmpty('Please enter your email.'),   v.email('The email is badly formatted.'),   v.maxLength(30, 'Your email is too long.') );`

### [](#password-schema)Password schema

Schema to validate a password.

`const PasswordSchema = v.pipe(   v.string(),   v.minLength(8, 'Your password is too short.'),   v.maxLength(30, 'Your password is too long.'),   v.regex(/[a-z]/, 'Your password must contain a lowercase letter.'),   v.regex(/[A-Z]/, 'Your password must contain a uppercase letter.'),   v.regex(/[0-9]/, 'Your password must contain a number.') );`

### [](#url-schema)URL schema

Schema to validate a URL.

`const UrlSchema = v.pipe(   v.string('A URL must be string.'),   v.url('The URL is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `string`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`check`](/api/check/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`excludes`](/api/excludes/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`json`](/api/json/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`minBytes`](/api/minBytes/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`regex`](/api/regex/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`slug`](/api/slug/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#symbol)symbol
=================

Creates a symbol schema.

`const Schema = v.symbol<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SymbolIssue](/api/SymbolIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `symbol` you can validate the data type of the input. If it is not a symbol, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[SymbolSchema](/api/SymbolSchema/)<TMessage>`

[](#examples)Examples
---------------------

The following examples show how `symbol` can be used.

### [](#custom-message)Custom message

Symbol schema with a custom error message.

`const schema = v.symbol('A symbol is required');`

[](#related)Related
-------------------

The following APIs can be combined with `symbol`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#tuple)tuple
===============

Creates a tuple schema.

`const Schema = v.tuple<TItems, TMessage>(items, message);`

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItems](/api/TupleItems/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `items` `TItems`
*   `message` `TMessage`

### [](#explanation)Explanation

With `tuple` you can validate the data type of the input and whether the content matches `items`. If the input is not an array, you can use `message` to customize the error message.

> This schema removes unknown items. The output will only include the items you specify. To include unknown items, use [`looseTuple`](/api/looseTuple/). To return an issue for unknown items, use [`strictTuple`](/api/strictTuple/). To include and validate unknown items, use [`tupleWithRest`](/api/tupleWithRest/).

[](#returns)Returns
-------------------

*   `Schema` `[TupleSchema](/api/TupleSchema/)<TItems, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `tuple` can be used. Please see the [arrays guide](/guides/arrays/) for more examples and explanations.

### [](#simple-tuple-schema)Simple tuple schema

Schema to validate a tuple with two items.

`const SimpleTupleSchema = v.tuple([v.string(), v.number()]);`

[](#related)Related
-------------------

The following APIs can be combined with `tuple`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#tuplewithrest)tupleWithRest
===============================

Creates a tuple with rest schema.

`const Schema = v.tupleWithRest<TItems, TRest, TMessage>(items, rest, message);`

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItems](/api/TupleItems/)`
*   `TRest` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `items` `TItems`
*   `rest` `TRest`
*   `message` `TMessage`

### [](#explanation)Explanation

With `tupleWithRest` you can validate the data type of the input and whether the content matches `items` and `rest`. If the input is not an array, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[TupleWithRestSchema](/api/TupleWithRestSchema/)<TItems, TRest, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `tupleWithRest` can be used. Please see the [arrays guide](/guides/arrays/) for more examples and explanations.

### [](#tuple-schema-with-rest)Tuple schema with rest

Schema to validate a tuple with generic rest items.

`const TupleSchemaWithRest = v.tupleWithRest(   [v.string(), v.number()],   v.boolean() );`

[](#related)Related
-------------------

The following APIs can be combined with `tupleWithRest`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#undefined)undefined
=======================

Creates an undefined schema.

`const Schema = v.undefined<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UndefinedIssue](/api/UndefinedIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `undefined` you can validate the data type of the input and if it is not `undefined`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[UndefinedSchema](/api/UndefinedSchema/)<TMessage>`

[](#related)Related
-------------------

The following APIs can be combined with `undefined`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#undefinedable)undefinedable
===============================

Creates an undefinedable schema.

`const Schema = v.undefinedable<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, undefined>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `undefinedable` the validation of your schema will pass `undefined` inputs, and if you specify a `default_` input value, the schema will use it if the input is `undefined`. For this reason, the output type may differ from the input type of the schema.

> `undefinedable` behaves exactly the same as [`optional`](/api/optional/) at runtime. The only difference is the input and output type when used for object entries. While [`optional`](/api/optional/) adds a question mark to the key, `undefinedable` does not.

> Note that `undefinedable` does not accept `null` as an input. If you want to accept `null` inputs, use [`nullable`](/api/nullable/), and if you want to accept `null` and `undefined` inputs, use [`nullish`](/api/nullish/) instead. Also, if you want to set a default output value for any invalid input, you should use [`fallback`](/api/fallback/) instead.

[](#returns)Returns
-------------------

*   `Schema` `[UndefinedableSchema](/api/UndefinedableSchema/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `undefinedable` can be used.

### [](#undefinedable-string-schema)Undefinedable string schema

Schema that accepts `string` and `undefined`.

`const UndefinedableStringSchema = v.undefinedable(   v.string(),   "I'm the default!" );`

### [](#undefinedable-date-schema)Undefinedable date schema

Schema that accepts [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) and `undefined`.

> By using a function as the `default_` parameter, the schema will return a new [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) instance each time the input is `undefined`.

`const UndefinedableDateSchema = v.undefinedable(v.date(), () => new Date());`

### [](#undefinedable-entry-schema)Undefinedable entry schema

Object schema with an undefinedable entry.

`const UndefinedableEntrySchema = v.object({   key: v.undefinedable(v.string()), });`

### [](#unwrap-undefinedable-schema)Unwrap undefinedable schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `undefinedable`.

`const UndefinedableNumberSchema = v.undefinedable(v.number()); const NumberSchema = v.unwrap(UndefinedableNumberSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `undefinedable`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonUndefinedable`](/api/nonUndefinedable/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#union)union
===============

Creates an union schema.

> I recommend that you read the [unions guide](/guides/unions/) before using this schema function.

`const Schema = v.union<TOptions, TMessage>(options, message);`

[](#generics)Generics
---------------------

*   `TOptions` `extends [UnionOptions](/api/UnionOptions/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UnionIssue](/api/UnionIssue/)<[InferIssue](/api/InferIssue/)<TOptions[number]>>> | undefined`

[](#parameters)Parameters
-------------------------

*   `options` `TOptions`
*   `message` `TMessage`

### [](#explanation)Explanation

With `union` you can validate if the input matches one of the given `options`. If the input does not match a schema and cannot be clearly assigned to one of the options, you can use `message` to customize the error message.

If a bad input can be uniquely assigned to one of the schemas based on the data type, the result of that schema is returned. Otherwise, a general issue is returned that contains the issues of each schema as subissues. This is a special case within the library, as the issues of `union` can contradict each other.

[](#returns)Returns
-------------------

*   `Schema` `[UnionSchema](/api/UnionSchema/)<TOptions, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `union` can be used.

### [](#url-schema)URL schema

Schema to validate an URL or empty string.

`const UrlSchema = v.union([v.pipe(v.string(), v.url()), v.literal('')]);`

### [](#number-schema)Number schema

Schema to validate a number or decimal string.

`const NumberSchema = v.union([v.number(), v.pipe(v.string(), v.decimal())]);`

### [](#date-schema)Date schema

Schema to validate a `Date` or ISO timestamp.

`const DateSchema = v.union([v.date(), v.pipe(v.string(), v.isoTimestamp())]);`

[](#related)Related
-------------------

The following APIs can be combined with `union`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#unknown)unknown
===================

Creates an unknown schema.

> Use this schema function only if the data is truly unknown. Otherwise, use the other more specific schema functions that describe the data exactly.

`const Schema = v.unknown();`

[](#returns)Returns
-------------------

*   `Schema` `[UnknownSchema](/api/UnknownSchema/)`

[](#related)Related
-------------------

The following APIs can be combined with `unknown`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#variant)variant
===================

Creates a variant schema.

`const Schema = v.variant<TKey, TOptions, TMessage>(key, options, message);`

[](#generics)Generics
---------------------

*   `TKey` `extends string`
*   `TOptions` `extends [VariantOptions](/api/VariantOptions/)<TKey>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[VariantIssue](/api/VariantIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `key` `TKey`
*   `options` `TOptions`
*   `message` `TMessage`

### [](#explanation)Explanation

With `variant` you can validate if the input matches one of the given object `options`. The object schema to be used for the validation is determined by the discriminator `key`. If the input does not match a schema and cannot be clearly assigned to one of the options, you can use `message` to customize the error message.

> It is allowed to specify the exact same or a similar discriminator multiple times. However, in such cases `variant` will only return the output of the first untyped or typed variant option result. Typed results take precedence over untyped ones.

> For deeply nested `variant` schemas with several different discriminator keys, `variant` will return an issue for the first most likely object schemas on invalid input. The order of the discriminator keys and the presence of a discriminator in the input are taken into account.

[](#returns)Returns
-------------------

*   `Schema` `[VariantSchema](/api/VariantSchema/)<TKey, TOptions, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `variant` can be used.

### [](#variant-schema)Variant schema

Schema to validate an email, URL or date variant.

`const VariantSchema = v.variant('type', [   v.object({     type: v.literal('email'),     email: v.pipe(v.string(), v.email()),   }),   v.object({     type: v.literal('url'),     url: v.pipe(v.string(), v.url()),   }),   v.object({     type: v.literal('date'),     date: v.pipe(v.string(), v.isoDate()),   }), ]);`

### [](#nested-variant-schema)Nested variant schema

You can also nest `variant` schemas.

`const NestedVariantSchema = v.variant('type', [   VariantSchema,   v.object({     type: v.literal('color'),     date: v.pipe(v.string(), v.hexColor()),   }), ]);`

### [](#complex-variant-schema)Complex variant schema

You can also use `variant` to validate complex objects with multiple different discriminator keys.

`const ComplexVariantSchema = v.variant('kind', [   v.variant('type', [     v.object({       kind: v.literal('fruit'),       type: v.literal('apple'),       item: v.object({ … }),     }),     v.object({       kind: v.literal('fruit'),       type: v.literal('banana'),       item: v.object({ … }),     }),   ]),   v.variant('type', [     v.object({       kind: v.literal('vegetable'),       type: v.literal('carrot'),       item: v.object({ … }),     }),     v.object({       kind: v.literal('vegetable'),       type: v.literal('tomato'),       item: v.object({ … }),     }),   ]), ]);`

[](#related)Related
-------------------

The following APIs can be combined with `variant`.

### [](#schemas)Schemas

*   [`object`](/api/object/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#void)void
=============

Creates a void schema.

`const Schema = v.void<TMessage>(message);`

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[VoidIssue](/api/VoidIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `void` you can validate the data type of the input and if it is not `undefined`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[VoidSchema](/api/VoidSchema/)<TMessage>`

[](#related)Related
-------------------

The following APIs can be combined with `void`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

[](#assert)assert
=================

Checks if the input matches the scheme.

> As this is an assertion function, it can be used as a type guard.

`v.assert<TSchema>(schema, input);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `input` `unknown`

### [](#explanation)Explanation

`assert` does not modify the `input`. Therefore, transformations have no effect and unknown keys of an object are not removed. That is why this approach is not as safe and powerful as [`parse`](/api/parse/) and [`safeParse`](/api/safeParse/).

[](#example)Example
-------------------

The following example show how `assert` can be used.

`const EmailSchema = v.pipe(v.string(), v.email()); const data: unknown = 'jane@example.com';  v.assert(EmailSchema, data); const email = data; // string`

[](#related)Related
-------------------

The following APIs can be combined with `assert`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`unwrap`](/api/unwrap/)

[](#config)config
=================

Changes the local configuration of a schema.

`const Schema = v.config<TSchema>(schema, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `config` `[Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>>`

### [](#explanation)Explanation

This method overwrites the selected configuration properties by merging the previous configuration of the `schema` with the provided `config`.

[](#returns)Returns
-------------------

*   `Schema` `TSchema`

[](#examples)Examples
---------------------

The following examples show how `config` can be used.

### [](#same-error-message)Same error message

Schema that uses the same error message for the entire pipeline.

`const Schema = v.object({   email: v.config(     v.pipe(v.string(), v.trim(), v.email(), v.endsWith('@example.com')),     { message: 'The email does not conform to the required format.' }   ),   // ... });`

### [](#abort-pipeline-early)Abort pipeline early

Schema that aborts only a specific pipeline early.

`const Schema = v.object({   url: v.config(     v.pipe(v.string(), v.trim(), v.url(), v.endsWith('@example.com')),     { abortPipeEarly: true }   ),   // ... });`

[](#related)Related
-------------------

The following APIs can be combined with `config`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#fallback)fallback
=====================

Returns a fallback value as output if the input does not match the schema.

`const Schema = v.fallback<TSchema, TFallback>(schema, fallback);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TFallback` `extends [Fallback](/api/Fallback/)<TSchema>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `fallback` `TFallback`

### [](#explanation)Explanation

`fallback` allows you to define a fallback value for the output that will be used if the validation of the input fails. This means that no issues will be returned when using `fallback` and the schema will always return an output.

> If you only want to set a default value for `null` or `undefined` inputs, you should use [`optional`](/api/optional/), [`nullable`](/api/nullable/) or [`nullish`](/api/nullish/) instead.

> The fallback value is not validated. Make sure that the fallback value matches your schema.

[](#returns)Returns
-------------------

*   `Schema` `[SchemaWithFallback](/api/SchemaWithFallback/)<TSchema, TFallback>`

[](#examples)Examples
---------------------

The following examples show how `fallback` can be used.

### [](#fallback-string-schema)Fallback string schema

Schema that will always return a string output.

`const FallbackStringSchema = v.fallback(v.string(), "I'm the fallback!");`

### [](#fallback-date-schema)Fallback date schema

Schema that will always return a [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) output.

> By using a function as the `fallback` parameter, the schema will return a new [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) instance each time the input does not match the schema.

`const FallbackDateSchema = v.fallback(v.date(), () => new Date());`

[](#related)Related
-------------------

The following APIs can be combined with `fallback`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#flatten)flatten
===================

Flatten the error messages of issues.

`const errors = v.flatten<TSchema>(issues);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `issues` `[[InferIssue](/api/InferIssue/)<TSchema>, ...[InferIssue](/api/InferIssue/)<TSchema>[]]`

### [](#explanation)Explanation

The error messages of issues without a path that belong to the root of the schema are added to the `.root` key.

The error messages of issues with a path that belong to the nested parts of the schema and can be converted to a dot path are added to the `.nested` key.

Some issue paths, for example for complex data types like `Set` and `Map`, have no key or a key that cannot be converted to a dot path. These error messages are added to the `.other` key.

[](#returns)Returns
-------------------

*   `errors` `[FlatErrors](/api/FlatErrors/)<TSchema>`

[](#examples)Examples
---------------------

The following example show how `flatten` can be used.

`const Schema = v.object({   nested: v.object({     foo: v.string('Value of "nested.foo" is invalid.'),   }), });  const result = v.safeParse(Schema, { nested: { foo: null } });  if (result.issues) {   const flatErrors = v.flatten<typeof Schema>(result.issues);    // ... }`

[](#related)Related
-------------------

The following APIs can be combined with `flatten`.

### [](#methods)Methods

*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`safeParse`](/api/safeParse/)

[](#forward)forward
===================

Forwards the issues of the passed validation action.

`const Action = v.forward<TInput, TIssue, TPath>(action, path);`

[](#generics)Generics
---------------------

*   `TInput` `extends Record<string, unknown> | ArrayLike<unknown>`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
*   `TPath` `extends [RequiredPath](/api/RequiredPath/)`

[](#parameters)Parameters
-------------------------

*   `action` `[BaseValidation](/api/BaseValidation/)<TInput, TInput, TIssue>`
*   `path` `[ValidPath](/api/ValidPath/)<TInput, TPath>`

### [](#explanation)Explanation

`forward` allows you to forward the issues of the passed validation `action` via `path` to a nested field of a schema.

[](#returns)Returns
-------------------

*   `Action` `[BaseValidation](/api/BaseValidation/)<TInput, TInput, TIssue>`

[](#examples)Examples
---------------------

The following examples show how `forward` can be used.

### [](#register-schema)Register schema

Schema that ensures that the two passwords match.

`const RegisterSchema = v.pipe(   v.object({     email: v.pipe(       v.string(),       v.nonEmpty('Please enter your email.'),       v.email('The email address is badly formatted.')     ),     password1: v.pipe(       v.string(),       v.nonEmpty('Please enter your password.'),       v.minLength(8, 'Your password must have 8 characters or more.')     ),     password2: v.string(),   }),   v.forward(     v.partialCheck(       [['password1'], ['password2']],       (input) => input.password1 === input.password2,       'The two passwords do not match.'     ),     ['password2']   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `forward`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/)

### [](#methods)Methods

*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#getdefault)getDefault
=========================

Returns the default value of the schema.

`const value = v.getDefault<TSchema>(schema, dataset, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, BaseIssue<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, BaseIssue<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `dataset` `[UnknownDataset](/api/UnknownDataset/) | undefined`
*   `config` `Config<InferIssue<TSchema>> | undefined`

[](#returns)Returns
-------------------

*   `value` `[InferDefault](/api/InferDefault/)<TSchema>`

[](#examples)Examples
---------------------

The following examples show how `getDefault` can be used.

### [](#optional-string-schema)Optional string schema

Get the default value of an optional string schema.

`const OptionalStringSchema = v.optional(v.string(), "I'm the default!"); const defaultValue = v.getDefault(OptionalStringSchema); // "I'm the default!"`

[](#related)Related
-------------------

The following APIs can be combined with `getDefault`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`unwrap`](/api/unwrap/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#getdefaults)getDefaults
===========================

Returns the default values of the schema.

> The difference to [`getDefault`](/api/getDefault/) is that for object and tuple schemas this function recursively returns the default values of the subschemas instead of `undefined`.

`const values = v.getDefaults<TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

[](#returns)Returns
-------------------

*   `values` `[InferDefaults](/api/InferDefaults/)<TSchema>`

[](#examples)Examples
---------------------

The following examples show how `getDefaults` can be used.

### [](#object-defaults)Object defaults

Get the default values of an object schema.

`const ObjectSchema = v.object({   key: v.optional(v.string(), "I'm the default!"), });  const defaultValues = v.getDefaults(ObjectSchema); // { key: "I'm the default!" }`

### [](#tuple-defaults)Tuple defaults

Get the default values of a tuple schema.

`const TupleSchema = v.tuple([v.nullable(v.number(), 100)]); const defaultValues = v.getDefaults(TupleSchema); // [100]`

[](#related)Related
-------------------

The following APIs can be combined with `getDefaults`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`unwrap`](/api/unwrap/)

[](#getdescription)getDescription
=================================

Returns the description of the schema.

> If multiple descriptions are defined, the last one of the highest level is returned. If no description is defined, `undefined` is returned.

`const description = v.getDescription<TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [SchemaWithPipe](/api/SchemaWithPipe/)<readonly [[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ...([PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [DescriptionAction](/api/DescriptionAction/)<unknown, string>)[]]> | [SchemaWithPipeAsync](/api/SchemaWithPipeAsync/)<readonly [[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ...([PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [PipeItemAsync](/api/PipeItemAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [DescriptionAction](/api/DescriptionAction/)<unknown, string>)[]]>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

[](#returns)Returns
-------------------

*   `description` `string | undefined`

[](#examples)Examples
---------------------

The following examples show how `getDescription` can be used.

### [](#get-description-of-schema)Get description of schema

Get the description of a username schema.

`const UsernameSchema = v.pipe(   v.string(),   v.regex(/^[a-z0-9_-]{4,16}$/iu),   v.title('Username'),   v.description(     'A username must be between 4 and 16 characters long and can only contain letters, numbers, underscores and hyphens.'   ) );  const description = v.getDescription(UsernameSchema);`

### [](#overriding-inherited-descriptions)Overriding inherited descriptions

Get the description of a Gmail schema with an overridden description.

`const EmailSchema = v.pipe(v.string(), v.email(), v.description('Email'));  const GmailSchema = v.pipe(   EmailSchema,   v.endsWith('@gmail.com'),   v.description('Gmail') );  const description = v.getDescription(GmailSchema); // 'Gmail'`

[](#related)Related
-------------------

The following APIs can be combined with `getDescription`.

### [](#actions)Actions

*   [`description`](/api/description/)

[](#getfallback)getFallback
===========================

Returns the fallback value of the schema.

`const value = v.getFallback<TSchema>(schema, dataset, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, BaseIssue<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, BaseIssue<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `dataset` `[OutputDataset](/api/OutputDataset/)<InferOutput<TSchema>, InferIssue<TSchema>> | undefined`
*   `config` `Config<InferIssue<TSchema>> | undefined`

[](#returns)Returns
-------------------

*   `value` `[InferFallback](/api/InferFallback/)<TSchema>`

[](#examples)Examples
---------------------

The following examples show how `getFallback` can be used.

### [](#fallback-string-schema)Fallback string schema

Get the fallback value of a string schema.

`const FallbackStringSchema = v.fallback(v.string(), "I'm the fallback!"); const fallbackValue = v.getFallback(FallbackStringSchema); // "I'm the fallback!"`

[](#related)Related
-------------------

The following APIs can be combined with `getFallback`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`unwrap`](/api/unwrap/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#getfallbacks)getFallbacks
=============================

Returns the fallback values of the schema.

> The difference to [`getFallback`](/api/getFallback/) is that for object and tuple schemas this function recursively returns the fallback values of the subschemas instead of `undefined`.

`const values = v.getFallbacks<TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

[](#returns)Returns
-------------------

*   `values` `[InferFallbacks](/api/InferFallbacks/)<TSchema>`

[](#examples)Examples
---------------------

The following examples show how `getFallbacks` can be used.

### [](#object-fallbacks)Object fallbacks

Get the fallback values of an object schema.

`const ObjectSchema = v.object({   key: v.fallback(v.string(), "I'm the fallback!"), });  const fallbackValues = v.getFallbacks(ObjectSchema); // { key: "I'm the fallback!" }`

### [](#tuple-fallbacks)Tuple fallbacks

Get the fallback values of a tuple schema.

`const TupleSchema = v.tuple([v.fallback(v.number(), 100)]); const fallbackValues = v.getFallbacks(TupleSchema); // [100]`

[](#related)Related
-------------------

The following APIs can be combined with `getFallbacks`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`unwrap`](/api/unwrap/)

[](#getmetadata)getMetadata
===========================

Returns the metadata of the schema.

> If multiple metadata are defined, it shallowly merges them using depth-first search. If no metadata is defined, an empty object is returned.

`const metadata = v.getMetadata<TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [SchemaWithPipe](/api/SchemaWithPipe/)<readonly [[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ...([PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [MetadataAction](/api/MetadataAction/)<unknown, string>)[]]> | [SchemaWithPipeAsync](/api/SchemaWithPipeAsync/)<readonly [[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ...([PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [PipeItemAsync](/api/PipeItemAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [MetadataAction](/api/MetadataAction/)<unknown, string>)[]]>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

[](#returns)Returns
-------------------

*   `metadata` `[InferMetadata](/api/InferMetadata/)<TSchema>`

[](#examples)Examples
---------------------

The following examples show how `getMetadata` can be used.

### [](#get-metadata-of-schema)Get metadata of schema

Get the metadata of a username schema.

`const UsernameSchema = v.pipe(   v.string(),   v.regex(/^[a-z0-9_-]{4,16}$/iu),   v.title('Username'),   v.metadata({     length: { min: 4, max: 16 },     chars: ['letters', 'numbers', 'underscores', 'hyphens'],   }) );  const metadata = v.getMetadata(UsernameSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `getMetadata`.

### [](#actions)Actions

*   [`metadata`](/api/metadata/)

[](#gettitle)getTitle
=====================

Returns the title of the schema.

> If multiple titles are defined, the last one of the highest level is returned. If no title is defined, `undefined` is returned.

`const title = v.getTitle<TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [SchemaWithPipe](/api/SchemaWithPipe/)<readonly [[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ...([PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [TitleAction](/api/TitleAction/)<unknown, string>)[]]> | [SchemaWithPipeAsync](/api/SchemaWithPipeAsync/)<readonly [[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ...([PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [PipeItemAsync](/api/PipeItemAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [TitleAction](/api/TitleAction/)<unknown, string>)[]]>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

[](#returns)Returns
-------------------

*   `title` `string | undefined`

[](#examples)Examples
---------------------

The following examples show how `getTitle` can be used.

### [](#get-title-of-schema)Get title of schema

Get the title of a username schema.

`const UsernameSchema = v.pipe(   v.string(),   v.regex(/^[a-z0-9_-]{4,16}$/iu),   v.title('Username'),   v.description(     'A username must be between 4 and 16 characters long and can only contain letters, numbers, underscores and hyphens.'   ) );  const title = v.getTitle(UsernameSchema); // 'Username'`

### [](#overriding-inherited-titles)Overriding inherited titles

Get the title of a Gmail schema with an overridden title.

`const EmailSchema = v.pipe(v.string(), v.email(), v.title('Email'));  const GmailSchema = v.pipe(   EmailSchema,   v.endsWith('@gmail.com'),   v.title('Gmail') );  const title = v.getTitle(GmailSchema); // 'Gmail'`

[](#related)Related
-------------------

The following APIs can be combined with `getTitle`.

### [](#actions)Actions

*   [`title`](/api/title/)

[](#is)is
=========

Checks if the input matches the scheme.

> By using a type predicate, this function can be used as a type guard.

`const result = v.is<TSchema>(schema, input);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `input` `unknown`

### [](#explanation)Explanation

`is` does not modify the `input`. Therefore, transformations have no effect and unknown keys of an object are not removed. That is why this approach is not as safe and powerful as [`parse`](/api/parse/) and [`safeParse`](/api/safeParse/).

[](#returns)Returns
-------------------

*   `result` `boolean`

[](#example)Example
-------------------

The following example show how `is` can be used.

`const EmailSchema = v.pipe(v.string(), v.email()); const data: unknown = 'jane@example.com';  if (v.is(EmailSchema, data)) {   const email = data; // string }`

[](#related)Related
-------------------

The following APIs can be combined with `is`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`unwrap`](/api/unwrap/)

[](#keyof)keyof
===============

Creates a picklist schema of object keys.

`const Schema = v.keyof<TSchema, TMessage>(schema, message);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [LooseObjectSchema](/api/LooseObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [LooseObjectSchemaAsync](/api/LooseObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), ErrorMessage<ObjectIssue> | undefined> | [ObjectSchema](/api/ObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [ObjectSchemaAsync](/api/ObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), ErrorMessage<ObjectIssue> | undefined> | [ObjectWithRestSchema](/api/ObjectWithRestSchema/)<[ObjectEntries](/api/ObjectEntries/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ErrorMessage<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [ObjectWithRestSchemaAsync](/api/ObjectWithRestSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ErrorMessage<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [StrictObjectSchema](/api/StrictObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [StrictObjectSchemaAsync](/api/StrictObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), ErrorMessage<ObjectIssue> | undefined>`
*   `TMessage` `[ErrorMessage](/api/ErrorMessage/)<[PicklistIssue](/api/PicklistIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `message` `TMessage`

[](#returns)Returns
-------------------

*   `Schema` `[PicklistSchema](/api/PicklistSchema/)<ObjectKeys<TSchema, TMessage>>`

[](#examples)Examples
---------------------

The following examples show how `keyof` can be used.

### [](#object-key-schema)Object key schema

Schema to validate the keys of an object.

`const ObjectSchema = v.object({ key1: v.string(), key2: v.number() }); const ObjectKeySchema = v.keyof(ObjectSchema); // 'key1' | 'key2'`

[](#related)Related
-------------------

The following APIs can be combined with `keyof`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#message)message
===================

Changes the local message configuration of a schema.

`const Schema = v.message<TSchema>(schema, message_);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `message_` `[ErrorMessage](/api/ErrorMessage/)<[InferIssue](/api/InferIssue/)<TSchema>>`

### [](#explanation)Explanation

This method overrides the local message configuration of the schema. In practice, it is typically used to specify a single error message for an entire pipeline.

[](#returns)Returns
-------------------

*   `Schema` `TSchema`

[](#examples)Examples
---------------------

The following examples show how `message` can be used.

### [](#email-schema)Email schema

Email schema that uses the same error message for the entire pipeline.

`const EmailSchema = v.message(   v.pipe(v.string(), v.trim(), v.nonEmpty(), v.email(), v.maxLength(100)),   'The email is not in the required format.' );`

[](#related)Related
-------------------

The following APIs can be combined with `message`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#omit)omit
=============

Creates a modified copy of an object schema that does not contain the selected entries.

`const Schema = v.omit<TSchema, TKeys>(schema, keys);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [SchemaWithoutPipe](/api/SchemaWithoutPipe/)<[LooseObjectSchema](/api/LooseObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [LooseObjectSchemaAsync](/api/LooseObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), ErrorMessage<ObjectIssue> | undefined> | [ObjectSchema](/api/ObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [ObjectSchemaAsync](/api/ObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), ErrorMessage<ObjectIssue> | undefined> | [ObjectWithRestSchema](/api/ObjectWithRestSchema/)<[ObjectEntries](/api/ObjectEntries/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ErrorMessage<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [ObjectWithRestSchemaAsync](/api/ObjectWithRestSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ErrorMessage<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [StrictObjectSchema](/api/StrictObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [StrictObjectSchemaAsync](/api/StrictObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), ErrorMessage<ObjectIssue> | undefined>>`
*   `TKeys` `extends [ObjectKeys](/api/ObjectKeys/)<TSchema>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `keys` `TKey`

### [](#explanation)Explanation

`omit` creates a modified copy of the given object `schema` that does not contain the selected `keys`. It is similar to TypeScript's [`Omit`](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys) utility type.

> Because `omit` changes the data type of the input and output, it is not allowed to pass a schema that has been modified by the [`pipe`](/api/pipe/) method, as this may cause runtime errors. Please use the [`pipe`](/api/pipe/) method after you have modified the schema with `omit`.

[](#returns)Returns
-------------------

*   `Schema` `SchemaWithOmit<TSchema, TKeys>`

[](#examples)Examples
---------------------

The following examples show how `omit` can be used.

### [](#omit-specific-keys)Omit specific keys

Schema that does not contain the selected keys of an existing schema.

`const OmittedSchema = v.omit(   v.object({     key1: v.string(),     key2: v.number(),     key3: v.boolean(),   }),   ['key1', 'key3'] ); // { key2: number }`

[](#related)Related
-------------------

The following APIs can be combined with `omit`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/)

[](#parse)parse
===============

Parses an unknown input based on a schema.

`const output = v.parse<TSchema>(schema, input, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `input` `unknown`
*   `config` `[Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

### [](#explanation)Explanation

`parse` will throw a [`ValiError`](/api/ValiError/) if the `input` does not match the `schema`. Therefore you should use a try/catch block to catch errors. If the input matches the schema, it is valid and the `output` of the schema will be returned typed.

[](#returns)Returns
-------------------

*   `output` `[InferOutput](/api/InferOutput/)<TSchema>`

[](#example)Example
-------------------

The following example show how `parse` can be used.

`try {   const EmailSchema = v.pipe(v.string(), v.email());   const email = v.parse(EmailSchema, 'jane@example.com');    // Handle errors if one occurs } catch (error) {   console.log(error); }`

[](#related)Related
-------------------

The following APIs can be combined with `parse`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`flatten`](/api/flatten/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`summarize`](/api/summarize/),
*   [`unwrap`](/api/unwrap/)

### [](#utils)Utils

*   [`getDotPath`](/api/getDotPath/),
*   [`isValiError`](/api/isValiError/),
*   [`ValiError`](/api/ValiError/)

[](#parser)parser
=================

Returns a function that parses an unknown input based on a schema.

`const parser = v.parser<TSchema, TConfig>(schema, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TConfig` `extends [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `config` `TConfig`

[](#returns)Returns
-------------------

*   `parser` `[Parser](/api/Parser/)<TSchema, TConfig>`

[](#example)Example
-------------------

The following example show how `parser` can be used.

`try {   const EmailSchema = v.pipe(v.string(), v.email());   const emailParser = v.parser(EmailSchema);   const email = emailParser('jane@example.com');    // Handle errors if one occurs } catch (error) {   console.log(error); }`

[](#related)Related
-------------------

The following APIs can be combined with `parser`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`flatten`](/api/flatten/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`summarize`](/api/summarize/),
*   [`unwrap`](/api/unwrap/)

### [](#utils)Utils

*   [`getDotPath`](/api/getDotPath/),
*   [`isValiError`](/api/isValiError/),
*   [`ValiError`](/api/ValiError/)

[](#partial)partial
===================

Creates a modified copy of an object schema that marks all or only the selected entries as optional.

`const Schema = v.partial<TSchema, TKeys>(schema, keys);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [SchemaWithoutPipe](/api/SchemaWithoutPipe/)<[LooseObjectSchema](/api/LooseObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [ObjectSchema](/api/ObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [ObjectWithRestSchema](/api/ObjectWithRestSchema/)<[ObjectEntries](/api/ObjectEntries/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ErrorMessage<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [StrictObjectSchema](/api/StrictObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined>>`
*   `TKeys` `extends [ObjectKeys](/api/ObjectKeys/)<TSchema> | undefined`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `keys` `TKey`

### [](#explanation)Explanation

`partial` creates a modified copy of the given object `schema` where all entries or only the selected `keys` are optional. It is similar to TypeScript's [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype) utility type.

> Because `partial` changes the data type of the input and output, it is not allowed to pass a schema that has been modified by the [`pipe`](/api/pipe/) method, as this may cause runtime errors. Please use the [`pipe`](/api/pipe/) method after you have modified the schema with `partial`.

[](#returns)Returns
-------------------

*   `Schema` `[SchemaWithPartial](/api/SchemaWithPartial/)<TSchema, TKeys>`

[](#examples)Examples
---------------------

The following examples show how `partial` can be used.

### [](#partial-object-schema)Partial object schema

Schema to validate an object with partial entries.

`const PartialSchema = v.partial(   v.object({     key1: v.string(),     key2: v.number(),   }) ); // { key1?: string; key2?: number }`

### [](#with-only-specific-keys)With only specific keys

Schema to validate an object with only specific entries marked as optional.

`const PartialSchema = v.partial(   v.object({     key1: v.string(),     key2: v.number(),     key3: v.boolean(),   }),   ['key1', 'key3'] ); // { key1?: string; key2: number; key3?: boolean }`

[](#related)Related
-------------------

The following APIs can be combined with `partial`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pick`](/api/pick/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#pick)pick
=============

Creates a modified copy of an object schema that contains only the selected entries.

`const Schema = v.pick<TSchema, TKeys>(schema, keys);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [SchemaWithoutPipe](/api/SchemaWithoutPipe/)<[LooseObjectSchema](/api/LooseObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [LooseObjectSchemaAsync](/api/LooseObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), ErrorMessage<ObjectIssue> | undefined> | [ObjectSchema](/api/ObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [ObjectSchemaAsync](/api/ObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), ErrorMessage<ObjectIssue> | undefined> | [ObjectWithRestSchema](/api/ObjectWithRestSchema/)<[ObjectEntries](/api/ObjectEntries/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ErrorMessage<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [ObjectWithRestSchemaAsync](/api/ObjectWithRestSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ErrorMessage<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [StrictObjectSchema](/api/StrictObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), ErrorMessage<ObjectIssue> | undefined> | [StrictObjectSchemaAsync](/api/StrictObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), ErrorMessage<ObjectIssue> | undefined>>`
*   `TKeys` `extends [ObjectKeys](/api/ObjectKeys/)<TSchema>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `keys` `TKey`

### [](#explanation)Explanation

`pick` creates a modified copy of the given object `schema` that contains only the selected `keys`. It is similar to TypeScript's [`Pick`](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys) utility type.

> Because `pick` changes the data type of the input and output, it is not allowed to pass a schema that has been modified by the [`pipe`](/api/pipe/) method, as this may cause runtime errors. Please use the [`pipe`](/api/pipe/) method after you have modified the schema with `pick`.

[](#returns)Returns
-------------------

*   `Schema` `SchemaWithPick<TSchema, TKeys>`

[](#examples)Examples
---------------------

The following examples show how `pick` can be used.

### [](#pick-specific-keys)Pick specific keys

Schema that contains only the selected keys of an existing schema.

`const PickedSchema = v.pick(   object({     key1: string(),     key2: number(),     key3: boolean(),   }),   ['key1', 'key3'] ); // { key1: string; key3: boolean }`

[](#related)Related
-------------------

The following APIs can be combined with `pick`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/)

[](#pipe)pipe
=============

Adds a pipeline to a schema, that can validate and transform its input.

`const Schema = v.pipe<TSchema, TItems>(schema, ...items);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TItems` `extends readonly [PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>[]`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `items` `TItems`

### [](#explanation)Explanation

`pipe` creates a modified copy of the given `schema`, containing a pipeline for detailed validations and transformations. It passes the input data synchronously through the `items` in the order they are provided and each item can examine and modify it.

> Since `pipe` returns a schema that can be used as the first argument of another pipeline, it is possible to nest multiple `pipe` calls to extend the validation and transformation further.

The `pipe` aborts early and marks the output as untyped if issues were collected before attempting to execute a schema or transformation action as the next item in the pipeline, to prevent unexpected behavior.

[](#returns)Returns
-------------------

*   `Schema` `[SchemaWithPipe](/api/SchemaWithPipe/)<readonly [TSchema, ...TItems]>`

[](#examples)Examples
---------------------

The following examples show how `pipe` can be used. Please see the [pipeline guide](/guides/pipelines/) for more examples and explanations.

### [](#email-schema)Email schema

Schema to validate an email.

`const EmailSchema = v.pipe(   v.string(),   v.nonEmpty('Please enter your email.'),   v.email('The email is badly formatted.'),   v.maxLength(30, 'Your email is too long.') );`

### [](#string-to-number)String to number

Schema to convert a string to a number.

`const NumberSchema = v.pipe(v.string(), v.transform(Number), v.number());`

[](#related)Related
-------------------

The following APIs can be combined with `pipe`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#required)required
=====================

Creates a modified copy of an object schema that marks all or only the selected entries as required.

`const AllKeysSchema = v.required<TSchema, TMessage>(schema, message); const SelectedKeysSchema = v.required<TSchema, TKeys, TMessage>(   schema,   keys,   message );`

[](#generics)Generics
---------------------

*   `TSchema` `extends [SchemaWithoutPipe](/api/SchemaWithoutPipe/)<[LooseObjectSchema](/api/LooseObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), [ErrorMessage](/api/ErrorMessage/)<[LooseObjectIssue](/api/LooseObjectIssue/)> | undefined> | [ObjectSchema](/api/ObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), [ErrorMessage](/api/ErrorMessage/)<[ObjectIssue](/api/ObjectIssue/)> | undefined> | [ObjectWithRestSchema](/api/ObjectWithRestSchema/)<[ObjectEntries](/api/ObjectEntries/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [StrictObjectSchema](/api/StrictObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), [ErrorMessage](/api/ErrorMessage/)<[StrictObjectIssue](/api/StrictObjectIssue/)> | undefined>>`
*   `TKeys` `extends [ObjectKeys](/api/ObjectKeys/)<TSchema>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonOptionalIssue](/api/NonOptionalIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `keys` `TKey`
*   `message` `TMessage`

### [](#explanation)Explanation

`required` creates a modified copy of the given object `schema` where all or only the selected `keys` are required. It is similar to TypeScript's [`Required`](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype) utility type.

> Because `required` changes the data type of the input and output, it is not allowed to pass a schema that has been modified by the [`pipe`](/api/pipe/) method, as this may cause runtime errors. Please use the [`pipe`](/api/pipe/) method after you have modified the schema with `required`.

[](#returns)Returns
-------------------

*   `AllKeysSchema` `[SchemaWithRequired](/api/SchemaWithRequired/)<TSchema, undefined, TMessage>`
*   `SelectedKeysSchema` `[SchemaWithRequired](/api/SchemaWithRequired/)<TSchema, Tkeys, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `required` can be used.

### [](#required-object-schema)Required object schema

Schema to validate an object with required entries.

`const RequiredSchema = v.required(   v.object({     key1: v.optional(v.string()),     key2: v.optional(v.number()),   }) ); // { key1: string; key2: number }`

### [](#with-only-specific-keys)With only specific keys

Schema to validate an object with only specific entries marked as required.

`const RequiredSchema = v.required(   v.object({     key1: v.optional(v.string()),     key2: v.optional(v.number()),     key3: v.optional(v.boolean()),   }),   ['key1', 'key3'] ); // { key1: string; key2?: number; key3: boolean }`

[](#related)Related
-------------------

The following APIs can be combined with `required`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#safeparse)safeParse
=======================

Parses an unknown input based on a schema.

`const result = v.safeParse<TSchema>(schema, input, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `input` `unknown`
*   `config` `[Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#returns)Returns
-------------------

*   `result` `[SafeParseResult](/api/SafeParseResult/)<TSchema>`

[](#example)Example
-------------------

The following example show how `safeParse` can be used.

`const EmailSchema = v.pipe(v.string(), v.email()); const result = v.safeParse(EmailSchema, 'jane@example.com');  if (result.success) {   const email = result.output; } else {   console.log(result.issues); }`

[](#related)Related
-------------------

The following APIs can be combined with `safeParse`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`flatten`](/api/flatten/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`summarize`](/api/summarize/),
*   [`unwrap`](/api/unwrap/)

### [](#utils)Utils

*   [`getDotPath`](/api/getDotPath/)

[](#safeparser)safeParser
=========================

Returns a function that parses an unknown input based on a schema.

`const safeParser = v.safeParser<TSchema, TConfig>(schema, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TConfig` `extends [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `config` `TConfig`

[](#returns)Returns
-------------------

*   `safeParser` `[SafeParser](/api/SafeParser/)<TSchema, TConfig>`

[](#example)Example
-------------------

The following example show how `safeParser` can be used.

`const EmailSchema = v.pipe(v.string(), v.email()); const safeEmailParser = v.safeParser(EmailSchema); const result = safeEmailParser('jane@example.com');  if (result.success) {   const email = result.output; } else {   console.log(result.issues); }`

[](#related)Related
-------------------

The following APIs can be combined with `safeParser`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`flatten`](/api/flatten/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`summarize`](/api/summarize/),
*   [`unwrap`](/api/unwrap/)

### [](#utils)Utils

*   [`getDotPath`](/api/getDotPath/)

[](#summarize)summarize
=======================

Summarize the error messages of issues in a pretty-printable multi-line string.

`const errors = v.summarize(issues);`

[](#parameters)Parameters
-------------------------

*   `issues` `[[BaseIssue](/api/BaseIssue/)<unknown>, ...[BaseIssue](/api/BaseIssue/)<unknown>[]]`

### [](#explanation)Explanation

If an issue in `issues` contains a path that can be converted to a dot path, the dot path will be displayed in the `errors` output just below the issue's error message.

[](#returns)Returns
-------------------

*   `errors` `string`

[](#examples)Examples
---------------------

The following example show how `summarize` can be used.

`const Schema = v.object({   nested: v.object({     foo: v.string('Value of "nested.foo" is invalid.'),   }), });  const result = v.safeParse(Schema, { nested: { foo: null } });  if (result.issues) {   console.log(v.summarize(result.issues)); }`

[](#related)Related
-------------------

The following APIs can be combined with `summarize`.

### [](#methods)Methods

*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`safeParse`](/api/safeParse/)

[](#unwrap)unwrap
=================

Unwraps the wrapped schema.

`const Schema = v.unwrap<TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [ExactOptionalSchema](/api/ExactOptionalSchema/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, unknown> | [ExactOptionalSchemaAsync](/api/ExactOptionalSchemaAsync/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, unknown> | [NonNullableSchema](/api/NonNullableSchema/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[NonNullableIssue](/api/NonNullableIssue/)> | undefined> | [NonNullableSchemaAsync](/api/NonNullableSchemaAsync/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[NonNullableIssue](/api/NonNullableIssue/)> | undefined> | [NonNullishSchema](/api/NonNullishSchema/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[NonNullishIssue](/api/NonNullishIssue/)> | undefined> | [NonNullishSchemaAsync](/api/NonNullishSchemaAsync/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[NonNullishIssue](/api/NonNullishIssue/)> | undefined> | [NonOptionalSchema](/api/NonOptionalSchema/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[NonOptionalIssue](/api/NonOptionalIssue/)> | undefined> | [NonOptionalSchemaAsync](/api/NonOptionalSchemaAsync/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[NonOptionalIssue](/api/NonOptionalIssue/)> | undefined> | [NullableSchema](/api/NullableSchema/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, unknown> | [NullableSchemaAsync](/api/NullableSchemaAsync/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, unknown> | [NullishSchema](/api/NullishSchema/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, unknown> | [NullishSchemaAsync](/api/NullishSchemaAsync/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, unknown> | [OptionalSchema](/api/OptionalSchema/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, unknown> | [OptionalSchemaAsync](/api/OptionalSchemaAsync/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, unknown>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

[](#returns)Returns
-------------------

*   `Schema` `TSchema['wrapped']`

[](#examples)Examples
---------------------

The following examples show how `unwrap` can be used.

### [](#unwrap-string-schema)Unwrap string schema

Unwraps the wrapped string schema.

`const OptionalStringSchema = v.optional(v.string()); const StringSchema = v.unwrap(OptionalStringSchema);`

[](#related)Related
-------------------

The following APIs can be combined with `unwrap`.

### [](#schemas)Schemas

*   [`exactOptional`](/api/exactOptional/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`optional`](/api/optional/),
*   [`undefinedable`](/api/undefinedable/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`is`](/api/is/),
*   [`message`](/api/message/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`pipe`](/api/pipe/),
*   [`safeParse`](/api/safeParse/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/)

[](#args)args
=============

Creates a function arguments transformation action.

`const Action = v.args<TInput, TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TInput` `extends (...args: any[]) => unknown`
*   `TSchema` `extends [LooseTupleSchema](/api/LooseTupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined> | [StrictTupleSchema](/api/StrictTupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined> | [TupleSchema](/api/TupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined> | [TupleWithRestSchema](/api/TupleWithRestSchema/)<[TupleItems](/api/TupleItems/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

### [](#explanation)Explanation

With `args` you can force the arguments of a function to match the given `schema`.

[](#returns)Returns
-------------------

*   `Action` `[ArgsAction](/api/ArgsAction/)<TInput, TSchema>`

[](#examples)Examples
---------------------

The following examples show how `args` can be used.

### [](#function-schema)Function schema

Schema of a function that transforms a string to a number.

`const FunctionSchema = v.pipe(   v.function(),   v.args(v.tuple([v.pipe(v.string(), v.decimal())])),   v.returns(v.number()) );`

[](#related)Related
-------------------

The following APIs can be combined with `args`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`looseTuple`](/api/looseTuple/),
*   [`function`](/api/function/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#base64)base64
=================

Creates a [Base64](https://en.wikipedia.org/wiki/Base64) validation action.

`const Action = v.base64<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Base64Issue](/api/Base64Issue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `base64` you can validate the formatting of a string. If the input is not a Base64 string, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[Base64Action](/api/Base64Action/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `base64` can be used.

### [](#base64-schema)Base64 schema

Schema to validate a Base64 string.

`const Base64Schema = v.pipe(v.string(), v.base64('The data is badly encoded.'));`

[](#related)Related
-------------------

The following APIs can be combined with `base64`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#bic)bic
===========

Creates a [BIC](https://en.wikipedia.org/wiki/ISO_9362) validation action.

`const Action = v.bic<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[BicIssue](/api/BicIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `bic` you can validate the formatting of a string. If the input is not a BIC, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[BicAction](/api/BicAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `bic` can be used.

### [](#bic-schema)BIC schema

Schema to validate a BIC.

`const BicSchema = v.pipe(   v.string(),   v.toUpperCase(),   v.bic('The BIC is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `bic`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#brand)brand
===============

Creates a brand transformation action.

`const Action = v.brand<TInput, TName>(name);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TName` `extends [BrandName](/api/BrandName/)`

[](#parameters)Parameters
-------------------------

*   `name` `TName`

### [](#explanation)Explanation

`brand` allows you to brand the output type of a schema with a `name`. This ensures that data can only be considered valid if it has been validated by a particular branded schema.

[](#returns)Returns
-------------------

*   `Action` `[BrandAction](/api/BrandAction/)<TInput, TName>`

[](#examples)Examples
---------------------

The following examples show how `brand` can be used.

### [](#branded-fruit-schema)Branded fruit schema

Schema to ensure that only a validated fruit is accepted.

`// Create schema and infer output type const FruitSchema = v.pipe(v.object({ name: v.string() }), v.brand('Fruit')); type FruitOutput = v.InferOutput<typeof FruitSchema>;  // This works because output is branded const apple: FruitOutput = v.parse(FruitSchema, { name: 'apple' });  // But this will result in a type error const banana: FruitOutput = { name: 'banana' };`

[](#related)Related
-------------------

The following APIs can be combined with `brand`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#bytes)bytes
===============

Creates a [bytes](https://en.wikipedia.org/wiki/Byte) validation action.

`const Action = v.bytes<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[BytesIssue](/api/BytesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `bytes` you can validate the bytes of a string. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[BytesAction](/api/BytesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `bytes` can be used.

### [](#bytes-schema)Bytes schema

Schema to validate a string with 8 bytes.

`const BytesSchema = v.pipe(   v.string(),   v.bytes(8, 'Exactly 8 bytes are required.') );`

[](#related)Related
-------------------

The following APIs can be combined with `bytes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#check)check
===============

Creates a check validation action.

`const Action = v.check<TInput, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CheckIssue](/api/CheckIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `(input: TInput) => boolean`
*   `message` `TMessage`

### [](#explanation)Explanation

With `check` you can freely validate the input and return `true` if it is valid or `false` otherwise. If the input does not match your `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[CheckAction](/api/CheckAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `check` can be used.

### [](#check-object-properties)Check object properties

Schema to check the properties of an object.

`const CustomObjectSchema = v.pipe(   v.object({     list: v.array(v.string()),     length: v.number(),   }),   v.check(     (input) => input.list.length === input.length,     'The list does not match the length.'   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `check`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`forward`](/api/forward/),
*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#checkitems)checkItems
=========================

Creates a check items validation action.

`const Action = v.checkItems<TInput, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CheckItemsIssue](/api/CheckItemsIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`
*   `message` `TMessage`

### [](#explanation)Explanation

With `checkItems` you can freely validate the items of an array and return `true` if they are valid or `false` otherwise. If an item does not match your `requirement`, you can use `message` to customize the error message.

> The special thing about `checkItems` is that it automatically forwards each issue to the appropriate item.

[](#returns)Returns
-------------------

*   `Action` `[CheckItemsAction](/api/CheckItemsAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `checkItems` can be used.

### [](#no-duplicate-items)No duplicate items

Schema to validate that an array has no duplicate items.

`const ArraySchema = v.pipe(   v.array(v.string()),   v.checkItems(     (item, index, array) => array.indexOf(item) === index,     'Duplicate items are not allowed.'   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `checkItems`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#creditcard)creditCard
=========================

Creates a [credit card](https://en.wikipedia.org/wiki/Payment_card_number) validation action.

`const Action = v.creditCard<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `[ErrorMessage](/api/ErrorMessage/)<[CreditCardIssue](/api/CreditCardIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `creditCard` you can validate the formatting of a string. If the input is not a credit card, you can use `message` to customize the error message.

> The following credit card providers are currently supported: American Express, Diners Card, Discover, JCB, Union Pay, Master Card, and Visa.

[](#returns)Returns
-------------------

*   `Action` `[CreditCardAction](/api/CreditCardAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `creditCard` can be used.

### [](#credit-card-schema)Credit Card schema

Schema to validate a credit card.

`const CreditCardSchema = v.pipe(   v.string(),   v.creditCard('The credit card is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `creditCard`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#cuid2)cuid2
===============

Creates a [Cuid2](https://github.com/paralleldrive/cuid2) validation action.

`const Action = v.cuid2<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Cuid2Issue](/api/Cuid2Issue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `cuid2` you can validate the formatting of a string. If the input is not an Cuid2, you can use `message` to customize the error message.

> Since Cuid2s are not limited to a fixed length, it is recommended to combine `cuid2` with [`length`](/api/length/) to ensure the correct length.

[](#returns)Returns
-------------------

*   `Action` `[Cuid2Action](/api/Cuid2Action/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `cuid2` can be used.

### [](#cuid2-schema)Cuid2 schema

Schema to validate an Cuid2.

`const Cuid2Schema = v.pipe(   v.string(),   v.cuid2('The Cuid2 is badly formatted.'),   v.length(10, 'The Cuid2 must be 10 characters long.') );`

[](#related)Related
-------------------

The following APIs can be combined with `cuid2`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#decimal)decimal
===================

Creates a [decimal](https://en.wikipedia.org/wiki/Decimal) validation action.

> The difference between `decimal` and [`digits`](/api/digits/) is that `decimal` accepts floating point numbers and negative numbers, while [`digits`](/api/digits/) accepts only the digits 0-9.

`const Action = v.decimal<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[DecimalIssue](/api/DecimalIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `decimal` you can validate the formatting of a string. If the input is not a decimal, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[DecimalAction](/api/DecimalAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `decimal` can be used.

### [](#decimal-schema)Decimal schema

Schema to validate a decimal.

`const DecimalSchema = v.pipe(   v.string(),   v.decimal('The decimal is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `decimal`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#description)description
===========================

Creates a description metadata action.

`const Action = v.description<TInput, TDescription>(description_);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TDescription` `extends string`

[](#parameters)Parameters
-------------------------

*   `description_` `TDescription`

### [](#explanation)Explanation

With `description` you can describe the purpose of a schema. This can be useful when working with AI tools or for documentation purposes.

[](#returns)Returns
-------------------

*   `Action` `[DescriptionAction](/api/DescriptionAction/)<TInput, TDescription>`

[](#examples)Examples
---------------------

The following examples show how `description` can be used.

### [](#username-schema)Username schema

Schema to validate a user name.

`const UsernameSchema = v.pipe(   v.string(),   v.regex(/^[a-z0-9_-]{4,16}$/iu),   v.title('Username'),   v.description(     'A username must be between 4 and 16 characters long and can only contain letters, numbers, underscores and hyphens.'   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `description`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`getDescription`](/api/getDescription/),
*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#digits)digits
=================

Creates a [digits](https://en.wikipedia.org/wiki/Numerical_digit) validation action.

> The difference between `digits` and [`decimal`](/api/decimal/) is that `digits` accepts only the digits 0-9, while [`decimal`](/api/decimal/) accepts floating point numbers and negative numbers.

`const Action = v.digits<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[DigitsIssue](/api/DigitsIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `digits` you can validate the formatting of a string. If the input does not soley consist of numerical digits, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[DigitsAction](/api/DigitsAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `digits` can be used.

### [](#digits-schema)Digits schema

Schema to validate a digits.

`const DigitsSchema = v.pipe(   v.string(),   v.digits('The string contains something other than digits.') );`

[](#related)Related
-------------------

The following APIs can be combined with `digits`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#email)email
===============

Creates an [email](https://en.wikipedia.org/wiki/Email_address) validation action.

`const Action = v.email<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EmailIssue](/api/EmailIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `email` you can validate the formatting of a string. If the input is not an email, you can use `message` to customize the error message.

> This validation action intentionally only validates common email addresses. If you are interested in an action that covers the entire specification, please use the [`rfcEmail`](/api/rfcEmail/) action instead.

[](#returns)Returns
-------------------

*   `Action` `[EmailAction](/api/EmailAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `email` can be used.

### [](#email-schema)Email schema

Schema to validate an email.

`const EmailSchema = v.pipe(   v.string(),   v.nonEmpty('Please enter your email.'),   v.email('The email is badly formatted.'),   v.maxLength(30, 'Your email is too long.') );`

[](#related)Related
-------------------

The following APIs can be combined with `email`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#emoji)emoji
===============

Creates an [emoji](https://en.wikipedia.org/wiki/Emoji) validation action.

`const Action = v.emoji<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EmojiIssue](/api/EmojiIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `emoji` you can validate the formatting of a string. If the input is not an emoji, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[EmojiAction](/api/EmojiAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `emoji` can be used.

### [](#emoji-schema)Emoji schema

Schema to validate an emoji.

`const EmojiSchema = v.pipe(   v.string(),   v.emoji('Please provide a valid emoji.') );`

[](#related)Related
-------------------

The following APIs can be combined with `emoji`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#empty)empty
===============

Creates an empty validation action.

`const Action = v.empty<TInput, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EmptyIssue](/api/EmptyIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `empty` you can validate that a string or array is empty. If the input is not empty, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[EmptyAction](/api/EmptyAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `empty` can be used.

### [](#string-schema)String schema

Schema to validate that a string is empty.

`const StringSchema = v.pipe(v.string(), v.empty('The string must be empty.'));`

### [](#array-schema)Array schema

Schema to validate that an array is empty.

`const ArraySchema = v.pipe(   v.array(v.number()),   v.empty('The array must be empty.') );`

[](#related)Related
-------------------

The following APIs can be combined with `empty`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#endswith)endsWith
=====================

Creates an ends with validation action.

`const Action = v.endsWith<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EndsWithIssue](/api/EndsWithIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `endsWith` you can validate the end of a string. If the end does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[EndsWithAction](/api/EndsWithAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `endsWith` can be used.

### [](#email-schema)Email schema

Schema to validate an email with a specific domain.

`const EmailSchema = v.pipe(v.string(), v.email(), v.endsWith('@example.com'));`

[](#related)Related
-------------------

The following APIs can be combined with `endsWith`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#entries)entries
===================

Creates an entries validation action.

`const Action = v.entries<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EntriesIssue](/api/EntriesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `entries` you can validate the number of entries of an object. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[EntriesAction](/api/EntriesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `entries` can be used.

### [](#exact-object-entries)Exact object entries

Schema to validate an object that does have 5 entries.

`const EntriesSchema = v.pipe(   v.record(v.string(), v.number()),   v.entries(5, 'Object must have 5 entries') );`

[](#related)Related
-------------------

The following APIs can be combined with `entries`.

### [](#schemas)Schemas

*   [`looseObject`](/api/looseObject/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`variant`](/api/variant/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#everyitem)everyItem
=======================

Creates an every item validation action.

`const Action = v.everyItem<TInput, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EveryItemIssue](/api/EveryItemIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`
*   `message` `TMessage`

### [](#explanation)Explanation

With `everyItem` you can freely validate the items of an array and return `true` if they are valid or `false` otherwise. If not every item matches your `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[EveryItemAction](/api/EveryItemAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `everyItem` can be used.

### [](#sorted-array-schema)Sorted array schema

Schema to validate that an array is sorted.

`const SortedArraySchema = v.pipe(   v.array(v.number()),   v.everyItem(     (item, index, array) => index === 0 || item >= array[index - 1],     'The numbers must be sorted in ascending order.'   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `everyItem`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#excludes)excludes
=====================

Creates an excludes validation action.

`const Action = v.excludes<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ContentInput](/api/ContentInput/)`
*   `TRequirement` `extends [ContentRequirement](/api/ContentRequirement/)<[ContentInput](/api/ContentInput/)>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ExcludesIssue](/api/ExcludesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `excludes` you can validate the content of a string or array. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[ExcludesAction](/api/ExcludesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `excludes` can be used.

### [](#string-schema)String schema

Schema to validate that a string does not contain a specific substring.

`const StringSchema = v.pipe(   v.string(),   v.excludes('foo', 'The string must not contain "foo".') );`

### [](#array-schema)Array schema

Schema to validate that an array does not contain a specific string.

`const ArraySchema = v.pipe(   v.array(v.string()),   v.excludes('foo', 'The array must not contain "foo".') );`

[](#related)Related
-------------------

The following APIs can be combined with `excludes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#filteritems)filterItems
===========================

Creates a filter items transformation action.

`const Action = v.filterItems<TInput>(operation);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#parameters)Parameters
-------------------------

*   `operation` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`

### [](#explanation)Explanation

With `filterItems` you can filter the items of an array. Returning `true` for an item will keep it in the array and returning `false` will remove it.

[](#returns)Returns
-------------------

*   `Action` `[FilterItemsAction](/api/FilterItemsAction/)<TInput>`

[](#examples)Examples
---------------------

The following examples show how `filterItems` can be used.

### [](#filter-duplicate-items)Filter duplicate items

Schema to filter duplicate items from an array.

`const FilteredArraySchema = v.pipe(   v.array(v.string()),   v.filterItems((item, index, array) => array.indexOf(item) === index) );`

[](#related)Related
-------------------

The following APIs can be combined with `filterItems`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#finditem)findItem
=====================

Creates a find item transformation action.

`const Action = v.findItem<TInput>(operation);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#parameters)Parameters
-------------------------

*   `operation` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`

### [](#explanation)Explanation

With `findItem` you can extract the first item of an array that matches the given `operation`.

[](#returns)Returns
-------------------

*   `Action` `[FindItemAction](/api/FindItemAction/)<TInput>`

[](#examples)Examples
---------------------

The following examples show how `findItem` can be used.

### [](#find-duplicate-item)Find duplicate item

Schema to find the first duplicate item in an array.

`const DuplicateItemSchema = v.pipe(   v.array(v.string()),   v.findItem((item, index, array) => array.indexOf(item) !== index) );`

[](#related)Related
-------------------

The following APIs can be combined with `findItem`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#finite)finite
=================

Creates a [finite](https://en.wikipedia.org/wiki/Finite) validation action.

`const Action = v.finite<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[FiniteIssue](/api/FiniteIssue/)<TInput>> | unknown`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `finite` you can validate the value of a number. If the input is not a finite number, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[FiniteAction](/api/FiniteAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `finite` can be used.

### [](#finite-number-schema)Finite number schema

Schema to validate a finite number.

`const FiniteNumberSchema = v.pipe(   v.number(),   v.finite('The number must be finite.') );`

[](#related)Related
-------------------

The following APIs can be combined with `finite`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`number`](/api/number/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#flavor)flavor
=================

Creates a flavor transformation action.

`const Action = v.flavor<TInput, TName>(name);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TName` `extends [FlavorName](/api/FlavorName/)`

[](#parameters)Parameters
-------------------------

*   `name` `TName`

### [](#explanation)Explanation

`flavor` is a less strict version of [`brand`](/api/brand/) that allows you to flavor the output type of a schema with a `name`. Data is considered valid if it's type is unflavored or has been validated by a schema that has the same flavor.

> `falvor` can also be used as a TypeScript DX hack to improve the editor's autocompletion by displaying only literal types, but still allowing the unflavored root type to be passed.

[](#returns)Returns
-------------------

*   `Action` `[FlavorAction](/api/FlavorAction/)<TInput, TName>`

[](#examples)Examples
---------------------

The following examples show how `flavor` can be used.

### [](#flavored-id-schemas)Flavored ID schemas

Schema to ensure that different types of IDs are not mixed up.

`// Create user ID and order ID schema const UserIdSchema = v.pipe(v.string(), v.flavor('UserId')); const OrderIdSchema = v.pipe(v.string(), v.flavor('OrderId'));  // Infer output types of both schemas type UserId = v.InferOutput<typeof UserIdSchema>; type OrderId = v.InferOutput<typeof OrderIdSchema>;  // This works because output is flavored const userId: UserId = v.parse(UserIdSchema, 'c28443ef...'); const orderId: OrderId = v.parse(OrderIdSchema, '4b717520...');  // You can also use unflavored strings const newUserId1: UserId = '2d80cd94...';  // But this will result in a type error const newUserId2: UserId = orderId;`

[](#related)Related
-------------------

The following APIs can be combined with `flavor`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#graphemes)graphemes
=======================

Creates a [graphemes](https://en.wikipedia.org/wiki/Grapheme) validation action.

`const Action = v.graphemes<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[GraphemesIssue](/api/GraphemesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `graphemes` you can validate the graphemes of a string. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[GraphemesAction](/api/GraphemesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `graphemes` can be used.

### [](#graphemes-schema)Graphemes schema

Schema to validate a string with 8 graphemes.

`const GraphemesSchema = v.pipe(   v.string(),   v.graphemes(8, 'Exactly 8 graphemes are required.') );`

[](#related)Related
-------------------

The following APIs can be combined with `graphemes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#gtvalue)gtValue
===================

Creates a greater than value validation action.

`const Action = v.gtValue<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[GtValueIssue](/api/GtValueIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `gtValue` you can validate the value of a string, number, boolean or date. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[GtValueAction](/api/GtValueAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `gtValue` can be used.

### [](#number-schema)Number schema

Schema to validate a number with a greater than value.

`const NumberSchema = v.pipe(   v.number(),   v.gtValue(100, 'The number must be greater than 100.') );`

### [](#date-schema)Date schema

Schema to validate a date with a greater than year.

`const DateSchema = v.pipe(   v.date(),   v.gtValue(     new Date('2000-01-01'),     'The date must be greater than 1st January 2000.'   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `gtValue`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#hash)hash
=============

Creates a [hash](https://en.wikipedia.org/wiki/Hash_function) validation action.

`const Action = v.hash<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[HashIssue](/api/HashIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `types` `[[HashType](/api/HashType/), ...[HashType](/api/HashType/)[]]`
*   `message` `TMessage`

### [](#explanation)Explanation

With `hash` you can validate the formatting of a string. If the input is not a hash, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[HashAction](/api/HashAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `hash` can be used.

### [](#hash-schema)Hash schema

Schema to validate a hash.

`const HashSchema = v.pipe(   v.string(),   v.hash(['md5', 'sha1'], 'The specified hash is invalid.') );`

[](#related)Related
-------------------

The following APIs can be combined with `hash`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#hexadecimal)hexadecimal
===========================

Creates a [hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) validation action.

`const Action = v.hexadecimal<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[HexadecimalIssue](/api/HexadecimalIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `hexadecimal` you can validate the formatting of a string. If the input is not a hexadecimal, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[HexadecimalAction](/api/HexadecimalAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `hexadecimal` can be used.

### [](#hexadecimal-schema)Hexadecimal schema

Schema to validate a Hexadecimal string.

`const HexadecimalSchema = v.pipe(   v.string(),   v.hexadecimal('The hexadecimal is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `hexadecimal`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#hexcolor)hexColor
=====================

Creates a [hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) validation action.

`const Action = v.hexColor<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[HexColorIssue](/api/HexColorIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `hexColor` you can validate the formatting of a string. If the input is not a hex color, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[HexColorAction](/api/HexColorAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `hexColor` can be used.

### [](#hex-color-schema)Hex color schema

Schema to validate a hex color.

`const HexColorSchema = v.pipe(   v.string(),   v.hexColor('The hex color is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `hexColor`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#imei)imei
=============

Creates an [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) validation action.

`const Action = v.imei<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ImeiIssue](/api/ImeiIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `imei` you can validate the formatting of a string. If the input is not an imei, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[ImeiAction](/api/ImeiAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `imei` can be used.

### [](#imei-schema)IMEI schema

Schema to validate an IMEI.

`const ImeiSchema = v.pipe(v.string(), v.imei('The imei is badly formatted.'));`

[](#related)Related
-------------------

The following APIs can be combined with `imei`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#includes)includes
=====================

Creates an includes validation action.

`const Action = v.includes<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ContentInput](/api/ContentInput/)`
*   `TRequirement` `extends [ContentRequirement](/api/ContentRequirement/)<[ContentInput](/api/ContentInput/)>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IncludesIssue](/api/IncludesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `includes` you can validate the content of a string or array. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[IncludesAction](/api/IncludesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `includes` can be used.

### [](#string-schema)String schema

Schema to validate that a string contains a specific substring.

`const StringSchema = v.pipe(   v.string(),   v.includes('foo', 'The string must contain "foo".') );`

### [](#array-schema)Array schema

Schema to validate that an array contains a specific string.

`const ArraySchema = v.pipe(   v.array(v.string()),   v.includes('foo', 'The array must contain "foo".') );`

[](#related)Related
-------------------

The following APIs can be combined with `includes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#integer)integer
===================

Creates an [integer](https://en.wikipedia.org/wiki/Integer) validation action.

`const Action = v.integer<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IntegerIssue](/api/IntegerIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `integer` you can validate the value of a number. If the input is not an integer, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[IntegerAction](/api/IntegerAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `integer` can be used.

### [](#integer-schema)Integer schema

Schema to validate an integer.

`const IntegerSchema = v.pipe(   v.number(),   v.integer('The number must be an integer.') );`

[](#related)Related
-------------------

The following APIs can be combined with `integer`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`number`](/api/number/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#ip)ip
=========

Creates an [IP address](https://en.wikipedia.org/wiki/IP_address) validation action.

> This validation action accepts IPv4 and IPv6 addresses. For a more specific validation, you can also use [`ipv4`](/api/ipv4/) or [`ipv6`](/api/ipv6/).

`const Action = v.ip<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IpIssue](/api/IpIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `ip` you can validate the formatting of a string. If the input is not an IP address, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[IpAction](/api/IpAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `ip` can be used.

### [](#ip-address-schema)IP address schema

Schema to validate an IP address.

`const IpAddressSchema = v.pipe(   v.string(),   v.ip('The IP address is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `ip`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#ipv4)ipv4
=============

Creates an [IPv4](https://en.wikipedia.org/wiki/IPv4) address validation action.

`const Action = v.ipv4<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Ipv4Issue](/api/Ipv4Issue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `ipv4` you can validate the formatting of a string. If the input is not an IPv4 address, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[Ipv4Action](/api/Ipv4Action/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `ipv4` can be used.

### [](#ipv4-schema)IPv4 schema

Schema to validate an IPv4 address.

`const Ipv4Schema = v.pipe(   v.string(),   v.ipv4('The IP address is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `ipv4`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#ipv6)ipv6
=============

Creates an [IPv6](https://en.wikipedia.org/wiki/IPv6) address validation action.

`const Action = v.ipv6<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Ipv6Issue](/api/Ipv6Issue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `ipv6` you can validate the formatting of a string. If the input is not an IPv6 address, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[Ipv6Action](/api/Ipv6Action/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `ipv6` can be used.

### [](#ipv6-schema)IPv6 schema

Schema to validate an IPv6 address.

`const Ipv6Schema = v.pipe(   v.string(),   v.ipv6('The IP address is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `ipv6`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#isodate)isoDate
===================

Creates an [ISO date](https://en.wikipedia.org/wiki/ISO_8601) validation action.

Format: `yyyy-mm-dd`

> The regex used cannot validate the maximum number of days based on year and month. For example, "2023-06-31" is valid although June has only 30 days.

`const Action = v.isoDate<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoDateIssue](/api/IsoDateIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `isoDate` you can validate the formatting of a string. If the input is not an ISO date, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[IsoDateAction](/api/IsoDateAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `isoDate` can be used.

### [](#iso-date-schema)ISO date schema

Schema to validate an ISO date.

`const IsoDateSchema = v.pipe(   v.string(),   v.isoDate('The date is badly formatted.') );`

### [](#minimum-value-schema)Minimum value schema

Schema to validate an ISO date is after a certain date.

`const MinValueSchema = v.pipe(   v.string(),   v.isoDate(),   v.minValue('2000-01-01', 'The date must be after the year 1999.') );`

[](#related)Related
-------------------

The following APIs can be combined with `isoDate`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#isodatetime)isoDateTime
===========================

Creates an [ISO date time](https://en.wikipedia.org/wiki/ISO_8601) validation action.

Format: `yyyy-mm-ddThh:mm`

> The regex used cannot validate the maximum number of days based on year and month. For example, "2023-06-31T00:00" is valid although June has only 30 days.

> The regex also allows a space as a separator between the date and time parts instead of the "T" character.

`const Action = v.isoDateTime<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoDateTimeIssue](/api/IsoDateTimeIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `isoDateTime` you can validate the formatting of a string. If the input is not an ISO date time, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[IsoDateTimeAction](/api/IsoDateTimeAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `isoDateTime` can be used.

### [](#iso-date-time-schema)ISO date time schema

Schema to validate an ISO date time.

`const IsoDateTimeSchema = v.pipe(   v.string(),   v.isoDateTime('The date is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `isoDateTime`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#isotime)isoTime
===================

Creates an [ISO time](https://en.wikipedia.org/wiki/ISO_8601) validation action.

Format: `hh:mm`

`const Action = v.isoTime<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoTimeIssue](/api/IsoTimeIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `isoTime` you can validate the formatting of a string. If the input is not an ISO time, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[IsoTimeAction](/api/IsoTimeAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `isoTime` can be used.

### [](#iso-time-schema)ISO time schema

Schema to validate an ISO time.

`const IsoTimeSchema = v.pipe(   v.string(),   v.isoTime('The time is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `isoTime`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#isotimesecond)isoTimeSecond
===============================

Creates an [ISO time second](https://en.wikipedia.org/wiki/ISO_8601) validation action.

Format: `hh:mm:ss`

`const Action = v.isoTimeSecond<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoTimeSecondIssue](/api/IsoTimeSecondIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `isoTimeSecond` you can validate the formatting of a string. If the input is not an ISO time second, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[IsoTimeSecondAction](/api/IsoTimeSecondAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `isoTimeSecond` can be used.

### [](#iso-time-second-schema)ISO time second schema

Schema to validate an ISO time second.

`const IsoTimeSecondSchema = v.pipe(   v.string(),   v.isoTimeSecond('The time is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `isoTimeSecond`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#isotimestamp)isoTimestamp
=============================

Creates an [ISO timestamp](https://en.wikipedia.org/wiki/ISO_8601) validation action.

Formats: `yyyy-mm-ddThh:mm:ss.sssZ`, `yyyy-mm-ddThh:mm:ss.sss±hh:mm`, `yyyy-mm-ddThh:mm:ss.sss±hhmm`

> To support timestamps with lower or higher accuracy, the millisecond specification can be removed or contain up to 9 digits.

> The regex used cannot validate the maximum number of days based on year and month. For example, "2023-06-31T00:00:00.000Z" is valid although June has only 30 days.

> The regex also allows a space as a separator between the date and time parts instead of the "T" character.

`const Action = v.isoTimestamp<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoTimestampIssue](/api/IsoTimestampIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `isoTimestamp` you can validate the formatting of a string. If the input is not an ISO timestamp, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[IsoTimestampAction](/api/IsoTimestampAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `isoTimestamp` can be used.

### [](#iso-timestamp-schema)ISO timestamp schema

Schema to validate an ISO timestamp.

`const IsoTimestampSchema = v.pipe(   v.string(),   v.isoTimestamp('The timestamp is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `isoTimestamp`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#isoweek)isoWeek
===================

Creates an [ISO week](https://en.wikipedia.org/wiki/ISO_8601) validation action.

Format: `yyyy-Www`

> The regex used cannot validate the maximum number of weeks based on the year. For example, "2021W53" is valid although 2021 has only 52 weeks.

`const Action = v.isoWeek<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoWeekIssue](/api/IsoWeekIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `isoWeek` you can validate the formatting of a string. If the input is not an ISO week, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[IsoWeekAction](/api/IsoWeekAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `isoWeek` can be used.

### [](#iso-week-schema)ISO week schema

Schema to validate an ISO week.

`const IsoWeekSchema = v.pipe(   v.string(),   v.isoWeek('The week is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `isoWeek`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#length)length
=================

Creates a length validation action.

`const Action = v.length<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LengthIssue](/api/LengthIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `length` you can validate the length of a string or array. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[LengthAction](/api/LengthAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `length` can be used.

### [](#string-schema)String schema

Schema to validate the length of a string.

`const StringSchema = v.pipe(   v.string(),   v.length(8, 'The string must be 8 characters long.') );`

### [](#array-schema)Array schema

Schema to validate the length of an array.

`const ArraySchema = v.pipe(   v.array(v.number()),   v.length(100, 'The array must contain 100 numbers.') );`

[](#related)Related
-------------------

The following APIs can be combined with `length`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#ltvalue)ltValue
===================

Creates a less than value validation action.

`const Action = v.ltValue<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LtValueIssue](/api/LtValueIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `ltValue` you can validate the value of a string, number, boolean or date. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[LtValueAction](/api/LtValueAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `ltValue` can be used.

### [](#number-schema)Number schema

Schema to validate a number with a less than value.

`const NumberSchema = v.pipe(   v.number(),   v.ltValue(100, 'The number must be less than 100.') );`

### [](#date-schema)Date schema

Schema to validate a date with a less than value.

`const DateSchema = v.pipe(   v.date(),   v.ltValue(     new Date('2000-01-01'),     'The date must be less than 1st January 2000.'   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `ltValue`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#mac)mac
===========

Creates a [MAC address](https://en.wikipedia.org/wiki/MAC_address) validation action.

> This validation action accepts 48-bit and 64-bit MAC addresses. For a more specific validation, you can also use [`mac48`](/api/mac48/) or [`mac64`](/api/mac64/).

`const Action = v.mac<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MacIssue](/api/MacIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `mac` you can validate the formatting of a string. If the input is not a MAC address, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MacAction](/api/MacAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `mac` can be used.

### [](#mac-schema)MAC schema

Schema to validate a MAC address.

`const MacSchema = v.pipe(   v.string(),   v.mac('The MAC address is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `mac`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#mac48)mac48
===============

Creates a 48-bit [MAC address](https://en.wikipedia.org/wiki/MAC_address) validation action.

`const Action = v.mac48<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Mac48Issue](/api/Mac48Issue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `mac48` you can validate the formatting of a string. If the input is not a 48-bit MAC address, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[Mac48Action](/api/Mac48Action/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `mac48` can be used.

### [](#48-bit-mac-schema)48-bit MAC schema

Schema to validate a 48-bit MAC address.

`const Mac48Schema = v.pipe(   v.string(),   v.mac48('The MAC address is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `mac48`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#mac64)mac64
===============

Creates a 64-bit [MAC address](https://en.wikipedia.org/wiki/MAC_address) validation action.

`const Action = v.mac64<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Mac64Issue](/api/Mac64Issue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `mac64` you can validate the formatting of a string. If the input is not a 64-bit MAC address, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[Mac64Action](/api/Mac64Action/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `mac64` can be used.

### [](#64-bit-mac-schema)64-bit MAC schema

Schema to validate a 64-bit MAC address.

`const Mac64Schema = v.pipe(   v.string(),   v.mac64('The MAC address is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `mac64`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#mapitems)mapItems
=====================

Creates a map items transformation action.

`const Action = v.mapItems<TInput, TOutput>(operation);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TOutput` `extends any`

[](#parameters)Parameters
-------------------------

*   `operation` `(item: TInput[number], index: number, array: TInput) => TOutput`

### [](#explanation)Explanation

With `mapItems` you can apply an `operation` to each item in an array to transform it.

[](#returns)Returns
-------------------

*   `Action` `[MapItemsAction](/api/MapItemsAction/)<TInput, TOutput>`

[](#examples)Examples
---------------------

The following examples show how `mapItems` can be used.

### [](#mark-duplicates)Mark duplicates

`const MarkedArraySchema = v.pipe(   v.array(v.string()),   v.mapItems((item, index, array) => {     const isDuplicate = array.indexOf(item) !== index;     return { item, isDuplicate };   }) );`

[](#related)Related
-------------------

The following APIs can be combined with `mapItems`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#maxbytes)maxBytes
=====================

Creates a max [bytes](https://en.wikipedia.org/wiki/Byte) validation action.

`const Action = v.maxBytes<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxBytesIssue](/api/MaxBytesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `maxBytes` you can validate the bytes of a string. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MaxBytesAction](/api/MaxBytesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `maxBytes` can be used.

### [](#max-bytes-schema)Max bytes schema

Schema to validate a string with a maximum of 64 bytes.

`const MaxBytesSchema = v.pipe(   v.string(),   v.maxBytes(64, 'The string must not exceed 64 bytes.') );`

[](#related)Related
-------------------

The following APIs can be combined with `maxBytes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#maxentries)maxEntries
=========================

Creates a max entries validation action.

`const Action = v.maxEntries<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxEntriesIssue](/api/MaxEntriesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `maxEntries` you can validate the number of entries of an object. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MaxEntriesAction](/api/MaxEntriesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `maxEntries` can be used.

### [](#maximum-object-entries)Maximum object entries

Schema to validate an object with a maximum of 5 entries.

`const MaxEntriesSchema = v.pipe(   v.record(v.string(), v.number()),   v.maxEntries(5, 'Object must not exceed 5 entries.') );`

[](#related)Related
-------------------

The following APIs can be combined with `maxEntries`.

### [](#schemas)Schemas

*   [`looseObject`](/api/looseObject/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`variant`](/api/variant/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#maxgraphemes)maxGraphemes
=============================

Creates a max [graphemes](https://en.wikipedia.org/wiki/Grapheme) validation action.

`const Action = v.maxGraphemes<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxGraphemesIssue](/api/MaxGraphemesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `maxGraphemes` you can validate the graphemes of a string. If the input does not match the `requirement`, you can use `message` to customize the error message.

> Hint: The number of characters per grapheme is not limited. You may want to consider combining `maxGraphemes` with [`maxLength`](/api/maxLength/) or [`maxBytes`](/api/maxBytes/) to set a stricter limit.

[](#returns)Returns
-------------------

*   `Action` `[MaxGraphemesAction](/api/MaxGraphemesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `maxGraphemes` can be used.

### [](#max-graphemes-schema)Max graphemes schema

Schema to validate a string with a maximum of 8 graphemes.

`const MaxGraphemesSchema = v.pipe(   v.string(),   v.maxGraphemes(8, 'The string must not exceed 8 graphemes.') );`

[](#related)Related
-------------------

The following APIs can be combined with `maxGraphemes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#maxlength)maxLength
=======================

Creates a max length validation action.

`const Action = v.maxLength<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxLengthIssue](/api/MaxLengthIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `maxLength` you can validate the length of a string or array. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MaxLengthAction](/api/MaxLengthAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `maxLength` can be used.

### [](#maximum-string-length)Maximum string length

Schema to validate a string with a maximum length of 32 characters.

`const MaxStringSchema = v.pipe(   v.string(),   v.maxLength(32, 'The string must not exceed 32 characters.') );`

### [](#maximum-array-length)Maximum array length

Schema to validate an array with a maximum length of 5 items.

`const MaxArraySchema = v.pipe(   v.array(v.number()),   v.maxLength(5, 'The array must not exceed 5 numbers.') );`

[](#related)Related
-------------------

The following APIs can be combined with `maxLength`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#maxsize)maxSize
===================

Creates a max size validation action.

`const Action = v.maxSize<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxSizeIssue](/api/MaxSizeIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `maxSize` you can validate the size of a map, set or blob. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MaxSizeAction](/api/MaxSizeAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `maxSize` can be used.

### [](#blob-size-schema)Blob size schema

Schema to validate a blob with a maximum size of 10 MB.

`const BlobSchema = v.pipe(   v.blob(),   v.maxSize(10 * 1024 * 1024, 'The blob must not exceed 10 MB.') );`

### [](#set-size-schema)Set size schema

Schema to validate a set with a maximum of 8 numbers.

`const SetSchema = v.pipe(   v.set(number()),   v.maxSize(8, 'The set must not exceed 8 numbers.') );`

[](#related)Related
-------------------

The following APIs can be combined with `maxSize`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`blob`](/api/blob/),
*   [`custom`](/api/custom/),
*   [`file`](/api/file/),
*   [`instance`](/api/instance/),
*   [`map`](/api/map/),
*   [`set`](/api/set/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#maxvalue)maxValue
=====================

Creates a max value validation action.

`const Action = v.maxValue<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxValueIssue](/api/MaxValueIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `maxValue` you can validate the value of a string, number, boolean or date. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MaxValueAction](/api/MaxValueAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `maxValue` can be used.

### [](#number-schema)Number schema

Schema to validate a number with a maximum value.

`const NumberSchema = v.pipe(   v.number(),   v.maxValue(100, 'The number must not exceed 100.') );`

### [](#date-schema)Date schema

Schema to validate a date with a maximum year.

`const DateSchema = v.pipe(   v.date(),   v.maxValue(new Date('1999-12-31'), 'The date must not exceed the year 1999.') );`

[](#related)Related
-------------------

The following APIs can be combined with `maxValue`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#maxwords)maxWords
=====================

Creates a max [words](https://en.wikipedia.org/wiki/Word) validation action.

`const Action = v.maxWords<TInput, TLocales, TRequirement, TMessage>(   locales,   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TLocales` `extends Intl.LocalesArgument`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxWordsIssue](/api/MaxWordsIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `locales` `TLocales`
*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `maxWords` you can validate the words of a string based on the specified `locales`. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MaxWordsAction](/api/MaxWordsAction/)<TInput, TLocales, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `maxWords` can be used.

### [](#max-words-schema)Max words schema

Schema to validate a string with a maximum of 300 words.

`const MaxWordsSchema = v.pipe(   v.string(),   v.maxWords('en', 300, 'The string must not exceed 300 words.') );`

[](#related)Related
-------------------

The following APIs can be combined with `maxWords`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#metadata)metadata
=====================

Creates a custom metadata action.

`const Action = v.metadata<TInput, TMetadata>(metadata_);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMetadata` `extends Record<string, unknown>`

[](#parameters)Parameters
-------------------------

*   `metadata_` `TMetadata`

### [](#explanation)Explanation

With `metadata` you can attach custom metadata to a schema. This can be useful when working with AI tools or for documentation purposes.

[](#returns)Returns
-------------------

*   `Action` `[MetadataAction](/api/MetadataAction/)<TInput, TMetadata>`

[](#examples)Examples
---------------------

The following examples show how `metadata` can be used.

### [](#profile-table-schema)Profile table schema

Schema to describe a profile table.

`const ProfileTableSchema = v.pipe(   v.object({     username: v.pipe(v.string(), v.nonEmpty()),     email: v.pipe(v.string(), v.email()),     avatar: v.pipe(v.string(), v.url()),     description: v.pipe(v.string(), v.maxLength(500)),   }),   v.metadata({     table: 'profiles',     primaryKey: 'username',     indexes: ['email'],   }) );`

[](#related)Related
-------------------

The following APIs can be combined with `metadata`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`getMetadata`](/api/getMetadata/),
*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#mimetype)mimeType
=====================

Creates a [MIME type](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/MIME_types) validation action.

`const Action = v.mimeType<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends Blob`
*   `TRequirement` `extends string[]`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MimeTypeIssue](/api/MimeTypeIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `mimeType` you can validate the MIME type of a blob. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MimeTypeAction](/api/MimeTypeAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `mimeType` can be used.

### [](#image-schema)Image schema

Schema to validate an image file.

`const ImageSchema = v.pipe(   v.blob(),   v.mimeType(['image/jpeg', 'image/png'], 'Please select a JPEG or PNG file.') );`

[](#related)Related
-------------------

The following APIs can be combined with `mimeType`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`blob`](/api/blob/),
*   [`custom`](/api/custom/),
*   [`file`](/api/file/),
*   [`instance`](/api/instance/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#minbytes)minBytes
=====================

Creates a min [bytes](https://en.wikipedia.org/wiki/Byte) validation action.

`const Action = v.minBytes<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinBytesIssue](/api/MinBytesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `minBytes` you can validate the bytes of a string. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MinBytesAction](/api/MinBytesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `minBytes` can be used.

### [](#min-bytes-schema)Min bytes schema

Schema to validate a string with a minimum of 64 bytes.

`const MinBytesSchema = v.pipe(   v.string(),   v.minBytes(64, 'The string must contain at least 64 bytes.') );`

[](#related)Related
-------------------

The following APIs can be combined with `minBytes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#minentries)minEntries
=========================

Creates a min entries validation action.

`const Action = v.minEntries<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinEntriesIssue](/api/MinEntriesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `minEntries` you can validate the number of entries of an object. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MinEntriesAction](/api/MinEntriesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `minEntries` can be used.

### [](#minimum-object-entries)Minimum object entries

Schema to validate an object with a minimum of 5 entries.

`const MinEntriesSchema = v.pipe(   v.record(v.string(), v.number()),   v.minEntries(5, 'The object should have at least 5 entries.') );`

[](#related)Related
-------------------

The following APIs can be combined with `minEntries`.

### [](#schemas)Schemas

*   [`looseObject`](/api/looseObject/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`variant`](/api/variant/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#mingraphemes)minGraphemes
=============================

Creates a min [graphemes](https://en.wikipedia.org/wiki/Grapheme) validation action.

`const Action = v.minGraphemes<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinGraphemesIssue](/api/MinGraphemesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `minGraphemes` you can validate the graphemes of a string. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MinGraphemesAction](/api/MinGraphemesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `minGraphemes` can be used.

### [](#min-graphemes-schema)Min graphemes schema

Schema to validate a string with a minimum of 8 graphemes.

`const MinGraphemesSchema = v.pipe(   v.string(),   v.minGraphemes(8, 'The string must contain at least 8 graphemes.') );`

[](#related)Related
-------------------

The following APIs can be combined with `minGraphemes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#minlength)minLength
=======================

Creates a min length validation action.

`const Action = v.minLength<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinLengthIssue](/api/MinLengthIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `minLength` you can validate the length of a string or array. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MinLengthAction](/api/MinLengthAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `minLength` can be used.

### [](#minimum-string-length)Minimum string length

Schema to validate a string with a minimum length of 3 characters.

`const MinStringSchema = v.pipe(   v.string(),   v.minLength(3, 'The string must be 3 or more characters long.') );`

### [](#minimum-array-length)Minimum array length

Schema to validate an array with a minimum length of 5 items.

`const MinArraySchema = v.pipe(   v.array(v.number()),   v.minLength(5, 'The array must contain 5 numbers or more.') );`

[](#related)Related
-------------------

The following APIs can be combined with `minLength`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#minsize)minSize
===================

Creates a min size validation action.

`const Action = v.minSize<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinSizeIssue](/api/MinSizeIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `minSize` you can validate the size of a map, set or blob. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MinSizeAction](/api/MinSizeAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `minSize` can be used.

### [](#blob-size-schema)Blob size schema

Schema to validate a blob with a minimum size of 10 MB.

`const BlobSchema = v.pipe(   v.blob(),   v.minSize(10 * 1024 * 1024, 'The blob must be at least 10 MB.') );`

### [](#set-size-schema)Set size schema

Schema to validate a set with a minimum of 8 numbers.

`const SetSchema = v.pipe(   v.set(number()),   v.minSize(8, 'The set must contain at least 8 numbers.') );`

[](#related)Related
-------------------

The following APIs can be combined with `minSize`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`blob`](/api/blob/),
*   [`custom`](/api/custom/),
*   [`file`](/api/file/),
*   [`instance`](/api/instance/),
*   [`map`](/api/map/),
*   [`set`](/api/set/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#minvalue)minValue
=====================

Creates a min value validation action.

`const Action = v.minValue<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxValueIssue](/api/MaxValueIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `minValue` you can validate the value of a string, number, boolean or date. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MinValueAction](/api/MinValueAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `minValue` can be used.

### [](#number-schema)Number schema

Schema to validate a number with a minimum value.

`const NumberSchema = v.pipe(   v.number(),   v.minValue(100, 'The number must be at least 100.') );`

### [](#date-schema)Date schema

Schema to validate a date with a minimum year.

`const DateSchema = v.pipe(   v.date(),   v.minValue(new Date('2000-01-01'), 'The date must be after the year 1999.') );`

[](#related)Related
-------------------

The following APIs can be combined with `minValue`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#minwords)minWords
=====================

Creates a min [words](https://en.wikipedia.org/wiki/Word) validation action.

`const Action = v.minWords<TInput, TLocales, TRequirement, TMessage>(   locales,   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TLocales` `extends Intl.LocalesArgument`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinWordsIssue](/api/MinWordsIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `locales` `TLocales`
*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `minWords` you can validate the words of a string based on the specified `locales`. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MinWordsAction](/api/MinWordsAction/)<TInput, TLocales, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `minWords` can be used.

### [](#min-words-schema)Min words schema

Schema to validate a string with a minimum of 50 words.

`const MinWordsSchema = v.pipe(   v.string(),   v.minWords('en', 50, 'The string must contain at least 50 words.') );`

[](#related)Related
-------------------

The following APIs can be combined with `minWords`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#multipleof)multipleOf
=========================

Creates a [multiple](https://en.wikipedia.org/wiki/Multiple_\(mathematics\)) of validation action.

`const Action = v.multipleOf<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends number | bigint`
*   `TRequirement` `extends number | bigint`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MultipleOfIssue](/api/MultipleOfIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `multipleOf` you can validate the value of a number. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[MultipleOfAction](/api/MultipleOfAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `multipleOf` can be used.

### [](#even-number-schema)Even number schema

Schema to validate an even number.

`const EvenNumberSchema = v.pipe(   v.number(),   v.multipleOf(2, 'The number must be even.') );`

[](#related)Related
-------------------

The following APIs can be combined with `multipleOf`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`custom`](/api/custom/),
*   [`number`](/api/number/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#nanoid)nanoid
=================

Creates a [Nano ID](https://github.com/ai/nanoid) validation action.

`const Action = v.nanoid<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NanoIdIssue](/api/NanoIdIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `nanoid` you can validate the formatting of a string. If the input is not an Nano ID, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NanoIdAction](/api/NanoIdAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `nanoid` can be used.

> Since Nano IDs are not limited to a fixed length, it is recommended to combine `nanoid` with [`length`](/api/length/) to ensure the correct length.

### [](#nano-id-schema)Nano ID schema

Schema to validate a Nano ID.

`const NanoIdSchema = v.pipe(   v.string(),   v.nanoid('The Nano ID is badly formatted.'),   v.length(21, 'The Nano ID must be 21 characters long.') );`

[](#related)Related
-------------------

The following APIs can be combined with `nanoid`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#nonempty)nonEmpty
=====================

Creates a non-empty validation action.

`const Action = v.nonEmpty<TInput, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonEmptyIssue](/api/NonEmptyIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `nonEmpty` you can validate that a string or array is non-empty. If the input is empty, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NonEmptyAction](/api/NonEmptyAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `nonEmpty` can be used.

### [](#string-schema)String schema

Schema to validate that a string is non-empty.

`const StringSchema = v.pipe(   v.string(),   v.nonEmpty('The string should contain at least one character.') );`

### [](#array-schema)Array schema

Schema to validate that an array is non-empty.

`const ArraySchema = v.pipe(   v.array(v.number()),   v.nonEmpty('The array should contain at least one item.') );`

[](#related)Related
-------------------

The following APIs can be combined with `nonEmpty`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#normalize)normalize
=======================

Creates a normalize transformation action.

`const Action = v.normalize<TForm>(form);`

[](#generics)Generics
---------------------

*   `TForm` `extends [NormalizeForm](/api/NormalizeForm/) | undefined`

[](#parameters)Parameters
-------------------------

*   `form` `TForm`

[](#returns)Returns
-------------------

*   `Action` `[NormalizeAction](/api/NormalizeAction/)`

[](#examples)Examples
---------------------

The following examples show how `normalize` can be used.

### [](#normalized-string)Normalized string

Schema to normalize a string.

`const StringSchema = v.pipe(v.string(), v.normalize());`

[](#related)Related
-------------------

The following APIs can be combined with `normalize`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#notbytes)notBytes
=====================

Creates a not [bytes](https://en.wikipedia.org/wiki/Byte) validation action.

`const Action = v.notBytes<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotBytesIssue](/api/NotBytesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `notBytes` you can validate the bytes of a string. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NotBytesAction](/api/NotBytesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `notBytes` can be used.

### [](#not-bytes-schema)Not bytes schema

Schema to validate a string with more or less than 8 bytes.

`const NotBytesSchema = v.pipe(   v.string(),   v.notBytes(8, 'The string must not have 8 bytes.') );`

[](#related)Related
-------------------

The following APIs can be combined with `notBytes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#notentries)notEntries
=========================

Creates a not entries validation action.

`const Action = v.notEntries<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotEntriesIssue](/api/NotEntriesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `notEntries` you can validate the number of entries of an object. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NotEntriesAction](/api/NotEntriesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `notEntries` can be used.

### [](#not-object-entries)Not object entries

Schema to validate an object that does not have 5 entries.

`const NotEntriesSchema = v.pipe(   v.record(v.string(), v.number()),   v.notEntries(5, 'Object must not have 5 entries') );`

[](#related)Related
-------------------

The following APIs can be combined with `notEntries`.

### [](#schemas)Schemas

*   [`looseObject`](/api/looseObject/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`variant`](/api/variant/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#notgraphemes)notGraphemes
=============================

Creates a not [graphemes](https://en.wikipedia.org/wiki/Grapheme) validation action.

`const Action = v.notGraphemes<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotGraphemesIssue](/api/NotGraphemesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `notGraphemes` you can validate the graphemes of a string. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NotGraphemesAction](/api/NotGraphemesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `notGraphemes` can be used.

### [](#not-graphemes-schema)Not graphemes schema

Schema to validate a string with more or less than 8 graphemes.

`const NotGraphemesSchema = v.pipe(   v.string(),   v.notGraphemes(8, 'The string must not have 8 graphemes.') );`

[](#related)Related
-------------------

The following APIs can be combined with `notGraphemes`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#notlength)notLength
=======================

Creates a not length validation action.

`const Action = v.notLength<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotLengthIssue](/api/NotLengthIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `notLength` you can validate the length of a string or array. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NotLengthAction](/api/NotLengthAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `notLength` can be used.

### [](#string-schema)String schema

Schema to validate the length of a string.

`const StringSchema = v.pipe(   v.string(),   v.notLength(8, 'The string must not be 8 characters long.') );`

### [](#array-schema)Array schema

Schema to validate the length of an array.

`const ArraySchema = v.pipe(   v.array(number()),   v.notLength(10, 'The array must not contain 10 numbers.') );`

[](#related)Related
-------------------

The following APIs can be combined with `notLength`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#notsize)notSize
===================

Creates a not size validation action.

`const Action = v.notSize<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotSizeIssue](/api/NotSizeIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `notSize` you can validate the size of a map, set or blob. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NotSizeAction](/api/NotSizeAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `notSize` can be used.

### [](#blob-size-schema)Blob size schema

Schema to validate a blob with less ore more then 10 MB.

`const BlobSchema = v.pipe(   v.blob(),   v.notSize(10 * 1024 * 1024, 'The blob must not be 10 MB in size.') );`

### [](#set-size-schema)Set size schema

Schema to validate a set with less ore more then 8 numbers.

`const SetSchema = v.pipe(   v.set(number()),   v.notSize(8, 'The set must not contain 8 numbers.') );`

[](#related)Related
-------------------

The following APIs can be combined with `notSize`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`blob`](/api/blob/),
*   [`custom`](/api/custom/),
*   [`file`](/api/file/),
*   [`instance`](/api/instance/),
*   [`map`](/api/map/),
*   [`set`](/api/set/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#notvalue)notValue
=====================

Creates a not value validation action.

`const Action = v.notValue<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotValueIssue](/api/NotValueIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `notValue` you can validate the value of a string, number, boolean or date. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NotValueAction](/api/NotValueAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `notValue` can be used.

### [](#number-schema)Number schema

Schema to validate a number that is more or less than 100.

`const NumberSchema = v.pipe(   v.number(),   v.notValue(100, 'The number must not be 100.') );`

### [](#date-schema)Date schema

Schema to validate a date that is before or after the start of 2000.

`const DateSchema = v.pipe(   v.date(),   v.notValue(new Date('2000-01-01'), 'The date must not be the start of 2000.') );`

[](#related)Related
-------------------

The following APIs can be combined with `notValue`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#notvalues)notValues
=======================

Creates a not values validation action.

`const Action = v.notValues<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends readonly TInput[]`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotValuesIssue](/api/NotValuesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `notValues` you can validate the value of a string, number, boolean or date. If the input matches one of the values in the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NotValuesAction](/api/NotValuesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `notValues` can be used.

### [](#number-schema)Number schema

Schema to validate a number that is not 10, 11 or 12.

`const NumberSchema = v.pipe(   v.number(),   v.notValues([10, 11, 12], 'The number must not be 10, 11 or 12.') );`

[](#related)Related
-------------------

The following APIs can be combined with `notValues`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#notwords)notWords
=====================

Creates a not [words](https://en.wikipedia.org/wiki/Word) validation action.

`const Action = v.notWords<TInput, TLocales, TRequirement, TMessage>(   locales,   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TLocales` `extends Intl.LocalesArgument`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotWordsIssue](/api/NotWordsIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `locales` `TLocales`
*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `notWords` you can validate the words of a string based on the specified `locales`. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[NotWordsAction](/api/NotWordsAction/)<TInput, TLocales, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `notWords` can be used.

### [](#not-words-schema)Not words schema

Schema to validate a string with more or less than 5 words.

`const NotWordsSchema = v.pipe(   v.string(),   v.notWords('en', 5, 'The string must not have 5 words.') );`

[](#related)Related
-------------------

The following APIs can be combined with `notWords`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#octal)octal
===============

Creates an [octal](https://en.wikipedia.org/wiki/Octal) validation action.

`const Action = v.octal<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[OctalIssue](/api/OctalIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `octal` you can validate the formatting of a string. If the input is not an octal, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[OctalAction](/api/OctalAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `octal` can be used.

### [](#octal-schema)Octal schema

Schema to validate a octal string.

`const OctalSchema = v.pipe(   v.string(),   v.octal('The octal is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `octal`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#parsejson)parseJson
=======================

Creates a JSON parse transformation action.

`const Action = v.parseJson<TInput, TConfig, TMessage>(config, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TConfig` `extends [ParseJsonConfig](/api/ParseJsonConfig/) | undefined`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ParseJsonIssue](/api/ParseJsonIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `config` `TConfig`
*   `message` `TMessage`

### [](#explanation)Explanation

With `parseJson` you can parse a JSON string. If the input is not valid JSON, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[ParseJsonAction](/api/ParseJsonAction/)<TInput, TConfig, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `parseJson` can be used.

### [](#parse-and-validate-json)Parse and validate JSON

Parse a JSON string and validate the result.

`const StringifiedObjectSchema = v.pipe(   v.string(),   v.parseJson(),   v.object({ key: v.string() }) );`

### [](#parse-json-with-reviver)Parse JSON with reviver

Parse a JSON string with a reviver function.

`const StringifiedObjectSchema = v.pipe(   v.string(),   v.parseJson({     reviver: (key, value) =>       typeof value === 'string' ? value.toUpperCase() : value,   }),   v.object({ key: v.string() }) );`

[](#related)Related
-------------------

The following APIs can be combined with `parseJson`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#partialcheck)partialCheck
=============================

Creates a partial check validation action.

`const Action = v.partialCheck<TInput, TPaths, TSelection, TMessage>(   paths,   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends Record<string, unknown> | ArrayLike<unknown>`
*   `TPaths` `extends [RequiredPaths](/api/RequiredPaths/)`
*   `TSelection` `extends [DeepPickN](/api/DeepPickN/)<TInput, TPaths>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[PartialCheckIssue](/api/PartialCheckIssue/)<TSelection>> | undefined`

[](#parameters)Parameters
-------------------------

*   `paths` `[ValidPaths](/api/ValidPaths/)<TInput, TPaths>`
*   `requirement` `(input: TSelection) => boolean`
*   `message` `TMessage`

### [](#explanation)Explanation

With `partialCheck` you can freely validate the selected input and return `true` if it is valid or `false` otherwise. If the input does not match your `requirement`, you can use `message` to customize the error message.

> The difference to [`check`](/api/check/) is that `partialCheck` can be executed whenever the selected part of the data is valid, while [`check`](/api/check/) is executed only when the entire dataset is typed. This can be an important advantage when working with forms.

[](#returns)Returns
-------------------

*   `Action` `[PartialCheckAction](/api/PartialCheckAction/)<TInput, TPaths, TSelection, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `partialCheck` can be used.

### [](#register-schema)Register schema

Schema that ensures that the two passwords match.

`const RegisterSchema = v.pipe(   v.object({     email: v.pipe(       v.string(),       v.nonEmpty('Please enter your email.'),       v.email('The email address is badly formatted.')     ),     password1: v.pipe(       v.string(),       v.nonEmpty('Please enter your password.'),       v.minLength(8, 'Your password must have 8 characters or more.')     ),     password2: v.string(),   }),   v.forward(     v.partialCheck(       [['password1'], ['password2']],       (input) => input.password1 === input.password2,       'The two passwords do not match.'     ),     ['password2']   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `partialCheck`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`union`](/api/union/),
*   [`variant`](/api/variant/)

### [](#methods)Methods

*   [`forward`](/api/forward/),
*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#rawcheck)rawCheck
=====================

Creates a raw check validation action.

`const Action = v.rawCheck<TInput>(action);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#parameters)Parameters
-------------------------

*   `action` `(context: [Context](/api/rawCheck/Context/)<TInput>) => void`

### [](#explanation)Explanation

With `rawCheck` you can freely validate the input with a custom `action` and add issues if necessary.

[](#returns)Returns
-------------------

*   `Action` `[RawCheckAction](/api/RawCheckAction/)<TInput>`

[](#examples)Examples
---------------------

The following examples show how `rawCheck` can be used.

### [](#emails-schema)Emails schema

Object schema that ensures that the primary email is not the same as any of the other emails.

> This `rawCheck` validation action adds an issue for any invalid other email and forwards it via `path` to the appropriate nested field.

`const EmailsSchema = v.pipe(   v.object({     primaryEmail: v.pipe(v.string(), v.email()),     otherEmails: v.array(v.pipe(v.string(), v.email())),   }),   v.rawCheck(({ dataset, addIssue }) => {     if (dataset.typed) {       dataset.value.otherEmails.forEach((otherEmail, index) => {         if (otherEmail === dataset.value.primaryEmail) {           addIssue({             message: 'This email is already being used as the primary email.',             path: [               {                 type: 'object',                 origin: 'value',                 input: dataset.value,                 key: 'otherEmails',                 value: dataset.value.otherEmails,               },               {                 type: 'array',                 origin: 'value',                 input: dataset.value.otherEmails,                 key: index,                 value: otherEmail,               },             ],           });         }       });     }   }) );`

[](#related)Related
-------------------

The following APIs can be combined with `rawCheck`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`forward`](/api/forward/),
*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#rawtransform)rawTransform
=============================

Creates a raw transformation action.

`const Action = v.rawTransform<TInput, TOutput>(action);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#parameters)Parameters
-------------------------

*   `action` `(context: [Context](/api/rawTransform/Context/)<TInput>) => TOutput`

### [](#explanation)Explanation

With `rawTransform` you can freely transform and validate the input with a custom `action` and add issues if necessary.

[](#returns)Returns
-------------------

*   `Action` `[RawTransformAction](/api/RawTransformAction/)<TInput, TOutput>`

[](#examples)Examples
---------------------

The following examples show how `rawTransform` can be used.

### [](#calculate-game-result)Calculate game result

Schema that calculates the total score of a game based on the scores and a multiplier.

> This `rawTransform` validation action adds an issue for points that exceed a certain maximum and forwards it via `path` to the appropriate nested score.

`const GameResultSchema = v.pipe(   v.object({     scores: v.array(v.pipe(v.number(), v.integer())),     multiplier: v.number(),   }),   v.rawTransform(({ dataset, addIssue, NEVER }) => {     // Create total variable     let total = 0;      // Iterate over scores and check points     for (let index = 0; index < dataset.value.scores.length; index++) {       // Calculate points by multiplying score with multiplier       const score = dataset.value.scores[index];       const points = score * dataset.value.multiplier;        // Add issue if points exceed maximum of 1,000 points       if (points > 1_000) {         addIssue({           message:             'The score exceeds the maximum allowed value of 1,000 points.',           path: [             {               type: 'object',               origin: 'value',               input: dataset.value,               key: 'scores',               value: dataset.value.scores,             },             {               type: 'array',               origin: 'value',               input: dataset.value.scores,               key: index,               value: score,             },           ],         });          // Abort transformation         return NEVER;       }        // Add points to total       total += points;     }      // Add calculated total to dataset     return { ...dataset.value, total };   }) );`

[](#related)Related
-------------------

The following APIs can be combined with `rawTransform`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`forward`](/api/forward/),
*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#readonly)readonly
=====================

Creates a readonly transformation action.

`const Action = v.readonly<TInput>();`

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#returns)Returns
-------------------

*   `Action` `[ReadonlyAction](/api/ReadonlyAction/)<TInput>`

[](#examples)Examples
---------------------

The following examples show how `readonly` can be used.

### [](#readonly-array)Readonly array

Schema for a readonly array of numbers.

`const ArraySchema = v.pipe(v.array(v.number()), v.readonly());`

### [](#readonly-entry)Readonly entry

Object schema with an entry marked as readonly.

`const ObjectSchema = v.object({   name: v.string(),   username: v.pipe(v.string(), v.readonly()),   age: v.number(), });`

[](#related)Related
-------------------

The following APIs can be combined with `readonly`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#reduceitems)reduceItems
===========================

Creates a reduce items transformation action.

`const Action = v.reduceItems<TInput, TOutput>(operation, initial);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TOutput` `extends any`

[](#parameters)Parameters
-------------------------

*   `operation` `(output: TOutput, item: TInput[number], index: number, array: TInput) => TOutput`
*   `initial` `TOutput`

### [](#explanation)Explanation

With `reduceItems` you can apply an `operation` to each item in an array to reduce it to a single value.

[](#returns)Returns
-------------------

*   `Action` `[ReduceItemsAction](/api/ReduceItemsAction/)<TInput, TOutput>`

[](#examples)Examples
---------------------

The following examples show how `reduceItems` can be used.

### [](#sum-all-numbers)Sum all numbers

Schema that sums all the numbers in an array.

`const SumArraySchema = v.pipe(   v.array(v.number()),   v.reduceItems((sum, item) => sum + item, 0) );`

[](#related)Related
-------------------

The following APIs can be combined with `reduceItems`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#regex)regex
===============

Creates a [regex](https://en.wikipedia.org/wiki/Regular_expression) validation action.

`const Action = v.regex<TInput, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[RegexIssue](/api/RegexIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `RegExp`
*   `message` `TMessage`

### [](#explanation)Explanation

With `regex` you can validate the formatting of a string. If the input does not match the `requirement`, you can use `message` to customize the error message.

> Hint: Be careful with the global flag `g` in your regex pattern, as it can lead to unexpected results. See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test#using_test_on_a_regex_with_the_global_flag) for more information.

[](#returns)Returns
-------------------

*   `Action` `[RegexAction](/api/RegexAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `regex` can be used.

### [](#pixel-string-schema)Pixel string schema

Schema to validate a pixel string.

`const PixelStringSchema = v.pipe(   v.string(),   v.regex(/^\d+px$/, 'The pixel string is badly formatted.') );`

[](#related)Related
-------------------

The following APIs can be combined with `regex`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#returns)returns
===================

Creates a function return transformation action.

`const Action = v.returns<TInput, TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TInput` `extends (...args: any[]) => unknown`
*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

### [](#explanation)Explanation

With `returns` you can force the returned value of a function to match the given `schema`.

[](#returns-1)Returns
---------------------

*   `Action` `[ReturnsAction](/api/ReturnsAction/)<TInput, TSchema>`

[](#examples)Examples
---------------------

The following examples show how `returns` can be used.

### [](#function-schema)Function schema

Schema of a function that transforms a string to a number.

`const FunctionSchema = v.pipe(   v.function(),   v.args(v.tuple([v.pipe(v.string(), v.decimal())])),   v.returns(v.number()) );`

[](#related)Related
-------------------

The following APIs can be combined with `returns`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#rfcemail)rfcEmail
=====================

Creates a [RFC email](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) validation action.

`const Action = v.rfcEmail<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[RfcEmailIssue](/api/RfcEmailIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `rfcEmail` you can validate the formatting of a string. If the input is not an email, you can use `message` to customize the error message.

> This validation action intentionally validates the entire RFC 5322 specification. If you are interested in an action that only covers common email addresses, please use the [`email`](/api/email/) action instead.

[](#returns)Returns
-------------------

*   `Action` `[RfcEmailAction](/api/RfcEmailAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `rfcEmail` can be used.

### [](#email-schema)Email schema

Schema to validate an email.

`const EmailSchema = v.pipe(   v.string(),   v.nonEmpty('Please enter your email.'),   v.rfcEmail('The email is badly formatted.'),   v.maxLength(30, 'Your email is too long.') );`

[](#related)Related
-------------------

The following APIs can be combined with `rfcEmail`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#safeinteger)safeInteger
===========================

Creates a safe integer validation action.

`const Action = v.safeInteger<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SafeIntegerIssue](/api/SafeIntegerIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `safeInteger` you can validate the value of a number. If the input is not a safe integer, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[SafeIntegerAction](/api/SafeIntegerAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `safeInteger` can be used.

### [](#safe-integer-schema)Safe integer schema

Schema to validate an safe integer.

`const SafeIntegerSchema = v.pipe(   v.number(),   v.safeInteger('The number must be a safe integer.') );`

[](#related)Related
-------------------

The following APIs can be combined with `safeInteger`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`number`](/api/number/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#size)size
=============

Creates a size validation action.

`const Action = v.size<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SizeIssue](/api/SizeIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `size` you can validate the size of a map, set or blob. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[SizeAction](/api/SizeAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `size` can be used.

### [](#blob-size-schema)Blob size schema

Schema to validate a blob with a size of 256 bytes.

`const BlobSchema = v.pipe(   v.blob(),   v.size(256, 'The blob must be 256 bytes in size.') );`

### [](#set-size-schema)Set size schema

Schema to validate a set of 8 numbers.

`const SetSchema = v.pipe(   v.set(number()),   v.size(8, 'The set must contain 8 numbers.') );`

[](#related)Related
-------------------

The following APIs can be combined with `size`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#slug)slug
=============

Creates an [slug](https://en.wikipedia.org/wiki/Clean_URL#Slug) validation action.

`const Action = v.slug<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SlugIssue](/api/SlugIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `slug` you can validate the formatting of a string. If the input is not a URL slug, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[SlugAction](/api/SlugAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `slug` can be used.

### [](#slug-schema)Slug schema

Schema to validate a slug.

`const SlugSchema = v.pipe(   v.string(),   v.nonEmpty('Please provide a slug.'),   v.slug('The slug is badly formatted.'),   v.maxLength(100, 'Your slug is too long.') );`

[](#related)Related
-------------------

The following APIs can be combined with `slug`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#someitem)someItem
=====================

Creates a some item validation action.

`const Action = v.someItem<TInput, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SomeItemIssue](/api/SomeItemIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`
*   `message` `TMessage`

### [](#explanation)Explanation

With `someItem` you can freely validate the items of an array and return `true` if they are valid or `false` otherwise. If not some item matches your `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[SomeItemAction](/api/SomeItemAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `someItem` can be used.

### [](#unsorted-array-schema)Unsorted array schema

Schema to validate that an array is not sorted.

`const UnsortedArraySchema = v.pipe(   v.array(v.number()),   v.someItem(     (item, index, array) => array.length === 1 || item < array[index - 1],     'The numbers must not be sorted in ascending order.'   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `someItem`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#sortitems)sortItems
=======================

Creates a sort items transformation action.

`const Action = v.sortItems<TInput>(operation);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#parameters)Parameters
-------------------------

*   `operation` `((itemA: TInput[number], itemB: TInput[number]) => number) | undefined`

### [](#explanation)Explanation

With `sortItems` you can sort the items of an array based on a custom `operation`. This is a function that takes two items and returns a number. If the number is less than 0, the first item is sorted before the second item. If the number is greater than 0, the second item is sorted before the first. If the number is 0, the order of the items is not changed.

[](#returns)Returns
-------------------

*   `Action` `[SortItemsAction](/api/SortItemsAction/)<TInput>`

[](#examples)Examples
---------------------

The following examples show how `sortItems` can be used.

### [](#sort-numbers)Sort numbers

Schema that sorts the numbers in an array in ascending order.

`const SortedArraySchema = v.pipe(v.array(v.number()), v.sortItems());`

[](#related)Related
-------------------

The following APIs can be combined with `sortItems`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#startswith)startsWith
=========================

Creates a starts with validation action.

`const Action = v.startsWith<TInput, TRequirement, TMessage>(   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StartsWithIssue](/api/StartsWithIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `startsWith` you can validate the start of a string. If the start does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[StartsWithAction](/api/StartsWithAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `startsWith` can be used.

### [](#https-url-schema)HTTPS URL schema

Schema to validate a HTTPS URL.

`const HttpsUrlSchema = v.pipe(v.string(), v.url(), v.startsWith('https://'));`

[](#related)Related
-------------------

The following APIs can be combined with `startsWith`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#stringifyjson)stringifyJson
===============================

Creates a JSON stringify transformation action.

`const Action = v.stringifyJson<TInput, TConfig, TMessage>(config, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TConfig` `extends [StringifyJsonConfig](/api/StringifyJsonConfig/) | undefined`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StringifyJsonIssue](/api/StringifyJsonIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `config` `TConfig`
*   `message` `TMessage`

### [](#explanation)Explanation

With `stringifyJson` you can stringify a JSON object. If the input is unable to be stringified, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[StringifyJsonAction](/api/StringifyJsonAction/)<TInput, TConfig, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `stringifyJson` can be used.

### [](#stringify-json)Stringify JSON

Stringify a JSON object.

`const StringifiedObjectSchema = v.pipe(   v.object({ key: v.string() }),   v.stringifyJson() );`

### [](#stringify-json-with-replacer)Stringify JSON with replacer

Stringify a JSON object with a replacer function.

`const StringifiedObjectSchema = v.pipe(   v.object({ key: v.string() }),   v.stringifyJson({     replacer: (key, value) =>       typeof value === 'string' ? value.toUpperCase() : value,   }) );`

[](#related)Related
-------------------

The following APIs can be combined with `stringifyJson`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`picklist`](/api/picklist/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#title)title
===============

Creates a title metadata action.

`const Action = v.title<TInput, TTitle>(title_);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TTitle` `extends string`

[](#parameters)Parameters
-------------------------

*   `title_` `TTitle`

### [](#explanation)Explanation

With `title` you can give a title to a schema. This can be useful when working with AI tools or for documentation purposes.

[](#returns)Returns
-------------------

*   `Action` `[TitleAction](/api/TitleAction/)<TInput, TTitle>`

[](#examples)Examples
---------------------

The following examples show how `title` can be used.

### [](#username-schema)Username schema

Schema to validate a user name.

`const UsernameSchema = v.pipe(   v.string(),   v.regex(/^[a-z0-9_-]{4,16}$/iu),   v.title('Username'),   v.description(     'A username must be between 4 and 16 characters long and can only contain letters, numbers, underscores and hyphens.'   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `title`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`getTitle`](/api/getTitle/),
*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#tolowercase)toLowerCase
===========================

Creates a to lower case transformation action.

`const Action = v.toLowerCase();`

[](#returns)Returns
-------------------

*   `Action` `[ToLowerCaseAction](/api/ToLowerCaseAction/)`

[](#examples)Examples
---------------------

The following examples show how `toLowerCase` can be used.

### [](#lower-case-string)Lower case string

Schema that transforms a string to lower case.

`const StringSchema = v.pipe(v.string(), v.toLowerCase());`

[](#related)Related
-------------------

The following APIs can be combined with `toLowerCase`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#tomaxvalue)toMaxValue
=========================

Creates a to max value transformation action.

`const Action = v.toMaxValue<TInput, TRequirement>(requirement);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`

### [](#explanation)Explanation

With `toMaxValue` you can enforce a maximum value for a number, date or string. If the input does not meet the `requirement`, it will be changed to its value.

[](#returns)Returns
-------------------

*   `Action` `[ToMaxValueAction](/api/ToMaxValueAction/)<TInput, TRequirement>`

[](#examples)Examples
---------------------

The following examples show how `toMaxValue` can be used.

### [](#number-schema)Number schema

Schema to enforce a maximum value for a number.

`const NumberSchema = v.pipe(v.number(), v.toMaxValue(100));`

### [](#date-schema)Date schema

Schema to enforce a maximum value for a date.

`const DateSchema = v.pipe(v.date(), v.toMaxValue(new Date('1999-12-31')));`

[](#related)Related
-------------------

The following APIs can be combined with `toMaxValue`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#tominvalue)toMinValue
=========================

Creates a to min value transformation action.

`const Action = v.toMinValue<TInput, TRequirement>(requirement);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`

### [](#explanation)Explanation

With `toMinValue` you can enforce a minimum value for a number, date or string. If the input does not meet the `requirement`, it will be changed to its value.

[](#returns)Returns
-------------------

*   `Action` `[ToMinValueAction](/api/ToMinValueAction/)<TInput, TRequirement>`

[](#examples)Examples
---------------------

The following examples show how `toMinValue` can be used.

### [](#number-schema)Number schema

Schema to enforce a minimum value for a number.

`const NumberSchema = v.pipe(v.number(), v.toMinValue(100));`

### [](#date-schema)Date schema

Schema to enforce a minimum value for a date.

`const DateSchema = v.pipe(v.date(), v.toMinValue(new Date('1999-12-31')));`

[](#related)Related
-------------------

The following APIs can be combined with `toMinValue`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#touppercase)toUpperCase
===========================

Creates a to upper case transformation action.

`const Action = v.toUpperCase();`

[](#returns)Returns
-------------------

*   `Action` `[ToUpperCaseAction](/api/ToUpperCaseAction/)`

[](#examples)Examples
---------------------

The following examples show how `toUpperCase` can be used.

### [](#lower-case-string)Lower case string

Schema that transforms a string to upper case.

`const StringSchema = v.pipe(v.string(), v.toUpperCase());`

[](#related)Related
-------------------

The following APIs can be combined with `toUpperCase`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#transform)transform
=======================

Creates a custom transformation action.

`const Action = v.transform<TInput, TOutput>(action);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#parameters)Parameters
-------------------------

*   `action` `(input: TInput) => TOutput`

### [](#explanation)Explanation

`transform` can be used to freely transform the input. The `action` parameter is a function that takes the input and returns the transformed output.

[](#returns)Returns
-------------------

*   `Action` `[TransformAction](/api/TransformAction/)<TInput, TOutput>`

[](#examples)Examples
---------------------

The following examples show how `transform` can be used.

### [](#transform-to-length)Transform to length

Schema that transforms a string to its length.

`const StringLengthSchema = v.pipe(   v.string(),   v.transform((input) => input.length) );`

### [](#add-object-entry)Add object entry

Schema that transforms an object to add an entry.

`const UserSchema = v.pipe(   v.object({ name: v.string(), age: v.number() }),   v.transform((input) => ({     ...input,     created: new Date().toISOString(),   })) );`

[](#related)Related
-------------------

The following APIs can be combined with `transform`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#trim)trim
=============

Creates a trim transformation action.

`const Action = v.trim();`

[](#returns)Returns
-------------------

*   `Action` `[TrimAction](/api/TrimAction/)`

[](#examples)Examples
---------------------

The following examples show how `trim` can be used.

### [](#trimmed-string)Trimmed string

Schema to trim the start and end of a string.

`const StringSchema = v.pipe(v.string(), v.trim());`

[](#related)Related
-------------------

The following APIs can be combined with `trim`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#trimend)trimEnd
===================

Creates a trim end transformation action.

`const Action = v.trimEnd();`

[](#returns)Returns
-------------------

*   `Action` `[TrimEndAction](/api/TrimEndAction/)`

[](#examples)Examples
---------------------

The following examples show how `trimEnd` can be used.

### [](#trimmed-string)Trimmed string

Schema to trimEnd the end of a string.

`const StringSchema = v.pipe(v.string(), v.trimEnd());`

[](#related)Related
-------------------

The following APIs can be combined with `trimEnd`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#trimstart)trimStart
=======================

Creates a trim start transformation action.

`const Action = v.trimStart();`

[](#returns)Returns
-------------------

*   `Action` `[TrimStartAction](/api/TrimStartAction/)`

[](#examples)Examples
---------------------

The following examples show how `trimStart` can be used.

### [](#trimmed-string)Trimmed string

Schema to trimStart the start of a string.

`const StringSchema = v.pipe(v.string(), v.trimStart());`

[](#related)Related
-------------------

The following APIs can be combined with `trimStart`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#ulid)ulid
=============

Creates an [ULID](https://github.com/ulid/spec) validation action.

`const Action = v.ulid<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UlidIssue](/api/UlidIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `ulid` you can validate the formatting of a string. If the input is not an ULID, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[UlidAction](/api/UlidAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `ulid` can be used.

### [](#ulid-schema)ULID schema

Schema to validate an ULID.

`const UlidSchema = v.pipe(v.string(), v.ulid('The ULID is badly formatted.'));`

[](#related)Related
-------------------

The following APIs can be combined with `ulid`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#url)url
===========

Creates an [URL](https://en.wikipedia.org/wiki/URL) validation action.

`const Action = v.url<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UrlIssue](/api/UrlIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `url` you can validate the formatting of a string. If the input is not an URL, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[UrlAction](/api/UrlAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `url` can be used.

### [](#url-schema)URL schema

Schema to validate an URL.

`const UrlSchema = v.pipe(   v.string(),   v.nonEmpty('Please enter your url.'),   v.url('The url is badly formatted.'),   v.endsWith('.com', 'Only ".com" domains are allowed.') );`

[](#related)Related
-------------------

The following APIs can be combined with `url`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#uuid)uuid
=============

Creates an [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) validation action.

`const Action = v.uuid<TInput, TMessage>(message);`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UuidIssue](/api/UuidIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `message` `TMessage`

### [](#explanation)Explanation

With `uuid` you can validate the formatting of a string. If the input is not an UUID, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[UuidAction](/api/UuidAction/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `uuid` can be used.

### [](#uuid-schema)UUID schema

Schema to validate an UUID.

`const UuidSchema = v.pipe(v.string(), v.uuid('The UUID is badly formatted.'));`

[](#related)Related
-------------------

The following APIs can be combined with `uuid`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#value)value
===============

Creates a value validation action.

`const Action = v.value<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ValueIssue](/api/ValueIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `value` you can validate the value of a string, number, boolean or date. If the input does not match the `requirement`, you can use `message` to customize the error message.

> This action does not change the type of the pipeline. Use the [`literal`](/api/literal/) schema instead if you want the type to match a specific value.

[](#returns)Returns
-------------------

*   `Action` `[ValueAction](/api/ValueAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `value` can be used.

### [](#number-schema)Number schema

Schema to validate a number with a specific value.

`const NumberSchema = v.pipe(   v.number(),   v.value(100, 'The number must be 100.') );`

### [](#date-schema)Date schema

Schema to validate a date with a specific value.

`const DateSchema = v.pipe(   v.date(),   v.value(new Date('2000-01-01'), 'The date must be the first day of 2000.') );`

[](#related)Related
-------------------

The following APIs can be combined with `value`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#values)values
=================

Creates a values validation action.

`const Action = v.values<TInput, TRequirement, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends readonly TInput[]`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ValuesIssue](/api/ValuesIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `values` you can validate the value of a string, number, boolean or date. If the input does not match one of the values in the `requirement`, you can use `message` to customize the error message.

> This action does not change the type of the pipeline. Use the [`picklist`](/api/picklist/) schema instead if you want the type to match the union of specific values.

[](#returns)Returns
-------------------

*   `Action` `[ValuesAction](/api/ValuesAction/)<TInput, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `values` can be used.

### [](#number-schema)Number schema

Schema to validate a number with specific values.

`const NumberSchema = v.pipe(   v.number(),   v.values([5, 15, 20], 'The number must be one of the allowed numbers.') );`

[](#related)Related
-------------------

The following APIs can be combined with `values`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`number`](/api/number/),
*   [`string`](/api/string/),
*   [`unknown`](/api/unknown/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#words)words
===============

Creates a [words](https://en.wikipedia.org/wiki/Word) validation action.

`const Action = v.words<TInput, TLocales, TRequirement, TMessage>(   locales,   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TLocales` `extends Intl.LocalesArgument`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[WordsIssue](/api/WordsIssue/)<TInput, TRequirement>> | undefined`

[](#parameters)Parameters
-------------------------

*   `locales` `TLocales`
*   `requirement` `TRequirement`
*   `message` `TMessage`

### [](#explanation)Explanation

With `words` you can validate the words of a string based on the specified `locales`. If the input does not match the `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[WordsAction](/api/WordsAction/)<TInput, TLocales, TRequirement, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `words` can be used.

### [](#words-schema)Words schema

Schema to validate a string with 3 words.

`const WordsSchema = v.pipe(   v.string(),   v.words('en', 3, 'Exactly 3 words are required.') );`

[](#related)Related
-------------------

The following APIs can be combined with `words`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`string`](/api/string/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

[](#deleteglobalconfig)deleteGlobalConfig
=========================================

Deletes the global configuration.

`v.deleteGlobalConfig();`

[](#deleteglobalmessage)deleteGlobalMessage
===========================================

Deletes a global error message.

`v.deleteGlobalMessage(lang);`

[](#parameters)Parameters
-------------------------

*   `lang` `string | undefined`

[](#deleteschemamessage)deleteSchemaMessage
===========================================

Deletes a schema error message.

`v.deleteSchemaMessage(lang);`

[](#parameters)Parameters
-------------------------

*   `lang` `string | undefined`

[](#deletespecificmessage)deleteSpecificMessage
===============================================

Deletes a specific error message.

`v.deleteSpecificMessage(reference, lang);`

[](#parameters)Parameters
-------------------------

*   `reference` `[Reference](/api/Reference/)`
*   `lang` `string | undefined`

[](#getglobalconfig)getGlobalConfig
===================================

Returns the global configuration.

`const config = v.getGlobalConfig<TIssue>(merge);`

[](#generics)Generics
---------------------

*   `TIssue` `extends [BaseIssue](/api/types/)<unknown>`

[](#parameters)Parameters
-------------------------

*   `merge` `[Config](/api/Config/)<TIssue> | undefined`

### [](#explanation)Explanation

Properties that you want to explicitly override can be optionally specified with `merge`.

[](#returns)Returns
-------------------

*   `config` `[Config](/api/Config/)<TIssue>`

[](#getglobalmessage)getGlobalMessage
=====================================

Returns a global error message.

`const message = v.getGlobalMessage(lang);`

[](#parameters)Parameters
-------------------------

*   `lang` `string | undefined`

[](#returns)Returns
-------------------

*   `message` `[ErrorMessage](/api/ErrorMessage/)<[BaseIssue](/api/BaseIssue/)<unknown>> | undefined`

[](#getschemamessage)getSchemaMessage
=====================================

Returns a schema error message.

`const message = v.getSchemaMessage(lang);`

[](#parameters)Parameters
-------------------------

*   `lang` `string | undefined`

[](#returns)Returns
-------------------

*   `message` `[ErrorMessage](/api/ErrorMessage/)<[BaseIssue](/api/BaseIssue/)<unknown>> | undefined`

[](#getspecificmessage)getSpecificMessage
=========================================

Returns a specific error message.

`const message = v.getSpecificMessage(reference, lang);`

[](#parameters)Parameters
-------------------------

*   `reference` `[Reference](/api/Reference/)`
*   `lang` `string | undefined`

[](#returns)Returns
-------------------

*   `message` `[ErrorMessage](/api/ErrorMessage/)<[BaseIssue](/api/BaseIssue/)<unknown>> | undefined`

[](#setglobalconfig)setGlobalConfig
===================================

Sets the global configuration.

`v.setGlobalConfig(merge);`

[](#parameters)Parameters
-------------------------

*   `config` `[GlobalConfig](/api/GlobalConfig/)`

### [](#explanation)Explanation

The properties specified by `config` are merged with the existing global configuration. If a property is already set, it will be overwritten.

[](#setglobalmessage)setGlobalMessage
=====================================

Sets a global error message.

`v.setGlobalMessage(message, lang);`

[](#parameters)Parameters
-------------------------

*   `message` `[ErrorMessage](/api/ErrorMessage/)<[BaseIssue](/api/BaseIssue/)<unknown>>`
*   `lang` `string | undefined`

[](#setschemamessage)setSchemaMessage
=====================================

Sets a schema error message.

`v.setSchemaMessage(message, lang);`

[](#parameters)Parameters
-------------------------

*   `message` `[ErrorMessage](/api/ErrorMessage/)<[BaseIssue](/api/BaseIssue/)<unknown>>`
*   `lang` `string | undefined`

[](#setspecificmessage)setSpecificMessage
=========================================

Sets a specific error message.

`v.setSpecificMessage<TReference>(reference, message, lang);`

[](#generics)Generics
---------------------

*   `TReference` `extends [Reference](/api/Reference/)`

[](#parameters)Parameters
-------------------------

*   `reference` `TReference`
*   `message` `[ErrorMessage](/api/ErrorMessage/)<[InferIssue](/api/InferIssue/)<ReturnType<TReference>>>`
*   `lang` `string | undefined`

[](#entriesfromlist)entriesFromList
===================================

Creates an object entries definition from a list of keys and a schema.

`const entries = v.entriesFromList<TList, TSchema>(list, schema);`

[](#generics)Generics
---------------------

*   `TList` `extends (string | number | symbol)[]`
*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `list` `TList`
*   `schema` `TSchema`

[](#returns)Returns
-------------------

*   `entries` `Record<TList[number], TSchema>`

[](#examples)Examples
---------------------

The following example show how `entriesFromList` can be used.

`const ObjectSchema = v.object(   v.entriesFromList(['foo', 'bar', 'baz'], v.string()) );`

[](#related)Related
-------------------

The following APIs can be combined with `entriesFromList`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unionWithRest`](/api/unionWithRest/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

[](#entriesfromobjects)entriesFromObjects
=========================================

Creates a new object entries definition from existing object schemas.

`const entries = v.entriesFromObjects<TSchemas>(schemas);`

[](#generics)Generics
---------------------

*   `TSchemas` `extends [Schema, ...Schema[]]`

[](#parameters)Parameters
-------------------------

*   `schemas` `TSchemas`

[](#returns)Returns
-------------------

*   `entries` `MergedEntries<TSchemas>`

[](#examples)Examples
---------------------

The following example show how `entriesFromObjects` can be used.

> Hint: The third schema of the list overwrites the `foo` and `baz` properties of the previous schemas.

`const ObjectSchema = v.object(   v.entriesFromObjects([      v.object({ foo:  v.string(), bar:  v.string() });      v.object({ baz:  v.number(), qux:  v.number() });      v.object({ foo:  v.boolean(), baz:  v.boolean() });   ]) );`

[](#related)Related
-------------------

The following APIs can be combined with `entriesFromObjects`.

### [](#schemas)Schemas

*   [`looseObject`](/api/looseObject/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`strictObject`](/api/strictObject/)

[](#getdotpath)getDotPath
=========================

Creates and returns the dot path of an issue if possible.

`const dotPath = v.getDotPath<TSchema>(issue);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `issue` `[InferIssue](/api/InferIssue/)<TSchema>`

[](#returns)Returns
-------------------

*   `dotPath` `[IssueDotPath](/api/IssueDotPath/)<TSchema> | null`

[](#isofkind)isOfKind
=====================

A generic type guard to check the kind of an object.

`const result = v.isOfKind<TKind, TObject>(kind, object);`

[](#generics)Generics
---------------------

*   `TKind` `extends TObject['kind']`
*   `TObject` `extends { kind: string }`

[](#parameters)Parameters
-------------------------

*   `kind` `TKind`
*   `object` `TObject`

[](#returns)Returns
-------------------

*   `result` `boolean`

[](#isoftype)isOfType
=====================

A generic type guard to check the type of an object.

`const result = v.isOfType<TType, TObject>(type, object);`

[](#generics)Generics
---------------------

*   `TType` `extends TObject['type']`
*   `TObject` `extends { type: string }`

[](#parameters)Parameters
-------------------------

*   `type` `TType`
*   `object` `TObject`

[](#returns)Returns
-------------------

*   `result` `boolean`

[](#isvalierror)isValiError
===========================

A type guard to check if an error is a ValiError.

`const result = v.isValiError<TSchema>(error);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `error` `unknown`

[](#returns)Returns
-------------------

*   `result` `boolean`

[](#valierror)ValiError
=======================

Creates a Valibot error with useful information.

`const error = new v.ValiError<TSchema>(issues);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `issues` `[InferIssue<TSchema>, ...InferIssue<TSchema>[]]`

[](#returns)Returns
-------------------

*   `error` `ValiError<TSchema>`

[](#argsasync)argsAsync
=======================

Creates a function arguments transformation action.

`const Action = v.argsAsync<TInput, TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TInput` `extends (...args: any[]) => unknown`
*   `TSchema` `extends [LooseTupleSchema](/api/LooseTupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined> | [LooseTupleSchemaAsync](/api/LooseTupleSchemaAsync/)<[TupleItemsAsync](/api/TupleItemsAsync/), [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined> | [StrictTupleSchema](/api/StrictTupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined> | [StrictTupleSchemaAsync](/api/StrictTupleSchemaAsync/)<[TupleItemsAsync](/api/TupleItemsAsync/), [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined> | [TupleSchema](/api/TupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined> | [TupleSchemaAsync](/api/TupleSchemaAsync/)<[TupleItemsAsync](/api/TupleItemsAsync/), [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined> | [TupleWithRestSchema](/api/TupleWithRestSchema/)<[TupleItems](/api/TupleItems/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined> | [TupleWithRestSchemaAsync](/api/TupleWithRestSchemaAsync/)<[TupleItemsAsync](/api/TupleItemsAsync/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

### [](#explanation)Explanation

With `argsAsync` you can force the arguments of a function to match the given `schema`.

[](#returns)Returns
-------------------

*   `Action` `[ArgsActionAsync](/api/ArgsActionAsync/)<TInput, TSchema>`

[](#examples)Examples
---------------------

The following examples show how `argsAsync` can be used.

### [](#product-function-schema)Product function schema

Schema of a function that returns a product by its ID.

`import { isValidProductId } from '~/api';  const ProductFunctionSchema = v.pipeAsync(   v.function(),   v.argsAsync(     v.tupleAsync([v.pipeAsync(v.string(), v.checkAsync(isValidProductId))])   ),   v.returnsAsync(     v.pipeAsync(       v.promise(),       v.awaitAsync(),       v.object({         id: v.string(),         name: v.string(),         price: v.number(),       })     )   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `argsAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`custom`](/api/custom/),
*   [`looseTuple`](/api/looseTuple/),
*   [`function`](/api/function/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`customAsync`](/api/customAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`returnsAsync`](/api/returnsAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/)

[](#arrayasync)arrayAsync
=========================

Creates an array schema.

`const Schema = v.arrayAsync<TItem, TMessage>(item, message);`

[](#generics)Generics
---------------------

*   `TItem` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ArrayIssue](/api/ArrayIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `item` `TItem`
*   `message` `TMessage`

### [](#explanation)Explanation

With `arrayAsync` you can validate the data type of the input. If the input is not an array, you can use `message` to customize the error message.

> If your array has a fixed length, consider using [`tupleAsync`](/api/tupleAsync/) for a more precise typing.

[](#returns)Returns
-------------------

*   `Schema` `[ArraySchemaAsync](/api/ArraySchemaAsync/)<TItem, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `arrayAsync` can be used.

### [](#stored-emails-schema)Stored emails schema

Schema to validate an array of stored emails.

`import { isEmailPresent } from '~/api';  const StoredEmailsSchema = v.arrayAsync(   v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is not in the database.')   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `arrayAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#awaitasync)awaitAsync
=========================

Creates an await transformation action.

`const Action = v.awaitAsync<TInput>();`

[](#generics)Generics
---------------------

*   `TInput` `extends Promise<unknown>`

### [](#explanation)Explanation

With `awaitAsync` you can transform a promise into its resolved value.

[](#returns)Returns
-------------------

*   `Action` `[AwaitActionAsync](/api/AwaitActionAsync/)<TInput>`

[](#examples)Examples
---------------------

The following examples show how `awaitAsync` can be used.

### [](#unique-emails-schema)Unique emails schema

Schema to check a set of emails wrapped in a promise object.

`const UniqueEmailsSchema = v.pipeAsync(   v.promise(),   v.awaitAsync(),   v.set(v.pipe(v.string(), v.email())) );`

[](#related)Related
-------------------

The following APIs can be combined with `awaitAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#checkasync)checkAsync
=========================

Creates a check validation action.

`const Action = v.checkAsync<TInput, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CheckIssue](/api/CheckIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `(input: TInput) => [MaybePromise](/api/MaybePromise/)<boolean>`
*   `message` `TMessage`

### [](#explanation)Explanation

With `checkAsync` you can freely validate the input and return `true` if it is valid or `false` otherwise. If the input does not match your `requirement`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Action` `[CheckActionAsync](/api/CheckActionAsync/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `checkAsync` can be used.

### [](#cart-item-schema)Cart item schema

Schema to check a cart item object.

`import { getProductItem } from '~/api';  const CartItemSchema = v.pipeAsync(   v.object({     itemId: v.pipe(v.string(), v.regex(/^[a-z0-9]{10}$/i)),     quantity: v.pipe(v.number(), v.minValue(1)),   }),   v.checkAsync(async (input) => {     const productItem = await getProductItem(input.itemId);     return productItem?.quantity >= input.quantity;   }, 'The required quantity is greater than available.') );`

[](#related)Related
-------------------

The following APIs can be combined with `checkAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#checkitemsasync)checkItemsAsync
===================================

Creates a check items validation action.

`const Action = v.checkItemsAsync<TInput, TMessage>(requirement, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CheckItemsIssue](/api/CheckItemsIssue/)<TInput>> | undefined`

[](#parameters)Parameters
-------------------------

*   `requirement` `[ArrayRequirementAsync](/api/ArrayRequirementAsync/)<TInput>`
*   `message` `TMessage`

### [](#explanation)Explanation

With `checkItemsAsync` you can freely validate the items of an array and return `true` if they are valid or `false` otherwise. If an item does not match your `requirement`, you can use `message` to customize the error message.

> The special thing about `checkItemsAsync` is that it automatically forwards each issue to the appropriate item.

[](#returns)Returns
-------------------

*   `Action` `[CheckItemsActionAsync](/api/CheckItemsActionAsync/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `checkItemsAsync` can be used.

### [](#cart-items-schema)Cart items schema

Schema to check an array of cart item objects.

`import { getProductItem } from '~/api';  const CartItemsSchema = v.pipeAsync(   v.array(     v.object({       itemId: v.pipe(v.string(), v.uuid()),       quantity: v.pipe(v.number(), v.minValue(1)),     })   ),   v.checkItemsAsync(async (input) => {     const productItem = await getProductItem(input.itemId);     return (productItem?.quantity ?? 0) >= input.quantity;   }, 'The required quantity is greater than available.') );`

[](#related)Related
-------------------

The following APIs can be combined with `checkItemsAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`tuple`](/api/tuple/),
*   [`unknown`](/api/unknown/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`tupleAsync`](/api/tupleAsync/)

[](#customasync)customAsync
===========================

Creates a custom schema.

> This schema function allows you to define a schema that matches a value based on a custom function. Use it whenever you need to define a schema that cannot be expressed using any of the other schema functions.

`const Schema = v.customAsync<TInput, TMessage>(check, message);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CustomIssue](/api/CustomIssue/)> | undefined = [ErrorMessage](/api/ErrorMessage/)<[CustomIssue](/api/CustomIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `check` `(input: unknown) => [MaybePromise](/api/MaybePromise/)<boolean>`
*   `message` `TMessage`

### [](#explanation)Explanation

With `customAsync` you can validate the data type of the input. If the input does not match the validation of `check`, you can use `message` to customize the error message.

> Make sure that the validation in `check` matches the data type of `TInput`.

[](#returns)Returns
-------------------

*   `Schema` `[CustomSchemaAsync](/api/CustomSchemaAsync/)<TInput, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `customAsync` can be used.

### [](#vacant-seat-schema)Vacant seat schema

Schema to validate a vacant seat.

``import { isSeatVacant } from '~/api';  type Group = 'A' | 'B' | 'C' | 'D' | 'E'; type DigitLessThanSix = '0' | '1' | '2' | '3' | '4' | '5'; type Digit = DigitLessThanSix | '6' | '7' | '8' | '9'; type Seat = `${Group}${DigitLessThanSix}${Digit}`;  function isSeat(possibleSeat: string): possibleSeat is Seat {   return /^[A-E][0-5]\d$/.test(possibleSeat); }  const VacantSeatSchema = v.customAsync<Seat>(   (input) => typeof input === 'string' && isSeat(input) && isSeatVacant(input),   'The input is not a valid vacant seat.' );``

[](#related)Related
-------------------

The following APIs can be combined with `customAsync`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/)

[](#exactoptionalasync)exactOptionalAsync
=========================================

Creates an exact optional schema.

`const Schema = v.exactOptionalAsync<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, never>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `exactOptionalAsync` the validation of your schema will pass missing object entries, and if you specify a `default_` input value, the schema will use it if the object entry is missing. For this reason, the output type may differ from the input type of the schema.

> The difference to [`optionalAsync`](/api/optionalAsync/) is that this schema function follows the implementation of TypeScript's [`exactOptionalPropertyTypes` configuration](https://www.typescriptlang.org/tsconfig/#exactOptionalPropertyTypes) and only allows missing but not undefined object entries.

[](#returns)Returns
-------------------

*   `Schema` `[ExactOptionalSchemaAsync](/api/ExactOptionalSchemaAsync/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `exactOptionalAsync` can be used.

### [](#new-user-schema)New user schema

Schema to validate new user details.

`import { isEmailUnique, isUsernameUnique } from '~/api';  const NewUserSchema = v.objectAsync({   email: v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailUnique, 'The email is not unique.')   ),   username: v.exactOptionalAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ),   password: v.pipe(v.string(), v.minLength(8)), });  /*   The input and output types of the schema:     {       email: string;       password: string;       username?: string;     } */`

### [](#unwrap-exact-optional-schema)Unwrap exact optional schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `exactOptionalAsync`.

`import { isUsernameUnique } from '~/api';  const UsernameSchema = v.unwrap(   // Assume this schema is from a different file and is reused here   v.exactOptionalAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `exactOptionalAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#fallbackasync)fallbackAsync
===============================

Returns a fallback value as output if the input does not match the schema.

`const Schema = v.fallbackAsync<TSchema, TFallback>(schema, fallback);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TFallback` `extends [FallbackAsync](/api/FallbackAsync/)<TSchema>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `fallback` `TFallback`

### [](#explanation)Explanation

`fallbackAsync` allows you to define a fallback value for the output that will be used if the validation of the input fails. This means that no issues will be returned when using `fallbackAsync` and the schema will always return an output.

> If you only want to set a default value for `null` or `undefined` inputs, you should use [`optionalAsync`](/api/optionalAsync/), [`nullableAsync`](/api/nullableAsync/) or [`nullishAsync`](/api/nullishAsync/) instead.

> The fallback value is not validated. Make sure that the fallback value matches your schema.

[](#returns)Returns
-------------------

*   `Schema` `[SchemaWithFallbackAsync](/api/SchemaWithFallbackAsync/)<TSchema, TFallback>`

[](#examples)Examples
---------------------

The following examples show how `fallbackAsync` can be used.

### [](#unique-username-schema)Unique username schema

Schema that will always return a unique username.

> By using a function as the `fallbackAsync` parameter, the schema will return any unique username each time the input does not match the schema.

`import { getAnyUniqueUsername, isUsernameUnique } from '~/api';  const UniqueUsernameSchema = v.fallbackAsync(   v.pipeAsync(v.string(), v.minLength(4), v.checkAsync(isUsernameUnique)),   getAnyUniqueUsername );`

[](#related)Related
-------------------

The following APIs can be combined with `fallbackAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`pick`](/api/pick/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#forwardasync)forwardAsync
=============================

Forwards the issues of the passed validation action.

`const Action = v.forwardAsync<TInput, TIssue, TPath>(action, path);`

[](#generics)Generics
---------------------

*   `TInput` `extends Record<string, unknown> | ArrayLike<unknown>`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
*   `TPath` `extends [RequiredPath](/api/RequiredPath/)`

[](#parameters)Parameters
-------------------------

*   `action` `[BaseValidation](/api/BaseValidation/)<TInput, TInput, TIssue> | [BaseValidationAsync](/api/BaseValidationAsync/)<TInput, TInput, TIssue>`
*   `path` `[ValidPath](/api/ValidPath/)<TInput, TPath>`

### [](#explanation)Explanation

`forwardAsync` allows you to forward the issues of the passed validation `action` via `path` to a nested field of a schema.

[](#returns)Returns
-------------------

*   `Action` `[BaseValidationAsync](/api/BaseValidationAsync/)<TInput, TInput, TIssue>`

[](#examples)Examples
---------------------

The following examples show how `forwardAsync` can be used.

### [](#allowed-action-schema)Allowed action schema

Schema that checks if the user is allowed to complete an action.

`import { isAllowedAction, isUsernamePresent } from '~/api';  const AllowedActionSchema = v.pipeAsync(   v.objectAsync({     username: v.pipeAsync(       v.string(),       v.minLength(3),       v.checkAsync(isUsernamePresent, 'The username is not in the database.')     ),     action: v.picklist(['view', 'edit', 'delete']),   }),   v.forwardAsync(     v.checkAsync(       isAllowedAction,       'The user is not allowed to complete the action.'     ),     ['action']   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `forwardAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/)

### [](#methods)Methods

*   [`omit`](/api/omit/),
*   [`pick`](/api/pick/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#getdefaultsasync)getDefaultsAsync
=====================================

Returns the default values of the schema.

> The difference to [`getDefault`](/api/getDefault/) is that for object and tuple schemas this function recursively returns the default values of the subschemas instead of `undefined`.

`const values = v.getDefaultsAsync<TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

[](#returns)Returns
-------------------

*   `values` `Promise<[InferDefaults](/api/InferDefaults/)<TSchema>>`

[](#examples)Examples
---------------------

The following examples show how `getDefaultsAsync` can be used.

### [](#donation-schema-defaults)Donation schema defaults

Get the default values of a donation schema.

`import { getRandomOrgId } from '~/api';  const DonationSchema = v.objectAsync({   timestamp: v.optional(v.date(), () => new Date()),   sponsor: v.optional(v.pipe(v.string(), v.nonEmpty()), 'anonymous'),   organizationId: v.optionalAsync(v.pipe(v.string(), v.uuid()), getRandomOrgId),   message: v.optional(v.pipe(v.string(), v.minLength(1))), });  const defaultValues = await v.getDefaultsAsync(DonationSchema);  /*   {     timestamp: new Date(),     sponsor: "anonymous",     organizationId: "43775869-95f3-4e00-9f37-161ec8f9f7cd",     message: undefined   } */`

[](#related)Related
-------------------

The following APIs can be combined with `getDefaultsAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`unwrap`](/api/unwrap/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#getfallbacksasync)getFallbacksAsync
=======================================

Returns the fallback values of the schema.

> The difference to [`getFallback`](/api/getFallback/) is that for object and tuple schemas this function recursively returns the fallback values of the subschemas instead of `undefined`.

`const values = v.getFallbacksAsync<TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

[](#returns)Returns
-------------------

*   `values` `Promise<[InferFallbacks](/api/InferFallbacks/)<TSchema>>`

[](#examples)Examples
---------------------

The following examples show how `getFallbacksAsync` can be used.

### [](#new-user-fallbacks)New user fallbacks

Get the fallback values of a new user schema.

`import { getAnyUniqueUsername, isUsernameUnique } from '~/api';  const NewUserSchema = v.objectAsync({   username: v.fallbackAsync(     v.pipeAsync(v.string(), v.minLength(3), v.checkAsync(isUsernameUnique)),     getAnyUniqueUsername   ),   password: v.pipe(v.string(), v.minLength(8)), });  const fallbackValues = await v.getFallbacksAsync(NewUserSchema); /*   {     username: "cookieMonster07",     password: undefined   } */`

[](#related)Related
-------------------

The following APIs can be combined with `getFallbacksAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`unwrap`](/api/unwrap/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#intersectasync)intersectAsync
=================================

Creates an intersect schema.

> I recommend to read the [intersections guide](/guides/intersections/) before using this schema function.

`const Schema = v.intersectAsync<TOptions, TMessage>(options, message);`

[](#generics)Generics
---------------------

*   `TOptions` `extends [IntersectOptionsAsync](/api/IntersectOptionsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IntersectIssue](/api/IntersectIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `options` `TOptions`
*   `message` `TMessage`

### [](#explanation)Explanation

With `intersectAsync` you can validate if the input matches each of the given `options`. If the output of the intersection cannot be successfully merged, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[IntersectSchemaAsync](/api/IntersectSchemaAsync/)<TOptions, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `intersectAsync` can be used.

### [](#donation-schema)Donation schema

Schema that combines objects to validate donation details.

`import { isOrganizationPresent } from '~/api';  const DonationSchema = v.intersectAsync([   v.objectAsync({     organizationId: v.pipeAsync(       v.string(),       v.uuid(),       v.checkAsync(         isOrganizationPresent,         'The organization is not in the database.'       )     ),   }),   // Assume the schemas below are from different files and are reused here   v.object({     amount: v.pipe(v.number(), v.minValue(100)),     message: v.pipe(v.string(), v.nonEmpty()),   }),   v.object({     amount: v.pipe(v.number(), v.maxValue(1_000_000)),     message: v.pipe(v.string(), v.maxLength(500)),   }), ]);`

[](#related)Related
-------------------

The following APIs can be combined with `intersectAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexColor`](/api/hexColor/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#lazyasync)lazyAsync
=======================

Creates a lazy schema.

`const Schema = v.lazyAsync<TWrapped>(getter);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `getter` `(input: unknown) => [MaybePromise](/api/MaybePromise/)<TWrapped>`

### [](#explanation)Explanation

The `getter` function is called lazily to retrieve the schema. This is necessary to be able to access the input through the first argument of the `getter` function and to avoid a circular dependency for recursive schemas.

[](#returns)Returns
-------------------

*   `Schema` `[LazySchemaAsync](/api/LazySchemaAsync/)<TWrapped>`

[](#examples)Examples
---------------------

The following examples show how `lazyAsync` can be used.

### [](#transaction-list-schema)Transaction list schema

Recursive schema to validate transactions.

> Due to a TypeScript limitation, the input and output types of recursive schemas cannot be inferred automatically. Therefore, you must explicitly specify these types using [`GenericSchemaAsync`](/api/GenericSchemaAsync/).

`import { isTransactionValid } from '~/api';  type Transaction = {   transactionId: string;   next: Transaction | null; };  const TransactionSchema: v.GenericSchemaAsync<Transaction> = v.objectAsync({   transactionId: v.pipeAsync(     v.string(),     v.uuid(),     v.checkAsync(isTransactionValid, 'The transaction is not valid.')   ),   next: v.nullableAsync(v.lazyAsync(() => TransactionSchema)), });`

### [](#email-or-username-schema)Email or username schema

Schema to validate an object containing an email or username.

> In most cases, [`unionAsync`](/api/unionAsync/) and [`variantAsync`](/api/variantAsync/) are the better choices for creating such a schema. I recommend using `lazyAsync` only in special cases.

`import { isEmailPresent, isUsernamePresent } from '~/api';  const EmailOrUsernameSchema = v.lazyAsync((input) => {   if (input && typeof input === 'object' && 'type' in input) {     switch (input.type) {       case 'email':         return v.objectAsync({           type: v.literal('email'),           email: v.pipeAsync(             v.string(),             v.email(),             v.checkAsync(               isEmailPresent,               'The email is not present in the database.'             )           ),         });       case 'username':         return v.objectAsync({           type: v.literal('username'),           username: v.pipeAsync(             v.string(),             v.nonEmpty(),             v.checkAsync(               isUsernamePresent,               'The username is not present in the database.'             )           ),         });     }   }   return v.never(); });`

[](#related)Related
-------------------

The following APIs can be combined with `lazyAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexColor`](/api/hexColor/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#looseobjectasync)looseObjectAsync
=====================================

Creates a loose object schema.

`const Schema = v.looseObjectAsync<TEntries, TMessage>(entries, message);`

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntriesAsync](/api/ObjectEntriesAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LooseObjectIssue](/api/LooseObjectIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `entries` `TEntries`
*   `message` `TMessage`

### [](#explanation)Explanation

With `looseObjectAsync` you can validate the data type of the input and whether the content matches `entries`. If the input is not an object, you can use `message` to customize the error message.

> The difference to [`objectAsync`](/api/objectAsync/) is that this schema includes any unknown entries in the output. In addition, this schema filters certain entries from the unknown entries for security reasons.

[](#returns)Returns
-------------------

*   `Schema` `[LooseObjectSchemaAsync](/api/LooseObjectSchemaAsync/)<TEntries, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `looseObjectAsync` can be used. Please see the [object guide](/guides/objects/) for more examples and explanations.

### [](#new-user-schema)New user schema

Schema to validate a loose object containing specific new user details.

`import { isEmailPresent } from '~/api';  const NewUserSchema = v.looseObjectAsync({   firstName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),   lastName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),   email: v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is already in use by another user.')   ),   password: v.pipe(v.string(), v.minLength(8)),   avatar: v.optional(v.pipe(v.string(), v.url())), });`

[](#related)Related
-------------------

The following APIs can be combined with `looseObjectAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`keyof`](/api/keyof/),
*   [`omit`](/api/omit/),
*   [`pick`](/api/pick/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`flavor`](/api/flavor/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#loosetupleasync)looseTupleAsync
===================================

Creates a loose tuple schema.

`const Schema = v.looseTupleAsync<TItems, TMessage>(items, message);`

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItemsAsync](/api/TupleItemsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `items` `TItems`
*   `message` `TMessage`

### [](#explanation)Explanation

With `looseTuplAsynce` you can validate the data type of the input and whether the content matches `items`. If the input is not an array, you can use `message` to customize the error message.

> The difference to [`tupleAsync`](/api/tupleAsync/) is that this schema does include unknown items into the output.

[](#returns)Returns
-------------------

*   `Schema` `[LooseTupleSchemaAsync](/api/LooseTupleSchemaAsync/)<TItems, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `looseTupleAsync` can be used. Please see the [arrays guide](/guides/arrays/) for more examples and explanations.

### [](#number-and-email-tuple)Number and email tuple

Schema to validate a loose tuple with one number and one stored email address.

`import { isEmailPresent } from '~/api';  const TupleSchema = v.looseTupleAsync([   v.number(),   v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is not in the database.')   ), ]);`

[](#related)Related
-------------------

The following APIs can be combined with `looseTupleAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#mapasync)mapAsync
=====================

Creates a map schema.

`const Schema = v.mapAsync<TKey, TValue, TMessage>(key, value, message);`

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MapIssue](/api/MapIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `key` `TKey`
*   `value` `TValue`
*   `message` `TMessage`

### [](#explanation)Explanation

With `mapAsync` you can validate the data type of the input and whether the entries match `key` and `value`. If the input is not a map, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[MapSchemaAsync](/api/MapSchemaAsync/)<TKey, TValue, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `mapAsync` can be used.

### [](#shopping-items-schema)Shopping items schema

Schema to validate a map with usernames that are allowed to shop as keys and the total items purchased as values.

`import { isUserVerified } from '~/api';  const ShoppingItemsSchema = v.mapAsync(   v.pipeAsync(     v.string(),     v.checkAsync(isUserVerified, 'The username is not allowed to shop.')   ),   v.pipe(v.number(), v.minValue(0)) );`

[](#related)Related
-------------------

The following APIs can be combined with `mapAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`maxSize`](/api/maxSize/),
*   [`metadata`](/api/metadata/),
*   [`minSize`](/api/minSize/),
*   [`notSize`](/api/notSize/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`size`](/api/size/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#nonnullableasync)nonNullableAsync
=====================================

Creates a non nullable schema.

> This schema function can be used to override the behavior of [`nullableAsync`](/api/nullableAsync/).

`const Schema = v.nonNullableAsync<TWrapped, TMessage>(wrapped, message);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonNullableIssue](/api/NonNullableIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `message` `TMessage`

### [](#explanation)Explanation

With `nonNullableAsync` the validation of your schema will not pass `null` inputs. If the input is `null`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NonNullableSchemaAsync](/api/NonNullableSchemaAsync/)<TWrapped, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `nonNullableAsync` can be used.

### [](#unique-username-schema)Unique username schema

Schema to validate a non-null unique username.

`import { isUsernameUnique } from '~/api';  const UniqueUsernameSchema = v.nonNullableAsync(   // Assume this schema is from a different file and reused here.   v.nullableAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `nonNullableAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#nonnullishasync)nonNullishAsync
===================================

Creates a non nullish schema.

> This schema function can be used to override the behavior of [`nullishAsync`](/api/nullishAsync/).

`const Schema = v.nonNullishAsync<TWrapped, TMessage>(wrapped, message);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonNullishIssue](/api/NonNullishIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `message` `TMessage`

### [](#explanation)Explanation

With `nonNullishAsync` the validation of your schema will not pass `null` and `undefined` inputs. If the input is `null` or `undefined`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NonNullishSchemaAsync](/api/NonNullishSchemaAsync/)<TWrapped, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `nonNullishAsync` can be used.

### [](#allowed-country-schema)Allowed country schema

Schema to check if a string matches one of the allowed country names.

`import { isAllowedCountry } from '~/api';  const AllowedCountrySchema = v.nonNullishAsync(   // Assume this schema is from a different file and reused here.   v.nullishAsync(     v.pipeAsync(v.string(), v.nonEmpty(), v.checkAsync(isAllowedCountry))   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `nonNullishAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#nonoptionalasync)nonOptionalAsync
=====================================

Creates a non optional schema.

> This schema function can be used to override the behavior of [`optionalAsync`](/api/optionalAsync/).

`const Schema = v.nonOptionalAsync<TWrapped, TMessage>(wrapped, message);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonOptionalIssue](/api/NonOptionalIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `message` `TMessage`

### [](#explanation)Explanation

With `nonOptionalAsync` the validation of your schema will not pass `undefined` inputs. If the input is `undefined`, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[NonOptionalSchemaAsync](/api/NonOptionalSchemaAsync/)<TWrapped, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `nonOptionalAsync` can be used.

### [](#add-user-schema)Add user schema

Schema to validate an object containing details required to add a user to an existing group.

`import { isGroupPresent } from '~/api';  const AddUserSchema = v.objectAsync({   groupId: v.nonOptionalAsync(     // Assume this schema is from a different file and reused here.     v.optionalAsync(       v.pipeAsync(         v.string(),         v.uuid(),         v.checkAsync(           isGroupPresent,           'The group is not present in the database.'         )       )     )   ),   userEmail: v.pipe(v.string(), v.email()), });`

[](#related)Related
-------------------

The following APIs can be combined with `nonOptionalAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#nullableasync)nullableAsync
===============================

Creates a nullable schema.

`const Schema = v.nullableAsync<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, null>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `nullableAsync` the validation of your schema will pass `null` inputs, and if you specify a `default_` input value, the schema will use it if the input is `null`. For this reason, the output type may differ from the input type of the schema.

> Note that `nullableAsync` does not accept `undefined` as an input. If you want to accept `undefined` inputs, use [`optionalAsync`](/api/optionalAsync/), and if you want to accept `null` and `undefined` inputs, use [`nullishAsync`](/api/nullishAsync/) instead. Also, if you want to set a default output value for any invalid input, you should use [`fallbackAsync`](/api/fallbackAsync/) instead.

[](#returns)Returns
-------------------

*   `Schema` `[NullableSchemaAsync](/api/NullableSchemaAsync/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `nullableAsync` can be used.

### [](#nullable-username-schema)Nullable username schema

Schema that accepts a unique username or `null`.

> By using a function as the `default_` parameter, the schema will return a unique username from the function call each time the input is `null`.

`import { getUniqueUsername, isUsernameUnique } from '~/api';  const NullableUsernameSchema = v.nullableAsync(   v.pipeAsync(     v.string(),     v.nonEmpty(),     v.checkAsync(isUsernameUnique, 'The username is not unique.')   ),   getUniqueUsername );`

### [](#unwrap-nullable-schema)Unwrap nullable schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `nullableAsync`.

`import { isUsernameUnique } from '~/api';  const UsernameSchema = v.unwrap(   // Assume this schema is from a different file and is reused here   v.nullableAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `nullableAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#nullishasync)nullishAsync
=============================

Creates a nullish schema.

`const Schema = v.nullishAsync<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, null | undefined>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `nullishAsync` the validation of your schema will pass `undefined` and `null` inputs, and if you specify a `default_` input value, the schema will use it if the input is `undefined` or `null`. For this reason, the output type may differ from the input type of the schema.

> Note that `nullishAsync` accepts `undefined` or `null` as an input. If you want to accept only `null` inputs, use [`nullableAsync`](/api/nullableAsync/), and if you want to accept only `undefined` inputs, use [`optionalAsync`](/api/optionalAsync/) instead. Also, if you want to set a default output value for any invalid input, you should use [`fallbackAsync`](/api/fallbackAsync/) instead.

[](#returns)Returns
-------------------

*   `Schema` `[NullishSchemaAsync](/api/NullishSchemaAsync/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `nullishAsync` can be used.

### [](#nullish-username-schema)Nullish username schema

Schema that accepts a unique username, `undefined` or `null`.

> By using a function as the `default_` parameter, the schema will return a unique username from the function call each time the input is `undefined` or `null`.

`import { getUniqueUsername, isUsernameUnique } from '~/api';  const NullishUsernameSchema = v.nullishAsync(   v.pipeAsync(     v.string(),     v.nonEmpty(),     v.checkAsync(isUsernameUnique, 'The username is not unique.')   ),   getUniqueUsername );`

### [](#new-user-schema)New user schema

Schema to validate new user details.

`import { isEmailUnique, isUsernameUnique } from '~/api';  const NewUserSchema = v.objectAsync({   email: v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailUnique, 'The email is not unique.')   ),   username: v.nullishAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ),   password: v.pipe(v.string(), v.minLength(8)), });  /*   The input and output types of the schema:     {       email: string;       password: string;       username?: string | null | undefined;     } */`

### [](#unwrap-nullish-schema)Unwrap nullish schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `nullishAsync`.

`import { isUsernameUnique } from '~/api';  const UsernameSchema = v.unwrap(   // Assume this schema is from a different file and is reused here   v.nullishAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `nullishAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#objectasync)objectAsync
===========================

Creates an object schema.

`const Schema = v.objectAsync<TEntries, TMessage>(entries, message);`

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntriesAsync](/api/ObjectEntriesAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ObjectIssue](/api/ObjectIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `entries` `TEntries`
*   `message` `TMessage`

### [](#explanation)Explanation

With `objectAsync` you can validate the data type of the input and whether the content matches `entries`. If the input is not an object, you can use `message` to customize the error message.

> This schema removes unknown entries. The output will only include the entries you specify. To include unknown entries, use [`looseObjectAsync`](/api/looseObjectAsync/). To return an issue for unknown entries, use [`strictObjectAsync`](/api/strictObjectAsync/). To include and validate unknown entries, use [`objectWithRestAsync`](/api/objectWithRestAsync/).

[](#returns)Returns
-------------------

*   `Schema` `[ObjectSchemaAsync](/api/ObjectSchemaAsync/)<TEntries, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `objectAsync` can be used. Please see the [object guide](/guides/objects/) for more examples and explanations.

### [](#new-user-schema)New user schema

Schema to validate an object containing new user details.

`import { isEmailPresent } from '~/api';  const NewUserSchema = v.objectAsync({   firstName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),   lastName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),   email: v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is already in use by another user.')   ),   password: v.pipe(v.string(), v.minLength(8)),   avatar: v.optional(v.pipe(v.string(), v.url())), });`

[](#related)Related
-------------------

The following APIs can be combined with `objectAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`keyof`](/api/keyof/),
*   [`omit`](/api/omit/),
*   [`pick`](/api/pick/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#objectwithrestasync)objectWithRestAsync
===========================================

Creates an object with rest schema.

`const Schema = v.objectWithRestAsync<TEntries, TRest, TMessage>(   entries,   rest,   message );`

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntriesAsync](/api/ObjectEntriesAsync/)`
*   `TRest` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `entries` `TEntries`
*   `rest` `TRest`
*   `message` `TMessage`

### [](#explanation)Explanation

With `objectWithRestAsync` you can validate the data type of the input and whether the content matches `entries` and `rest`. If the input is not an object, you can use `message` to customize the error message.

> The difference to [`objectAsync`](/api/objectAsync/) is that this schema includes unknown entries in the output. In addition, this schema filters certain entries from the unknown entries for security reasons.

[](#returns)Returns
-------------------

*   `Schema` `[ObjectWithRestSchemaAsync](/api/ObjectWithRestSchemaAsync/)<TEntries, TRest, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `objectWithRestAsync` can be used. Please see the [object guide](/guides/objects/) for more examples and explanations.

### [](#word-map-schema)Word map schema

Schema to validate an object with word map mutation details.

`import { isUserAllowedToMutate } from '~/api';  // Assume the rest of the keys are always English words const WordMapSchema = v.objectWithRestAsync(   {     $userId: v.pipeAsync(       v.string(),       v.regex(/^[a-z0-9]{12}$/i),       v.checkAsync(         isUserAllowedToMutate,         'The user is not allowed to change the word map.'       )     ),     $targetLanguage: v.union([       v.literal('hindi'),       v.literal('spanish'),       v.literal('french'),     ]),   },   v.string() );`

[](#related)Related
-------------------

The following APIs can be combined with `objectWithRestAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`keyof`](/api/keyof/),
*   [`omit`](/api/omit/),
*   [`pick`](/api/pick/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#optionalasync)optionalAsync
===============================

Creates an optional schema.

`const Schema = v.optionalAsync<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, undefined>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `optionalAsync` the validation of your schema will pass `undefined` inputs, and if you specify a `default_` input value, the schema will use it if the input is `undefined`. For this reason, the output type may differ from the input type of the schema.

> Note that `optionalAsync` does not accept `null` as an input. If you want to accept `null` inputs, use [`nullableAsync`](/api/nullableAsync/), and if you want to accept `null` and `undefined` inputs, use [`nullishAsync`](/api/nullishAsync/) instead. Also, if you want to set a default output value for any invalid input, you should use [`fallbackAsync`](/api/fallbackAsync/) instead.

[](#returns)Returns
-------------------

*   `Schema` `[OptionalSchemaAsync](/api/OptionalSchemaAsync/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `optionalAsync` can be used.

### [](#optional-username-schema)Optional username schema

Schema that accepts a unique username or `undefined`.

> By using a function as the `default_` parameter, the schema will return a unique username from the function call each time the input is `undefined`.

`import { getUniqueUsername, isUsernameUnique } from '~/api';  const OptionalUsernameSchema = v.optionalAsync(   v.pipeAsync(     v.string(),     v.nonEmpty(),     v.checkAsync(isUsernameUnique, 'The username is not unique.')   ),   getUniqueUsername );`

### [](#new-user-schema)New user schema

Schema to validate new user details.

`import { isEmailUnique, isUsernameUnique } from '~/api';  const NewUserSchema = v.objectAsync({   email: v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailUnique, 'The email is not unique.')   ),   username: v.optionalAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ),   password: v.pipe(v.string(), v.minLength(8)), });  /*   The input and output types of the schema:     {       email: string;       password: string;       username?: string | undefined;     } */`

### [](#unwrap-optional-schema)Unwrap optional schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `optionalAsync`.

`import { isUsernameUnique } from '~/api';  const UsernameSchema = v.unwrap(   // Assume this schema is from a different file and is reused here   v.optionalAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `optionalAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#parseasync)parseAsync
=========================

Parses an unknown input based on a schema.

`const output = v.parseAsync<TSchema>(schema, input, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `input` `unknown`
*   `config` `[Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

### [](#explanation)Explanation

`parseAsync` will throw a [`ValiError`](/api/ValiError/) if the `input` does not match the `schema`. Therefore you should use a try/catch block to catch errors. If the input matches the schema, it is valid and the `output` of the schema will be returned typed.

> If an asynchronous operation associated with the passed schema throws an error, the promise returned by `parseAsync` is rejected and the error thrown may not be a [`ValiError`](/api/ValiError/).

[](#returns)Returns
-------------------

*   `output` `Promise<[InferOutput](/api/InferOutput/)<TSchema>>`

[](#examples)Examples
---------------------

The following examples show how `parseAsync` can be used.

`import { isEmailPresent } from '~/api';  try {   const StoredEmailSchema = v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is not in the database.')   );   const storedEmail = await v.parseAsync(StoredEmailSchema, 'jane@example.com');    // Handle errors if one occurs } catch (error) {   console.error(error); }`

[](#related)Related
-------------------

The following APIs can be combined with `parseAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`flatten`](/api/flatten/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`summarize`](/api/summarize/),
*   [`unwrap`](/api/unwrap/)

### [](#utils)Utils

*   [`getDotPath`](/api/getDotPath/),
*   [`isValiError`](/api/isValiError/),
*   [`ValiError`](/api/ValiError/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#parserasync)parserAsync
===========================

Returns a function that parses an unknown input based on a schema.

`const parser = v.parserAsync<TSchema, TConfig>(schema, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TConfig` `extends [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `config` `TConfig`

[](#returns)Returns
-------------------

*   `parser` `[ParserAsync](/api/ParserAsync/)<TSchema, TConfig>`

[](#examples)Examples
---------------------

The following examples show how `parserAsync` can be used.

`import { isEmailPresent } from '~/api';  try {   const StoredEmailSchema = v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is not in the database.')   );   const storedEmailParser = v.parserAsync(StoredEmailSchema);   const storedEmail = await storedEmailParser('jane@example.com');    // Handle errors if one occurs } catch (error) {   console.error(error); }`

[](#related)Related
-------------------

The following APIs can be combined with `parserAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`flatten`](/api/flatten/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`summarize`](/api/summarize/),
*   [`unwrap`](/api/unwrap/)

### [](#utils)Utils

*   [`getDotPath`](/api/getDotPath/),
*   [`isValiError`](/api/isValiError/),
*   [`ValiError`](/api/ValiError/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#partialasync)partialAsync
=============================

Creates a modified copy of an object schema that marks all or only the selected entries as optional.

`const Schema = v.partialAsync<TSchema, TKeys>(schema, keys);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [SchemaWithoutPipe](/api/SchemaWithoutPipe/)<[LooseObjectSchemaAsync](/api/LooseObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [ErrorMessage](/api/ErrorMessage/)<[LooseObjectIssue](/api/LooseObjectIssue/)> | undefined> | [ObjectSchemaAsync](/api/ObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [ErrorMessage](/api/ErrorMessage/)<[ObjectIssue](/api/ObjectIssue/)> | undefined> | [ObjectWithRestSchemaAsync](/api/ObjectWithRestSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [StrictObjectSchemaAsync](/api/StrictObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [ErrorMessage](/api/ErrorMessage/)<[StrictObjectIssue](/api/StrictObjectIssue/)> | undefined>>`
*   `TKeys` `extends [ObjectKeys](/api/ObjectKeys/)<TSchema> | undefined`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `keys` `TKey`

### [](#explanation)Explanation

`partialAsync` creates a modified copy of the given object `schema` where all entries or only the selected `keys` are optional. It is similar to TypeScript's [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype) utility type.

> Because `partialAsync` changes the data type of the input and output, it is not allowed to pass a schema that has been modified by the [`pipeAsync`](/api/pipeAsync/) method, as this may cause runtime errors. Please use the [`pipeAsync`](/api/pipeAsync/) method after you have modified the schema with `partialAsync`.

[](#returns)Returns
-------------------

*   `Schema` `[SchemaWithPartialAsync](/api/SchemaWithPartialAsync)<TSchema, TKeys>`

[](#examples)Examples
---------------------

The following examples show how `partialAsync` can be used.

### [](#update-user-schema)Update user schema

Schema to update the user details.

`import { isEmailAbsent, isUsernameAbsent } from '~/api';  const UserSchema = v.objectAsync({   email: v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailAbsent, 'The email is already in the database.')   ),   username: v.pipeAsync(     v.string(),     v.nonEmpty(),     v.checkAsync(isUsernameAbsent, 'The username is already in the database.')   ),   password: v.pipe(v.string(), v.minLength(8)), });  const UpdateUserSchema = v.partialAsync(UserSchema);  /*   {      email?: string;     username?: string;      password?: string;   } */`

[](#related)Related
-------------------

The following APIs can be combined with `partialAsync`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`pick`](/api/pick/),
*   [`required`](/api/required/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/)

[](#partialcheckasync)partialCheckAsync
=======================================

Creates a partial check validation action.

`const Action = v.partialCheckAsync<TInput, TPaths, TSelection, TMessage>(   paths,   requirement,   message );`

[](#generics)Generics
---------------------

*   `TInput` `extends [PartialInput](/api/PartialInput/)`
*   `TPaths` `extends [RequiredPaths](/api/RequiredPaths/)`
*   `TSelection` `extends [DeepPickN](/api/DeepPickN/)<TInput, TPaths>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[PartialCheckIssue](/api/PartialCheckIssue/)<TSelection>> | undefined`

[](#parameters)Parameters
-------------------------

*   `paths` `[ValidPaths](/api/ValidPaths/)<TInput, TPaths>`
*   `requirement` `(input: TSelection) => [MaybePromise](/api/MaybePromise/)<boolean>`
*   `message` `TMessage`

### [](#explanation)Explanation

With `partialCheckAsync` you can freely validate the selected input and return `true` if it is valid or `false` otherwise. If the input does not match your `requirement`, you can use `message` to customize the error message.

> The difference to [`checkAsync`](/api/checkAsync/) is that `partialCheckAsync` can be executed whenever the selected part of the data is valid, while [`checkAsync`](/api/checkAsync/) is executed only when the entire dataset is typed. This can be an important advantage when working with forms.

[](#returns)Returns
-------------------

*   `Action` `[PartialCheckActionAsync](/api/PartialCheckActionAsync/)<TInput, TPaths, TSelection, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `partialCheckAsync` can be used.

### [](#message-details-schema)Message details schema

Schema to validate details associated with a message.

`import { isSenderInTheGroup } from '~/api';  const MessageDetailsSchema = v.pipeAsync(   v.object({     sender: v.object({       name: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),       email: v.pipe(v.string(), v.email()),     }),     groupId: v.pipe(v.string(), v.uuid()),     message: v.pipe(v.string(), v.nonEmpty(), v.maxLength(500)),   }),   v.forwardAsync(     v.partialCheckAsync(       [['sender', 'email'], ['groupId']],       (input) =>         isSenderInTheGroup({           senderEmail: input.sender.email,           groupId: input.groupId,         }),       'The sender is not in the group.'     ),     ['sender', 'email']   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `partialCheckAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`custom`](/api/custom/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`union`](/api/union/),
*   [`variant`](/api/variant/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#pipeasync)pipeAsync
=======================

Adds a pipeline to a schema, that can validate and transform its input.

`const Schema = v.pipeAsync<TSchema, TItems>(schema, ...items);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TItems` `extends readonly ([PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [PipeItemAsync](/api/PipeItemAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>)[]`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `items` `TItems`

### [](#explanation)Explanation

`pipeAsync` creates a modified copy of the given `schema`, containing a pipeline for detailed validations and transformations. It passes the input data asynchronously through the `items` in the order they are provided and each item can examine and modify it.

> Since `pipeAsync` returns a schema that can be used as the first argument of another pipeline, it is possible to nest multiple `pipeAsync` calls to extend the validation and transformation further.

`pipeAsync` aborts early and marks the output as untyped if issues were collected before attempting to execute a schema or transformation action as the next item in the pipeline, to prevent unexpected behavior.

[](#returns)Returns
-------------------

*   `Schema` `[SchemaWithPipeAsync](/api/SchemaWithPipeAsync/)<readonly [TSchema, ...TItems]>`

[](#examples)Examples
---------------------

The following examples show how `pipeAsync` can be used. Please see the [pipeline guide](/guides/pipelines/) for more examples and explanations.

### [](#stored-email-schema)Stored email schema

Schema to validate a stored email address.

`import { isEmailPresent } from '~/api';  const StoredEmailSchema = v.pipeAsync(   v.string(),   v.nonEmpty('Please enter your email.'),   v.email('The email is badly formatted.'),   v.maxLength(30, 'Your email is too long.'),   v.checkAsync(isEmailPresent, 'The email is not in the database.') );`

### [](#new-user-schema)New user schema

Schema to validate and transform new user details to a string.

``import { isUsernameUnique } from '~/api';  const NewUserSchema = v.pipeAsync(   v.objectAsync({     firstName: v.pipe(v.string(), v.nonEmpty(), v.maxLength(30)),     lastName: v.pipe(v.string(), v.nonEmpty(), v.maxLength(30)),     username: v.pipeAsync(       v.string(),       v.nonEmpty(),       v.maxLength(30),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     ),   }),   v.transform(     ({ firstName, lastName, username }) =>       `${username} (${firstName} ${lastName})`   ) );``

[](#related)Related
-------------------

The following APIs can be combined with `pipeAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`is`](/api/is/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`parse`](/api/parse/),
*   [`parser`](/api/parser/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`required`](/api/required/),
*   [`safeParse`](/api/safeParse/),
*   [`safeParser`](/api/safeParser/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nanoid`](/api/nanoid/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#rawcheckasync)rawCheckAsync
===============================

Creates a raw check validation action.

`const Action = v.rawCheckAsync<TInput>(action);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#parameters)Parameters
-------------------------

*   `action` `(context: [Context](/api/rawCheck/Context/)<TInput>) => [MaybePromise](/api/MaybePromise/)<void>`

### [](#explanation)Explanation

With `rawCheckAsync` you can freely validate the input with a custom `action` and add issues if necessary.

[](#returns)Returns
-------------------

*   `Action` `[RawCheckActionAsync](/api/RawCheckActionAsync/)<TInput>`

[](#examples)Examples
---------------------

The following examples show how `rawCheckAsync` can be used.

### [](#add-users-schema)Add users schema

Object schema that ensures that only users not already in the group are included.

> This `rawCheckAsync` validation action adds an issue for any invalid username and forwards it via `path` to the appropriate nested field.

`import { isAlreadyInGroup } from '~/api';  const AddUsersSchema = v.pipeAsync(   v.object({     groupId: v.pipe(v.string(), v.uuid()),     usernames: v.array(v.pipe(v.string(), v.nonEmpty())),   }),   v.rawCheckAsync(async ({ dataset, addIssue }) => {     if (dataset.typed) {       await Promise.all(         dataset.value.usernames.map(async (username, index) => {           if (await isAlreadyInGroup(username, dataset.value.groupId)) {             addIssue({               received: username,               message: 'The user is already in the group.',               path: [                 {                   type: 'object',                   origin: 'value',                   input: dataset.value,                   key: 'usernames',                   value: dataset.value.usernames,                 },                 {                   type: 'array',                   origin: 'value',                   input: dataset.value.usernames,                   key: index,                   value: username,                 },               ],             });           }         })       );     }   }) );`

[](#related)Related
-------------------

The following APIs can be combined with `rawCheckAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#rawtransformasync)rawTransformAsync
=======================================

Creates a raw transformation action.

`const Action = v.rawTransformAsync<TInput, TOutput>(action);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#parameters)Parameters
-------------------------

*   `action` `(context: [Context](/api/rawTransform/Context/)<TInput>) => [MaybePromise](/api/MaybePromise/)<TOutput>`

### [](#explanation)Explanation

With `rawTransformAsync` you can freely transform and validate the input with a custom `action` and add issues if necessary.

[](#returns)Returns
-------------------

*   `Action` `[RawTransformActionAsync](/api/RawTransformActionAsync/)<TInput, TOutput>`

[](#examples)Examples
---------------------

The following examples show how `rawTransformAsync` can be used.

### [](#order-schema)Order schema

Schema that rejects an order that does not meet a requirement when free delivery is expected.

``import { getTotalAmount } from '~/api'; import { FREE_DELIVERY_MIN_AMOUNT } from '~/constants';  const OrderSchema = v.pipeAsync(   v.object({     cart: v.array(       v.object({         itemId: v.pipe(v.string(), v.uuid()),         quantity: v.pipe(v.number(), v.integer(), v.minValue(1)),       })     ),     expectsFreeDelivery: v.optional(v.boolean(), false),   }),   v.rawTransformAsync(     async ({ dataset: { value: input }, addIssue, NEVER }) => {       const total = await getTotalAmount(input.cart);       if (input.expectsFreeDelivery && total < FREE_DELIVERY_MIN_AMOUNT) {         addIssue({           label: 'order',           expected: `>=${FREE_DELIVERY_MIN_AMOUNT}`,           received: `${total}`,           message: `The total amount must be at least $${FREE_DELIVERY_MIN_AMOUNT} for free delivery.`,           path: [             {               type: 'object',               origin: 'value',               input,               key: 'cart',               value: input.cart,             },           ],         });         return NEVER;       }       return { ...input, total };     }   ) );``

[](#related)Related
-------------------

The following APIs can be combined with `rawTransformAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#recordasync)recordAsync
===========================

Creates a record schema.

`const Schema = v.recordAsync<TKey, TValue, TMessage>(key, value, message);`

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<string, string | number | symbol, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<string, string | number | symbol, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[RecordIssue](/api/RecordIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `key` `TKey`
*   `value` `TValue`
*   `message` `TMessage`

### [](#explanation)Explanation

With `recordAsync` you can validate the data type of the input and whether the entries match `key` and `value`. If the input is not an object, you can use `message` to customize the error message.

> This schema filters certain entries from the record for security reasons.

> This schema marks an entry as optional if it detects that its key is a literal type. The reason for this is that it is not technically possible to detect missing literal keys without restricting the `key` schema to [`string`](/api/string/), [`enum`](/api/enum/) and [`picklist`](/api/picklist/). However, if [`enum`](/api/enum/) and [`picklist`](/api/picklist/) are used, it is better to use [`objectAsync`](/api/objectAsync/) with [`entriesFromList`](/api/entriesFromList/) because it already covers the needed functionality. This decision also reduces the bundle size of `recordAsync`, because it only needs to check the entries of the input and not any missing keys.

[](#returns)Returns
-------------------

*   `Schema` `[RecordSchemaAsync](/api/RecordSchemaAsync/)<TKey, TValue, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `recordAsync` can be used.

### [](#id-to-email-schema)ID to email schema

Schema to validate a record that maps an ID to a public user email.

`import { isEmailPublic } from '~/api';  const IdToEmailSchema = v.recordAsync(   v.pipe(v.string(), v.uuid()),   v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPublic, 'The email address is private.')   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `recordAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#requiredasync)requiredAsync
===============================

Creates a modified copy of an object schema that marks all or only the selected entries as required.

`const AllKeysSchema = v.requiredAsync<TSchema, TMessage>(schema, message); const SelectedKeysSchema = v.requiredAsync<TSchema, TKeys, TMessage>(   schema,   keys,   message );`

[](#generics)Generics
---------------------

*   `TSchema` `extends [SchemaWithoutPipe](/api/SchemaWithoutPipe/)<[LooseObjectSchemaAsync](/api/LooseObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [ErrorMessage](/api/ErrorMessage/)<[LooseObjectIssue](/api/LooseObjectIssue/)> | undefined> | [ObjectSchemaAsync](/api/ObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [ErrorMessage](/api/ErrorMessage/)<[ObjectIssue](/api/ObjectIssue/)> | undefined> | [ObjectWithRestSchemaAsync](/api/ObjectWithRestSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [StrictObjectSchemaAsync](/api/StrictObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [ErrorMessage](/api/ErrorMessage/)<[StrictObjectIssue](/api/StrictObjectIssue/)> | undefined>>`
*   `TKeys` `[ObjectKeys](/api/ObjectKeys/)<TSchema>`
*   `TMessage` `[ErrorMessage](/api/ErrorMessage/)<[NonOptionalIssue](/api/NonOptionalIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `keys` `TKey`
*   `message` `TMessage`

### [](#explanation)Explanation

`requiredAsync` creates a modified copy of the given object `schema` where all or only the selected `keys` are required. It is similar to TypeScript's [`Required`](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype) utility type.

> Because `requiredAsync` changes the data type of the input and output, it is not allowed to pass a schema that has been modified by the [`pipeAsync`](/api/pipeAsync/) method, as this may cause runtime errors. Please use the [`pipeAsync`](/api/pipeAsync/) method after you have modified the schema with `requiredAsync`.

[](#returns)Returns
-------------------

*   `AllKeysSchema` `[SchemaWithRequiredAsync](/api/SchemaWithRequiredAsync/)<TSchema, undefined, TMessage>`
*   `SelectedKeysSchema` `[SchemaWithRequiredAsync](/api/SchemaWithRequiredAsync/)<TSchema, TKeys, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `requiredAsync` can be used.

### [](#new-task-schema)New task schema

Schema to validate an object containing task details.

`import { isOwnerPresent } from '~/api';  const UpdateTaskSchema = v.objectAsync({   owner: v.optionalAsync(     v.pipeAsync(       v.string(),       v.email(),       v.checkAsync(isOwnerPresent, 'The owner is not in the database.')     )   ),   title: v.optional(v.pipe(v.string(), v.nonEmpty(), v.maxLength(255))),   description: v.optional(v.pipe(v.string(), v.nonEmpty())), });  const NewTaskSchema = v.requiredAsync(UpdateTaskSchema);  /*   {     owner: string;     title: string;     description: string;   } */`

[](#related)Related
-------------------

The following APIs can be combined with `requiredAsync`.

### [](#schemas)Schemas

*   [`array`](/api/array/),
*   [`exactOptional`](/api/exactOptional/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`forward`](/api/forward/),
*   [`getDefault`](/api/getDefault/),
*   [`getDefaults`](/api/getDefaults/),
*   [`getFallback`](/api/getFallback/),
*   [`getFallbacks`](/api/getFallbacks/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/)

[](#returnsasync)returnsAsync
=============================

Creates a function return transformation action.

`const Action = v.returnsAsync<TInput, TSchema>(schema);`

[](#generics)Generics
---------------------

*   `TInput` `extends (...args: any[]) => unknown`
*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`

### [](#explanation)Explanation

With `returnsAsync` you can force the returned value of a function to match the given `schema`.

[](#returns)Returns
-------------------

*   `Action` `[ReturnsActionAsync](/api/ReturnsActionAsync/)<TInput, TSchema>`

[](#examples)Examples
---------------------

The following examples show how `returnsAsync` can be used.

### [](#product-function-schema)Product function schema

Schema of a function that returns a product by its ID.

`import { isValidProductId } from '~/api';  const ProductFunctionSchema = v.pipeAsync(   v.function(),   v.argsAsync(     v.tupleAsync([v.pipeAsync(v.string(), v.checkAsync(isValidProductId))])   ),   v.returnsAsync(     v.pipeAsync(       v.promise(),       v.awaitAsync(),       v.object({         id: v.string(),         name: v.string(),         price: v.number(),       })     )   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `returnsAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`pipe`](/api/pipe/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#safeparseasync)safeParseAsync
=================================

Parses an unknown input based on a schema.

`const result = v.safeParseAsync<TSchema>(schema, input, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `input` `unknown`
*   `config` `[Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#returns)Returns
-------------------

*   `result` `Promise<[SafeParseResult](/api/SafeParseResult/)<TSchema>>`

[](#example)Example
-------------------

The following example shows how `safeParseAsync` can be used.

`import { isEmailPresent } from '~/api';  const StoredEmailSchema = v.pipeAsync(   v.string(),   v.email(),   v.checkAsync(isEmailPresent, 'The email is not in the database.') ); const result = await v.safeParseAsync(StoredEmailSchema, 'jane@example.com');  if (result.success) {   const storedEmail = result.output; } else {   console.error(result.issues); }`

[](#related)Related
-------------------

The following APIs can be combined with `safeParseAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`flatten`](/api/flatten/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`summarize`](/api/summarize/),
*   [`unwrap`](/api/unwrap/)

### [](#utils)Utils

*   [`getDotPath`](/api/getDotPath/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#safeparserasync)safeParserAsync
===================================

Returns a function that parses an unknown input based on a schema.

`const safeParser = v.safeParserAsync<TSchema, TConfig>(schema, config);`

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TConfig` `extends [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#parameters)Parameters
-------------------------

*   `schema` `TSchema`
*   `config` `TConfig`

[](#returns)Returns
-------------------

*   `safeParser` `[SafeParserAsync](/api/SafeParserAsync/)<TSchema, TConfig>`

[](#example)Example
-------------------

The following example shows how `safeParserAsync` can be used.

`import { isEmailPresent } from '~/api';  const StoredEmailSchema = v.pipeAsync(   v.string(),   v.email(),   v.checkAsync(isEmailPresent, 'The email is not in the database.') ); const safeStoredEmailParser = v.safeParserAsync(StoredEmailSchema); const result = await safeStoredEmailParser('jane@example.com');  if (result.success) {   const storedEmail = result.output; } else {   console.error(result.issues); }`

[](#related)Related
-------------------

The following APIs can be combined with `safeParserAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`assert`](/api/assert/),
*   [`config`](/api/config/),
*   [`fallback`](/api/fallback/),
*   [`flatten`](/api/flatten/),
*   [`keyof`](/api/keyof/),
*   [`message`](/api/message/),
*   [`omit`](/api/omit/),
*   [`partial`](/api/partial/),
*   [`pick`](/api/pick/),
*   [`pipe`](/api/pipe/),
*   [`required`](/api/required/),
*   [`summarize`](/api/summarize/),
*   [`unwrap`](/api/unwrap/)

### [](#utils)Utils

*   [`getDotPath`](/api/getDotPath/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#setasync)setAsync
=====================

Creates a set schema.

`const Schema = v.setAsync<TValue, TMessage>(value, message);`

[](#generics)Generics
---------------------

*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SetIssue](/api/SetIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `value` `TValue`
*   `message` `TMessage`

### [](#explanation)Explanation

With `setAsync` you can validate the data type of the input and whether the content matches `value`. If the input is not a set, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[SetSchemaAsync](/api/SetSchemaAsync/)<TValue, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `setAsync` can be used.

### [](#allowed-ips-schema)Allowed IPs schema

Schema to validate a set of allowed IP addresses.

`import { isIpAllowed } from '~/api';  const AllowedIPsSchema = v.setAsync(   v.pipeAsync(     v.string(),     v.ip(),     v.checkAsync(isIpAllowed, 'This IP address is not allowed.')   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `setAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`maxSize`](/api/maxSize/),
*   [`metadata`](/api/metadata/),
*   [`minSize`](/api/minSize/),
*   [`notSize`](/api/notSize/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`size`](/api/size/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#strictobjectasync)strictObjectAsync
=======================================

Creates a strict object schema.

`const Schema = v.strictObjectAsync<TEntries, TMessage>(entries, message);`

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntriesAsync](/api/ObjectEntriesAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StrictObjectIssue](/api/StrictObjectIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `entries` `TEntries`
*   `message` `TMessage`

### [](#explanation)Explanation

With `strictObjectAsync` you can validate the data type of the input and whether the content matches `entries`. If the input is not an object or does include unknown entries, you can use `message` to customize the error message.

> The difference to [`objectAsync`](/api/objectAsync/) is that this schema returns an issue for unknown entries. It intentionally returns only one issue. Otherwise, attackers could send large objects to exhaust device resources. If you want an issue for every unknown key, use the [`objectWithRestAsync`](/api/objectWithRestAsync/) schema with [`never`](/api/never/) for the `rest` argument.

[](#returns)Returns
-------------------

*   `Schema` `[StrictObjectSchemaAsync](/api/StrictObjectSchemaAsync/)<TEntries, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `strictObjectAsync` can be used. Please see the [object guide](/guides/objects/) for more examples and explanations.

### [](#new-user-schema)New user schema

Schema to validate a strict object containing only specific new user details.

`import { isEmailPresent } from '~/api';  const NewUserSchema = v.strictObjectAsync({   firstName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),   lastName: v.pipe(v.string(), v.minLength(2), v.maxLength(45)),   email: v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is already in use by another user.')   ),   password: v.pipe(v.string(), v.minLength(8)),   avatar: v.optional(v.pipe(v.string(), v.url())), });`

[](#related)Related
-------------------

The following APIs can be combined with `strictObjectAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`keyof`](/api/keyof/),
*   [`omit`](/api/omit/),
*   [`pick`](/api/pick/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`forwardAsync`](/api/forwardAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialAsync`](/api/partialAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`requiredAsync`](/api/requiredAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#stricttupleasync)strictTupleAsync
=====================================

Creates a strict tuple schema.

`const Schema = v.strictTupleAsync<TItems, TMessage>(items, message);`

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItemsAsync](/api/TupleItemsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `items` `TItems`
*   `message` `TMessage`

### [](#explanation)Explanation

With `strictTupleAsync` you can validate the data type of the input and whether the content matches `items`. If the input is not an array or does include unknown items, you can use `message` to customize the error message.

> The difference to [`tupleAsync`](/api/tupleAsync/) is that this schema returns an issue for unknown items. It intentionally returns only one issue. Otherwise, attackers could send large arrays to exhaust device resources. If you want an issue for every unknown item, use the [`tupleWithRestAsync`](/api/tupleWithRestAsync/) schema with [`never`](/api/never/) for the `rest` argument.

[](#returns)Returns
-------------------

*   `Schema` `[StrictTupleSchemaAsync](/api/StrictTupleSchemaAsync/)<TItems, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `strictTupleAsync` can be used. Please see the [arrays guide](/guides/arrays/) for more examples and explanations.

### [](#number-and-email-tuple)Number and email tuple

Schema to validate a strict tuple with one number and one stored email address.

`import { isEmailPresent } from '~/api';  const TupleSchema = v.strictTupleAsync([   v.number(),   v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is not in the database.')   ), ]);`

[](#related)Related
-------------------

The following APIs can be combined with `strictTupleAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#transformasync)transformAsync
=================================

Creates a custom transformation action.

`const Action = v.transformAsync<TInput, TOutput>(operation);`

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#parameters)Parameters
-------------------------

*   `operation` `(input: TInput) => Promise<TOutput>`

### [](#explanation)Explanation

`transformAsync` can be used to freely transform the input. The `operation` parameter is a function that takes the input and returns the transformed output.

[](#returns)Returns
-------------------

*   `Action` `[TransformActionAsync](/api/TransformActionAsync/)<TInput, TOutput>`

[](#examples)Examples
---------------------

The following examples show how `transformAsync` can be used.

### [](#blob-to-string)Blob to string

Schema that transforms a blob to its string value.

`const StringSchema = v.pipeAsync(   v.blob(),   v.transformAsync((value) => value.text()) );`

[](#related)Related
-------------------

The following APIs can be combined with `transformAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#utils)Utils

*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`undefinedableAsync`](/api/undefinedableAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#tupleasync)tupleAsync
=========================

Creates a tuple schema.

`const Schema = v.tupleAsync<TItems, TMessage>(items, message);`

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItemsAsync](/api/TupleItemsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `items` `TItems`
*   `message` `TMessage`

### [](#explanation)Explanation

With `tupleAsync` you can validate the data type of the input and whether the content matches `items`. If the input is not an array, you can use `message` to customize the error message.

> This schema removes unknown items. The output will only include the items you specify. To include unknown items, use [`looseTupleAsync`](/api/looseTupleAsync/). To return an issue for unknown items, use [`strictTupleAsync`](/api/strictTupleAsync/). To include and validate unknown items, use [`tupleWithRestAsync`](/api/tupleWithRestAsync/).

[](#returns)Returns
-------------------

*   `Schema` `[TupleSchemaAsync](/api/TupleSchemaAsync/)<TItems, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `tupleAsync` can be used. Please see the [arrays guide](/guides/arrays/) for more examples and explanations.

### [](#number-and-email-tuple)Number and email tuple

Schema to validate a tuple with one number and one stored email address.

`import { isEmailPresent } from '~/api';  const TupleSchema = v.tupleAsync([   v.number(),   v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is not in the database.')   ), ]);`

[](#related)Related
-------------------

The following APIs can be combined with `tupleAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#tuplewithrestasync)tupleWithRestAsync
=========================================

Creates a tuple with rest schema.

`const Schema = v.tupleWithRestAsync<TItems, TRest, TMessage>(   items,   rest,   message );`

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItemsAsync](/api/TupleItemsAsync/)`
*   `TRest` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `items` `TItems`
*   `rest` `TRest`
*   `message` `TMessage`

### [](#explanation)Explanation

With `tupleWithRestAsync` you can validate the data type of the input and whether the content matches `items` and `rest`. If the input is not an array, you can use `message` to customize the error message.

[](#returns)Returns
-------------------

*   `Schema` `[TupleWithRestSchemaAsync](/api/TupleWithRestSchemaAsync/)<TItems, TRest, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `tupleWithRestAsync` can be used. Please see the [arrays guide](/guides/arrays/) for more examples and explanations.

### [](#tuple-schema-with-rest)Tuple schema with rest

Schema to validate a tuple with generic rest items.

`import { isEmailPresent } from '~/api';  const TupleSchemaWithRest = v.tupleWithRestAsync(   [     v.number(),     v.pipeAsync(       v.string(),       v.email(),       v.checkAsync(isEmailPresent, 'The email is not in the database.')     ),   ],   v.boolean() );`

[](#related)Related
-------------------

The following APIs can be combined with `tupleWithRestAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`brand`](/api/brand/),
*   [`description`](/api/description/),
*   [`empty`](/api/empty/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`flavor`](/api/flavor/),
*   [`includes`](/api/includes/),
*   [`length`](/api/length/),
*   [`mapItems`](/api/mapItems/),
*   [`maxLength`](/api/maxLength/),
*   [`metadata`](/api/metadata/),
*   [`minLength`](/api/minLength/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notLength`](/api/notLength/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`someItem`](/api/someItem/),
*   [`sortItems`](/api/sortItems/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#undefinedableasync)undefinedableAsync
=========================================

Creates an undefinedable schema.

`const Schema = v.undefinedableAsync<TWrapped, TDefault>(wrapped, default_);`

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, undefined>`

[](#parameters)Parameters
-------------------------

*   `wrapped` `TWrapped`
*   `default_` `TDefault`

### [](#explanation)Explanation

With `undefinedableAsync` the validation of your schema will pass `undefined` inputs, and if you specify a `default_` input value, the schema will use it if the input is `undefined`. For this reason, the output type may differ from the input type of the schema.

> `undefinedableAsync` behaves exactly the same as [`optionalAsync`](/api/optionalAsync/) at runtime. The only difference is the input and output type when used for object entries. While [`optionalAsync`](/api/optionalAsync/) adds a question mark to the key, `undefinedableAsync` does not.

> Note that `undefinedableAsync` does not accept `null` as an input. If you want to accept `null` inputs, use [`nullableAsync`](/api/nullableAsync/), and if you want to accept `null` and `undefined` inputs, use [`nullishAsync`](/api/nullishAsync/) instead. Also, if you want to set a default output value for any invalid input, you should use [`fallbackAsync`](/api/fallbackAsync/) instead.

[](#returns)Returns
-------------------

*   `Schema` `[UndefinedableSchemaAsync](/api/UndefinedableSchemaAsync/)<TWrapped, TDefault>`

[](#examples)Examples
---------------------

The following examples show how `undefinedableAsync` can be used.

### [](#undefinedable-username-schema)Undefinedable username schema

Schema that accepts a unique username or `undefined`.

> By using a function as the `default_` parameter, the schema will return a unique username from the function call each time the input is `undefined`.

`import { getUniqueUsername, isUsernameUnique } from '~/api';  const UndefinedableUsernameSchema = v.undefinedableAsync(   v.pipeAsync(     v.string(),     v.nonEmpty(),     v.checkAsync(isUsernameUnique, 'The username is not unique.')   ),   getUniqueUsername );`

### [](#new-user-schema)New user schema

Schema to validate new user details.

`import { isEmailUnique, isUsernameUnique } from '~/api';  const NewUserSchema = v.objectAsync({   email: v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailUnique, 'The email is not unique.')   ),   username: v.undefinedableAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ),   password: v.pipe(v.string(), v.minLength(8)), });  /*   The input and output types of the schema:     {       email: string;       password: string;       username: string | undefined;     } */`

### [](#unwrap-undefinedable-schema)Unwrap undefinedable schema

Use [`unwrap`](/api/unwrap/) to undo the effect of `undefinedableAsync`.

`import { isUsernameUnique } from '~/api';  const UsernameSchema = v.unwrap(   // Assume this schema is from a different file and is reused here   v.undefinedableAsync(     v.pipeAsync(       v.string(),       v.nonEmpty(),       v.checkAsync(isUsernameUnique, 'The username is not unique.')     )   ) );`

[](#related)Related
-------------------

The following APIs can be combined with `undefinedableAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonUndefinedable`](/api/nonUndefinedable/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/),
*   [`unwrap`](/api/unwrap/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`flavor`](/api/flavor/),
*   [`metadata`](/api/metadata/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`unionAsync`](/api/unionAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#unionasync)unionAsync
=========================

Creates an union schema.

> I recommend that you read the [unions guide](/guides/unions/) before using this schema function.

`const Schema = v.unionAsync<TOptions, TMessage>(options, message);`

[](#generics)Generics
---------------------

*   `TOptions` `extends [UnionOptionsAsync](/api/UnionOptionsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UnionIssue](/api/UnionIssue/)<[InferIssue](/api/InferIssue/)<TOptions[number]>>> | undefined`

[](#parameters)Parameters
-------------------------

*   `options` `TOptions`
*   `message` `TMessage`

### [](#explanation)Explanation

With `unionAsync` you can validate if the input matches one of the given `options`. If the input does not match a schema and cannot be clearly assigned to one of the options, you can use `message` to customize the error message.

If a bad input can be uniquely assigned to one of the schemas based on the data type, the result of that schema is returned. Otherwise, a general issue is returned that contains the issues of each schema as subissues. This is a special case within the library, as the issues of `unionAsync` can contradict each other.

[](#returns)Returns
-------------------

*   `Schema` `[UnionSchemaAsync](/api/UnionSchemaAsync/)<TOptions, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `unionAsync` can be used.

### [](#user-schema)User schema

Schema to validate a user's email or username.

`import { isEmailPresent, isUsernamePresent } from '~/api';  const UserSchema = v.unionAsync([   v.pipeAsync(     v.string(),     v.email(),     v.checkAsync(isEmailPresent, 'The email is not in the database.')   ),   v.pipeAsync(     v.string(),     v.nonEmpty(),     v.checkAsync(isUsernamePresent, 'The username is not in the database.')   ), ]);`

[](#related)Related
-------------------

The following APIs can be combined with `unionAsync`.

### [](#schemas)Schemas

*   [`any`](/api/any/),
*   [`array`](/api/array/),
*   [`bigint`](/api/bigint/),
*   [`blob`](/api/blob/),
*   [`boolean`](/api/boolean/),
*   [`custom`](/api/custom/),
*   [`date`](/api/date/),
*   [`enum`](/api/enum/),
*   [`exactOptional`](/api/exactOptional/),
*   [`file`](/api/file/),
*   [`function`](/api/function/),
*   [`instance`](/api/instance/),
*   [`intersect`](/api/intersect/),
*   [`lazy`](/api/lazy/),
*   [`literal`](/api/literal/),
*   [`looseObject`](/api/looseObject/),
*   [`looseTuple`](/api/looseTuple/),
*   [`map`](/api/map/),
*   [`nan`](/api/nan/),
*   [`never`](/api/never/),
*   [`nonNullable`](/api/nonNullable/),
*   [`nonNullish`](/api/nonNullish/),
*   [`nonOptional`](/api/nonOptional/),
*   [`null`](/api/null/),
*   [`nullable`](/api/nullable/),
*   [`nullish`](/api/nullish/),
*   [`number`](/api/number/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`optional`](/api/optional/),
*   [`picklist`](/api/picklist/),
*   [`promise`](/api/promise/),
*   [`record`](/api/record/),
*   [`set`](/api/set/),
*   [`strictObject`](/api/strictObject/),
*   [`strictTuple`](/api/strictTuple/),
*   [`string`](/api/string/),
*   [`symbol`](/api/symbol/),
*   [`tuple`](/api/tuple/),
*   [`tupleWithRest`](/api/tupleWithRest/),
*   [`undefined`](/api/undefined/),
*   [`undefinedable`](/api/undefinedable/),
*   [`union`](/api/union/),
*   [`unknown`](/api/unknown/),
*   [`variant`](/api/variant/),
*   [`void`](/api/void/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`args`](/api/args/),
*   [`base64`](/api/base64/),
*   [`bic`](/api/bic/),
*   [`brand`](/api/brand/),
*   [`bytes`](/api/bytes/),
*   [`check`](/api/check/),
*   [`checkItems`](/api/checkItems/),
*   [`creditCard`](/api/creditCard/),
*   [`cuid2`](/api/cuid2/),
*   [`decimal`](/api/decimal/),
*   [`description`](/api/description/),
*   [`digits`](/api/digits/),
*   [`email`](/api/email/),
*   [`emoji`](/api/emoji/),
*   [`empty`](/api/empty/),
*   [`endsWith`](/api/endsWith/),
*   [`entries`](/api/entries/),
*   [`everyItem`](/api/everyItem/),
*   [`excludes`](/api/excludes/),
*   [`filterItems`](/api/filterItems/),
*   [`findItem`](/api/findItem/),
*   [`finite`](/api/finite/),
*   [`flavor`](/api/flavor/),
*   [`graphemes`](/api/graphemes/),
*   [`gtValue`](/api/gtValue/),
*   [`hash`](/api/hash/),
*   [`hexadecimal`](/api/hexadecimal/),
*   [`hexColor`](/api/hexColor/),
*   [`imei`](/api/imei/),
*   [`includes`](/api/includes/),
*   [`integer`](/api/integer/),
*   [`ip`](/api/ip/),
*   [`ipv4`](/api/ipv4/),
*   [`ipv6`](/api/ipv6/),
*   [`isoDate`](/api/isoDate/),
*   [`isoDateTime`](/api/isoDateTime/),
*   [`isoTime`](/api/isoTime/),
*   [`isoTimeSecond`](/api/isoTimeSecond/),
*   [`isoTimestamp`](/api/isoTimestamp/),
*   [`isoWeek`](/api/isoWeek/),
*   [`length`](/api/length/),
*   [`ltValue`](/api/ltValue/),
*   [`mac`](/api/mac/),
*   [`mac48`](/api/mac48/),
*   [`mac64`](/api/mac64/),
*   [`mapItems`](/api/mapItems/),
*   [`maxBytes`](/api/maxBytes/),
*   [`maxEntries`](/api/maxEntries/),
*   [`maxGraphemes`](/api/maxGraphemes/),
*   [`maxLength`](/api/maxLength/),
*   [`maxSize`](/api/maxSize/),
*   [`maxValue`](/api/maxValue/),
*   [`maxWords`](/api/maxWords/),
*   [`metadata`](/api/metadata/),
*   [`mimeType`](/api/mimeType/),
*   [`minBytes`](/api/minBytes/),
*   [`minEntries`](/api/minEntries/),
*   [`minGraphemes`](/api/minGraphemes/),
*   [`minLength`](/api/minLength/),
*   [`minSize`](/api/minSize/),
*   [`minValue`](/api/minValue/),
*   [`minWords`](/api/minWords/),
*   [`multipleOf`](/api/multipleOf/),
*   [`nonEmpty`](/api/nonEmpty/),
*   [`notBytes`](/api/notBytes/),
*   [`notEntries`](/api/notEntries/),
*   [`notGraphemes`](/api/notGraphemes/),
*   [`notLength`](/api/notLength/),
*   [`notSize`](/api/notSize/),
*   [`notValue`](/api/notValue/),
*   [`notValues`](/api/notValues/),
*   [`notWords`](/api/notWords/),
*   [`octal`](/api/octal/),
*   [`parseJson`](/api/parseJson/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`reduceItems`](/api/reduceItems/),
*   [`regex`](/api/regex/),
*   [`returns`](/api/returns/),
*   [`rfcEmail`](/api/rfcEmail/),
*   [`safeInteger`](/api/safeInteger/),
*   [`size`](/api/size/),
*   [`slug`](/api/slug/),
*   [`someItem`](/api/someItem/),
*   [`sortItem`](/api/sortItem/),
*   [`startsWith`](/api/startsWith/),
*   [`stringifyJson`](/api/stringifyJson/),
*   [`title`](/api/title/),
*   [`toLowerCase`](/api/toLowerCase/),
*   [`toMaxValue`](/api/toMaxValue/),
*   [`toMinValue`](/api/toMinValue/),
*   [`toUpperCase`](/api/toUpperCase/),
*   [`transform`](/api/transform/),
*   [`trim`](/api/trim/),
*   [`trimEnd`](/api/trimEnd/),
*   [`trimStart`](/api/trimStart/),
*   [`ulid`](/api/ulid/),
*   [`url`](/api/url/),
*   [`uuid`](/api/uuid/),
*   [`value`](/api/value/),
*   [`values`](/api/values/),
*   [`words`](/api/words/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`arrayAsync`](/api/arrayAsync/),
*   [`awaitAsync`](/api/awaitAsync/),
*   [`checkAsync`](/api/checkAsync/),
*   [`customAsync`](/api/customAsync/),
*   [`exactOptionalAsync`](/api/exactOptionalAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`intersectAsync`](/api/intersectAsync/),
*   [`lazyAsync`](/api/lazyAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`looseTupleAsync`](/api/looseTupleAsync/),
*   [`mapAsync`](/api/mapAsync/),
*   [`nonNullableAsync`](/api/nonNullableAsync/),
*   [`nonNullishAsync`](/api/nonNullishAsync/),
*   [`nonOptionalAsync`](/api/nonOptionalAsync/),
*   [`nullableAsync`](/api/nullableAsync/),
*   [`nullishAsync`](/api/nullishAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`optionalAsync`](/api/optionalAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`recordAsync`](/api/recordAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`setAsync`](/api/setAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`strictTupleAsync`](/api/strictTupleAsync/),
*   [`transformAsync`](/api/transformAsync/),
*   [`tupleAsync`](/api/tupleAsync/),
*   [`tupleWithRestAsync`](/api/tupleWithRestAsync/),
*   [`variantAsync`](/api/variantAsync/)

[](#variantasync)variantAsync
=============================

Creates a variant schema.

`const Schema = v.variantAsync<TKey, TOptions, TMessage>(key, options, message);`

[](#generics)Generics
---------------------

*   `TKey` `extends string`
*   `TOptions` `extends [VariantOptionsAsync](/api/VariantOptionsAsync/)<TKey>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[VariantIssue](/api/VariantIssue/)> | undefined`

[](#parameters)Parameters
-------------------------

*   `key` `TKey`
*   `options` `TOptions`
*   `message` `TMessage`

### [](#explanation)Explanation

With `variantAsync` you can validate if the input matches one of the given object `options`. The object schema to be used for the validation is determined by the discriminator `key`. If the input does not match a schema and cannot be clearly assigned to one of the options, you can use `message` to customize the error message.

> It is allowed to specify the exact same or a similar discriminator multiple times. However, in such cases `variantAsync` will only return the output of the first untyped or typed variant option result. Typed results take precedence over untyped ones.

> For deeply nested `variant` schemas with several different discriminator keys, `variant` will return an issue for the first most likely object schemas on invalid input. The order of the discriminator keys and the presence of a discriminator in the input are taken into account.

[](#returns)Returns
-------------------

*   `Schema` `[VariantSchemaAsync](/api/VariantSchemaAsync/)<TKey, TOptions, TMessage>`

[](#examples)Examples
---------------------

The following examples show how `variantAsync` can be used.

### [](#message-schema)Message schema

Schema to validate a message object.

`import { isValidGroupReceiver, isValidUserReceiver } from '~/api';  const MessageSchema = v.objectAsync({   message: v.pipe(v.string(), v.nonEmpty()),   receiver: v.variantAsync('type', [     v.objectAsync({       type: v.literal('group'),       groupId: v.pipeAsync(         v.string(),         v.uuid(),         v.checkAsync(isValidGroupReceiver, 'The group cannot receive messages.')       ),     }),     v.objectAsync({       type: v.literal('user'),       email: v.pipeAsync(         v.string(),         v.email(),         v.checkAsync(isValidUserReceiver, 'The user cannot receive messages.')       ),     }),   ]), });`

### [](#user-schema)User schema

Schema to validate unique user details.

`import { isRegisteredEmail, isRegisteredUsername, isValidUserId } from '~/api';  const UserSchema = v.variantAsync('type', [   // Assume this schema is from a different file and reused here.   v.variantAsync('type', [     v.objectAsync({       type: v.literal('email'),       email: v.pipeAsync(         v.string(),         v.email(),         v.checkAsync(isRegisteredEmail, 'The email is not registered.')       ),     }),     v.objectAsync({       type: v.literal('username'),       username: v.pipeAsync(         v.string(),         v.nonEmpty(),         v.checkAsync(isRegisteredUsername, 'The username is not registered.')       ),     }),   ]),   v.objectAsync({     type: v.literal('userId'),     userId: v.pipeAsync(       v.string(),       v.uuid(),       v.checkAsync(isValidUserId, 'The user id is not valid.')     ),   }), ]);`

[](#related)Related
-------------------

The following APIs can be combined with `variantAsync`.

### [](#schemas)Schemas

*   [`looseObject`](/api/looseObject/),
*   [`object`](/api/object/),
*   [`objectWithRest`](/api/objectWithRest/),
*   [`strictObject`](/api/strictObject/)

### [](#methods)Methods

*   [`config`](/api/config/),
*   [`getDefault`](/api/getDefault/),
*   [`getFallback`](/api/getFallback/)

### [](#actions)Actions

*   [`brand`](/api/brand/),
*   [`check`](/api/check/),
*   [`description`](/api/description/),
*   [`entries`](/api/entries/),
*   [`flavor`](/api/flavor/),
*   [`maxEntries`](/api/maxEntries/),
*   [`metadata`](/api/metadata/),
*   [`minEntries`](/api/minEntries/),
*   [`notEntries`](/api/notEntries/),
*   [`partialCheck`](/api/partialCheck/),
*   [`rawCheck`](/api/rawCheck/),
*   [`rawTransform`](/api/rawTransform/),
*   [`readonly`](/api/readonly/),
*   [`title`](/api/title/),
*   [`transform`](/api/transform/)

### [](#utils)Utils

*   [`entriesFromList`](/api/entriesFromList/),
*   [`isOfKind`](/api/isOfKind/),
*   [`isOfType`](/api/isOfType/)

### [](#async)Async

*   [`checkAsync`](/api/checkAsync/),
*   [`fallbackAsync`](/api/fallbackAsync/),
*   [`getDefaultsAsync`](/api/getDefaultsAsync/),
*   [`getFallbacksAsync`](/api/getFallbacksAsync/),
*   [`looseObjectAsync`](/api/looseObjectAsync/),
*   [`objectAsync`](/api/objectAsync/),
*   [`objectWithRestAsync`](/api/objectWithRestAsync/),
*   [`parseAsync`](/api/parseAsync/),
*   [`parserAsync`](/api/parserAsync/),
*   [`partialCheckAsync`](/api/partialCheckAsync/),
*   [`pipeAsync`](/api/pipeAsync/),
*   [`rawCheckAsync`](/api/rawCheckAsync/),
*   [`rawTransformAsync`](/api/rawTransformAsync/),
*   [`safeParseAsync`](/api/safeParseAsync/),
*   [`safeParserAsync`](/api/safeParserAsync/),
*   [`strictObjectAsync`](/api/strictObjectAsync/),
*   [`transformAsync`](/api/transformAsync/)

[](#anyschema)AnySchema
=======================

Any schema interface.

[](#definition)Definition
-------------------------

*   `AnySchema` `extends [BaseSchema](/api/BaseSchema/)<any, any, never>`
    *   `type` `'any'`
    *   `reference` `typeof [any](/api/any/)`
    *   `expects` `'any'`

[](#argsaction)ArgsAction
=========================

Args action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends (...args: any[]) => unknown`
*   `TSchema` `extends [LooseTupleSchema](/api/LooseTupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined> | [StrictTupleSchema](/api/StrictTupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined> | [TupleSchema](/api/TupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined> | [TupleWithRestSchema](/api/TupleWithRestSchema/)<[TupleItems](/api/TupleItems/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined>`

[](#definition)Definition
-------------------------

*   `ArgsAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, (...args: [InferInput](/api/InferInput/)<TSchema>) => ReturnType<TInput>, never>`
    *   `type` `'args'`
    *   `reference` `typeof [args](/api/args/)`
    *   `schema` `TSchema`

[](#argsactionasync)ArgsActionAsync
===================================

Args action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends (...args: any[]) => unknown`
*   `TSchema` `extends [LooseTupleSchema](/api/LooseTupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined> | [LooseTupleSchemaAsync](/api/LooseTupleSchemaAsync/)<[TupleItemsAsync](/api/TupleItemsAsync/), [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined> | [StrictTupleSchema](/api/StrictTupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined> | [StrictTupleSchemaAsync](/api/StrictTupleSchemaAsync/)<[TupleItemsAsync](/api/TupleItemsAsync/), [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined> | [TupleSchema](/api/TupleSchema/)<[TupleItems](/api/TupleItems/), [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined> | [TupleSchemaAsync](/api/TupleSchemaAsync/)<[TupleItemsAsync](/api/TupleItemsAsync/), [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined> | [TupleWithRestSchema](/api/TupleWithRestSchema/)<[TupleItems](/api/TupleItems/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined> | [TupleWithRestSchemaAsync](/api/TupleWithRestSchemaAsync/)<[TupleItemsAsync](/api/TupleItemsAsync/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined>`

[](#definition)Definition
-------------------------

*   `ArgsActionAsync` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, (...args: [InferInput](/api/InferInput/)<TSchema>) => Promise<Awaited<ReturnType<TInput>>>, never>`
    *   `type` `'args'`
    *   `reference` `typeof [argsAsync](/api/argsAsync/)`
    *   `schema` `TSchema`

[](#arrayinput)ArrayInput
=========================

Array input type.

[](#definition)Definition
-------------------------

*   `ArrayInput` `[MaybeReadonly](/api/MaybeReadonly/)<unknown[]>`

[](#arrayissue)ArrayIssue
=========================

Array issue interface.

[](#definition)Definition
-------------------------

*   `ArrayIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'array'`
    *   `expected` `'Array'`

[](#arraypathitem)ArrayPathItem
===============================

Array path item interface.

[](#definition)Definition
-------------------------

*   `ArrayPathItem`
    *   `type` `'array'`
    *   `origin` `'value'`
    *   `input` `[MaybeReadonly](/api/MaybeReadonly/)<unknown[]>`
    *   `key` `number`
    *   `value` `unknown`

The `input` of a path item may differ from the `input` of its issue. This is because path items are subsequently added by parent schemas and are related to their input. Transformations of child schemas are not taken into account.

[](#arrayrequirement)ArrayRequirement
=====================================

Array requirement type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#definition)Definition
-------------------------

*   `ArrayRequirement` `(item: TInput[number], index: number, array: TInput) => boolean`

[](#arrayrequirementasync)ArrayRequirementAsync
===============================================

Array requirement async type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#definition)Definition
-------------------------

*   `ArrayRequirementAsync` `(item: TInput[number], index: number, array: TInput) => [MaybePromise](/api/MaybePromise/)<boolean>`

[](#arrayschema)ArraySchema
===========================

Array schema interface.

[](#generics)Generics
---------------------

*   `TItem` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ArrayIssue](/api/ArrayIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `ArraySchema` `extends [BaseSchema](/api/BaseSchema/)<[InferInput](/api/InferInput/)<TItem>[], [InferOutput](/api/InferOutput/)<TItem>[], [ArrayIssue](/api/ArrayIssue/) | [InferIssue](/api/InferIssue/)<TItem>>`
    *   `type` `'array'`
    *   `reference` `typeof [array](/api/array/)`
    *   `expects` `'Array'`
    *   `item` `TItem`
    *   `message` `TMessage`

[](#arrayschemaasync)ArraySchemaAsync
=====================================

Array schema async interface.

[](#generics)Generics
---------------------

*   `TItem` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ArrayIssue](/api/ArrayIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `ArraySchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferInput](/api/InferInput/)<TItem>[], [InferOutput](/api/InferOutput/)<TItem>[], [ArrayIssue](/api/ArrayIssue/) | [InferIssue](/api/InferIssue/)<TItem>>`
    *   `type` `'array'`
    *   `reference` `typeof [array](/api/array/) | typeof [arrayAsync](/api/arrayAsync/)`
    *   `expects` `'Array'`
    *   `item` `TItem`
    *   `message` `TMessage`

[](#awaitactionasync)AwaitActionAsync
=====================================

Await action async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends Promise<unknown>`

[](#definition)Definition
-------------------------

*   `AwaitActionAsync` `extends [BaseTransformationAsync](/api/BaseTransformationAsync/)<TInput, Awaited<TInput>, never>`
    *   `type` `'await'`
    *   `reference` `typeof [awaitAsync](/api/awaitAsync/)`

[](#base64action)Base64Action
=============================

Base64 action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Base64Issue](/api/Base64Issue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `Base64Action` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [Base64Issue](/api/Base64Issue/)<TInput>>`
    *   `type` `'base64'`
    *   `reference` `typeof [base64](/api/base64/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#base64issue)Base64Issue
===========================

Base64 issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `Base64Issue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'base64'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#baseissue)BaseIssue
=======================

Schema issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#definition)Definition
-------------------------

*   `BaseIssue` `extends [Config](/api/Config/)<BaseIssue<TInput>>`
    *   `kind` `'schema' | 'validation' | 'transformation'`
    *   `type` `string`
    *   `input` `TInput`
    *   `expected` `string | null`
    *   `received` `string`
    *   `message` `string`
    *   `requirement` `unknown | undefined`
    *   `path` `[[IssuePathItem](/api/IssuePathItem/), ...[IssuePathItem](/api/IssuePathItem/)[]] | undefined`
    *   `issues` `[BaseIssue<TInput>, ...BaseIssue<TInput>[]] | undefined`

[](#basemetadata)BaseMetadata
=============================

Base metadata interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#definition)Definition
-------------------------

*   `BaseMetadata`
    *   `kind` `'metadata'`
    *   `type` `string`
    *   `reference` `(...args: any[]) => BaseMetadata<any>`
    *   `~types` `{ input: TInput, output: TInput, issue: never } | undefined`

[](#baseschema)BaseSchema
=========================

Base schema interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `BaseSchema`
    *   `kind` `'schema'`
    *   `type` `string`
    *   `reference` `(...args: any[]) => BaseSchema<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
    *   `expects` `string`
    *   `async` `false`
    *   `~standard` `[StandardProps](/api/StandardProps/)<TInput, TOutput>`
    *   `~run` `(dataset: [UnknownDataset](/api/UnknownDataset/), config: [Config](/api/Config/)<[BaseIssue](/api/BaseIssue/)<unknown>>) => [OutputDataset](/api/OutputDataset/)<TOutput, TIssue>`
    *   `~types` `{ input: TInput, output: TOutput, issue: TIssue } | undefined`

[](#baseschemaasync)BaseSchemaAsync
===================================

Base schema async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `BaseSchemaAsync` `extends Omit<[BaseSchema](/api/BaseSchema/)<TInput, TOutput, TIssue>, 'reference' | 'async' | '~run'>`
    *   `reference` `((...args: any[]) => [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | BaseSchemaAsync<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>)`
    *   `async` `true`
    *   `~run` `(dataset: [UnknownDataset](/api/UnknownDataset/), config: [Config](/api/Config/)<[BaseIssue](/api/BaseIssue/)<unknown>>) => Promise<[OutputDataset](/api/OutputDataset/)<TOutput, TIssue>>`

[](#basetransformation)BaseTransformation
=========================================

Base transformation interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `BaseTransformation`
    *   `kind` `'transformation'`
    *   `type` `string`
    *   `reference` `(...args: any[]) => BaseTransformation<any, any, [BaseIssue](/api/BaseIssue/)<unknown>>`
    *   `async` `false`
    *   `~run` `(dataset: [SuccessDataset](/api/SuccessDataset/)<TInput>, config: [Config](/api/Config/)<[BaseIssue](/api/BaseIssue/)<unknown>>) => [OutputDataset](/api/OutputDataset/)<TOutput, [BaseIssue](/api/BaseIssue/)<unknown> | TIssue>`
    *   `~types` `{ input: TInput, output: TOutput, issue: TIssue } | undefined`

[](#basetransformationasync)BaseTransformationAsync
===================================================

Base transformation async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `BaseTransformationAsync` `extends Omit<[BaseTransformation](/api/BaseTransformation/)<TInput, TOutput, TIssue>, 'reference' | 'async' | '~run'>`
    *   `reference` `((...args: any[]) => [BaseTransformation](/api/BaseTransformation/)<any, any, [BaseIssue](/api/BaseIssue/)<unknown>> | BaseTransformationAsync<any, any, [BaseIssue](/api/BaseIssue/)<unknown>>)`
    *   `async` `true`
    *   `~run` `(dataset: [SuccessDataset](/api/SuccessDataset/)<TInput>, config: [Config](/api/Config/)<[BaseIssue](/api/BaseIssue/)<unknown>>) => Promise<[OutputDataset](/api/OutputDataset/)<TOutput, [BaseIssue](/api/BaseIssue/)<unknown> | TIssue>>`

[](#basevalidation)BaseValidation
=================================

Base action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `BaseValidation`
    *   `kind` `'validation'`
    *   `type` `string`
    *   `reference` `(...args: any[]) => BaseValidation<any, any, [BaseIssue](/api/BaseIssue/)<unknown>>`
    *   `expects` `string | null`
    *   `async` `false`
    *   `~run` `(dataset: [OutputDataset](/api/OutputDataset/)<TInput, [BaseIssue](/api/BaseIssue/)<unknown>>, config: [Config](/api/Config/)<TIssue>) => [OutputDataset](/api/OutputDataset/)<TOutput, [BaseIssue](/api/BaseIssue/)<unknown> | TIssue>`
    *   `~types` `{ input: TInput, output: TOutput, issue: TIssue } | undefined`

[](#basevalidationasync)BaseValidationAsync
===========================================

Base validation async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `BaseValidationAsync` `extends Omit<[BaseValidation](/api/BaseValidation/)<TInput, TOutput, TIssue>, 'reference' | 'async' | '~run'>`
    *   `reference` `((...args: any[]) => [BaseValidation](/api/BaseValidation/)<any, any, [BaseIssue](/api/BaseIssue/)<unknown>> | BaseValidationAsync<any, any, [BaseIssue](/api/BaseIssue/)<unknown>>)`
    *   `async` `true`
    *   `~run` `(dataset: [OutputDataset](/api/OutputDataset/)<TInput, [BaseIssue](/api/BaseIssue/)<unknown>>, config: [Config](/api/Config/)<TIssue>) => Promise<[OutputDataset](/api/OutputDataset/)<TOutput, [BaseIssue](/api/BaseIssue/)<unknown> | TIssue>>`

[](#bicaction)BicAction
=======================

BIC action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends ErrorMessage<[BicIssue](/api/BicIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `BicAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [BicIssue](/api/BicIssue/)<TInput>>`
    *   `type` `'bic'`
    *   `reference` `typeof [bic](/api/bic/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#bicissue)BicIssue
=====================

Bic issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `BicIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'bic'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#bigintissue)BigintIssue
===========================

Bigint issue interface.

[](#definition)Definition
-------------------------

*   `BigintIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'bigint'`
    *   `expected` `'bigint'`

[](#bigintschema)BigintSchema
=============================

Bigint schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[BigintIssue](/api/BigintIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `BigintSchema` `extends [BaseSchema](/api/BaseSchema/)<bigint, bigint, [BigintIssue](/api/BigintIssue/)>`
    *   `type` `'bigint'`
    *   `reference` `typeof [bigint](/api/bigint/)`
    *   `expects` `'bigint'`
    *   `message` `TMessage`

[](#blobissue)BlobIssue
=======================

Blob issue interface.

[](#definition)Definition
-------------------------

*   `BlobIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'blob'`
    *   `expected` `'Blob'`

[](#blobschema)BlobSchema
=========================

Blob schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[BlobIssue](/api/BlobIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `BlobSchema` `extends [BaseSchema](/api/BaseSchema/)<Blob, Blob, [BlobIssue](/api/BlobIssue/)>`
    *   `type` `'blob'`
    *   `reference` `typeof [blob](/api/blob/)`
    *   `expects` `'Blob'`
    *   `message` `BlobIssue`

[](#booleanissue)BooleanIssue
=============================

Boolean issue interface.

[](#definition)Definition
-------------------------

*   `BooleanIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'boolean'`
    *   `expected` `'boolean'`

[](#booleanschema)BooleanSchema
===============================

Boolean schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[BooleanIssue](/api/BooleanIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `BooleanSchema` `extends [BaseSchema](/api/BaseSchema/)<boolean, boolean, [BooleanIssue](/api/BooleanIssue/)>`
    *   `type` `'boolean'`
    *   `reference` `typeof [boolean](/api/boolean/)`
    *   `expects` `'boolean'`
    *   `message` `TMessage`

[](#brand)Brand
===============

Brand interface.

[](#generics)Generics
---------------------

*   `TName` `extends [BrandName](/api/BrandName/)`

[](#definition)Definition
-------------------------

*   `Brand` `{ [BrandSymbol]: { [TValue in TName]: TValue } }`

[](#brandaction)BrandAction
===========================

Brand action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TName` `extends [BrandName](/api/BrandName/)`

[](#definition)Definition
-------------------------

*   `BrandAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TInput & [Brand](/api/Brand/)<TName>, never>`
    *   `type` `'brand'`
    *   `reference` `typeof [brand](/api/brand/)`
    *   `name` `TName`

[](#brandname)BrandName
=======================

Brand name type.

[](#definition)Definition
-------------------------

*   `BrandName` `string | number | symbol`

[](#bytesaction)BytesAction
===========================

Bytes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[BytesIssue](/api/BytesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `BytesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [BytesIssue](/api/BytesIssue/)<TInput, TRequirement>>`
    *   `type` `'bytes'`
    *   `reference` `typeof [bytes](/api/bytes/)`
    *   `expects` `` `${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#bytesissue)BytesIssue
=========================

Bytes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `BytesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'bytes'`
    *   `expected` `` `${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#checkaction)CheckAction
===========================

Check action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CheckIssue](/api/CheckIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `CheckAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [CheckIssue](/api/CheckIssue/)<TInput>>`
    *   `type` `'check'`
    *   `reference` `typeof [check](/api/check/)`
    *   `expects` `null`
    *   `requirement` `(input: TInput) => boolean`
    *   `message` `TMessage`

[](#checkactionasync)CheckActionAsync
=====================================

Check action async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CheckIssue](/api/CheckIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `CheckActionAsync` `extends [BaseValidationAsync](/api/BaseValidationAsync/)<TInput, TInput, [CheckIssue](/api/CheckIssue/)<TInput>>`
    *   `type` `'check'`
    *   `reference` `typeof [checkAsync](/api/checkAsync/)`
    *   `expects` `null`
    *   `requirement` `(input: TInput) => [MaybePromise](/api/MaybePromise/)<boolean>`
    *   `message` `TMessage`

[](#checkissue)CheckIssue
=========================

Check issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#definition)Definition
-------------------------

*   `CheckIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'check'`
    *   `expected` `null`
    *   `requirement` `(input: TInput) => MaybePromise<boolean>`

[](#checkitemsaction)CheckItemsAction
=====================================

Check items action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CheckItemsIssue](/api/CheckItemsIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `CheckItemsAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [CheckItemsIssue](/api/CheckItemsIssue/)<TInput>>`
    *   `type` `'check_items'`
    *   `reference` `typeof [checkItems](/api/checkItems/)`
    *   `expects` `null`
    *   `requirement` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`
    *   `message` `TMessage`

[](#checkitemsactionasync)CheckItemsActionAsync
===============================================

Check items action async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CheckItemsIssue](/api/CheckItemsIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `CheckItemsActionAsync` `extends [BaseValidationAsync](/api/BaseValidationAsync/)<TInput, TInput, [CheckItemsIssue](/api/CheckItemsIssue/)<TInput>>`
    *   `type` `'check_items'`
    *   `reference` `typeof [checkItemsAsync](/api/checkItemsAsync/)`
    *   `expects` `null`
    *   `requirement` `[ArrayRequirementAsync](/api/ArrayRequirementAsync/)<TInput>`
    *   `message` `TMessage`

[](#checkitemsissue)CheckItemsIssue
===================================

Check items issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#definition)Definition
-------------------------

*   `CheckItemsIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput[number]>`
    *   `kind` `'validation'`
    *   `type` `'check_items'`
    *   `expected` `null`
    *   `requirement` `[ArrayRequirementAsync](/api/ArrayRequirementAsync/)<TInput>`

[](#class)Class
===============

Class type.

[](#definition)Definition
-------------------------

*   `Class` `new (...args: any[]) => any`

[](#config)Config
=================

Config interface.

[](#generics)Generics
---------------------

*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `Config`
    *   `lang` `string | undefined`
    *   `message` `[ErrorMessage](/api/ErrorMessage/)<TIssue> | undefined`
    *   `abortEarly` `boolean | undefined`
    *   `abortPipeEarly` `boolean | undefined`

[](#contentinput)ContentInput
=============================

Content input type.

[](#definition)Definition
-------------------------

*   `ContentInput` `string | [MaybeReadonly](/api/MaybeReadonly/)<unknown[]>`

[](#contentrequirement)ContentRequirement
=========================================

Content requirement type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ContentInput](/api/ContentInput/)`

[](#definition)Definition
-------------------------

*   `ContentRequirement` `TInput extends readonly unknown[] ? TInput[number] : TInput`

[](#creditcardaction)CreditCardAction
=====================================

Credit card action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends ErrorMessage<[CreditCardIssue](/api/CreditCardIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `CreditCardAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [CreditCardIssue](/api/CreditCardIssue/)<TInput>>`
    *   `type` `'credit_card'`
    *   `reference` `typeof [creditCard](/api/creditCard/)`
    *   `expects` `null`
    *   `requirement` `(input: string) => boolean`
    *   `message` `TMessage`

[](#creditcardissue)CreditCardIssue
===================================

Credit card issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `CreditCardIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'credit_card'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `(input: string) => boolean`

[](#cuid2action)Cuid2Action
===========================

Cuid2 action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends ErrorMessage<[Cuid2Issue](/api/Cuid2Issue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `Cuid2Action` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [Cuid2Issue](/api/Cuid2Issue/)<TInput>>`
    *   `type` `'cuid2'`
    *   `reference` `typeof [cuid2](/api/cuid2/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#cuid2issue)Cuid2Issue
=========================

Cuid2 issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `Cuid2Issue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'cuid2'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#customissue)CustomIssue
===========================

Custom issue interface.

[](#definition)Definition
-------------------------

*   `CustomIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'custom'`
    *   `expected` `'unknown'`

[](#customschema)CustomSchema
=============================

Custom schema interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CustomIssue](/api/CustomIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `CustomSchema` `extends [BaseSchema](/api/BaseSchema/)<TInput, TInput, [CustomIssue](/api/CustomIssue/)>`
    *   `type` `'custom'`
    *   `reference` `typeof [custom](/api/custom/)`
    *   `expects` `'unknown'`
    *   `check` `(input: unknown) => boolean`
    *   `message` `TMessage`

[](#customschemaasync)CustomSchemaAsync
=======================================

Custom schema async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[CustomIssue](/api/CustomIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `CustomSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<TInput, TInput, [CustomIssue](/api/CustomIssue/)>`
    *   `type` `'custom'`
    *   `reference` `typeof [custom](/api/custom/) | typeof [customAsync](/api/customAsync/)`
    *   `expects` `'unknown'`
    *   `check` `(input: unknown) => [MaybePromise](/api/MaybePromise/)<boolean>`
    *   `message` `TMessage`

[](#dateissue)DateIssue
=======================

Date issue interface.

[](#definition)Definition
-------------------------

*   `DateIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'date'`
    *   `expected` `'Date'`

[](#dateschema)DateSchema
=========================

Date schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[DateIssue](/api/DateIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `DateSchema` `extends [BaseSchema](/api/BaseSchema/)<Date, Date, [DateIssue](/api/DateIssue/)>`
    *   `type` `'date'`
    *   `reference` `typeof [date](/api/date/)`
    *   `expects` `'Date'`
    *   `message` `TMessage`

[](#decimalaction)DecimalAction
===============================

Decimal action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[DecimalIssue](/api/DecimalIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `DecimalAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [DecimalIssue](/api/DecimalIssue/)<TInput>>`
    *   `type` `'decimal'`
    *   `reference` `typeof [decimal](/api/decimal/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#decimalissue)DecimalIssue
=============================

Decimal issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `DecimalIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'decimal'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#deeppickn)DeepPickN
=======================

Deeply picks N specific keys.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/types/utils.ts).

[](#default)Default
===================

Default type.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TInput` `extends null | undefined`

[](#definition)Definition
-------------------------

*   `Default` `[MaybeReadonly](/api/MaybeReadonly/)<[InferInput](/api/InferInput/)<TWrapped>, TInput> | ((dataset?: [UnknownDataset](/api/UnknownDataset/), config?: [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TWrapped>>) => [MaybeReadonly](/api/MaybeReadonly/)<[InferInput](/api/InferInput/)<TWrapped>, TInput>)`

[](#defaultasync)DefaultAsync
=============================

Default async type.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TInput` `extends null | undefined`

[](#definition)Definition
-------------------------

*   `DefaultAsync` `[MaybeReadonly](/api/MaybeReadonly/)<[InferInput](/api/InferInput/)<TWrapped>, TInput> | ((dataset?: [UnknownDataset](/api/UnknownDataset/), config?: [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TWrapped>>) => [MaybePromise](/api/MaybePromise/)<[MaybeReadonly](/api/MaybeReadonly/)<[InferInput](/api/InferInput/)<TWrapped>, TInput>>)`

[](#defaultvalue)DefaultValue
=============================

Default value type.

[](#generics)Generics
---------------------

*   `TDefault` `extends [Default](/api/Default/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, null | undefined> | [DefaultAsync](/api/DefaultAsync/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, null | undefined>`

[](#definition)Definition
-------------------------

*   `DefaultValue` `TDefault extends [DefaultAsync](/api/DefaultAsync/)<infer TWrapped, infer TInput> ? TDefault extends (dataset?: [UnknownDataset](/api/UnknownDataset/), config?: [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TWrapped>>) => [MaybePromise](/api/MaybePromise/)<[MaybeReadonly](/api/MaybeReadonly/)<[InferInput](/api/InferInput/)<TWrapped>, TInput>> ? Awaited<ReturnType<TDefault>> : TDefault : never`

[](#descriptionaction)DescriptionAction
=======================================

Description action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TDescription` `extends string`

[](#definition)Definition
-------------------------

*   `DescriptionAction` `extends [BaseMetadata](/api/BaseMetadata/)<TInput>`
    *   `type` `'description'`
    *   `reference` `typeof [description](/api/description/)`
    *   `description` `TDescription`

[](#digitsaction)DigitsAction
=============================

Digits action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[DecimalIssue](/api/DecimalIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `DigitsAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [DigitsIssue](/api/DigitsIssue/)<TInput>>`
    *   `type` `'digits'`
    *   `reference` `typeof [digits](/api/digits/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#digitsissue)DigitsIssue
===========================

Digits issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `DigitsIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'digits'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#emailaction)EmailAction
===========================

Email action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EmailIssue](/api/EmailIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `EmailAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [EmailIssue](/api/EmailIssue/)<TInput>>`
    *   `type` `'email'`
    *   `reference` `typeof [email](/api/email/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#emailissue)EmailIssue
=========================

Email issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `EmailIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'email'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#emojiaction)EmojiAction
===========================

Emoji action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EmojiIssue](/api/EmojiIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `EmojiAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [EmojiIssue](/api/EmojiIssue/)<TInput>>`
    *   `type` `'emoji'`
    *   `reference` `typeof [emoji](/api/emoji/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#emojiissue)EmojiIssue
=========================

Emoji issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `EmojiIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'emoji'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#emptyaction)EmptyAction
===========================

Empty action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EmptyIssue](/api/EmptyIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `EmptyAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [EmptyIssue](/api/EmptyIssue/)<TInput, TRequirement>>`
    *   `type` `'empty'`
    *   `reference` `typeof [empty](/api/empty/)`
    *   `expects` `'0'`
    *   `message` `TMessage`

[](#emptyissue)EmptyIssue
=========================

Empty issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`

[](#definition)Definition
-------------------------

*   `EmptyIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'empty'`
    *   `expected` `'0'`
    *   `received` `` `${number}` ``

[](#endswithaction)EndsWithAction
=================================

Ends with action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EndsWithIssue](/api/EndsWithIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `EndsWithAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [EndsWithIssue](/api/EndsWithIssue/)<TInput, TRequirement>>`
    *   `type` `'ends_with'`
    *   `reference` `typeof [endsWith](/api/endsWith/)`
    *   `expects` `` `"${TRequirement}"` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#endswithissue)EndsWithIssue
===============================

Ends with issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends string`

[](#definition)Definition
-------------------------

*   `EndsWithIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'ends_with'`
    *   `expected` `` `"${TRequirement}"` ``
    *   `received` `` `"${string}"` ``
    *   `requirement` `TRequirement`

[](#entriesaction)EntriesAction
===============================

Entries action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EntriesIssue](/api/EntriesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `EntriesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [EntriesIssue](/api/EntriesIssue/)<TInput, TRequirement>>`
    *   `type` `'entries'`
    *   `reference` `typeof [entries](/api/entries/)`
    *   `expects` `` `${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#entriesinput)EntriesInput
=============================

Entries input type.

[](#definition)Definition
-------------------------

*   `EntriesInput` `Record<string | number, unknown>`

[](#entriesissue)EntriesIssue
=============================

Entries issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `EntriesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'entries'`
    *   `expected` `` `${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#enum)Enum
=============

Enum interface.

[](#definition)Definition
-------------------------

*   `Enum` `{ [key: string]: string | number }`

[](#enumissue)EnumIssue
=======================

Enum issue interface.

[](#definition)Definition
-------------------------

*   `EnumIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'enum'`
    *   `expected` `string`

[](#enumschema)EnumSchema
=========================

Enum schema interface.

[](#generics)Generics
---------------------

*   `TEnum` `extends [Enum](/api/Enum/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EnumIssue](/api/EnumIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `EnumSchema` `extends [BaseSchema](/api/BaseSchema/)<TEnum[keyof TEnum], TEnum[keyof TEnum], [EnumIssue](/api/EnumIssue/)>`
    *   `type` `'enum'`
    *   `reference` `typeof [enum](/api/enum/)`
    *   `enum` `TEnum`
    *   `options` `TEnum[keyof TEnum][]`
    *   `message` `TMessage`

[](#errormessage)ErrorMessage
=============================

Error message type.

[](#generics)Generics
---------------------

*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `ErrorMessage` `((issue: TIssue) => string) | string`

[](#everyitemaction)EveryItemAction
===================================

Every action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends readonly unknown[]`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[EveryItemIssue](/api/EveryItemIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `EveryItemAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [EveryItemIssue](/api/EveryItemIssue/)<TInput>>`
    *   `type` `'every_item'`
    *   `reference` `typeof [everyItem](/api/everyItem/)`
    *   `expects` `null`
    *   `requirement` `(item: TInput[number], index: number, array: TInput) => boolean`
    *   `message` `TMessage`

[](#everyitemissue)EveryItemIssue
=================================

Every item issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#definition)Definition
-------------------------

*   `EveryItemIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'every_item'`
    *   `expected` `null`
    *   `requirement` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`

[](#exactoptionalschema)ExactOptionalSchema
===========================================

Exact optional schema interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, undefined>`

[](#definition)Definition
-------------------------

*   `ExactOptionalSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferInput](/api/InferInput/)<TWrapped>, [InferOutput](/api/InferOutput/)<TWrapped>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'exact_optional'`
    *   `reference` `typeof [exactOptional](/api/exactOptional/)`
    *   `expects` `TWrapped['expects']`
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#exactoptionalschemaasync)ExactOptionalSchemaAsync
=====================================================

Exact optional schema async interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, undefined>`

[](#definition)Definition
-------------------------

*   `ExactOptionalSchemaAsync` `[BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferInput](/api/InferInput/)<TWrapped>, [InferOutput](/api/InferOutput/)<TWrapped>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'exact_optional'`
    *   `reference` `typeof [exactOptional](/api/exactOptional/) | typeof [exactOptionalAsync](/api/exactOptionalAsync/)`
    *   `expects` `` `(${TWrapped['expects']} | undefined)` ``
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#excludesaction)ExcludesAction
=================================

Excludes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ContentInput](/api/ContentInput/)`
*   `TRequirement` `extends [ContentRequirement](/api/ContentRequirement/)<TInput>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ExcludesIssue](/api/ExcludesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `ExcludesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [ExcludesIssue](/api/ExcludesIssue/)<TInput, TRequirement>>`
    *   `type` `'excludes'`
    *   `referece` `typeof [excludes](/api/excludes/)`
    *   `expects` `string`
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#excludesissue)ExcludesIssue
===============================

Excludes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ContentInput](/api/ContentInput/)`
*   `TRequirement` `extends [ContentRequirement](/api/ContentRequirement/)<TInput>`

[](#definition)Definition
-------------------------

*   `ExcludesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'excludes'`
    *   `expected` `string`
    *   `requirement` `TRequirement`

[](#failuredataset)FailureDataset
=================================

Failure dataset interface.

[](#generics)Generics
---------------------

*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `UntypedDataset`
    *   `typed` `false`
    *   `value` `unknown`
    *   `issues` `[TIssue, ...TIssue[]]`

[](#fallback)Fallback
=====================

Fallback type.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `Fallback` `extends [MaybeReadonly](/api/MaybeReadonly/)<[InferOutput](/api/InferOutput/)<TSchema>> | ((dataset?: [OutputDataset](/api/OutputDataset/)<[InferOutput](/api/InferOutput/)<TSchema>, [InferIssue](/api/InferIssue/)<TSchema>>, config?: [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>>) => [MaybeReadonly](/api/MaybeReadonly/)<[InferOutput](/api/InferOutput/)<TSchema>>)`

[](#fallbackasync)FallbackAsync
===============================

Fallback async type.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `FallbackAsync` `extends [MaybeReadonly](/api/MaybeReadonly/)<[InferOutput](/api/InferOutput/)<TSchema>> | ((dataset?: [OutputDataset](/api/OutputDataset/)<[InferOutput](/api/InferOutput/)<TSchema>, [InferIssue](/api/InferIssue/)<TSchema>>, config?: [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>>) => [MaybePromise](/api/MaybePromise/)<[MaybeReadonly](/api/MaybeReadonly/)<[InferOutput](/api/InferOutput/)<TSchema>>>)`

[](#fileissue)FileIssue
=======================

File issue interface.

[](#definition)Definition
-------------------------

*   `FileIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'file'`
    *   `expected` `'File'`

[](#fileschema)FileSchema
=========================

File schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[FileIssue](/api/FileIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `FileSchema` `extends [BaseSchema](/api/BaseSchema/)<File, File, [FileIssue](/api/FileIssue/)>`
    *   `type` `'file'`
    *   `reference` `typeof [file](/api/file/)`
    *   `expects` `'File'`
    *   `message` `TMessage`

[](#filteritemsaction)FilterItemsAction
=======================================

Filter items action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#definition)Definition
-------------------------

*   `FilterItemsAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TInput, never>`
    *   `type` `'filter_items'`
    *   `reference` `typeof [filterItems](/api/filterItems/)`
    *   `operation` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`

[](#finditemaction)FindItemAction
=================================

Find item action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#definition)Definition
-------------------------

*   `FindItemAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TInput[number] | undefined, never>`
    *   `type` `'find_item'`
    *   `reference` `typeof [findItem](/api/findItem/)`
    *   `operation` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`

[](#finiteaction)FiniteAction
=============================

Finite action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[FiniteIssue](/api/FiniteIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `FiniteAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [FiniteIssue](/api/FiniteIssue/)<TInput>>`
    *   `type` `'finite'`
    *   `reference` `typeof [finite](/api/finite/)`
    *   `expects` `null`
    *   `requirement` `(input: number) => boolean`
    *   `message` `TMessage`

[](#finiteissue)FiniteIssue
===========================

Finite issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends number`

[](#definition)Definition
-------------------------

*   `FiniteIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'finite'`
    *   `expected` `null`
    *   `received` `` `${number}` ``
    *   `requirement` `(input: number) => boolean`

[](#firsttupleitem)FirstTupleItem
=================================

Extracts first tuple item.

[](#generics)Generics
---------------------

*   `TTuple` `extends [unknown, ...unknown[]]`

[](#definition)Definition
-------------------------

*   `FirstTupleItem` `TTuple[0]`

[](#flaterrors)FlatErrors
=========================

Flat errors type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/flatten/flatten.ts).

[](#flavor)Flavor
=================

Flavor interface.

[](#generics)Generics
---------------------

*   `TName` `extends [FlavorName](/api/FlavorName/)`

[](#definition)Definition
-------------------------

*   `Flavor` `{ [FlavorSymbol]: { [TValue in TName]: TValue } }`

[](#flavoraction)FlavorAction
=============================

Flavor action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TName` `extends [FlavorName](/api/FlavorName/)`

[](#definition)Definition
-------------------------

*   `FlavorAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TInput & [Flavor](/api/Flavor/)<TName>, never>`
    *   `type` `'flavor'`
    *   `reference` `typeof [flavor](/api/flavor/)`
    *   `name` `TName`

[](#flavorname)FlavorName
=========================

Flavor name type.

[](#definition)Definition
-------------------------

*   `FlavorName` `string | number | symbol`

[](#functionissue)FunctionIssue
===============================

Function issue interface.

[](#definition)Definition
-------------------------

*   `FunctionIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'function'`
    *   `expected` `'Function'`

[](#functionschema)FunctionSchema
=================================

Function schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[FunctionIssue](/api/FunctionIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `FunctionSchema` `extends [BaseSchema](/api/BaseSchema/)<(...args: unknown[]) => unknown, (...args: unknown[]) => unknown, [FunctionIssue](/api/FunctionIssue/)>`
    *   `type` `'function'`
    *   `reference` `typeof [function](/api/function/)`
    *   `expects` `'Function'`
    *   `message` `TMessage`

[](#genericissue)GenericIssue
=============================

Generic issue type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = unknown`

[](#definition)Definition
-------------------------

*   `GenericIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`

[](#genericmetadata)GenericMetadata
===================================

Generic metadata type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = any`

[](#definition)Definition
-------------------------

*   `GenericMetadata` `extends [BaseMetadata](/api/BaseMetadata/)<TInput>`

[](#genericpipeaction)GenericPipeAction
=======================================

Generic pipe action type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = any`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericPipeAction` `extends [PipeAction](/api/PipeAction/)<TInput, TOutput, TIssue>`

[](#genericpipeactionasync)GenericPipeActionAsync
=================================================

Generic pipe action async type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = any`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericPipeActionAsync` `extends [PipeActionAsync](/api/PipeActionAsync/)<TInput, TOutput, TIssue>`

[](#genericpipeitem)GenericPipeItem
===================================

Generic pipe item type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = any`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericPipeItem` `extends [PipeItem](/api/PipeItem/)<TInput, TOutput, TIssue>`

[](#genericpipeitemasync)GenericPipeItemAsync
=============================================

Generic pipe item async type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = any`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericPipeItemAsync` `extends [PipeItemAsync](/api/PipeItemAsync/)<TInput, TOutput, TIssue>`

[](#genericschema)GenericSchema
===============================

Generic schema type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = unknown`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericSchema` `extends [BaseSchema](/api/BaseSchema/)<TInput, TOutput, TIssue>`

[](#genericschemaasync)GenericSchemaAsync
=========================================

Generic schema async type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = unknown`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericSchemaAsync` `[BaseSchemaAsync](/api/BaseSchemaAsync/)<TInput, TOutput, TIssue>`

[](#generictransformation)GenericTransformation
===============================================

Generic transformation type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = any`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericTransformation` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TOutput, TIssue>`

[](#generictransformationasync)GenericTransformationAsync
=========================================================

Generic transformation async type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = any`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericTransformationAsync` `[BaseTransformationAsync](/api/BaseTransformationAsync/)<TInput, TOutput, TIssue>`

[](#genericvalidation)GenericValidation
=======================================

Generic validation type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = any`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericValidation` `extends [BaseValidation](/api/BaseValidation/)<TInput, TOutput, TIssue>`

[](#genericvalidationasync)GenericValidationAsync
=================================================

Generic validation async type.

[](#generics)Generics
---------------------

*   `TInput` `extends any = any`
*   `TOutput` `extends any = TInput`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown> = BaseIssue<unknown>`

[](#definition)Definition
-------------------------

*   `GenericValidationAsync` `[BaseValidationAsync](/api/BaseValidationAsync/)<TInput, TOutput, TIssue>`

[](#globalconfig)GlobalConfig
=============================

The global config type.

[](#definition)Definition
-------------------------

*   `GlobalConfig` `Omit<[Config](/api/Config/)<never>, 'message'>`

[](#graphemesaction)GraphemesAction
===================================

Graphemes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[GraphemesIssue](/api/GraphemesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `GraphemesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [GraphemesIssue](/api/GraphemesIssue/)<TInput, TRequirement>>`
    *   `type` `'graphemes'`
    *   `reference` `typeof [graphemes](/api/graphemes/)`
    *   `expects` `` `${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#graphemesissue)GraphemesIssue
=================================

Graphemes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `GraphemesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'graphemes'`
    *   `expected` `` `${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#gtvalueaction)GtValueAction
===============================

Greater than value action type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[GtValueIssue](/api/GtValueIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `GtValueAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [GtValueIssue](/api/GtValueIssue/)<TInput, TRequirement>>`
    *   `type` `'gt_value'`
    *   `reference` `typeof [gtValue](/api/gtValue/)`
    *   `expects` `` `>${string}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#gtvalueissue)GtValueIssue
=============================

Greater than value issue type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#definition)Definition
-------------------------

*   `GtValueIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'gt_value'`
    *   `expected` `` `>${string}` ``
    *   `requirement` `TRequirement`

[](#hashaction)HashAction
=========================

Hash action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[HashIssue](/api/HashIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `HashAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [HashIssue](/api/HashIssue/)<TInput>>`
    *   `type` `'hash'`
    *   `reference` `typeof [hash](/api/hash/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#hashissue)HashIssue
=======================

Hash issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `HashIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'hash'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#hashtype)HashType
=====================

Hash type type.

[](#definition)Definition
-------------------------

*   `HashType` `'md4' | 'md5' | 'sha1' | 'sha256' | 'sha384' | 'sha512' | 'ripemd128' | 'ripemd160' | 'tiger128' | 'tiger160' | 'tiger192' | 'crc32' | 'crc32b' | 'adler32'`

[](#hexadecimalaction)HexadecimalAction
=======================================

Hexadecimal action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[HexadecimalIssue](/api/HexadecimalIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `HexadecimalAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [HexadecimalIssue](/api/HexadecimalIssue/)<TInput>>`
    *   `type` `'hexadecimal'`
    *   `reference` `typeof [hexadecimal](/api/hexadecimal/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#hexadecimalissue)HexadecimalIssue
=====================================

Hexadecimal issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `HexadecimalIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'hexadecimal'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#hexcoloraction)HexColorAction
=================================

Hex color action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[HexColorIssue](/api/HexColorIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `HexColorAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [HexColorIssue](/api/HexColorIssue/)<TInput>>`
    *   `type` `'hex_color'`
    *   `reference` `typeof [hexColor](/api/hexColor/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#hexcolorissue)HexColorIssue
===============================

HexColor issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `HexColorIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'hex_color'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#imeiaction)ImeiAction
=========================

Imei action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ImeiIssue](/api/ImeiIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `ImeiAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [ImeiIssue](/api/ImeiIssue/)<TInput>>`
    *   `type` `'imei'`
    *   `reference` `typeof [imei](/api/imei/)`
    *   `expects` `null`
    *   `requirement` `(input: string) => boolean`
    *   `message` `TMessage`

[](#imeiissue)ImeiIssue
=======================

IMEI issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `ImeiIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'imei'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `(input: string) => boolean`

[](#includesaction)IncludesAction
=================================

Includes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ContentInput](/api/ContentInput/)`
*   `TRequirement` `extends [ContentRequirement](/api/ContentRequirement/)<TInput>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IncludesIssue](/api/IncludesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `IncludesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [IncludesIssue](/api/IncludesIssue/)<TInput, TRequirement>>`
    *   `type` `'includes'`
    *   `reference` `typeof [includes](/api/includes/)`
    *   `expects` `string`
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#includesissue)IncludesIssue
===============================

Includes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ContentInput](/api/ContentInput/)`
*   `TRequirement` `extends [ContentRequirement](/api/ContentRequirement/)<TInput>`

[](#definition)Definition
-------------------------

*   `IncludesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'includes'`
    *   `expected` `string`
    *   `requirement` `TRequirement`

[](#inferdefault)InferDefault
=============================

Infer default type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/getDefault/getDefault.ts).

[](#inferdefaults)InferDefaults
===============================

Infer defaults type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/getDefaults/types.ts).

[](#inferfallback)InferFallback
===============================

Infer fallback type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/getFallback/getFallback.ts).

[](#inferfallbacks)InferFallbacks
=================================

Infer fallbacks type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/getFallbacks/types.ts).

[](#inferinput)InferInput
=========================

Infer input type.

[](#generics)Generics
---------------------

*   `TItem` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseValidation](/api/BaseValidation/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseValidationAsync](/api/BaseValidationAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseTransformation](/api/BaseTransformation/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseTransformationAsync](/api/BaseTransformationAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseMetadata](/api/BaseMetadata/)<any>`

[](#definition)Definition
-------------------------

*   `InferInput` `NonNullable<TItem['~types']>['input']`

[](#example)Example
-------------------

`// Create object schema const ObjectSchema = v.object({   key: v.pipe(     v.string(),     v.transform((input) => input.length)   ), });  // Infer object input type type ObjectInput = v.InferInput<typeof ObjectSchema>; // { key: string }`

[](#inferintersectinput)InferIntersectInput
===========================================

Infer intersect input type.

`// Create object schemas const ObjectSchemas = [   v.object({     key1: v.pipe(       v.string(),       v.transform((input) => input.length)     ),   }),   v.object({     key2: v.pipe(       v.string(),       v.transform((input) => input.length)     ),   }), ];  // Infer object intersect input type type ObjectInput = v.InferIntersectInput<typeof ObjectSchemas>; // { key1: string } & { key2: string }`

[](#inferintersectoutput)InferIntersectOutput
=============================================

Infer intersect output type.

`// Create object schemas const ObjectSchemas = [   v.object({     key1: v.pipe(       v.string(),       v.transform((input) => input.length)     ),   }),   v.object({     key2: v.pipe(       v.string(),       v.transform((input) => input.length)     ),   }), ];  // Infer object intersect output type type ObjectOutput = v.InferIntersectOutput<typeof ObjectSchemas>; // { key1: number } & { key2: number }`

[](#inferissue)InferIssue
=========================

Infer issue type.

[](#generics)Generics
---------------------

*   `TItem` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseValidation](/api/BaseValidation/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseValidationAsync](/api/BaseValidationAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseTransformation](/api/BaseTransformation/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseTransformationAsync](/api/BaseTransformationAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseMetadata](/api/BaseMetadata/)<any>`

[](#definition)Definition
-------------------------

*   `InferIssue` `NonNullable<TItem['~types']>['issue']`

[](#infermapinput)InferMapInput
===============================

Infer map input type.

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `InferMapInput` `Map<[InferInput](/api/InferInput/)<TKey>, [InferInput](/api/InferInput/)<TValue>>`

[](#infermapoutput)InferMapOutput
=================================

Infer map output type.

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `InferMapOutput` `Map<[InferOutput](/api/InferOutput/)<TKey>, [InferOutput](/api/InferOutput/)<TValue>>`

[](#infermetadata)InferMetadata
===============================

Infer fallbacks type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/getMetadata/getMetadata.ts).

[](#infernonnullableinput)InferNonNullableInput
===============================================

Infer non nullable input type.

`// Create nullable sting schema const NullableStringSchema = v.nullable(   v.pipe(     v.string(),     v.transform((input) => input.length)   ) );  // Infer non nullable string input type type NonNullableStringInput = v.InferNonNullableInput<   typeof NullableStringSchema >; // string`

[](#infernonnullableissue)InferNonNullableIssue
===============================================

Infer non nullable issue type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/schemas/nonNullable/types.ts).

[](#infernonnullableoutput)InferNonNullableOutput
=================================================

Infer non nullable output type.

`// Create nullable sting schema const NullableStringSchema = v.nullable(   v.pipe(     v.string(),     v.transform((input) => input.length)   ) );  // Infer non nullable string output type type NonNullableStringOutput = v.InferNonNullableOutput<   typeof NullableStringSchema >; // number`

[](#infernonnullishinput)InferNonNullishInput
=============================================

Infer non nullable input type.

`// Create nullish sting schema const NullishStringSchema = v.nullish(   v.pipe(     v.string(),     v.transform((input) => input.length)   ) );  // Infer non nullish string input type type NonNullishStringInput = v.InferNonNullishInput<typeof NullishStringSchema>; // string`

[](#infernonnullishissue)InferNonNullishIssue
=============================================

Infer non nullish issue type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/schemas/nonNullish/types.ts).

[](#infernonnullishoutput)InferNonNullishOutput
===============================================

Infer non nullable output type.

`// Create nullish sting schema const NullishStringSchema = v.nullish(   v.pipe(     v.string(),     v.transform((input) => input.length)   ) );  // Infer non nullish string output type type NonNullishStringOutput = v.InferNonNullishOutput<   typeof NullishStringSchema >; // number`

[](#infernonoptionalinput)InferNonOptionalInput
===============================================

Infer non optional input type.

`// Create optional sting schema const OptionalStringSchema = v.optional(   v.pipe(     v.string(),     v.transform((input) => input.length)   ) );  // Infer non optional string input type type NonOptionalStringInput = v.InferNonOptionalInput<   typeof OptionalStringSchema >; // string`

[](#infernonoptionalissue)InferNonOptionalIssue
===============================================

Infer non optional issue type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/schemas/nonOptional/types.ts).

[](#infernonoptionaloutput)InferNonOptionalOutput
=================================================

Infer non optional output type.

`// Create optional sting schema const OptionalStringSchema = v.optional(   v.pipe(     v.string(),     v.transform((input) => input.length)   ) );  // Infer non optional string output type type NonOptionalStringOutput = v.InferNonOptionalOutput<   typeof OptionalStringSchema >; // number`

[](#infernullableoutput)InferNullableOutput
===========================================

Infer nullable output type.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, null>`

[](#definition)Definition
-------------------------

*   `InferNullableOutput` `[TDefault] extends [never] ? [InferOutput](/api/InferOutput/)<TWrapped> | null : [NonNullable](/api/NonNullable/)<[InferOutput](/api/InferOutput/)<TWrapped>> | Extract<DefaultValue<TDefault>, null>`

[](#infernullishoutput)InferNullishOutput
=========================================

Infer nullish output type.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, null | undefined>`

[](#definition)Definition
-------------------------

*   `InferNullishOutput` `[TDefault] extends [never] ? [InferOutput](/api/InferOutput/)<TWrapped> | null | undefined : [NonNullish](/api/NonNullish/)<[InferOutput](/api/InferOutput/)<TWrapped>> | Extract<DefaultValue<TDefault>, null | undefined>`

[](#inferobjectinput)InferObjectInput
=====================================

Infer object input type.

`// Create object entries const entries = {   key: v.pipe(     v.string(),     v.transform((input) => input.length)   ), };  // Infer entries input type type EntriesInput = v.InferObjectInput<typeof entries>; // { key: string }`

[](#inferobjectissue)InferObjectIssue
=====================================

Infer object issue type.

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntries](/api/ObjectEntries/) | [ObjectEntriesAsync](/api/ObjectEntriesAsync/)`

[](#definition)Definition
-------------------------

*   `InferObjectIssue` `[InferIssue](/api/InferIssue/)<TEntries[keyof TEntries]>`

[](#inferobjectoutput)InferObjectOutput
=======================================

Infer object output type.

`// Create object entries const entries = {   key: v.pipe(     v.string(),     v.transform((input) => input.length)   ), };  // Infer entries output type type EntriesOutput = v.InferObjectOutput<typeof entries>; // { key: number }`

[](#inferoptionaloutput)InferOptionalOutput
===========================================

Infer optional output type.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, undefined>`

[](#definition)Definition
-------------------------

*   `InferOptionalOutput` `[TDefault] extends [never] ? [InferOutput](/api/InferOutput/)<TWrapped> | undefined : [NonOptional](/api/NonOptional/)<[InferOutput](/api/InferOutput/)<TWrapped>> | Extract<DefaultValue<TDefault>, undefined>`

[](#inferoutput)InferOutput
===========================

Infer output type.

[](#generics)Generics
---------------------

*   `TItem` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseValidation](/api/BaseValidation/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseValidationAsync](/api/BaseValidationAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseTransformation](/api/BaseTransformation/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseTransformationAsync](/api/BaseTransformationAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseMetadata](/api/BaseMetadata/)<any>`

[](#definition)Definition
-------------------------

*   `InferIssue` `NonNullable<TItem['~types']>['output']`

[](#example)Example
-------------------

`// Create object schema const ObjectSchema = v.object({   key: v.pipe(     v.string(),     v.transform((input) => input.length)   ), });  // Infer object output type type ObjectOutput = v.InferOutput<typeof ObjectSchema>; // { key: number }`

[](#inferrecordinput)InferRecordInput
=====================================

Infer record input type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/schemas/record/types.ts).

[](#inferrecordoutput)InferRecordOutput
=======================================

Infer record output type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/schemas/record/types.ts).

[](#infersetinput)InferSetInput
===============================

Infer set input type.

[](#generics)Generics
---------------------

*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `InferSetInput` `Set<[InferInput](/api/InferInput/)<TValue>>`

[](#infersetoutput)InferSetOutput
=================================

Infer set output type.

[](#generics)Generics
---------------------

*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `InferSetOutput` `Set<[InferOutput](/api/InferOutput/)<TValue>>`

[](#infertupleinput)InferTupleInput
===================================

Infer tuple output type.

`// Create tuple items const items = [   v.pipe(     v.string(),     v.transform((input) => input.length)   ), ];  // Infer items input type type ItemsInput = v.InferTupleInput<typeof items>; // [string]`

[](#infertupleissue)InferTupleIssue
===================================

Infer tuple issue type.

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItems](/api/TupleItems/) | [TupleItemsAsync](/api/TupleItemsAsync/)`

[](#definition)Definition
-------------------------

*   `InferTupleIssue` `[InferIssue](/api/InferIssue/)<TItems[number]>`

[](#infertupleoutput)InferTupleOutput
=====================================

Infer tuple issue type.

`const items = [   v.pipe(     v.string(),     v.transform((input) => input.length)   ), ];  // Infer items output type type ItemsOutput = v.InferTupleOutput<typeof items>; // [number]`

[](#infervariantissue)InferVariantIssue
=======================================

Infer variant issue type.

[](#generics)Generics
---------------------

*   `TOptions` `extends [VariantOptions](/api/VariantOptions/)<string> | [VariantOptionsAsync](/api/VariantOptionsAsync/)<string>`

[](#definition)Definition
-------------------------

*   `InferVariantIssue` `Exclude<[InferIssue](/api/InferIssue/)<TOptions[number]>, { type: 'loose_object' | 'object' | 'object_with_rest' }>`

[](#instanceissue)InstanceIssue
===============================

Instance issue interface.

[](#definition)Definition
-------------------------

*   `InstanceIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'instance'`
    *   `expected` `string`

[](#instanceschema)InstanceSchema
=================================

Instance schema interface.

[](#generics)Generics
---------------------

*   `TClass` `extends [Class](/api/Class/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[InstanceIssue](/api/InstanceIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `InstanceSchema` `extends [BaseSchema](/api/BaseSchema/)<InstanceType<TClass>, InstanceType<TClass>, [InstanceIssue](/api/InstanceIssue/)>`
    *   `type` `'instance'`
    *   `reference` `typeof [instance](/api/instance/)`
    *   `class` `TClass`
    *   `message` `TMessage`

[](#integeraction)IntegerAction
===============================

Integer action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IntegerIssue](/api/IntegerIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `IntegerAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [IntegerIssue](/api/IntegerIssue/)<TInput>>`
    *   `type` `'integer'`
    *   `reference` `typeof [integer](/api/integer/)`
    *   `expects` `null`
    *   `requirement` `(input: number) => boolean`
    *   `message` `TMessage`

[](#integerissue)IntegerIssue
=============================

Integer issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends number`

[](#definition)Definition
-------------------------

*   `IntegerIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'integer'`
    *   `expected` `null`
    *   `received` `` `${number}` ``
    *   `requirement` `(input: number) => boolean`

[](#intersectissue)IntersectIssue
=================================

Intersect issue interface.

[](#definition)Definition
-------------------------

*   `IntersectIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'intersect'`
    *   `expected` `string`

[](#intersectoptions)IntersectOptions
=====================================

Intersect options type.

[](#definition)Definition
-------------------------

*   `IntersectOptions` `[MaybeReadonly](/api/MaybeReadonly/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>[]>`

[](#intersectoptionsasync)IntersectOptionsAsync
===============================================

Intersect options async type.

[](#definition)Definition
-------------------------

*   `IntersectOptionsAsync` `[MaybeReadonly](/api/MaybeReadonly/)<([BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>)[]>`

[](#intersectschema)IntersectSchema
===================================

Intersect schema interface.

[](#generics)Generics
---------------------

*   `TOptions` `extends [IntersectOptions](/api/IntersectOptions/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IntersectIssue](/api/IntersectIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `IntersectSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferIntersectInput](/api/InferIntersectInput/)<TOptions>, [InferIntersectOutput](/api/InferIntersectOutput/)<TOptions>, [IntersectIssue](/api/IntersectIssue/) | [InferIssue](/api/InferIssue/)<TOptions[number]>>`
    *   `type` `'intersect'`
    *   `reference` `typeof [intersect](/api/intersect/)`
    *   `options` `TOptions`
    *   `message` `TMessage`

[](#intersectschemaasync)IntersectSchemaAsync
=============================================

Intersect schema async interface.

[](#generics)Generics
---------------------

*   `TOptions` `extends [IntersectOptionsAsync](/api/IntersectOptionsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IntersectIssue](/api/IntersectIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `IntersectSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferIntersectInput](/api/InferIntersectInput/)<TOptions>, [InferIntersectOutput](/api/InferIntersectOutput/)<TOptions>, [IntersectIssue](/api/IntersectIssue/) | [InferIssue](/api/InferIssue/)<TOptions[number]>>`
    *   `type` `'intersect'`
    *   `reference` `typeof [intersect](/api/intersect/) | typeof [intersectAsync](/api/intersectAsync/)`
    *   `options` `TOptions`
    *   `message` `TMessage`

[](#ipaction)IpAction
=====================

IP action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IpIssue](/api/IpIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `IpAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [IpIssue](/api/IpIssue/)<TInput>>`
    *   `type` `'ip'`
    *   `reference` `typeof [ip](/api/ip/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#ipissue)IpIssue
===================

IP issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `IpIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'ip'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#ipv4action)Ipv4Action
=========================

IPv4 action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Ipv4Issue](/api/Ipv4Issue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `Ipv4Action` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [Ipv4Issue](/api/Ipv4Issue/)<TInput>>`
    *   `type` `'ipv4'`
    *   `reference` `typeof [ipv4](/api/ipv4/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#ipv4issue)Ipv4Issue
=======================

IPv4 issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `Ipv4Issue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'ipv4'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#ipv6action)Ipv6Action
=========================

IPv6 action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Ipv6Issue](/api/Ipv6Issue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `Ipv6Action` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [Ipv6Issue](/api/Ipv6Issue/)<TInput>>`
    *   `type` `'ipv6'`
    *   `reference` `typeof [ipv6](/api/ipv6/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#ipv6issue)Ipv6Issue
=======================

IPv6 issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `Ipv6Issue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'ipv6'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#isodateaction)IsoDateAction
===============================

ISO date action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoDateIssue](/api/IsoDateIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `IsoDateAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [IsoDateIssue](/api/IsoDateIssue/)<TInput>>`
    *   `type` `'iso_date'`
    *   `reference` `typeof [isoDate](/api/isoDate/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#isodateissue)IsoDateIssue
=============================

ISO date issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `IsoDateIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'iso_date'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#isodatetimeaction)IsoDateTimeAction
=======================================

ISO date time action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoDateTimeIssue](/api/IsoDateTimeIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `IsoDateTimeAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [IsoDateTimeIssue](/api/IsoDateTimeIssue/)<TInput>>`
    *   `type` `'iso_date_time'`
    *   `reference` `typeof [isoDateTime](/api/isoDateTime/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#isodatetimeissue)IsoDateTimeIssue
=====================================

ISO date time issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `IsoDateTimeIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'iso_date_time'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#isotimeaction)IsoTimeAction
===============================

ISO time action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoTimeIssue](/api/IsoTimeIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `IsoTimeAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [IsoTimeIssue](/api/IsoTimeIssue/)<TInput>>`
    *   `type` `'iso_time'`
    *   `reference` `typeof [isoTime](/api/IsoTimeAction/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#isotimeissue)IsoTimeIssue
=============================

ISO time issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `IsoTimeIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'iso_time'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#isotimesecondaction)IsoTimeSecondAction
===========================================

ISO time second action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoTimeSecondIssue](/api/IsoTimeSecondIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `IsoTimeSecondAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [IsoTimeSecondIssue](/api/IsoTimeSecondIssue/)<TInput>>`
    *   `type` `'iso_time_second'`
    *   `reference` `typeof [isoTimeSecond](/api/isoTimeSecond/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#isotimesecondissue)IsoTimeSecondIssue
=========================================

ISO time second issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `IsoTimeSecondIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'iso_time_second'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#isotimestampaction)IsoTimestampAction
=========================================

ISO timestamp action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoTimestampIssue](/api/IsoTimestampIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `IsoTimestampAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [IsoTimestampIssue](/api/IsoTimestampIssue/)<TInput>>`
    *   `type` `'iso_timestamp'`
    *   `reference` `typeof [isoTimestamp](/api/isoTimestamp/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#isotimestampissue)IsoTimestampIssue
=======================================

ISO timestamp issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `IsoTimestampIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'iso_timestamp'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#isoweekaction)IsoWeekAction
===============================

ISO week action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[IsoWeekIssue](/api/IsoWeekIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `IsoWeekAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [IsoWeekIssue](/api/IsoWeekIssue/)<TInput>>`
    *   `type` `'iso_week'`
    *   `reference` `typeof [isoWeek](/api/isoWeek/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#isoweekissue)IsoWeekIssue
=============================

ISO week issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `IsoWeekIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'iso_week'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#issuedotpath)IssueDotPath
=============================

Issue dot path type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/types/issue.ts).

[](#issuepathitem)IssuePathItem
===============================

Path item type.

[](#definition)Definition
-------------------------

*   `IssuePathItem` `[ArrayPathItem](/api/ArrayPathItem/) | [MapPathItem](/api/MapPathItem/) | [ObjectPathItem](/api/ObjectPathItem/) | [SetPathItem](/api/SetPathItem/) | [UnknownPathItem](/api/UnknownPathItem/)`

[](#lazyschema)LazySchema
=========================

Lazy schema interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `LazySchema` `extends [BaseSchema](/api/BaseSchema/)<[InferInput](/api/InferInput/)<TWrapped>, [InferOutput](/api/InferOutput/)<TWrapped>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'lazy'`
    *   `reference` `typeof [lazy](/api/lazy/)`
    *   `expects` `'unknown'`
    *   `getter` `(input: unknown) => TWrapped`

[](#lazyschemaasync)LazySchemaAsync
===================================

Lazy schema async interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `LazySchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferInput](/api/InferInput/)<TWrapped>, [InferOutput](/api/InferOutput/)<TWrapped>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'lazy'`
    *   `reference` `typeof [lazy](/api/lazy/) | typeof [lazyAsync](/api/lazyAsync/)`
    *   `expects` `'unknown'`
    *   `getter` `(input: unknown) => [MaybePromise](/api/MaybePromise/)<TWrapped>`

[](#lengthaction)LengthAction
=============================

Length action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LengthIssue](/api/LengthIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `LengthAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [LengthIssue](/api/LengthIssue/)<TInput, TRequirement>>`
    *   `type` `'length'`
    *   `reference` `typeof [length](/api/length/)`
    *   `expects` `` `${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#lengthinput)LengthInput
===========================

Length input type.

[](#definition)Definition
-------------------------

*   `LengthInput` `string | ArrayLike<unknown>`

[](#lengthissue)LengthIssue
===========================

Length issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `LengthIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'length'`
    *   `expected` `` `${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#literal)Literal
===================

Literal type.

[](#definition)Definition
-------------------------

*   `Literal` `bigint | boolean | number | string | symbol`

[](#literalissue)LiteralIssue
=============================

Literal issue interface.

[](#definition)Definition
-------------------------

*   `LiteralIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'literal'`
    *   `expected` `string`

[](#looseobjectissue)LooseObjectIssue
=====================================

Loose object issue interface.

[](#definition)Definition
-------------------------

*   `LooseObjectIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'loose_object'`
    *   `expected` `` 'Object' | `"${string}"` ``

[](#looseobjectschema)LooseObjectSchema
=======================================

Loose object schema interface.

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntries](/api/ObjectEntries/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LooseObjectIssue](/api/LooseObjectIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `LooseObjectSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferObjectInput](/api/InferObjectInput/)<TEntries> & { [key: string]: unknown }, [InferObjectOutput](/api/InferObjectOutput/)<TEntries> & { [key: string]: unknown }, [LooseObjectIssue](/api/LooseObjectIssue/) | [InferObjectIssue](/api/InferObjectIssue/)<TEntries>>`
    *   `type` `'loose_object'`
    *   `reference` `typeof [looseObject](/api/looseObject/)`
    *   `expects` `'Object'`
    *   `entries` `TEntries`
    *   `message` `TMessage`

[](#looseobjectschemaasync)LooseObjectSchemaAsync
=================================================

Loose object schema async interface.

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntriesAsync](/api/ObjectEntriesAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LooseObjectIssue](/api/LooseObjectIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `LooseObjectSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferObjectInput](/api/InferObjectInput/)<TEntries> & { [key: string]: unknown }, [InferObjectOutput](/api/InferObjectOutput/)<TEntries> & { [key: string]: unknown }, [LooseObjectIssue](/api/LooseObjectIssue/) | [InferObjectIssue](/api/InferObjectIssue/)<TEntries>>`
    *   `type` `'loose_object'`
    *   `reference` `typeof [looseObject](/api/looseObject/) | typeof [looseObjectAsync](/api/looseObjectAsync/)`
    *   `expects` `'Object'`
    *   `entries` `TEntries`
    *   `message` `TMessage`

[](#loosetupleissue)LooseTupleIssue
===================================

Loose tuple issue interface.

[](#definition)Definition
-------------------------

*   `LooseTupleIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'loose_tuple'`
    *   `expected` `'Array'`

[](#loosetupleschema)LooseTupleSchema
=====================================

Loose tuple schema interface.

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItems](/api/TupleItems/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `LooseTupleSchema` `extends [BaseSchema](/api/BaseSchema/)<[...[InferTupleInput](/api/InferTupleInput/)<TItems>, ...unknown[]], [...[InferTupleOutput](/api/InferTupleOutput/)<TItems>, ...unknown[]], [LooseTupleIssue](/api/LooseTupleIssue/) | [InferTupleIssue](/api/InferTupleIssue/)<TItems>>`
    *   `type` `'loose_tuple'`
    *   `reference` `typeof [looseTuple](/api/looseTuple/)`
    *   `expects` `'Array'`
    *   `items` `TItems`
    *   `message` `TMessage`

[](#loosetupleschemaasync)LooseTupleSchemaAsync
===============================================

Loose tuple schema async interface.

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItemsAsync](/api/TupleItemsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LooseTupleIssue](/api/LooseTupleIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `LooseTupleSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[...[InferTupleInput](/api/InferTupleInput/)<TItems>, ...unknown[]], [...[InferTupleOutput](/api/InferTupleOutput/)<TItems>, ...unknown[]], [LooseTupleIssue](/api/LooseTupleIssue/) | [InferTupleIssue](/api/InferTupleIssue/)<TItems>>`
    *   `type` `'loose_tuple'`
    *   `reference` `typeof [looseTuple](/api/looseTuple/) | typeof [looseTupleAsync](/api/looseTupleAsync/)`
    *   `expects` `'Array'`
    *   `items` `TItems`
    *   `message` `TMessage`

[](#literalschema)LiteralSchema
===============================

Literal schema interface.

[](#generics)Generics
---------------------

*   `TLiteral` `extends [Literal](/api/Literal/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LiteralIssue](/api/LiteralIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `LiteralSchema` `extends [BaseSchema](/api/BaseSchema/)<TLiteral, TLiteral, [LiteralIssue](/api/LiteralIssue/)>`
    *   `type` `'literal'`
    *   `reference` `typeof [literal](/api/literal/)`
    *   `literal` `TLiteral`
    *   `message` `TMessage`

[](#ltvalueaction)LtValueAction
===============================

Less than value action type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[LtValueIssue](/api/LtValueIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `LtValueAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [LtValueIssue](/api/LtValueIssue/)<TInput, TRequirement>>`
    *   `type` `'lt_value'`
    *   `reference` `typeof [ltValue](/api/ltValue/)`
    *   `expects` `` `<${string}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#ltvalueissue)LtValueIssue
=============================

Less than value issue type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#definition)Definition
-------------------------

*   `LtValueIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'lt_value'`
    *   `expected` `` `<${string}` ``
    *   `requirement` `TRequirement`

[](#mac48action)Mac48Action
===========================

48-bit MAC action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Mac48Issue](/api/Mac48Issue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `Mac48Action` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [Mac48Issue](/api/Mac48Issue/)<TInput>>`
    *   `type` `'mac48'`
    *   `reference` `typeof [mac48](/api/mac48/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#mac48issue)Mac48Issue
=========================

48-bit MAC issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `Mac48Issue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'mac48'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#mac64action)Mac64Action
===========================

64-bit MAC action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[Mac64Issue](/api/Mac64Issue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `Mac64Action` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [Mac64Issue](/api/Mac64Issue/)<TInput>>`
    *   `type` `'mac64'`
    *   `reference` `typeof [mac64](/api/mac64/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#mac64issue)Mac64Issue
=========================

64-bit MAC issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `Mac64Issue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'mac64'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#macaction)MacAction
=======================

MAC action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MacIssue](/api/MacIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `MacAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MacIssue](/api/MacIssue/)<TInput>>`
    *   `type` `'mac'`
    *   `reference` `typeof [mac](/api/mac/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#macissue)MacIssue
=====================

MAC issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `MacIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'mac'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#mapissue)MapIssue
=====================

Map issue interface.

[](#definition)Definition
-------------------------

*   `MapIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'map'`
    *   `expected` `'Map'`

[](#mapitemsaction)MapItemsAction
=================================

Map items action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `MapItemsAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TOuput[], never>`
    *   `type` `'map_items'`
    *   `reference` `typeof [mapItems](/api/mapItems/)`
    *   `operation` `(item: TInput[number], index: number, array: TInput) => TOutput`

[](#mappathitem)MapPathItem
===========================

Map path item interface.

[](#definition)Definition
-------------------------

*   `MapPathItem`
    *   `type` `'map'`
    *   `origin` `'key' | 'value'`
    *   `input` `Map<unknown, unknown>`
    *   `key` `unknown`
    *   `value` `unknown`

The `input` of a path item may differ from the `input` of its issue. This is because path items are subsequently added by parent schemas and are related to their input. Transformations of child schemas are not taken into account.

[](#mapschema)MapSchema
=======================

Map schema interface.

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MapIssue](/api/MapIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `MapSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferMapInput](/api/InferMapInput/)<TKey, TValue>, [InferMapOutput](/api/InferMapOutput/)<TKey, TValue>, [MapIssue](/api/MapIssue/) | [InferIssue](/api/InferIssue/)<TKey> | [InferIssue](/api/InferIssue/)<TValue>>`
    *   `type` `'map'`
    *   `reference` `typeof [map](/api/map/)`
    *   `expects` `'Map'`
    *   `key` `TKey`
    *   `value` `TValue`
    *   `message` `TMessage`

[](#mapschemaasync)MapSchemaAsync
=================================

Map schema async interface.

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MapIssue](/api/MapIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `MapSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferMapInput](/api/InferMapInput/)<TKey, TValue>, [InferMapOutput](/api/InferMapOutput/)<TKey, TValue>, [MapIssue](/api/MapIssue/) | [InferIssue](/api/InferIssue/)<TKey> | [InferIssue](/api/InferIssue/)<TValue>>`
    *   `type` `'map'`
    *   `reference` `typeof [map](/api/map/) | typeof [mapAsync](/api/mapAsync/)`
    *   `expects` `'Map'`
    *   `key` `TKey`
    *   `value` `TValue`
    *   `message` `TMessage`

[](#maxbytesaction)MaxBytesAction
=================================

Max bytes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxBytesIssue](/api/MaxBytesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MaxBytesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MaxBytesIssue](/api/MaxBytesIssue/)<TInput, TRequirement>>`
    *   `type` `'max_bytes'`
    *   `reference` `typeof [maxBytes](/api/maxBytes/)`
    *   `expects` `` `<=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#maxbytesissue)MaxBytesIssue
===============================

Max bytes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MaxBytesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'max_bytes'`
    *   `expected` `` `<=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#maxentriesaction)MaxEntriesAction
=====================================

Max entries action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxEntriesIssue](/api/MaxEntriesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MaxEntriesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MaxEntriesIssue](/api/MaxEntriesIssue/)<TInput, TRequirement>>`
    *   `type` `'max_entries'`
    *   `reference` `typeof [maxEntries](/api/maxEntries/)`
    *   `expects` `` `<=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#maxentriesissue)MaxEntriesIssue
===================================

Max entries issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MaxEntriesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'max_entries'`
    *   `expected` `` `<=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#maxgraphemesaction)MaxGraphemesAction
=========================================

Max graphemes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxGraphemesIssue](/api/MaxGraphemesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MaxGraphemesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MaxGraphemesIssue](/api/MaxGraphemesIssue/)<TInput, TRequirement>>`
    *   `type` `'max_graphemes'`
    *   `reference` `typeof [maxGraphemes](/api/maxGraphemes/)`
    *   `expects` `` `<=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#maxgraphemesissue)MaxGraphemesIssue
=======================================

Max graphemes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MaxGraphemesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'max_graphemes'`
    *   `expected` `` `<=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#maxlengthaction)MaxLengthAction
===================================

Max length action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxLengthIssue](/api/MaxLengthIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MaxLengthAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MaxLengthIssue](/api/MaxLengthIssue/)<TInput, TRequirement>>`
    *   `type` `'max_length'`
    *   `reference` `typeof [maxLength](/api/maxLength/)`
    *   `expects` `` `<=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#maxlengthissue)MaxLengthIssue
=================================

Max length issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MaxLengthIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'max_length'`
    *   `expected` `` `<=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#maxsizeaction)MaxSizeAction
===============================

Max size action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxSizeIssue](/api/MaxSizeIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MaxSizeAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MaxSizeIssue](/api/MaxSizeIssue/)<TInput, TRequirement>>`
    *   `type` `'max_size'`
    *   `reference` `typeof [maxSize](/api/maxSize/)`
    *   `expects` `` `<=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#maxsizeissue)MaxSizeIssue
=============================

Max size issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MaxSizeIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'max_size'`
    *   `expected` `` `<=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#maxvalueaction)MaxValueAction
=================================

Max value action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxValueIssue](/api/MaxValueIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MaxValueAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MaxValueIssue](/api/MaxValueIssue/)<TInput, TRequirement>>`
    *   `type` `'max_value'`
    *   `reference` `typeof [maxValue](/api/maxValue/)`
    *   `expects` `` `<=${string}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#maxvalueissue)MaxValueIssue
===============================

Max value issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#definition)Definition
-------------------------

*   `MaxValueIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'max_value'`
    *   `expected` `` `<=${string}` ``
    *   `requirement` `TRequirement`

[](#maxwordsaction)MaxWordsAction
=================================

Max words action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TLocales` `extends Intl.LocalesArgument`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MaxWordsIssue](/api/MaxWordsIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MaxWordsAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MaxWordsIssue](/api/MaxWordsIssue/)<TInput, TRequirement>>`
    *   `type` `'max_words'`
    *   `reference` `typeof [maxWords](/api/maxWords/)`
    *   `expects` `` `<=${TRequirement}` ``
    *   `locales` `TLocales`
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#maxwordsissue)MaxWordsIssue
===============================

Max words issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MaxWordsIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'max_words'`
    *   `expected` `` `<=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#maybepromise)MaybePromise
=============================

Maybe promise type.

[](#generics)Generics
---------------------

*   `TValue` `extends any`

[](#definition)Definition
-------------------------

*   `MaybePromise` `TValue | Promise<TValue>`

[](#maybereadonly)MaybeReadonly
===============================

Maybe readonly type.

[](#generics)Generics
---------------------

*   `TValue` `extends any`

[](#definition)Definition
-------------------------

*   `MaybeReadonly` `TValue | Readonly<TValue>`

[](#metadataaction)MetadataAction
=================================

Metadata action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TMetadata` `extends Record<string, unknown>`

[](#definition)Definition
-------------------------

*   `MetadataAction` `extends [BaseMetadata](/api/BaseMetadata/)<TInput>`
    *   `type` `'metadata'`
    *   `reference` `typeof [metadata](/api/metadata/)`
    *   `metadata_` `TMetadata`

[](#mimetypeaction)MimeTypeAction
=================================

MIME type action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends Blob`
*   `TRequirement` `extends string[]`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MimeTypeIssue](/api/MimeTypeAction/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MimeTypeAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MimeTypeIssue](/api/MimeTypeIssue/)<TInput, TRequirement>>`
    *   `type` `'mime_type'`
    *   `reference` `typeof [mimeType](/api/mimeType/)`
    *   `expects` `string`
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#mimetypeissue)MimeTypeIssue
===============================

Mime type issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` ``extends `${string}/${string}`[]``

[](#definition)Definition
-------------------------

*   `MimeTypeIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'mime_type'`
    *   `expected` `string`
    *   `received` `` `"${string}"` ``
    *   `requirement` `TRequirement`

[](#minbytesaction)MinBytesAction
=================================

Min bytes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinBytesIssue](/api/MinBytesAction/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MinBytesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MinBytesIssue](/api/MinBytesAction/)<TInput, TRequirement>>`
    *   `type` `'min_bytes'`
    *   `reference` `typeof [minBytes](/api/minBytes/)`
    *   `expects` `` `>=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#minbytesissue)MinBytesIssue
===============================

Min bytes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MinBytesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'min_bytes'`
    *   `expected` `` `>=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#minentriesaction)MinEntriesAction
=====================================

Min entries action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinEntriesIssue](/api/MinEntriesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MinEntriesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MinEntriesIssue](/api/MinEntriesIssue/)<TInput, TRequirement>>`
    *   `type` `'min_entries'`
    *   `reference` `typeof [minEntries](/api/minEntries/)`
    *   `expects` `` `>=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#minentriesissue)MinEntriesIssue
===================================

Min entries issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MinEntriesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'min_entries'`
    *   `expected` `` `>=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#mingraphemesaction)MinGraphemesAction
=========================================

Min graphemes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinGraphemesIssue](/api/MinGraphemesAction/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MinGraphemesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MinGraphemesIssue](/api/MinGraphemesAction/)<TInput, TRequirement>>`
    *   `type` `'min_graphemes'`
    *   `reference` `typeof [minGraphemes](/api/minGraphemes/)`
    *   `expects` `` `>=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#mingraphemesissue)MinGraphemesIssue
=======================================

Min graphemes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MinGraphemesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'min_graphemes'`
    *   `expected` `` `>=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#minlengthaction)MinLengthAction
===================================

Min length action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinLengthIssue](/api/MinLengthIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MinLengthAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MinLengthIssue](/api/MinLengthIssue/)<TInput, TRequirement>>`
    *   `type` `'min_length'`
    *   `reference` `typeof [minLength](/api/minLength/)`
    *   `expects` `` `>=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#minlengthissue)MinLengthIssue
=================================

Min length issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MinLengthIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'min_length'`
    *   `expected` `` `>=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#minsizeaction)MinSizeAction
===============================

Min size action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinSizeIssue](/api/MinSizeAction/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MinSizeAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MinSizeIssue](/api/MinSizeAction/)<TInput, TRequirement>>`
    *   `type` `'min_size'`
    *   `referece` `typeof [minSize](/api/minSize/)`
    *   `expects` `` `>=${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#minsizeissue)MinSizeIssue
=============================

Min size issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MinSizeIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'min_size'`
    *   `expected` `` `>=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#minvalueaction)MinValueAction
=================================

Min value action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinValueIssue](/api/MinValueAction/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MinValueAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MinValueIssue](/api/MinValueAction/)<TInput, TRequirement>>`
    *   `type` `'min_value'`
    *   `reference` `typeof [minValue](/api/minValue/)`
    *   `expects` `` `>=${string}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#minvalueissue)MinValueIssue
===============================

Min value issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#definition)Definition
-------------------------

*   `MinValueIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'min_value'`
    *   `expected` `` `>=${string}` ``
    *   `requirement` `TRequirement`

[](#minwordsaction)MinWordsAction
=================================

Min words action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TLocales` `extends Intl.LocalesArgument`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MinWordsIssue](/api/MinWordsAction/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MinWordsAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MinWordsIssue](/api/MinWordsAction/)<TInput, TRequirement>>`
    *   `type` `'min_words'`
    *   `reference` `typeof [minWords](/api/minWords/)`
    *   `expects` `` `>=${TRequirement}` ``
    *   `locales` `TLocales`
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#minwordsissue)MinWordsIssue
===============================

Min words issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `MinWordsIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'min_words'`
    *   `expected` `` `>=${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#multipleofaction)MultipleOfAction
=====================================

Multiple of action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends number | bigint`
*   `TRequirement` `extends number | bigint`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[MultipleOfIssue](/api/MultipleOfAction/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `MultipleOfAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [MultipleOfIssue](/api/MultipleOfAction/)<TInput, TRequirement>>`
    *   `type` `'multiple_of'`
    *   `reference` `typeof [multipleOf](/api/multipleOf/)`
    *   `expects` `` `%${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#multipleofissue)MultipleOfIssue
===================================

Multiple of issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends number | bigint`
*   `TRequirement` `extends number | bigint`

[](#definition)Definition
-------------------------

*   `MultipleOfIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'multiple_of'`
    *   `expected` `` `%${TRequirement}` ``
    *   `received` `` `${TInput}` ``
    *   `requirement` `TRequirement`

[](#nanissue)NanIssue
=====================

NaN issue interface.

[](#definition)Definition
-------------------------

*   `NanIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'nan'`
    *   `expected` `'NaN'`

[](#nanschema)NanSchema
=======================

NaN schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NanIssue](/api/NanIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NanSchema` `extends [BaseSchema](/api/BaseSchema/)<number, number, [NanIssue](/api/NanIssue/)>`
    *   `type` `'nan'`
    *   `reference` `readonly [nan](/api/nan/)`
    *   `expects` `'NaN'`
    *   `message` `TMessage`

[](#neverissue)NeverIssue
=========================

Never issue interface.

[](#definition)Definition
-------------------------

*   `NeverIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'never'`
    *   `expected` `'never'`

[](#neverschema)NeverSchema
===========================

Never schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NeverIssue](/api/NeverIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NeverSchema` `extends [BaseSchema](/api/BaseSchema/)<never, never, [NeverIssue](/api/NeverIssue/)>`
    *   `type` `'never'`
    *   `reference` `readonly [never](/api/never/)`
    *   `expects` `'never'`
    *   `message` `TMessage`

[](#nonemptyaction)NonEmptyAction
=================================

Non empty action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonEmptyIssue](/api/NonEmptyIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `NonEmptyAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [NonEmptyIssue](/api/NonEmptyIssue/)<TInput, TRequirement>>`
    *   `type` `'non_empty'`
    *   `reference` `typeof [nonEmpty](/api/nonEmpty/)`
    *   `expects` `'!0'`
    *   `message` `TMessage`

[](#nonemptyissue)NonEmptyIssue
===============================

Non empty issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`

[](#definition)Definition
-------------------------

*   `NonEmptyIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'non_empty'`
    *   `expected` `'!0'`
    *   `received` `'0'`

[](#nonnullable)NonNullable
===========================

Extracts `null` from a type.

[](#generics)Generics
---------------------

*   `TValue` `extends any`

[](#definition)Definition
-------------------------

*   `NonNullable` `TValue extends null ? never : TValue`

[](#nonnullableissue)NonNullableIssue
=====================================

Non nullable issue interface.

[](#definition)Definition
-------------------------

*   `NonNullableIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'non_nullable'`
    *   `expected` `'!null'`

[](#nonnullableschema)NonNullableSchema
=======================================

Non nullable schema interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonNullableIssue](/api/NonNullableIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NonNullableSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferNonNullableInput](/api/InferNonNullableInput/)<TWrapped>, [InferNonNullableOutput](/api/InferNonNullableOutput/)<TWrapped>, [NonNullableIssue](/api/NonNullableIssue/) | [InferNonNullableIssue](/api/InferNonNullableIssue/)<TWrapped>>`
    *   `type` `'non_nullable'`
    *   `reference` `typeof [nonNullable](/api/nonNullable/)`
    *   `expects` `'!null'`
    *   `wrapped` `TWrapped`
    *   `message` `TMessage`

[](#nonnullableschemaasync)NonNullableSchemaAsync
=================================================

Non nullable schema async interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonNullableIssue](/api/NonNullableIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NonNullableSchemaAsync` `[BaseSchema](/api/BaseSchema/)<[InferNonNullableInput](/api/InferNonNullableInput/)<TWrapped>, [InferNonNullableOutput](/api/InferNonNullableOutput/)<TWrapped>, [NonNullableIssue](/api/NonNullableIssue/) | [InferNonNullishIssue](/api/InferNonNullishIssue/)<TWrapped>>`
    *   `type` `'non_nullable'`
    *   `reference` `typeof [nonNullable](/api/nonNullable/) | typeof [nonNullableAsync](/api/nonNullableAsync/)`
    *   `expects` `'!null'`
    *   `wrapped` `TWrapped`
    *   `message` `TMessage`

[](#nonnullish)NonNullish
=========================

Extracts `null` and `undefined` from a type.

[](#generics)Generics
---------------------

*   `TValue` `extends any`

[](#definition)Definition
-------------------------

*   `NonNullish` `TValue extends null | undefined ? never : TValue`

[](#nonnullishissue)NonNullishIssue
===================================

Non nullish issue interface.

[](#definition)Definition
-------------------------

*   `NonNullishIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'non_nullish'`
    *   `expected` `'(!null & !undefined)'`

[](#nonnullishschema)NonNullishSchema
=====================================

Non nullish schema interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonNullishIssue](/api/NonNullishIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NonNullishSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferNonNullishInput](/api/InferNonNullishInput/)<TWrapped>, [InferNonNullishOutput](/api/InferNonNullishOutput/)<TWrapped>, [NonNullishIssue](/api/NonNullishIssue/) | [InferNonNullishIssue](/api/InferNonNullishIssue/)<TWrapped>>`
    *   `type` `'non_nullish'`
    *   `reference` `typeof [nonNullish](/api/nonNullish/)`
    *   `expects` `'(!null & !undefined)'`
    *   `wrapped` `TWrapped`
    *   `message` `TMessage`

[](#nonnullishschemaasync)NonNullishSchemaAsync
===============================================

Non nullish schema async interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonNullishIssue](/api/NonNullishIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NonNullishSchemaAsync` `[BaseSchema](/api/BaseSchema/)<[InferNonNullishInput](/api/InferNonNullishInput/)<TWrapped>, [InferNonNullishOutput](/api/InferNonNullishOutput/)<TWrapped>, [NonNullishIssue](/api/NonNullishIssue/) | [InferNonNullishIssue](/api/InferNonNullishIssue/)<TWrapped>>`
    *   `type` `'non_nullish'`
    *   `reference` `typeof [nonNullish](/api/nonNullish/) | typeof [nonNullishAsync](/api/nonNullishAsync/)`
    *   `expects` `'(!null & !undefined)'`
    *   `wrapped` `TWrapped`
    *   `message` `TMessage`

[](#nonoptional)NonOptional
===========================

Extracts `undefined` from a type.

[](#generics)Generics
---------------------

*   `TValue` `extends any`

[](#definition)Definition
-------------------------

*   `NonOptional` `TValue extends undefined ? never : TValue`

[](#nonoptionalissue)NonOptionalIssue
=====================================

Non optional issue interface.

[](#definition)Definition
-------------------------

*   `NonOptionalIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'non_optional'`
    *   `expected` `'!undefined'`

[](#nonoptionalschema)NonOptionalSchema
=======================================

Non optional schema interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonOptionalIssue](/api/NonOptionalIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NonOptionalSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferNonOptionalInput](/api/InferNonOptionalInput/)<TWrapped>, [InferNonOptionalOutput](/api/InferNonOptionalOutput/)<TWrapped>, [NonOptionalIssue](/api/NonOptionalIssue/) | [InferNonOptionalIssue](/api/InferNonOptionalIssue/)<TWrapped>>`
    *   `type` `'non_optional'`
    *   `reference` `typeof [nonOptional](/api/nonOptional/)`
    *   `expects` `'!undefined'`
    *   `wrapped` `TWrapped`
    *   `message` `TMessage`

[](#nonoptionalschemaasync)NonOptionalSchemaAsync
=================================================

Non optional schema async interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NonOptionalIssue](/api/NonOptionalIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NonOptionalSchemaAsync` `[BaseSchema](/api/BaseSchema/)<[InferNonOptionalInput](/api/InferNonOptionalInput/)<TWrapped>, [InferNonOptionalOutput](/api/InferNonOptionalOutput/)<TWrapped>, [NonOptionalIssue](/api/NonOptionalIssue/) | [InferNonOptionalIssue](/api/InferNonOptionalIssue/)<TWrapped>>`
    *   `type` `'non_optional'`
    *   `reference` `typeof [nonOptional](/api/nonOptional/) | typeof [nonOptionalAsync](/api/nonOptionalAsync/)`
    *   `expects` `'!undefined'`
    *   `wrapped` `TWrapped`
    *   `message` `TMessage`

[](#normalizeaction)NormalizeAction
===================================

Normalize action interface.

[](#generics)Generics
---------------------

*   `TForm` `extends [NormalizeForm](/api/NormalizeForm/)`

[](#definition)Definition
-------------------------

*   `NormalizeAction` `extends [BaseTransformation](/api/BaseTransformation/)<string, string, never>`
    *   `type` `'normalize'`
    *   `reference` `typeof [normalize](/api/normalize/)`
    *   `form` `TForm`

[](#normalizeform)NormalizeForm
===============================

Normalize form type.

[](#definition)Definition
-------------------------

*   `NormalizeForm` `'NFC' | 'NFD' | 'NFKC' | 'NFKD'`

[](#notbytesaction)NotBytesAction
=================================

Not bytes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotBytesIssue](/api/NotBytesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `NotBytesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [NotBytesIssue](/api/NotBytesIssue/)<TInput, TRequirement>>`
    *   `type` `'not_bytes'`
    *   `reference` `typeof [notBytes](/api/notBytes/)`
    *   `expects` `` `!${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#notbytesissue)NotBytesIssue
===============================

Not bytes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `NotBytesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'not_bytes'`
    *   `expected` `` `!${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#notentriesaction)NotEntriesAction
=====================================

Not entries action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotEntriesIssue](/api/NotEntriesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `NotEntriesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [NotEntriesIssue](/api/NotEntriesIssue/)<TInput, TRequirement>>`
    *   `type` `'not_entries'`
    *   `reference` `typeof [notEntries](/api/notEntries/)`
    *   `expects` `` `!${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#notentriesissue)NotEntriesIssue
===================================

Not entries issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [EntriesInput](/api/EntriesInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `NotEntriesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'not_entries'`
    *   `expected` `` `!${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#notgraphemesaction)NotGraphemesAction
=========================================

Not graphemes action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotGraphemesIssue](/api/NotGraphemesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `NotGraphemesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [NotGraphemesIssue](/api/NotGraphemesIssue/)<TInput, TRequirement>>`
    *   `type` `'not_graphemes'`
    *   `reference` `typeof [notGraphemes](/api/notGraphemes/)`
    *   `expects` `` `!${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#notgraphemesissue)NotGraphemesIssue
=======================================

Not graphemes issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `NotGraphemesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'not_graphemes'`
    *   `expected` `` `!${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#notlengthaction)NotLengthAction
===================================

Not length action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotLengthIssue](/api/NotLengthIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `NotLengthAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [NotLengthIssue](/api/NotLengthIssue/)<TInput, TRequirement>>`
    *   `type` `'not_length'`
    *   `reference` `typeof [notLength](/api/notLength/)`
    *   `expects` `` `!${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#notlengthissue)NotLengthIssue
=================================

Not length issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [LengthInput](/api/LengthInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `NotLengthIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'not_length'`
    *   `expected` `` `!${TRequirement}` ``
    *   `received` `` `${TRequirement}` ``
    *   `requirement` `TRequirement`

[](#notsizeaction)NotSizeAction
===============================

Not size action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotSizeIssue](/api/NotSizeIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `NotSizeAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [NotSizeIssue](/api/NotSizeIssue/)<TInput, TRequirement>>`
    *   `type` `'not_size'`
    *   `reference` `typeof [notSize](/api/notSize/)`
    *   `expects` `` `!${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#notsizeissue)NotSizeIssue
=============================

Not size issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `NotSizeIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'not_size'`
    *   `expected` `` `!${TRequirement}` ``
    *   `received` `` `${TRequirement}` ``
    *   `requirement` `TRequirement`

[](#notvalueaction)NotValueAction
=================================

Not value action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotValueIssue](/api/NotValueIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `NotValueAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [NotValueIssue](/api/NotValueIssue/)<TInput, TRequirement>>`
    *   `type` `'not_value'`
    *   `reference` `typeof [notValue](/api/notValue/)`
    *   `expects` `` `!${string}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#notvaluesaction)NotValuesAction
===================================

Not values action type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends readonly TInput[]`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotValuesIssue](/api/NotValuesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `NotValuesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [NotValuesIssue](/api/NotValuesIssue/)<TInput, TRequirement>>`
    *   `type` `'not_values'`
    *   `reference` `typeof [notValues](/api/notValues/)`
    *   `expects` `` `!${string}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#notvalueissue)NotValueIssue
===============================

Not value issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#definition)Definition
-------------------------

*   `NotValueIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'not_value'`
    *   `expected` `` `!${string}` ``
    *   `requirement` `TRequirement`

[](#notvaluesissue)NotValuesIssue
=================================

Not values issue type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends readonly TInput[]`

[](#definition)Definition
-------------------------

*   `NotValuesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'not_values'`
    *   `expected` `` `!${string}` ``
    *   `requirement` `TRequirement`

[](#notwordsaction)NotWordsAction
=================================

Not words action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TLocales` `extends Intl.LocalesArgument`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NotWordsIssue](/api/NotWordsIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `NotWordsAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [NotWordsIssue](/api/NotWordsIssue/)<TInput, TRequirement>>`
    *   `type` `'not_words'`
    *   `reference` `typeof [notWords](/api/notWords/)`
    *   `expects` `` `!${TRequirement}` ``
    *   `locales` `TLocales`
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#notwordsissue)NotWordsIssue
===============================

Not words issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `NotWordsIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'not_words'`
    *   `expected` `` `!${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#nullableschema)NullableSchema
=================================

Nullable schema interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, null>`

[](#definition)Definition
-------------------------

*   `NullableSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferInput](/api/InferInput/)<TWrapped> | null, [InferNullableOutput](/api/InferNullableOutput/)<TWrapped, TDefault>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'nullable'`
    *   `reference` `typeof [nullable](/api/nullable/)`
    *   `expects` `` `(${TWrapped['expects']} | null)` ``
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#nullableschemaasync)NullableSchemaAsync
===========================================

Nullable schema async interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, null>`

[](#definition)Definition
-------------------------

*   `NullableSchemaAsync` `[BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferInput](/api/InferInput/)<TWrapped> | null, [InferNullableOutput](/api/InferNullableOutput/)<TWrapped, TDefault>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'nullable'`
    *   `reference` `typeof [nullable](/api/nullable/) | typeof [nullableAsync](/api/nullableAsync/)`
    *   `expects` `` `(${TWrapped['expects']} | null)` ``
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#nullishschema)NullishSchema
===============================

Nullish schema interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, null | undefined>`

[](#definition)Definition
-------------------------

*   `Nullish` `extends [BaseSchema](/api/BaseSchema/)<[InferInput](/api/InferInput/)<TWrapped> | null | undefined, [InferNullishOutput](/api/InferNullishOutput/)<TWrapped, TDefault>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'nullish'`
    *   `reference` `typeof [nullish](/api/nullish/)`
    *   `expects` `` `(${TWrapped['expects']} | null | undefined)` ``
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#nullishschemaasync)NullishSchemaAsync
=========================================

Nullish schema async interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, null | undefined>`

[](#definition)Definition
-------------------------

*   `Nullish` `[BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferInput](/api/InferInput/)<TWrapped> | null | undefined, [InferNullishOutput](/api/InferNullishOutput/)<TWrapped, TDefault>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'nullish'`
    *   `reference` `typeof [nullishAsync](/api/nullish/)`
    *   `expects` `` `(${TWrapped['expects']} | null | undefined)` ``
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#nullissue)NullIssue
=======================

Null issue interface.

[](#definition)Definition
-------------------------

*   `NullIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'null'`
    *   `expected` `'null'`

[](#nullschema)NullSchema
=========================

Null schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NullIssue](/api/NullIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NullSchema` `extends [BaseSchema](/api/BaseSchema/)<null, null, [NullIssue](/api/NullIssue/)>`
    *   `type` `'null'`
    *   `reference` `typeof [null](/api/null/)`
    *   `expects` `'null'`
    *   `message` `TMessage`

[](#numberissue)NumberIssue
===========================

Number issue interface.

[](#definition)Definition
-------------------------

*   `NumberIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'number'`
    *   `expected` `'number'`

[](#numberschema)NumberSchema
=============================

Number schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[NumberIssue](/api/NumberIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `NumberSchema` `extends [BaseSchema](/api/BaseSchema/)<number, number, [NumberIssue](/api/NumberIssue/)>`
    *   `type` `'number'`
    *   `reference` `typeof [number](/api/number/)`
    *   `expects` `'number'`
    *   `message` `TMessage`

[](#objectentries)ObjectEntries
===============================

Object entries interface.

[](#definition)Definition
-------------------------

*   `ObjectEntries` `{ [key: string]: [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> }`

[](#objectentriesasync)ObjectEntriesAsync
=========================================

Object entries async interface.

[](#definition)Definition
-------------------------

*   `ObjectEntriesAsync` `{ [key: string]: [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> }`

[](#objectissue)ObjectIssue
===========================

Object issue interface.

[](#definition)Definition
-------------------------

*   `ObjectIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'object'`
    *   `expected` `` 'Object' | `"${string}"` ``

[](#objectkeys)ObjectKeys
=========================

Object keys type.

[](#generics)Generics
---------------------

*   `TSchema` `extends [LooseObjectSchema](/api/LooseObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), [ErrorMessage](/api/ErrorMessage/)<[LooseObjectIssue](/api/LooseObjectIssue/)> | undefined> | [LooseObjectSchemaAsync](/api/LooseObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [ErrorMessage](/api/ErrorMessage/)<[LooseObjectIssue](/api/LooseObjectIssue/)> | undefined> | [ObjectSchema](/api/ObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), [ErrorMessage](/api/ErrorMessage/)<[ObjectIssue](/api/ObjectIssue/)> | undefined> | [ObjectSchemaAsync](/api/ObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [ErrorMessage](/api/ErrorMessage/)<[ObjectIssue](/api/ObjectIssue/)> | undefined> | [ObjectWithRestSchema](/api/ObjectWithRestSchema/)<[ObjectEntries](/api/ObjectEntries/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [ObjectWithRestSchemaAsync](/api/ObjectWithRestSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, [ErrorMessage](/api/ErrorMessage/)<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined> | [StrictObjectSchema](/api/StrictObjectSchema/)<[ObjectEntries](/api/ObjectEntries/), [ErrorMessage](/api/ErrorMessage/)<[StrictObjectIssue](/api/StrictObjectIssue/)> | undefined> | [StrictObjectSchemaAsync](/api/StrictObjectSchemaAsync/)<[ObjectEntriesAsync](/api/ObjectEntriesAsync/), [ErrorMessage](/api/ErrorMessage/)<[StrictObjectIssue](/api/StrictObjectIssue/)> | undefined>`

[](#definition)Definition
-------------------------

*   `ObjectKeys` `[MaybeReadonly](/api/MaybeReadonly/)<[keyof TSchema['entries'], ...(keyof TSchema['entries'])[]]>`

[](#objectpathitem)ObjectPathItem
=================================

Object path item interface.

[](#definition)Definition
-------------------------

*   `ObjectPathItem`
    *   `type` `'object'`
    *   `origin` `'key' | 'value'`
    *   `input` `Record<string, unknown>`
    *   `key` `string`
    *   `value` `unknown`

The `input` of a path item may differ from the `input` of its issue. This is because path items are subsequently added by parent schemas and are related to their input. Transformations of child schemas are not taken into account.

[](#objectschema)ObjectSchema
=============================

Object schema interface.

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntries](/api/ObjectEntries/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ObjectIssue](/api/ObjectIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `ObjectSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferObjectInput](/api/InferObjectInput/)<TEntries>, [InferObjectOutput](/api/InferObjectOutput/)<TEntries>, [ObjectIssue](/api/ObjectIssue/) | [InferObjectIssue](/api/InferObjectIssue/)<TEntries>>`
    *   `type` `'object'`
    *   `reference` `typeof [object](/api/object/)`
    *   `expects` `'Object'`
    *   `entries` `TEntries`
    *   `message` `TMessage`

[](#objectschemaasync)ObjectSchemaAsync
=======================================

Object schema async interface.

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntriesAsync](/api/ObjectEntriesAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ObjectIssue](/api/ObjectIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `ObjectSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferObjectInput](/api/InferObjectInput/)<TEntries>, [InferObjectOutput](/api/InferObjectOutput/)<TEntries>, [ObjectIssue](/api/ObjectIssue/) | [InferObjectIssue](/api/InferObjectIssue/)<TEntries>>`
    *   `type` `'object'`
    *   `reference` `typeof [object](/api/object/) | typeof [objectAsync](/api/objectAsync/)`
    *   `expects` `'Object'`
    *   `entries` `TEntries`
    *   `message` `TMessage`

[](#objectwithrestissue)ObjectWithRestIssue
===========================================

Object with rest issue interface.

[](#definition)Definition
-------------------------

*   `ObjectWithRestIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'object_with_rest'`
    *   `expected` `` 'Object' | `"${string}"` ``

[](#objectwithrestschema)ObjectWithRestSchema
=============================================

Object with rest schema interface.

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntries](/api/ObjectEntries/)`
*   `TRest` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `ObjectWithRestSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferObjectInput](/api/InferObjectInput/)<TEntries> & { [key: string]: [InferInput](/api/InferInput/)<TRest> }, [InferObjectOutput](/api/InferObjectOutput/)<TEntries> & { [key: string]: [InferInput](/api/InferInput/)<TRest> }, [ObjectWithRestIssue](/api/ObjectWithRestIssue/) | [InferObjectIssue](/api/InferObjectIssue/)<TEntries>>`
    *   `type` `'object_with_rest'`
    *   `reference` `typeof [objectWithRest](/api/objectWithRest/)`
    *   `expects` `'Object'`
    *   `entries` `TEntries`
    *   `rest` `TRest`
    *   `message` `TMessage`

[](#objectwithrestschemaasync)ObjectWithRestSchemaAsync
=======================================================

Object schema async interface.

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntriesAsync](/api/ObjectEntriesAsync/)`
*   `TRest` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ObjectWithRestIssue](/api/ObjectWithRestIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `ObjectWithRestSchemaAsync` `extends [BaseSchema](/api/BaseSchema/)<[InferObjectInput](/api/InferObjectInput/)<TEntries> & { [key: string]: [InferInput](/api/InferInput/)<TRest> }, [InferObjectOutput](/api/InferObjectOutput/)<TEntries> & { [key: string]: [InferInput](/api/InferInput/)<TRest> }, [ObjectWithRestIssue](/api/ObjectWithRestIssue/) | [InferObjectIssue](/api/InferObjectIssue/)<TEntries>>`
    *   `type` `'object_with_rest'`
    *   `reference` `typeof [objectWithRest](/api/objectWithRest/)`
    *   `expects` `'Object'`
    *   `entries` `TEntries`
    *   `rest` `TRest`
    *   `message` `TMessage`

[](#octalaction)OctalAction
===========================

Octal action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[OctalIssue](/api/OctalIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `OctalAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [OctalIssue](/api/OctalIssue/)<TInput>>`
    *   `type` `'octal'`
    *   `reference` `typeof [octal](/api/octal/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#octalissue)OctalIssue
=========================

Octal issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `OctalIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'octal'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#optionalschema)OptionalSchema
=================================

Optional schema interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, undefined>`

[](#definition)Definition
-------------------------

*   `OptionalSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferInput](/api/InferInput/)<TWrapped> | undefined, [InferOptionalOutput](/api/InferOptionalOutput/)<TWrapped, TDefault>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'optional'`
    *   `reference` `typeof [optional](/api/optional/)`
    *   `expects` `` `(${TWrapped['expects']} | undefined)` ``
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#optionalschemaasync)OptionalSchemaAsync
===========================================

Optional schema async interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, undefined>`

[](#definition)Definition
-------------------------

*   `OptionalSchemaAsync` `[BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferInput](/api/InferInput/)<TWrapped> | undefined, [InferOptionalOutput](/api/InferOptionalOutput/)<TWrapped, TDefault>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'optional'`
    *   `reference` `typeof [optional](/api/optional/) | typeof [optionalAsync](/api/optionalAsync/)`
    *   `expects` `` `(${TWrapped['expects']} | undefined)` ``
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#outputdataset)OutputDataset
===============================

Output dataset interface.

[](#generics)Generics
---------------------

*   `TValue` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `OutputDataset` `[SuccessDataset](/api/SuccessDataset/)<TValue> | [PartialDataset](/api/PartialDataset/)<TValue, TIssue> | [FailureDataset](/api/FailureDataset/)<TIssue>`

[](#parsejsonaction)ParseJsonAction
===================================

JSON parse action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TConfig` `extends [ParseJsonConfig](/api/ParseJsonConfig/) | undefined`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ParseJsonIssue](/api/ParseJsonIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `ParseJsonAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, unknown, [ParseJsonIssue](/api/ParseJsonIssue/)<TInput>>`
    *   `type` `'parse_json'`
    *   `reference` `typeof [parseJson](/api/parseJson/)`
    *   `config` `TConfig`
    *   `message` `TMessage`

[](#parsejsonconfig)ParseJsonConfig
===================================

JSON parse config interface.

[](#definition)Definition
-------------------------

*   `ParseJsonConfig`
    *   `reviver` `((this: any, key: string, value: any) => any) | undefined`

[](#parsejsonissue)ParseJsonIssue
=================================

JSON parse issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `ParseJsonIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'transformation'`
    *   `type` `'parse_json'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``

[](#parser)Parser
=================

The parser interface.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TConfig` `extends [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#definition)Definition
-------------------------

*   `Parser`
    *   `(input: unknown) => [InferOutput](/api/InferOutput/)<TSchema>`
    *   `schema` `TSchema`
    *   `config` `TConfig`

[](#parserasync)ParserAsync
===========================

The parser async interface.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TConfig` `extends [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#definition)Definition
-------------------------

*   `ParserAsync`
    *   `(input: unknown) => Promise<[InferOutput](/api/InferOutput/)<TSchema>>`
    *   `schema` `TSchema`
    *   `config` `TConfig`

[](#partialcheckaction)PartialCheckAction
=========================================

Partial check action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [PartialInput](/api/PartialInput/)`
*   `TPaths` `extends [Paths](/api/Paths/)`
*   `TSelection` `extends [DeepPickN](/api/DeepPickN/)<TInput, TPaths>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[PartialCheckIssue](/api/PartialCheckIssue/)<TSelection>> | undefined`

[](#definition)Definition
-------------------------

*   `PartialCheckAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [PartialCheckIssue](/api/PartialCheckIssue/)<TSelection>>`
    *   `type` `'partial_check'`
    *   `reference` `typeof [partialCheck](/api/partialCheck/)`
    *   `expects` `null`
    *   `paths` `TPaths`
    *   `requirement` `(input: TSelection) => boolean`
    *   `message` `TMessage`

[](#partialcheckactionasync)PartialCheckActionAsync
===================================================

Partial check action async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [PartialInput](/api/PartialInput/)`
*   `TPaths` `extends [Paths](/api/Paths/)`
*   `TSelection` `extends [DeepPickN](/api/DeepPickN/)<TInput, TPaths>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[PartialCheckIssue](/api/PartialCheckIssue/)<TSelection>> | undefined`

[](#definition)Definition
-------------------------

*   `PartialCheckActionAsync` `extends [BaseValidationAsync](/api/BaseValidationAsync/)<TInput, TInput, [PartialCheckIssue](/api/PartialCheckIssue/)<TSelection>>`
    *   `type` `'partial_check'`
    *   `reference` `typeof [partialCheckAsync](/api/partialCheckAsync/)`
    *   `expects` `null`
    *   `paths` `TPaths`
    *   `requirement` `(input: TSelection) => [MaybePromise](/api/MaybePromise/)<boolean>`
    *   `message` `TMessage`

[](#partialcheckissue)PartialCheckIssue
=======================================

Partial check issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [PartialInput](/api/PartialInput/)`

[](#definition)Definition
-------------------------

*   `PartialCheckIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'partial_check'`
    *   `expected` `null`
    *   `requirement` `(input: TInput) => MaybePromise<boolean>`

[](#partialdataset)PartialDataset
=================================

Partial dataset interface.

[](#generics)Generics
---------------------

*   `TValue` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `UntypedDataset`
    *   `typed` `true`
    *   `value` `TValue`
    *   `issues` `[TIssue, ...TIssue[]]`

[](#partialinput)PartialInput
=============================

Partial input type.

[](#definition)Definition
-------------------------

*   `PartialInput` `Record<string, unknown> | ArrayLike<unknown>`

[](#picklistoptions)PicklistOptions
===================================

Picklist options type.

[](#definition)Definition
-------------------------

*   `PicklistOptions` `[MaybeReadonly](/api/MaybeReadonly/)<(string | number | bigint)[]>`

[](#picklistissue)PicklistIssue
===============================

Picklist issue interface.

[](#definition)Definition
-------------------------

*   `PicklistIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'picklist'`
    *   `expected` `string`

[](#picklistschema)PicklistSchema
=================================

Picklist schema interface.

[](#generics)Generics
---------------------

*   `TOptions` `extends [PicklistOptions](/api/PicklistOptions/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[PicklistIssue](/api/PicklistIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `PicklistSchema` `extends [BaseSchema](/api/BaseSchema/)<TOptions[number], TOptions[number], [PicklistIssue](/api/PicklistIssue/)>`
    *   `type` `'picklist'`
    *   `reference` `typeof [picklist](/api/picklist/)`
    *   `options` `TOptions`
    *   `message` `TMessage`

[](#pipeaction)PipeAction
=========================

Pipe action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `PipeAction` `[BaseValidation](/api/BaseValidation/)<TInput, TOutput, TIssue> | [BaseTransformation](/api/BaseTransformation/)<TInput, TOutput, TIssue> | [BaseMetadata](/api/BaseMetadata/)<TInput>`

[](#pipeactionasync)PipeActionAsync
===================================

Pipe action async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `PipeActionAsync` `[BaseValidationAsync](/api/BaseValidationAsync/)<TInput, TOutput, TIssue> | [BaseTransformationAsync](/api/BaseTransformationAsync/)<TInput, TOutput, TIssue>`

[](#pipeitem)PipeItem
=====================

Pipe item type.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `PipeItem` `[BaseSchema](/api/BaseSchema/)<TInput, TOutput, TIssue> | [PipeAction](/api/PipeAction/)<TInput, TOutput, TIssue>`

[](#pipeitemasync)PipeItemAsync
===============================

Pipe item async type.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`
*   `TIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `PipeItemAsync` `[BaseSchemaAsync](/api/BaseSchemaAsync/)<TInput, TOutput, TIssue> | [PipeActionAsync](/api/PipeActionAsync/)<TInput, TOutput, TIssue>`

[](#promiseissue)PromiseIssue
=============================

Promise issue interface.

[](#definition)Definition
-------------------------

*   `PromiseIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'promise'`
    *   `expected` `'Promise'`

[](#promiseschema)PromiseSchema
===============================

Promise schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[PromiseIssue](/api/PromiseIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `PromiseSchema` `extends [BaseSchema](/api/BaseSchema/)<Promise<unknown>, Promise<unknown>, [PromiseIssue](/api/PromiseIssue/)>`
    *   `type` `'promise'`
    *   `reference` `typeof [promise](/api/promise/)`
    *   `expects` `'Promise'`
    *   `message` `TMessage`

[](#rawcheckaction)RawCheckAction
=================================

Raw check action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#definition)Definition
-------------------------

*   `RawCheckAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [RawCheckIssue](/api/RawCheckIssue/)<TInput>>`
    *   `type` `'raw_check'`
    *   `reference` `typeof [rawCheck](/api/rawCheck/)`

[](#rawcheckactionasync)RawCheckActionAsync
===========================================

Raw check action async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#definition)Definition
-------------------------

*   `RawCheckActionAsync` `extends [BaseValidationAsync](/api/BaseValidationAsync/)<TInput, TInput, [RawCheckIssue](/api/RawCheckIssue/)<TInput>>`
    *   `type` `'raw_check'`
    *   `reference` `typeof [rawCheckAsync](/api/rawCheckAsync/)`
    *   `expects` `null`

[](#rawcheckissue)RawCheckIssue
===============================

Raw check issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#definition)Definition
-------------------------

*   `RawCheckIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'raw_check'`

[](#rawtransformaction)RawTransformAction
=========================================

Raw transform action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `RawTransformAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TOutput, [RawTransformIssue](/api/RawTransformIssue/)<TInput>>`
    *   `type` `'raw_transform'`
    *   `reference` `typeof [rawTransform](/api/rawTransform/)`

[](#rawtransformactionasync)RawTransformActionAsync
===================================================

Raw transform action async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `RawTransformActionAsync` `extends [BaseTransformationAsync](/api/BaseTransformationAsync/)<TInput, TOutput, [RawTransformIssue](/api/RawTransformIssue/)<TInput>>`
    *   `type` `'raw_transform'`
    *   `reference` `typeof [rawTransformAsync](/api/rawTransformAsync/)`

[](#rawtransformissue)RawTransformIssue
=======================================

Raw transform issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#definition)Definition
-------------------------

*   `RawTransformIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'raw_transform'`

[](#readonlyaction)ReadonlyAction
=================================

Readonly action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#definition)Definition
-------------------------

*   `ReadonlyAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, Readonly<TInput>, never>`
    *   `type` `'readonly'`
    *   `reference` `typeof [readonly](/api/readonly/)`

[](#recordissue)RecordIssue
===========================

Record issue interface.

[](#definition)Definition
-------------------------

*   `RecordIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'record'`
    *   `expected` `'Object'`

[](#recordschema)RecordSchema
=============================

Record schema interface.

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<string, string | number | symbol, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[RecordIssue](/api/RecordIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `RecordSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferRecordInput](/api/InferRecordInput/)<TKey, TValue>, [InferRecordOutput](/api/InferRecordOutput/)<TKey, TValue>, [RecordIssue](/api/RecordIssue/) | [InferIssue](/api/InferIssue/)<TKey> | [InferIssue](/api/InferIssue/)<TValue>>`
    *   `type` `'record'`
    *   `reference` `typeof [record](/api/record/)`
    *   `expects` `'Object'`
    *   `key` `TKey`
    *   `value` `TValue`
    *   `message` `TMessage`

[](#recordschemaasync)RecordSchemaAsync
=======================================

Record schema async interface.

[](#generics)Generics
---------------------

*   `TKey` `extends [BaseSchema](/api/BaseSchema/)<string, string | number | symbol, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<string, string | number | symbol, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[RecordIssue](/api/RecordIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `RecordSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferRecordInput](/api/InferRecordInput/)<TKey, TValue>, [InferRecordOutput](/api/InferRecordOutput/)<TKey, TValue>, [RecordIssue](/api/RecordIssue/) | [InferIssue](/api/InferIssue/)<TKey> | [InferIssue](/api/InferIssue/)<TValue>>`
    *   `type` `'record'`
    *   `reference` `typeof [record](/api/record/) | typeof [recordAsync](/api/recordAsync/)`
    *   `expects` `'Object'`
    *   `key` `TKey`
    *   `value` `TValue`
    *   `message` `TMessage`

[](#reduceitemsaction)ReduceItemsAction
=======================================

Reduce items action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`
*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `ReduceItemsAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TOuput, never>`
    *   `type` `'reduce_items'`
    *   `reference` `typeof [reduceItems](/api/reduceItems/)`
    *   `operation` `(output: TOutput, item: TInput[number], index: number, array: TInput) => TOutput`
    *   `initial` `TOutput`

[](#regexaction)RegexAction
===========================

Regex action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[RegexIssue](/api/RegexIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `RegexAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [RegexIssue](/api/RegexIssue/)<TInput>>`
    *   `type` `'regex'`
    *   `reference` `typeof [regex](/api/regex/)`
    *   `expects` `string`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#regexissue)RegexIssue
=========================

Regex issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `RegexIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'regex'`
    *   `expected` `string`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#returnsaction)ReturnsAction
===============================

Returns action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends (...args: any[]) => unknown`
*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `ReturnsAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, (...args: Parameters<TInput>) => [InferOutput](/api/InferOutput/)<TSchema>, never>`
    *   `type` `'returns'`
    *   `reference` `typeof [returns](/api/returns/)`
    *   `schema` `TSchema`

[](#returnsactionasync)ReturnsActionAsync
=========================================

Returns action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends (...args: any[]) => unknown`
*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `ReturnsActionAsync` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, (...args: Parameters<TInput>) => Promise<Awaited<[InferOutput](/api/InferOutput/)<TSchema>>>, never>`
    *   `type` `'returns'`
    *   `reference` `typeof [returnsAsync](/api/returnsAsync/)`
    *   `schema` `TSchema`

[](#rfcemailaction)RfcEmailAction
=================================

RFC email action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[RfcEmailIssue](/api/RfcEmailIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `EmailAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [RfcEmailIssue](/api/RfcEmailIssue/)<TInput>>`
    *   `type` `'rfc_email'`
    *   `reference` `typeof [rfcEmail](/api/rfcEmail/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#rfcemailissue)RfcEmailIssue
===============================

RFC email issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `EmailIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'rfc_email'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#safeintegeraction)SafeIntegerAction
=======================================

Safe integer action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SafeIntegerIssue](/api/SafeIntegerIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `SafeIntegerAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [SafeIntegerIssue](/api/SafeIntegerIssue/)<TInput>>`
    *   `type` `'safe_integer'`
    *   `reference` `typeof [safeInteger](/api/safeInteger/)`
    *   `expects` `null`
    *   `requirement` `(input: number) => boolean`
    *   `message` `TMessage`

[](#safeintegerissue)SafeIntegerIssue
=====================================

Safe integer issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends number`

[](#definition)Definition
-------------------------

*   `SafeIntegerIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'safe_integer'`
    *   `expected` `null`
    *   `received` `` `${number}` ``
    *   `requirement` `(input: number) => boolean`

[](#safeparser)SafeParser
=========================

The safe parser interface.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TConfig` `extends [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#definition)Definition
-------------------------

*   `SafeParser`
    *   `(input: unknown) => [SafeParseResult](/api/SafeParseResult/)<TSchema>`
    *   `schema` `TSchema`
    *   `config` `TConfig`

[](#safeparserasync)SafeParserAsync
===================================

The safe parser async interface.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TConfig` `extends [Config](/api/Config/)<[InferIssue](/api/InferIssue/)<TSchema>> | undefined`

[](#definition)Definition
-------------------------

*   `SafeParserAsync`
    *   `(input: unknown) => Promise<[SafeParseResult](/api/SafeParseResult/)<TSchema>>`
    *   `schema` `TSchema`
    *   `config` `TConfig`

[](#safeparseresult)SafeParseResult
===================================

Safe parse result type.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `SafeParseResult`
    *   `typed` `boolean`
    *   `success` `boolean`
    *   `output` `[InferOutput](/api/InferOutput/)<TSchema> | unknown`
    *   `issues` `[[InferIssue](/api/InferIssue/)<TSchema>, ...[InferIssue](/api/InferIssue/)<TSchema>[]] | undefined`

[](#schemawithfallback)SchemaWithFallback
=========================================

Schema with fallback type.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TFallback` `extends [Fallback](/api/Fallback/)<TSchema>`

[](#definition)Definition
-------------------------

*   `SchemaWithFallback` `extends TSchema`
    *   `fallback` `TFallback`

[](#schemawithfallbackasync)SchemaWithFallbackAsync
===================================================

Schema with fallback async type.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TFallback` `extends [FallbackAsync](/api/FallbackAsync/)<TSchema>`

[](#definition)Definition
-------------------------

*   `SchemaWithFallbackAsync` `extends Omit<TSchema, 'async' | '~run'>`
    *   `fallback` `TFallback`
    *   `async` `true`
    *   `~run` `(dataset: [UnknownDataset](/api/UnknownDataset/), config: [Config](/api/Config/)<[BaseIssue](/api/BaseIssue/)<unknown>>) => Promise<[OutputDataset](/api/OutputDataset/)<[InferOutput](/api/InferOutput/)<TSchema>, [InferIssue](/api/InferIssue/)<TSchema>>>`

[](#schemawithoutpipe)SchemaWithoutPipe
=======================================

Schema without pipe type.

[](#generics)Generics
---------------------

*   `TSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`

[](#definition)Definition
-------------------------

*   `SchemaWithoutPipe` `TSchema & { pipe?: never }`

[](#schemawithpartial)SchemaWithPartial
=======================================

Schema with partial type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/partial/partial.ts).

[](#schemawithpartialasync)SchemaWithPartialAsync
=================================================

Schema with partial async type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/partial/partialAsync.ts).

[](#schemawithpipe)SchemaWithPipe
=================================

Schema with pipe type.

[](#generics)Generics
---------------------

*   `TPipe` `extends readonly [[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ...[PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>[]]`

[](#definition)Definition
-------------------------

*   `SchemaWithPipe` `extends Omit<[FirstTupleItem](/api/FirstTupleItem/)<TPipe>, '~types' | '~run'>`
    *   `pipe` `TPipe`
    *   `~types` `{ input: [InferInput](/api/InferInput/)<[FirstTupleItem](/api/FirstTupleItem/)<TPipe>>, output: [InferOutput](/api/InferOutput/)<[LastTupleItem](/api/LastTupleItem/)<TPipe>>, issue: [InferIssue](/api/InferIssue/)<TPipe[number]> } | undefined`
    *   `~run` `(dataset: [UnknownDataset](/api/UnknownDataset/), config: [Config](/api/Config/)<[BaseIssue](/api/BaseIssue/)<unknown>>) => [OutputDataset](/api/OutputDataset/)<[InferOutput](/api/InferOutput/)<[LastTupleItem](/api/LastTupleItem/)<TPipe>>, [InferIssue](/api/InferIssue/)<TPipe[number]>>`

[](#schemawithpipeasync)SchemaWithPipeAsync
===========================================

Schema with pipe async type.

[](#generics)Generics
---------------------

*   `TPipe` `extends readonly [[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>, ...([PipeItem](/api/PipeItem/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [PipeItemAsync](/api/PipeItemAsync/)<any, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>)[]]`

[](#definition)Definition
-------------------------

*   `SchemaWithPipeAsync` `extends Omit<[FirstTupleItem](/api/FirstTupleItem/)<TPipe>, 'async' | '~types' | '~run'>`
    *   `pipe` `TPipe`
    *   `async` `true`
    *   `~types` `{ input: [InferInput](/api/InferInput/)<[FirstTupleItem](/api/FirstTupleItem/)<TPipe>>, output: [InferOutput](/api/InferOutput/)<[LastTupleItem](/api/LastTupleItem/)<TPipe>>, issue: [InferIssue](/api/InferIssue/)<TPipe[number]> } | undefined`
    *   `~run` `(dataset: [UnknownDataset](/api/UnknownDataset/), config: [Config](/api/Config/)<[BaseIssue](/api/BaseIssue/)<unknown>>) => Promise<[OutputDataset](/api/OutputDataset/)<[InferOutput](/api/InferOutput/)<[LastTupleItem](/api/LastTupleItem/)<TPipe>>, [InferIssue](/api/InferIssue/)<TPipe[number]>>>`

[](#schemawithrequired)SchemaWithRequired
=========================================

Schema with required type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/required/required.ts).

[](#schemawithrequiredasync)SchemaWithRequiredAsync
===================================================

Schema with required async type.

> This type is too complex to display. Please refer to the [source code](https://github.com/fabian-hiller/valibot/blob/main/library/src/methods/required/requiredAsync.ts).

[](#setpathitem)SetPathItem
===========================

Set path item interface.

[](#definition)Definition
-------------------------

*   `SetPathItem` `object`
    *   `type` `'set'`
    *   `origin` `'value'`
    *   `input` `Set<unknown>`
    *   `value` `unknown`

The `input` of a path item may differ from the `input` of its issue. This is because path items are subsequently added by parent schemas and are related to their input. Transformations of child schemas are not taken into account.

[](#recordissue)RecordIssue
===========================

Record issue interface.

[](#definition)Definition
-------------------------

*   `RecordIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'set'`
    *   `expected` `'Set'`

[](#setschema)SetSchema
=======================

Set schema interface.

[](#generics)Generics
---------------------

*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `[ErrorMessage](/api/ErrorMessage/)<[SetIssue](/api/SetIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `SetSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferSetInput](/api/InferSetInput/)<TValue>, [InferSetOutput](/api/InferSetOutput/)<TValue>, [SetIssue](/api/SetIssue/) | [InferIssue](/api/InferIssue/)<TValue>>`
    *   `type` `'set'`
    *   `reference` `typeof [set](/api/set/)`
    *   `expects` `'Set'`
    *   `value` `TValue`
    *   `message` `TMessage`

[](#setschemaasync)SetSchemaAsync
=================================

Set schema async interface.

[](#generics)Generics
---------------------

*   `TValue` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `[ErrorMessage](/api/ErrorMessage/)<[SetIssue](/api/SetIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `SetSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferSetInput](/api/InferSetInput/)<TValue>, [InferSetOutput](/api/InferSetOutput/)<TValue>, [SetIssue](/api/SetIssue/) | [InferIssue](/api/InferIssue/)<TValue>>`
    *   `type` `'set'`
    *   `reference` `typeof [set](/api/set/) | typeof [setAsync](/api/setAsync/)`
    *   `expects` `'Set'`
    *   `value` `TValue`
    *   `message` `TMessage`

[](#sizeaction)SizeAction
=========================

Size action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SizeIssue](/api/SizeIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `SizeAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [SizeIssue](/api/SizeIssue/)<TInput, TRequirement>>`
    *   `type` `'size'`
    *   `reference` `typeof [size](/api/size/)`
    *   `expects` `` `${TRequirement}` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#sizeinput)SizeInput
=======================

Size input type.

[](#definition)Definition
-------------------------

*   `SizeInput` `Blob | Map<unknown, unknown> | Set<unknown>`

[](#sizeissue)SizeIssue
=======================

Size issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [SizeInput](/api/SizeInput/)`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `SizeIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'size'`
    *   `expected` `` `${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`

[](#slugaction)SlugAction
=========================

Slug action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SlugIssue](/api/SlugIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `SlugAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [SlugIssue](/api/SlugIssue/)<TInput>>`
    *   `type` `'slug'`
    *   `reference` `typeof [slug](/api/slug/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#slugissue)SlugIssue
=======================

Slug issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `SlugIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'slug'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#someitemaction)SomeItemAction
=================================

Some action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends readonly unknown[]`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[SomeItemIssue](/api/SomeItemIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `SomeItemAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [SomeItemIssue](/api/SomeItemIssue/)<TInput>>`
    *   `type` `'some_item'`
    *   `reference` `typeof [someItem](/api/someItem/)`
    *   `expects` `null`
    *   `requirement` `(item: TInput[number], index: number, array: TInput) => boolean`
    *   `message` `TMessage`

[](#someitemissue)SomeItemIssue
===============================

Some item issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#definition)Definition
-------------------------

*   `SomeItemIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'some_item'`
    *   `expected` `null`
    *   `requirement` `[ArrayRequirement](/api/ArrayRequirement/)<TInput>`

[](#sortitemsaction)SortItemsAction
===================================

Sort items action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ArrayInput](/api/ArrayInput/)`

[](#definition)Definition
-------------------------

*   `SortItemsAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TInput, never>`
    *   `type` `'sort_items'`
    *   `reference` `typeof [sortItems](/api/sortItems/)`
    *   `operation` `((itemA: TInput[number], itemB: TInput[number]) => number) | undefined`

[](#standardfailureresult)StandardFailureResult
===============================================

The result interface if validation fails.

[](#definition)Definition
-------------------------

*   `StandardFailureResult`
    *   `issues` `readonly [StandardIssue](/api/StandardIssue/)[]`

[](#standardissue)StandardIssue
===============================

The issue interface of the failure output.

[](#definition)Definition
-------------------------

*   `StandardIssue`
    *   `message` `string`
    *   `path` `readonly (PropertyKey | [StandardPathItem](/api/StandardPathItem/))[] | undefined`

[](#standardpathitem)StandardPathItem
=====================================

The path item interface of the issue.

[](#definition)Definition
-------------------------

*   `StandardPathItem`
    *   `key` `PropertyKey`

[](#standardprops)StandardProps
===============================

The Standard Schema properties interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `StandardProps`
    *   `version` `1`
    *   `vendor` `'valibot'`
    *   `validate` `((value: unknown) => [StandardResult](/api/StandardResult/)<TOutput> | Promise<[StandardResult](/api/StandardResult/)<TOutput>>)`
    *   `types` `[StandardTypes](/api/StandardTypes/)<TInput, TOutput>`

[](#standardresult)StandardResult
=================================

The result interface of the validate function.

[](#generics)Generics
---------------------

*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `StandardResult` `[StandardSuccessResult](/api/StandardSuccessResult/)<TOutput> | [StandardFailureResult](/api/StandardFailureResult/)`

[](#standardsuccessresult)StandardSuccessResult
===============================================

The result interface if validation succeeds.

[](#generics)Generics
---------------------

*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `StandardSuccessResult`
    *   `value` `TOutput`
    *   `issues` `undefined`

[](#standardtypes)StandardTypes
===============================

The Standard Schema types interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `StandardTypes`
    *   `input` `TInput`
    *   `output` `TOutput`

[](#startswithaction)StartsWithAction
=====================================

Starts with action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StartsWithIssue](/api/StartsWithIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `StartsWithAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [StartsWithIssue](/api/StartsWithIssue/)<TInput, TRequirement>>`
    *   `type` `'starts_with'`
    *   `reference` `typeof [startsWith](/api/startsWith/)`
    *   `expects` `` `"${TRequirement}"` ``
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#startswithissue)StartsWithIssue
===================================

Starts with issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends string`

[](#definition)Definition
-------------------------

*   `StartsWithIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'starts_with'`
    *   `expected` `` `"${TRequirement}"` ``
    *   `received` `` `"${string}"` ``
    *   `requirement` `TRequirement`

[](#strictobjectissue)StrictObjectIssue
=======================================

Strict object issue interface.

[](#definition)Definition
-------------------------

*   `StrictObjectIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'strict_object'`
    *   `expected` ``'Object' | `"${string}"` | 'never'``

[](#strictobjectschema)StrictObjectSchema
=========================================

Strict object schema interface.

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntries](/api/ObjectEntries/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StrictObjectIssue](/api/StrictObjectIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `StrictObjectSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferObjectInput](/api/InferObjectInput/)<TEntries>, [InferObjectOutput](/api/InferObjectOutput/)<TEntries>, [StrictObjectIssue](/api/StrictObjectIssue/) | [InferObjectIssue](/api/InferObjectIssue/)<TEntries>>`
    *   `type` `'strict_object'`
    *   `reference` `typeof [strictObject](/api/strictObject/)`
    *   `expects` `'Object'`
    *   `entries` `TEntries`
    *   `message` `TMessage`

[](#strictobjectschemaasync)StrictObjectSchemaAsync
===================================================

Strict object schema async interface.

[](#generics)Generics
---------------------

*   `TEntries` `extends [ObjectEntriesAsync](/api/ObjectEntriesAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StrictObjectIssue](/api/StrictObjectIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `StrictObjectSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferObjectInput](/api/InferObjectInput/)<TEntries>, [InferObjectOutput](/api/InferObjectOutput/)<TEntries>, [StrictObjectIssue](/api/StrictObjectIssue/) | [InferObjectIssue](/api/InferObjectIssue/)<TEntries>>`
    *   `type` `'strict_object'`
    *   `reference` `typeof [strictObject](/api/strictObject/) | typeof [strictObjectAsync](/api/strictObjectAsync/)`
    *   `expects` `'Object'`
    *   `entries` `TEntries`
    *   `message` `TMessage`

[](#stricttupleissue)StrictTupleIssue
=====================================

Strict tuple issue interface.

[](#definition)Definition
-------------------------

*   `StrictTupleIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'strict_tuple'`
    *   `expected` `'Array'`

[](#stricttupleschema)StrictTupleSchema
=======================================

Strict tuple schema interface.

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItems](/api/TupleItems/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `StrictTupleSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferTupleInput](/api/InferTupleInput/)<TItems>, [InferTupleOutput](/api/InferTupleOutput/)<TItems>, [StrictTupleIssue](/api/StrictTupleIssue/) | [InferTupleIssue](/api/InferTupleIssue/)<TItems>>`
    *   `type` `'strict_tuple'`
    *   `reference` `typeof [strictTuple](/api/strictTuple/)`
    *   `expects` `'Array'`
    *   `items` `TItems`
    *   `message` `TMessage`

[](#stricttupleschemaasync)StrictTupleSchemaAsync
=================================================

Strict tuple schema async interface.

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItemsAsync](/api/TupleItemsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StrictTupleIssue](/api/StrictTupleIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `StrictTupleSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferTupleInput](/api/InferTupleInput/)<TItems>, [InferTupleOutput](/api/InferTupleOutput/)<TItems>, [StrictTupleIssue](/api/StrictTupleIssue/) | [InferTupleIssue](/api/InferTupleIssue/)<TItems>>`
    *   `type` `'strict_tuple'`
    *   `reference` `typeof [strictTuple](/api/strictTuple/) | typeof [strictTupleAsync](/api/strictTupleAsync/)`
    *   `expects` `'Array'`
    *   `items` `TItems`
    *   `message` `TMessage`

[](#recordissue)RecordIssue
===========================

Record issue interface.

[](#definition)Definition
-------------------------

*   `RecordIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'string'`
    *   `expected` `'string'`

[](#stringschema)StringSchema
=============================

String schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/) | undefined`

[](#definition)Definition
-------------------------

*   `StringSchema` `extends [BaseSchema](/api/BaseSchema/)<string, string, [StringIssue](/api/StringIssue/)>`
    *   `type` `'string'`
    *   `reference` `typeof [string](/api/string/)`
    *   `expects` `'string'`
    *   `message` `TMessage`

[](#stringifyjsonaction)StringifyJsonAction
===========================================

JSON stringify action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TConfig` `extends [StringifyJsonConfig](/api/StringifyJsonConfig/) | undefined`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[StringifyJsonIssue](/api/StringifyJsonIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `StringifyJsonAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, string, [StringifyJsonIssue](/api/StringifyJsonIssue/)<TInput>>`
    *   `type` `'stringify_json'`
    *   `reference` `typeof [stringifyJson](/api/stringifyJson/)`
    *   `config` `TConfig`
    *   `message` `TMessage`

[](#stringifyjsonconfig)StringifyJsonConfig
===========================================

JSON stringify config interface.

[](#definition)Definition
-------------------------

*   `StringifyJsonConfig`
    *   `replacer` `((this: any, key: string, value: any) => any) | (string | number)[] | undefined`
    *   `space` `string | number | undefined`

[](#stringifyjsonissue)StringifyJsonIssue
=========================================

JSON stringify issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`

[](#definition)Definition
-------------------------

*   `StringifyJsonIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'transformation'`
    *   `type` `'stringify_json'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``

[](#successdataset)SuccessDataset
=================================

Success dataset interface.

[](#generics)Generics
---------------------

*   `TValue` `extends any`

[](#definition)Definition
-------------------------

*   `TypedDataset`
    *   `typed` `true`
    *   `value` `TValue`
    *   `issues` `undefined`

[](#symbolissue)SymbolIssue
===========================

Symbol issue interface.

[](#definition)Definition
-------------------------

*   `SymbolIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'symbol'`
    *   `expected` `'symbol'`

[](#symbolschema)SymbolSchema
=============================

Symbol schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/) | undefined`

[](#definition)Definition
-------------------------

*   `SymbolSchema` `extends [BaseSchema](/api/BaseSchema/)<symbol, symbol, [SymbolIssue](/api/SymbolIssue/)>`
    *   `type` `'symbol'`
    *   `reference` `typeof [symbol](/api/symbol/)`
    *   `expects` `'symbol'`
    *   `message` `TMessage`

[](#titleaction)TitleAction
===========================

Title action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TTitle` `extends string`

[](#definition)Definition
-------------------------

*   `TitleAction` `extends [BaseMetadata](/api/BaseMetadata/)<TInput>`
    *   `type` `'title'`
    *   `reference` `typeof [title](/api/title/)`
    *   `title` `TTitle`

[](#tolowercaseaction)ToLowerCaseAction
=======================================

To lower case action interface.

[](#definition)Definition
-------------------------

*   `ToLowerCaseAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TInput, never>`
    *   `type` `'to_lower_case'`
    *   `reference` `typeof [toLowerCase](/api/toLowerCase/)`

[](#tominvalueaction)ToMinValueAction
=====================================

To min value action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#definition)Definition
-------------------------

*   `ToMinValueAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TInput, never>`
    *   `type` `'to_min_value'`
    *   `reference` `typeof [toMinValue](/api/toMinValue/)`
    *   `requirement` `TRequirement`

[](#tomaxvalueaction)ToMaxValueAction
=====================================

To max value action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#definition)Definition
-------------------------

*   `ToMaxValueAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TInput, never>`
    *   `type` `'to_max_value'`
    *   `reference` `typeof [toMaxValue](/api/toMaxValue/)`
    *   `requirement` `TRequirement`

[](#touppercaseaction)ToUpperCaseAction
=======================================

To upper case action interface.

[](#definition)Definition
-------------------------

*   `ToUpperCaseAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TInput, never>`
    *   `type` `'to_upper_case'`
    *   `reference` `typeof [toUpperCase](/api/toUpperCase/)`

[](#transformaction)TransformAction
===================================

Transform action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `TransformAction` `extends [BaseTransformation](/api/BaseTransformation/)<TInput, TOutput, never>`
    *   `type` `'transform'`
    *   `reference` `typeof [transform](/api/transform/)`
    *   `operation` `(input: TInput) => TOutput`

[](#transformactionasync)TransformActionAsync
=============================================

Transform action async interface.

[](#generics)Generics
---------------------

*   `TInput` `extends any`
*   `TOutput` `extends any`

[](#definition)Definition
-------------------------

*   `TransformActionAsync` `extends [BaseTransformationAsync](/api/BaseTransformationAsync/)<TInput, TOutput, never>`
    *   `type` `'transform'`
    *   `reference` `typeof [transform](/api/transform/) | typeof [transformAsync](/api/transformAsync/)`
    *   `operation` `(input: TInput) => Promise<TOutput>`

[](#trimaction)TrimAction
=========================

Trim action interface.

[](#definition)Definition
-------------------------

*   `TrimAction` `extends [BaseTransformation](/api/BaseTransformation/)<string, string, never>`
    *   `type` `'trim'`
    *   `reference` `typeof [trim](/api/trim/)`

[](#trimendaction)TrimEndAction
===============================

Trim end action interface.

[](#definition)Definition
-------------------------

*   `TrimEndAction` `extends [BaseTransformation](/api/BaseTransformation/)<string, string, never>`
    *   `type` `'trim_end'`
    *   `reference` `typeof [trimEnd](/api/trimEnd/)`

[](#trimstartaction)TrimStartAction
===================================

Trim start action interface.

[](#definition)Definition
-------------------------

*   `TrimStartAction` `extends [BaseTransformation](/api/BaseTransformation/)<string, string, never>`
    *   `type` `'trim_start'`
    *   `reference` `typeof [trimStart](/api/trimStart/)`

[](#tupleissue)TupleIssue
=========================

Tuple issue interface.

[](#definition)Definition
-------------------------

*   `TupleIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'tuple'`
    *   `expected` `'Array'`

[](#tupleitems)TupleItems
=========================

Tuple items type.

[](#definition)Definition
-------------------------

*   `TupleItems` `[MaybeReadonly](/api/MaybeReadonly/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>[]>`

[](#tupleitemsasync)TupleItemsAsync
===================================

Tuple items async type.

[](#definition)Definition
-------------------------

*   `TupleItemsAsync` `[MaybeReadonly](/api/MaybeReadonly/)<([BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>)[]>`

[](#tupleschema)TupleSchema
===========================

Tuple schema interface.

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItems](/api/TupleItems/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `TupleSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferTupleInput](/api/InferTupleInput/)<TItems>, [InferTupleOutput](/api/InferTupleOutput/)<TItems>, [TupleIssue](/api/TupleIssue/) | [InferTupleIssue](/api/InferTupleIssue/)<TItems>>`
    *   `type` `'tuple'`
    *   `reference` `typeof [tuple](/api/tuple/)`
    *   `expects` `'Array'`
    *   `items` `TItems`
    *   `message` `TMessage`

[](#tupleschemaasync)TupleSchemaAsync
=====================================

Tuple schema async interface.

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItemsAsync](/api/TupleItemsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[TupleIssue](/api/TupleIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `TupleSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferTupleInput](/api/InferTupleInput/)<TItems>, [InferTupleOutput](/api/InferTupleOutput/)<TItems>, [TupleIssue](/api/TupleIssue/) | [InferTupleIssue](/api/InferTupleIssue/)<TItems>>`
    *   `type` `'tuple'`
    *   `reference` `typeof [tuple](/api/tuple/) | typeof [tupleAsync](/api/tupleAsync/)`
    *   `expects` `'Array'`
    *   `items` `TItems`
    *   `message` `TMessage`

[](#tuplewithrestissue)TupleWithRestIssue
=========================================

Tuple with rest issue interface.

[](#definition)Definition
-------------------------

*   `TupleWithRestIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'tuple_with_rest'`
    *   `expected` `'Array'`

[](#tuplewithrestschema)TupleWithRestSchema
===========================================

Tuple with rest schema interface.

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItems](/api/TupleItems/)`
*   `TRest` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `TupleWithRestSchema` `extends [BaseSchema](/api/BaseSchema/)<[...[InferTupleInput](/api/InferTupleInput/)<TItems>, ...[InferInput](/api/InferInput/)<TRest>[]], [...[InferTupleOutput](/api/InferTupleOutput/)<TItems>, ...[InferOutput](/api/InferOutput/)<TRest>[]], [TupleWithRestIssue](/api/TupleWithRestIssue/) | [InferTupleIssue](/api/InferTupleIssue/)<TItems> | [InferIssue](/api/InferIssue/)<TRest>>`
    *   `type` `'tuple_with_rest'`
    *   `reference` `typeof [tupleWithRest](/api/tupleWithRest/)`
    *   `expects` `'Array'`
    *   `items` `TItems`
    *   `rest` `TRest`
    *   `message` `TMessage`

[](#tuplewithrestschemaasync)TupleWithRestSchemaAsync
=====================================================

Tuple with rest schema async interface.

[](#generics)Generics
---------------------

*   `TItems` `extends [TupleItemsAsync](/api/TupleItemsAsync/)`
*   `TRest` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[TupleWithRestIssue](/api/TupleWithRestIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `TupleWithRestSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[...[InferTupleInput](/api/InferTupleInput/)<TItems>, ...[InferInput](/api/InferInput/)<TRest>[]], [...[InferTupleOutput](/api/InferTupleOutput/)<TItems>, ...[InferOutput](/api/InferOutput/)<TRest>[]], [TupleWithRestIssue](/api/TupleWithRestIssue/) | [InferTupleIssue](/api/InferTupleIssue/)<TItems> | [InferIssue](/api/InferIssue/)<TRest>>`
    *   `type` `'tuple_with_rest'`
    *   `reference` `typeof [tupleWithRest](/api/tupleWithRest/) | typeof [tupleWithRestAsync](/api/tupleWithRestAsync/)`
    *   `expects` `'Array'`
    *   `items` `TItems`
    *   `rest` `TRest`
    *   `message` `TMessage`

[](#ulidaction)UlidAction
=========================

ULID action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UlidIssue](/api/UlidIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `UlidAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [UlidIssue](/api/UlidIssue/)<TInput>>`
    *   `type` `'ulid'`
    *   `reference` `typeof [ulid](/api/ulid/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#ulidissue)UlidIssue
=======================

ULID issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `UlidIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'ulid'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#undefinedableschema)UndefinedableSchema
===========================================

Undefinedable schema interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [Default](/api/Default/)<TWrapped, undefined>`

[](#definition)Definition
-------------------------

*   `UndefinedableSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferInput](/api/InferInput/)<TWrapped> | undefined, [InferUndefinedableOutput](/api/InferUndefinedableOutput/)<TWrapped, TDefault>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'undefinedable'`
    *   `reference` `typeof [undefinedable](/api/undefinedable/)`
    *   `expects` `` `(${TWrapped['expects']} | undefined)` ``
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#undefinedableschemaasync)UndefinedableSchemaAsync
=====================================================

Undefinedable schema async interface.

[](#generics)Generics
---------------------

*   `TWrapped` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>`
*   `TDefault` `extends [DefaultAsync](/api/DefaultAsync/)<TWrapped, undefined>`

[](#definition)Definition
-------------------------

*   `UndefinedableSchemaAsync` `[BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferInput](/api/InferInput/)<TWrapped> | undefined, [InferUndefinedableOutput](/api/InferUndefinedableOutput/)<TWrapped, TDefault>, [InferIssue](/api/InferIssue/)<TWrapped>>`
    *   `type` `'undefinedable'`
    *   `reference` `typeof [undefinedable](/api/undefinedable/) | typeof [undefinedableAsync](/api/undefinedableAsync/)`
    *   `expects` `` `(${TWrapped['expects']} | undefined)` ``
    *   `wrapped` `TWrapped`
    *   `default` `TDefault`

[](#undefinedissue)UndefinedIssue
=================================

Undefined issue interface.

[](#definition)Definition
-------------------------

*   `UndefinedIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'undefined'`
    *   `expected` `'undefined'`

[](#undefinedschema)UndefinedSchema
===================================

Undefined schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UndefinedIssue](/api/UndefinedIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `UndefinedSchema` `extends [BaseSchema](/api/BaseSchema/)<undefined, undefined, [UndefinedIssue](/api/UndefinedIssue/)>`
    *   `type` `'undefined'`
    *   `reference` `typeof [undefined](/api/undefined/)`
    *   `expects` `'undefined'`
    *   `message` `TMessage`

[](#unionoptions)UnionOptions
=============================

Union options type.

[](#definition)Definition
-------------------------

*   `UnionOptions` `[MaybeReadonly](/api/MaybeReadonly/)<[BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>[]>`

[](#unionoptionsasync)UnionOptionsAsync
=======================================

Union options async type.

[](#definition)Definition
-------------------------

*   `UnionOptionsAsync` `[MaybeReadonly](/api/MaybeReadonly/)<([BaseSchema](/api/BaseSchema/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>> | [BaseSchemaAsync](/api/BaseSchemaAsync/)<unknown, unknown, [BaseIssue](/api/BaseIssue/)<unknown>>)[]>`

[](#unionissue)UnionIssue
=========================

Union issue interface.

[](#generics)Generics
---------------------

*   `TSubIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`

[](#definition)Definition
-------------------------

*   `UnionIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'union'`
    *   `expected` `string`
    *   `issues` `[TSubIssue, ...TSubIssue[]]`

[](#unionschema)UnionSchema
===========================

Union schema interface.

[](#generics)Generics
---------------------

*   `TOptions` `extends [UnionOptions](/api/UnionOptions/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UnionIssue](/api/UnionIssue/)<[InferIssue](/api/InferIssue/)[number]>> | undefined`

[](#definition)Definition
-------------------------

*   `UnionSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferInput](/api/InferInput/)<TOptions[number]>, [InferOutput](/api/InferOutput/)<TOptions[number]>, [UnionIssue](/api/UnionIssue/)<[InferIssue](/api/InferIssue/)<TOptions[number]>> | [InferIssue](/api/InferIssue/)<TOptions[number]>>`
    *   `type` `'union'`
    *   `reference` `typeof [union](/api/union/)`
    *   `options` `TOptions`
    *   `message` `TMessage`

[](#unionschemaasync)UnionSchemaAsync
=====================================

Union schema async interface.

[](#generics)Generics
---------------------

*   `TOptions` `extends [UnionOptionsAsync](/api/UnionOptionsAsync/)`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UnionIssue](/api/UnionIssue/)<[InferIssue](/api/InferIssue/)<TOptions[number]>>> | undefined`

[](#definition)Definition
-------------------------

*   `UnionSchemaAsync` `[BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferInput](/api/InferInput/)<TOptions[number]>, [InferOutput](/api/InferOutput/)<TOptions[number]>, [UnionIssue](/api/UnionIssue/)<[InferIssue](/api/InferIssue/)<TOptions[number]>> | [InferIssue](/api/InferIssue/)<TOptions[number]>>`
    *   `type` `'union'`
    *   `reference` `typeof [union](/api/union/) | typeof [unionAsync](/api/unionAsync/)`
    *   `options` `TOptions`
    *   `message` `TMessage`

[](#unknowndataset)UnknownDataset
=================================

Unknown dataset interface.

[](#definition)Definition
-------------------------

*   `TypedDataset`
    *   `typed` `false`
    *   `value` `unknown`
    *   `issues` `undefined`

[](#unknownpathitem)UnknownPathItem
===================================

Unknown path item interface.

[](#definition)Definition
-------------------------

*   `UnknownPathItem`
    *   `type` `'unknown'`
    *   `origin` `'key' | 'value'`
    *   `input` `unknown`
    *   `key` `unknown`
    *   `value` `unknown`

The `input` of a path item may differ from the `input` of its issue. This is because path items are subsequently added by parent schemas and are related to their input. Transformations of child schemas are not taken into account.

[](#unknownschema)UnknownSchema
===============================

Unknown schema interface.

[](#definition)Definition
-------------------------

*   `UnknownSchema` `extends [BaseSchema](/api/BaseSchema/)<unknown, unknown, never>`
    *   `type` `'unknown'`
    *   `reference` `typeof [unknown](/api/unknown/)`
    *   `expects` `'unknown'`

[](#urlaction)UrlAction
=======================

URL action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UrlIssue](/api/UrlIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `UrlAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [UrlIssue](/api/UrlIssue/)<TInput>>`
    *   `type` `'url'`
    *   `reference` `typeof [url](/api/url/)`
    *   `expects` `null`
    *   `requirement` `(input: string) => boolean`
    *   `message` `TMessage`

[](#urlissue)UrlIssue
=====================

URL issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `UrlIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'url'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `(input: string) => boolean`

[](#uuidaction)UuidAction
=========================

UUID action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[UuidIssue](/api/UuidIssue/)<TInput>> | undefined`

[](#definition)Definition
-------------------------

*   `UuidAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [UuidIssue](/api/UuidIssue/)<TInput>>`
    *   `type` `'uuid'`
    *   `reference` `typeof [uuid](/api/uuid/)`
    *   `expects` `null`
    *   `requirement` `RegExp`
    *   `message` `TMessage`

[](#uuidissue)UuidIssue
=======================

UUID issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`

[](#definition)Definition
-------------------------

*   `UuidIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'uuid'`
    *   `expected` `null`
    *   `received` `` `"${string}"` ``
    *   `requirement` `RegExp`

[](#valueaction)ValueAction
===========================

Value action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ValueIssue](/api/ValueIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `ValueAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [ValueIssue](/api/ValueIssue/)<TInput, TRequirement>>`
    *   `type` `'value'`
    *   `reference` `typeof [value](/api/value/)`
    *   `expects` `string`
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#valuesaction)ValuesAction
=============================

Values action type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends readonly TInput[]`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[ValuesIssue](/api/ValuesIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `ValuesAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [ValuesIssue](/api/ValuesIssue/)<TInput, TRequirement>>`
    *   `type` `'values'`
    *   `reference` `typeof [values](/api/values/)`
    *   `expects` `string`
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#valueinput)ValueInput
=========================

Value input type.

[](#definition)Definition
-------------------------

*   `ValueInput` `string | number | bigint | boolean | Date`

[](#valueissue)ValueIssue
=========================

Value issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends TInput`

[](#definition)Definition
-------------------------

*   `ValueIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'value'`
    *   `expected` `string`
    *   `requirement` `TRequirement`

[](#valuesissue)ValuesIssue
===========================

Values issue type.

[](#generics)Generics
---------------------

*   `TInput` `extends [ValueInput](/api/ValueInput/)`
*   `TRequirement` `extends readonly TInput[]`

[](#definition)Definition
-------------------------

*   `ValuesIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'values'`
    *   `expected` `string`
    *   `requirement` `TRequirement`

[](#variantissue)VariantIssue
=============================

Variant issue interface.

[](#definition)Definition
-------------------------

*   `VariantIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'variant'`
    *   `expected` `string`

[](#variantoptions)VariantOptions
=================================

Variant options type.

[](#generics)Generics
---------------------

*   `TKey` `extends string`

[](#definition)Definition
-------------------------

*   `VariantOptions` `[MaybeReadonly](/api/MaybeReadonly/)<[VariantOption](/api/VariantOption/)<TKey>[]>`

[](#variantoptionsasync)VariantOptionsAsync
===========================================

Variant options async type.

[](#generics)Generics
---------------------

*   `TKey` `extends string`

[](#definition)Definition
-------------------------

*   `VariantOptionsAsync` `[MaybeReadonly](/api/MaybeReadonly/)<[VariantOption](/api/VariantOption/)<TKey>[] | [VariantOptionAsync](/api/VariantOptionAsync/)<TKey>[]>`

[](#variantschema)VariantSchema
===============================

Variant schema interface.

[](#generics)Generics
---------------------

*   `TKey` `extends string`
*   `TOptions` `extends [VariantOptions](/api/VariantOptions/)<TKey>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[VariantIssue](/api/VariantIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `VariantSchema` `extends [BaseSchema](/api/BaseSchema/)<[InferInput](/api/InferInput/)<TOptions[number]>, [InferOutput](/api/InferOutput/)<TOptions[number]>, [VariantIssue](/api/VariantIssue/) | [InferVariantIssue](/api/InferVariantIssue/)<TOptions[number]>>`
    *   `type` `'variant'`
    *   `reference` `typeof [variant](/api/variant/)`
    *   `expects` `'Object'`
    *   `key` `TKey`
    *   `options` `TOptions`
    *   `message` `TMessage`

[](#variantschemaasync)VariantSchemaAsync
=========================================

Variant schema async interface.

[](#generics)Generics
---------------------

*   `TKey` `extends string`
*   `TOptions` `extends [VariantOptionsAsync](/api/VariantOptionsAsync/)<TKey>`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[VariantIssue](/api/VariantIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `VariantSchemaAsync` `extends [BaseSchemaAsync](/api/BaseSchemaAsync/)<[InferInput](/api/InferInput/)<TOptions[number]>, [InferOutput](/api/InferOutput/)<TOptions[number]>, [VariantIssue](/api/VariantIssue/) | [InferVariantIssue](/api/InferVariantIssue/)<TOptions>>`
    *   `type` `'variant'`
    *   `reference` `typeof [variant](/api/variant/) | typeof [variantAsync](/api/variantAsync/)`
    *   `expects` `'Object'`
    *   `key` `TKey`
    *   `options` `TOptions`
    *   `message` `TMessage`

[](#voidissue)VoidIssue
=======================

Void issue interface.

[](#definition)Definition
-------------------------

*   `VoidIssue` `extends [BaseIssue](/api/BaseIssue/)<unknown>`
    *   `kind` `'schema'`
    *   `type` `'void'`
    *   `expected` `'void'`

[](#voidschema)VoidSchema
=========================

Void schema interface.

[](#generics)Generics
---------------------

*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[VoidIssue](/api/VoidIssue/)> | undefined`

[](#definition)Definition
-------------------------

*   `VoidSchema` `extends [BaseSchema](/api/BaseSchema/)<void, void, [VoidIssue](/api/VoidIssue/)>`
    *   `type` `'void'`
    *   `reference` `typeof [void](/api/void/)`
    *   `expects` `'void'`
    *   `message` `TMessage`

[](#wordsaction)WordsAction
===========================

Words action interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TLocales` `extends Intl.LocalesArgument`
*   `TRequirement` `extends number`
*   `TMessage` `extends [ErrorMessage](/api/ErrorMessage/)<[WordsIssue](/api/WordsIssue/)<TInput, TRequirement>> | undefined`

[](#definition)Definition
-------------------------

*   `WordsAction` `extends [BaseValidation](/api/BaseValidation/)<TInput, TInput, [WordsIssue](/api/WordsIssue/)<TInput, TRequirement>>`
    *   `type` `'words'`
    *   `reference` `typeof [words](/api/words/)`
    *   `expects` `` `${TRequirement}` ``
    *   `locales` `TLocales`
    *   `requirement` `TRequirement`
    *   `message` `TMessage`

[](#wordsissue)WordsIssue
=========================

Words issue interface.

[](#generics)Generics
---------------------

*   `TInput` `extends string`
*   `TRequirement` `extends number`

[](#definition)Definition
-------------------------

*   `WordsIssue` `extends [BaseIssue](/api/BaseIssue/)<TInput>`
    *   `kind` `'validation'`
    *   `type` `'words'`
    *   `expected` `` `${TRequirement}` ``
    *   `received` `` `${number}` ``
    *   `requirement` `TRequirement`